module 'systools_rc' ['format_error'/1,'module_info'/0,'module_info'/1,'translate_scripts'/3,'translate_scripts'/4] attributes [ 'file' = [{[115|[114|[99|[47|[115|[121|[115|[116|[111|[111|[108|[115|[95|[114|[99|[46|[101|[114|[108]]]]]]]]]]]]]]]]]]],1}]
, 'file' = [{[115|[114|[99|[47|[115|[121|[115|[116|[111|[111|[108|[115|[46|[104|[114|[108]]]]]]]]]]]]]]]],1}]
, 'record' = [{'release',[{'record_field',29,{'atom',29,'name'}}|[{'record_field',30,{'atom',30,'vsn'}}|[{'record_field',31,{'atom',31,'erts_vsn'}}|[{'record_field',32,{'atom',32,'applications'}}|[{'record_field',35,{'atom',35,'incl_apps'}}]]]]]}]
, 'record' = [{'application',[{'record_field',41,{'atom',41,'name'}}|[{'record_field',42,{'atom',42,'type'},{'atom',42,'permanent'}}|[{'record_field',43,{'atom',43,'vsn'},{'string',43,[]}}|[{'record_field',44,{'atom',44,'id'},{'string',44,[]}}|[{'record_field',45,{'atom',45,'description'},{'string',45,[]}}|[{'record_field',46,{'atom',46,'modules'},{'nil',46}}|[{'record_field',49,{'atom',49,'uses'},{'nil',49}}|[{'record_field',51,{'atom',51,'includes'},{'nil',51}}|[{'record_field',53,{'atom',53,'regs'},{'nil',53}}|[{'record_field',56,{'atom',56,'env'},{'nil',56}}|[{'record_field',58,{'atom',58,'maxT'},{'atom',58,'infinity'}}|[{'record_field',60,{'atom',60,'maxP'},{'atom',60,'infinity'}}|[{'record_field',62,{'atom',62,'mod'},{'nil',62}}|[{'record_field',64,{'atom',64,'start_phases'}}|[{'record_field',67,{'atom',67,'dir'},{'string',67,[]}}]]]]]]]]]]]]]]]}]
, 'file' = [{[115|[114|[99|[47|[115|[121|[115|[116|[111|[111|[108|[115|[95|[114|[99|[46|[101|[114|[108]]]]]]]]]]]]]]]]]]],24}] ] 'translate_scripts'/3 = fun (_0,_1,_2) -> apply 'translate_scripts'/4 ('up',_0,_1,_2)
'translate_scripts'/4 = fun (_0,_1,_2,_3) -> let <Scripts2> = apply 'expand_scripts'/1 (_1) in let <_5> = catch apply 'do_translate_scripts'/4 (_0,Scripts2,_2,_3) in case _5 of <_@r0 = {'ok',NewScript}> when 'true' -> _@r0
<{'error',Reason}> when 'true' -> {'error','systools_rc',Reason}
<{'EXIT',Reason}> when 'true' -> {'error','systools_rc',Reason}
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
'expand_scripts'/1 = fun (_0) -> case _0 of <[Script|Scripts]> when 'true' -> let <_1> = apply 'expand_script'/1 (Script) in let <_2> = apply 'expand_scripts'/1 (Scripts) in [_1|_2]
<[]> when 'true' -> []
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'expand_scripts',1}}] )-|['compiler_generated'] ) end
'expand_script'/1 = fun (_0) -> case _0 of <[I|Script]> when 'true' -> let <_6> = case I of <{'load_module',Mod}> when 'true' -> {'load_module',Mod,'brutal_purge','brutal_purge',[]}
<{'load_module',Mod,Mods}> when call 'erlang':'is_list' (Mods) -> {'load_module',Mod,'brutal_purge','brutal_purge',Mods}
<{'update',Mod}> when 'true' -> {'update',Mod,'soft','brutal_purge','brutal_purge',[]}
<{'update',Mod,'supervisor'}> when 'true' -> {'update',Mod,'static','default',{'advanced',[]},'brutal_purge','brutal_purge',[]}
<{'update',Mod,Change}> when call 'erlang':'is_tuple' (Change) -> {'update',Mod,Change,'brutal_purge','brutal_purge',[]}
<{'update',Mod,Change}> when call 'erlang':'=:=' (Change,'soft') -> {'update',Mod,Change,'brutal_purge','brutal_purge',[]}
<{'update',Mod,Mods}> when call 'erlang':'is_list' (Mods) -> {'update',Mod,'soft','brutal_purge','brutal_purge',Mods}
<{'update',Mod,Change,Mods}> when let <_1> = call 'erlang':'is_tuple' (Change) in let <_2> = call 'erlang':'is_list' (Mods) in call 'erlang':'and' (_1,_2) -> {'update',Mod,Change,'brutal_purge','brutal_purge',Mods}
<{'update',Mod,Change,Mods}> when let <_3> = call 'erlang':'=:=' (Change,'soft') in let <_4> = call 'erlang':'is_list' (Mods) in call 'erlang':'and' (_3,_4) -> {'update',Mod,Change,'brutal_purge','brutal_purge',Mods}
<{'add_application',Application}> when 'true' -> {'add_application',Application,'permanent'}
<_11> when 'true' -> I end in case <> of <> when call 'erlang':'is_list' (_6) -> let <_8> = apply 'expand_script'/1 (Script) in call 'erlang':'++' (_6,_8)
<> when 'true' -> let <_9> = apply 'expand_script'/1 (Script) in [_6|_9] end
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'expand_script',1}}] )-|['compiler_generated'] ) end
'do_translate_scripts'/4 = fun (_0,_1,_2,_3) -> let <MergedScript> = apply 'merge_scripts'/1 (_1) in apply 'translate_merged_script'/4 (_0,MergedScript,_2,_3)
'translate_merged_script'/4 = fun (_0,_1,_2,_3) -> do apply 'check_syntax'/1 (_1) let <Script1> = apply 'normalize_instrs'/1 (_1) in case apply 'split_script'/1 (Script1) of <{Before,After}> when 'true' -> do apply 'check_script'/2 (Before,After) case apply 'translate_independent_instrs'/4 (Before,After,_2,_3) of <{Before1,After1}> when 'true' -> case apply 'translate_dependent_instrs'/4 (_0,Before1,After1,_2) of <{Before2,After2}> when 'true' -> let <Before3> = apply 'merge_load_object_code'/1 (Before2) in case apply 'sort_emulator_restart'/3 (_0,Before3,After2) of <{Before4,After4}> when 'true' -> let <NewScript> = call 'erlang':'++' (Before4,['point_of_no_return'|After4]) in do apply 'check_syntax'/1 (NewScript) {'ok',NewScript}
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'merge_scripts'/1 = fun (_0) -> let <_8> = fun (_5,_4) -> case <_5,_4> of <Script,{B1,A1}> when 'true' -> case apply 'split_script'/1 (Script) of <{B2,A2}> when 'true' -> let <_3> = call 'erlang':'++' (B1,B2) in let <_2> = call 'erlang':'++' (A1,A2) in {_3,_2}
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'-merge_scripts/1-fun-0-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'foldl' (_8,{[],[]},_0) of <{Before,After}> when 'true' -> call 'erlang':'++' (Before,['point_of_no_return'|After])
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
'split_script'/1 = fun (_0) -> case apply 'split_instrs'/1 (_0) of <{Before,After}> when 'true' -> let <_4> = fun (_2) -> case _2 of <{'load_object_code',_11}> when 'true' -> 'ok'
<{'apply',_12}> when 'true' -> 'ok'
<Instruction> when 'true' -> call 'erlang':'throw' ({'error',{'bad_op_before_point_of_no_return',Instruction}}) end in do call 'lists':'foreach' (_4,Before) let <_7> = fun (_5) -> case _5 of <{'load_object_code',_13}> when 'true' -> 'true'
<_14> when 'true' -> 'false' end in case apply 'split'/2 (_7,After) of <{Found,Rest}> when 'true' -> let <_9> = call 'erlang':'++' (Before,Found) in {_9,Rest}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'split_instrs'/1 = fun (_0) -> apply 'split_instrs'/2 (_0,[])
'split_instrs'/2 = fun (_0,_1) -> case <_0,_1> of <['point_of_no_return'|T],Before> when 'true' -> case call 'lists':'member' ('point_of_no_return',T) of <'true'> when 'true' -> call 'erlang':'throw' ({'error','too_many_point_of_no_return'})
<'false'> when 'true' -> let <_2> = call 'lists':'reverse' (Before) in {_2,T}
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<[H|T],Before> when 'true' -> apply 'split_instrs'/2 (T,[H|Before])
<[],Before> when 'true' -> let <_4> = call 'lists':'reverse' (Before) in {[],_4}
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'split_instrs',2}}] )-|['compiler_generated'] ) end
'check_script'/2 = fun (_0,_1) -> do apply 'check_load'/2 (_0,_1) do apply 'check_suspend_resume'/1 (_1) apply 'check_start_stop'/1 (_1)
'check_load'/2 = fun (_0,_1) -> let <_5> = fun (_3) -> case _3 of <{'load',{Mod,_8,_9}}> when 'true' -> case apply 'find_object_code'/2 (Mod,_0) of <'true'> when 'true' -> 'ok'
<'false'> when 'true' -> call 'erlang':'throw' ({'error',{'no_object_code',Mod}})
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<_10> when 'true' -> 'ok' end in call 'lists':'foreach' (_5,_1)
'find_object_code'/2 = fun (_0,_1) -> case <_0,_1> of <Mod,[{'load_object_code',{_5,_6,Mods}}|T]> when 'true' -> case call 'lists':'member' (Mod,Mods) of <'true'> when 'true' -> 'true'
<'false'> when 'true' -> apply 'find_object_code'/2 (Mod,T)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<Mod,[_7|T]> when 'true' -> apply 'find_object_code'/2 (Mod,T)
<_X_Mod,[]> when 'true' -> 'false'
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'find_object_code',2}}] )-|['compiler_generated'] ) end
'check_suspend_resume'/1 = fun (_0) -> let <_9> = fun (_7) -> case _7 of <{Mod,_X_Timeout}> when 'true' -> Mod
<Mod> when 'true' -> Mod end in let <_5> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{'suspend',X}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([X|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_29> when 'true' -> (primop 'match_fail' ({'function_clause',_29})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <_6> = call 'lists':'flatten' (_5) in let <Suspended> = call 'lists':'map' (_9,_6) in let <_15> = letrec 'lc$^2'/1 = fun (_13) -> case _13 of <[{'resume',X}|_12]> when 'true' -> let <_14> = apply 'lc$^2'/1 (_12) in ([X|_14]-|['compiler_generated'] )
(<[_11|_12]> when 'true' -> apply 'lc$^2'/1 (_12)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_30> when 'true' -> (primop 'match_fail' ({'function_clause',_30})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (_0) in let <Resumed> = call 'lists':'flatten' (_15) in let <_21> = letrec 'lc$^3'/1 = fun (_19) -> case _19 of <[{'code_change',_27,{X,_28}}|_18]> when 'true' -> let <_20> = apply 'lc$^3'/1 (_18) in ([X|_20]-|['compiler_generated'] )
(<[_17|_18]> when 'true' -> apply 'lc$^3'/1 (_18)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_31> when 'true' -> (primop 'match_fail' ({'function_clause',_31})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (_0) in let <CodeChanged> = call 'lists':'flatten' (_21) in do case apply 'difference'/2 (Suspended,Resumed) of <[]> when 'true' -> 'ok'
<S2> when 'true' -> call 'erlang':'throw' ({'error',{'suspended_not_resumed',S2}}) end do case apply 'difference'/2 (Resumed,Suspended) of <[]> when 'true' -> 'ok'
<R2> when 'true' -> call 'erlang':'throw' ({'error',{'resumed_not_suspended',R2}}) end case apply 'difference'/2 (CodeChanged,Suspended) of <[]> when 'true' -> 'ok'
<C2> when 'true' -> call 'erlang':'throw' ({'error',{'code_change_not_suspended',C2}}) end
'check_start_stop'/1 = fun (_0) -> let <_5> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{'start',X}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([X|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <Start> = call 'lists':'flatten' (_5) in let <_11> = letrec 'lc$^1'/1 = fun (_9) -> case _9 of <[{'stop',X}|_8]> when 'true' -> let <_10> = apply 'lc$^1'/1 (_8) in ([X|_10]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^1'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_0) in let <Stop> = call 'lists':'flatten' (_11) in do case apply 'difference'/2 (Start,Stop) of <[]> when 'true' -> 'ok'
<S2> when 'true' -> call 'erlang':'throw' ({'error',{'start_not_stop',S2}}) end case apply 'difference'/2 (Stop,Start) of <[]> when 'true' -> 'ok'
<S3> when 'true' -> call 'erlang':'throw' ({'error',{'stop_not_start',S3}}) end
'normalize_instrs'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'update',Mod,Change,PrePurge,PostPurge,Mods}> when 'true' -> {'update',Mod,'dynamic','default',Change,PrePurge,PostPurge,Mods}
<{'update',Mod,Timeout,Change,PrePurge,PostPurge,Mods}> when 'true' -> {'update',Mod,'dynamic',Timeout,Change,PrePurge,PostPurge,Mods}
<{'add_module',Mod}> when 'true' -> {'add_module',Mod,[]}
<{'delete_module',Mod}> when 'true' -> {'delete_module',Mod,[]}
<I> when 'true' -> I end in call 'lists':'map' (_3,_0)
'translate_independent_instrs'/4 = fun (_0,_1,_2,_3) -> let <After1> = apply 'translate_application_instrs'/3 (_1,_2,_3) in apply 'translate_add_module_instrs'/2 (_0,After1)
'translate_application_instrs'/3 = fun (_0,_1,_2) -> let <_51> = fun (_49) -> case _49 of <{'add_application',Appl,Type}> when 'true' -> case call 'lists':'keysearch' (Appl,2,_1) of <{'value',Application}> when 'true' -> (case Application of (<({'application',_56,_57,_58,_59,_60,_rec0,_61,_62,_63,_64,_65,_66,_67,_68,_69}-|['compiler_generated'] )> when 'true' -> let <_7> = case Type of <'none'> when 'true' -> []
<'load'> when 'true' -> [{'apply',{'application','load',[Appl|[]]}}|[]]
<_71> when 'true' -> [{'apply',{'application','start',[Appl|[Type|[]]]}}|[]] end in (letrec 'lc$^0'/1 = fun (_11) -> case _11 of <[M|_10]> when 'true' -> let <_12> = apply 'lc$^0'/1 (_10) in ([{'add_module',M,[]}|_12]-|['compiler_generated'] )
<[]> when 'true' -> _7
(<_133> when 'true' -> (primop 'match_fail' ({'function_clause',_133})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_rec0)-|['list_comprehension'] )-|['compiler_generated'] )
(<_70> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','application'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'throw' ({'error',{'no_such_application',Appl}})
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<{'remove_application',Appl}> when 'true' -> do case call 'lists':'keysearch' (Appl,2,_1) of <{'value',_X_Application}> when 'true' -> call 'erlang':'throw' ({'error',{'removed_application_present',Appl}})
<'false'> when 'true' -> 'ok'
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end case call 'lists':'keysearch' (Appl,2,_2) of <{'value',RemApplication}> when 'true' -> (case RemApplication of (<({'application',_72,_73,_74,_75,_76,_rec1,_77,_78,_79,_80,_81,_82,_83,_84,_85}-|['compiler_generated'] )> when 'true' -> let <_22> = letrec 'lc$^1'/1 = fun (_20) -> case _20 of <[M|_19]> when 'true' -> let <_21> = apply 'lc$^1'/1 (_19) in ([{'remove',{M,'brutal_purge','brutal_purge'}}|_21]-|['compiler_generated'] )
<[]> when 'true' -> [{'purge',_rec1}|[{'apply',{'application','unload',[Appl|[]]}}|[]]]
(<_134> when 'true' -> (primop 'match_fail' ({'function_clause',_134})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_rec1) in [{'apply',{'application','stop',[Appl|[]]}}|_22]-|['compiler_generated'] )
(<_86> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','application'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'throw' ({'error',{'no_such_application',Appl}})
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end
<{'restart_application',Appl}> when 'true' -> case call 'lists':'keysearch' (Appl,2,_2) of <{'value',PreApplication}> when 'true' -> (case PreApplication of (<({'application',_87,_88,_89,_90,_91,_rec2,_92,_93,_94,_95,_96,_97,_98,_99,_100}-|['compiler_generated'] )> when 'true' -> case call 'lists':'keysearch' (Appl,2,_1) of <{'value',PostApplication}> when 'true' -> (case PostApplication of (<({'application',_102,_103,_104,_105,_106,_rec3,_107,_108,_109,_110,_111,_112,_113,_114,_115}-|['compiler_generated'] )> when 'true' -> (case PostApplication of (<({'application',_117,_rec4,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127,_128,_129,_130}-|['compiler_generated'] )> when 'true' -> let <_34> = case _rec4 of <'none'> when 'true' -> []
<'load'> when 'true' -> [{'apply',{'application','load',[Appl|[]]}}|[]]
<_132> when 'true' -> [{'apply',{'application','start',[Appl|[_rec4|[]]]}}|[]] end in let <_40> = letrec 'lc$^2'/1 = fun (_38) -> case _38 of <[M|_37]> when 'true' -> let <_39> = apply 'lc$^2'/1 (_37) in ([{'add_module',M,[]}|_39]-|['compiler_generated'] )
<[]> when 'true' -> _34
(<_135> when 'true' -> (primop 'match_fail' ({'function_clause',_135})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (_rec3) in let <_41> = [{'purge',_rec2}|_40] in let <_46> = letrec 'lc$^3'/1 = fun (_44) -> case _44 of <[M|_43]> when 'true' -> let <_45> = apply 'lc$^3'/1 (_43) in ([{'remove',{M,'brutal_purge','brutal_purge'}}|_45]-|['compiler_generated'] )
<[]> when 'true' -> _41
(<_136> when 'true' -> (primop 'match_fail' ({'function_clause',_136})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (_rec2) in [{'apply',{'application','stop',[Appl|[]]}}|_46]-|['compiler_generated'] )
(<_131> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','application'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_116> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','application'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'throw' ({'error',{'no_such_application',Appl}})
(<_47> when 'true' -> primop 'match_fail' ({'case_clause',_47})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_101> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','application'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'throw' ({'error',{'no_such_application',Appl}})
(<_48> when 'true' -> primop 'match_fail' ({'case_clause',_48})-|['compiler_generated'] ) end
<X> when 'true' -> X end in let <L> = call 'lists':'map' (_51,_0) in call 'lists':'flatten' (L)
'translate_add_module_instrs'/2 = fun (_0,_1) -> let <_4> = fun (_2) -> case _2 of <{'add_module',Mod,Mods}> when 'true' -> {'load_module',Mod,'brutal_purge','brutal_purge',Mods}
<I> when 'true' -> I end in let <NAfter> = call 'lists':'map' (_4,_1) in {_0,NAfter}
'translate_dependent_instrs'/4 = fun (_0,_1,_2,_3) -> let <G> = apply 'make_dependency_graph'/1 (_2) in let <WCs> = call 'digraph_utils':'components' (G) in case apply 'translate_dep_loop'/7 (G,WCs,_2,_3,[],[],_0) of <{NBefore,NAfter}> when 'true' -> do call 'digraph':'delete' (G) let <_7> = call 'erlang':'++' (_1,NBefore) in {_7,NAfter}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'translate_dep_loop'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <G,WCs,_@r0 = [I|Is],Appls,Before,After,Mode> when try let <_7> = call 'erlang':'is_tuple' (I) in let <_8> = call 'erlang':'size' (I) in let <_9> = call 'erlang':'>' (_8,1) in call 'erlang':'and' (_7,_9) of <Try> -> Try catch <T,R> -> 'false' -> let <IName> = call 'erlang':'element' (1,I) in case call 'lists':'member' (IName,['update'|['load_module'|['add_module'|['delete_module']]]]) of <'true'> when 'true' -> let <Mod> = call 'erlang':'element' (2,I) in let <DepIs> = apply 'get_dependent_instructions'/3 (G,WCs,Mod) in case apply 'translate_dep_to_low'/3 (Mode,DepIs,Appls) of <{B2,A2}> when 'true' -> let <RemIs> = apply 'difference'/2 (_@r0,DepIs) in let <_16> = call 'erlang':'++' (Before,B2) in let <_15> = call 'erlang':'++' (After,A2) in apply 'translate_dep_loop'/7 (G,WCs,RemIs,Appls,_16,_15,Mode)
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_17> = call 'erlang':'++' (After,[I|[]]) in apply 'translate_dep_loop'/7 (G,WCs,Is,Appls,Before,_17,Mode)
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end
<G,WCs,[I|Is],Appls,Before,After,Mode> when 'true' -> let <_19> = call 'erlang':'++' (After,[I|[]]) in apply 'translate_dep_loop'/7 (G,WCs,Is,Appls,Before,_19,Mode)
<_X_G,_X_WCs,[],_X_Appls,Before,After,_X_Mode> when 'true' -> {Before,After}
(<_26,_25,_24,_23,_22,_21,_20> when 'true' -> (primop 'match_fail' ({'function_clause',_26,_25,_24,_23,_22,_21,_20})-|[{'function_name',{'translate_dep_loop',7}}] )-|['compiler_generated'] ) end
'make_dependency_graph'/1 = fun (_0) -> let <_4> = fun (_2) -> case _2 of <I> when call 'erlang':'is_tuple' (_2) -> let <IName> = call 'erlang':'element' (1,I) in call 'lists':'member' (IName,['update'|['load_module'|['add_module'|['delete_module']]]])
<_29> when 'true' -> 'false' end in let <DepIs> = call 'lists':'filter' (_4,_0) in let <_14> = fun (_11,_10) -> let <Mod> = call 'erlang':'element' (2,_11) in let <_7> = call 'erlang':'size' (_11) in let <Mods> = call 'erlang':'element' (_7,_11) in let <_9> = call 'erlang':'+' (_10,1) in {{Mod,Mods,{_10,_11}},_9} in case call 'lists':'mapfoldl' (_14,1,DepIs) of <{VDs,_30}> when 'true' -> let <G> = call 'digraph':'new' () in let <_20> = fun (_18) -> case _18 of <{Mod,_X_Mods,Data}> when 'true' -> case call 'digraph':'vertex' (G,Mod) of <'false'> when 'true' -> call 'digraph':'add_vertex' (G,Mod,Data)
<_31> when 'true' -> call 'erlang':'throw' ({'error',{'muldef_module',Mod}}) end
(<_19> when 'true' -> (primop 'match_fail' ({'function_clause',_19})-|[{'function_name',{'-make_dependency_graph/1-fun-2-',1}}] )-|['compiler_generated'] ) end in do call 'lists':'foreach' (_20,VDs) let <_27> = fun (_25) -> case _25 of <{Mod,Mods,_X_Data}> when 'true' -> let <_24> = fun (_22) -> case call 'digraph':'add_edge' (G,Mod,_22) of <{'error',_X_Reason}> when 'true' -> call 'erlang':'throw' ({'error',{'undef_module',_22}})
<_32> when 'true' -> 'ok' end in call 'lists':'foreach' (_24,Mods)
(<_26> when 'true' -> (primop 'match_fail' ({'function_clause',_26})-|[{'function_name',{'-make_dependency_graph/1-fun-4-',1}}] )-|['compiler_generated'] ) end in do call 'lists':'foreach' (_27,VDs) G
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
'get_dependent_instructions'/3 = fun (_0,_1,_2) -> let <_5> = fun (_3) -> call 'lists':'member' (_2,_3) in case call 'lists':'filter' (_5,_1) of <[WC|[]]> when 'true' -> let <H> = apply 'restriction'/2 (WC,_0) in let <S> = apply 'condensation'/1 (H) in let <Ts> = call 'digraph_utils':'topsort' (S) in let <_20> = fun (_18) -> let <_12> = fun (_10) -> case call 'digraph':'vertex' (H,_10) of <{_27,Data}> when 'true' -> Data
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end in let <NIs> = call 'lists':'map' (_12,_18) in let <SortedNIs> = call 'lists':'keysort' (1,NIs) in let <_17> = fun (_15) -> case _15 of <{_X_N,I}> when 'true' -> I
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'-get_dependent_instructions/3-fun-2-',1}}] )-|['compiler_generated'] ) end in call 'lists':'map' (_17,SortedNIs) in let <DepIss> = call 'lists':'map' (_20,Ts) in let <DepIs> = call 'lists':'flatten' (DepIss) in do call 'digraph':'delete' (H) do call 'digraph':'delete' (S) DepIs
<[]> when 'true' -> call 'erlang':'throw' ({'error',{'undef_module',_2}})
<_28> when 'true' -> call 'erlang':'throw' ({'error',{'muldef_module',_2}}) end
'translate_dep_to_low'/3 = fun (_0,_1,_2) -> let <_5> = fun (_3) -> case _3 of <{'update',Mod,_60,'default',_61,_62,_63,_64}> when 'true' -> {'true',Mod}
<{'update',Mod,_65,T,_66,_67,_68,_69}> when 'true' -> {'true',{Mod,T}}
<_70> when 'true' -> 'false' end in let <UpdateMods> = apply 'filtermap'/2 (_5,_1) in let <RevUpdateMods> = call 'lists':'reverse' (UpdateMods) in let <_8> = case <> of <> when call 'erlang':'=:=' (UpdateMods,[]) -> []
<> when 'true' -> [{'suspend',UpdateMods}|[]] end in let <_14> = case <> of <> when call 'erlang':'=:=' (UpdateMods,[]) -> []
<> when 'true' -> let <_12> = fun (_10) -> case _10 of <{Mod,_X_T}> when 'true' -> Mod
<Mod> when 'true' -> Mod end in let <_13> = call 'lists':'map' (_12,RevUpdateMods) in [{'resume',_13}|[]] end in let <_18> = fun (_16) -> case _16 of <{'update',Mod,_71,_72,_73,PreP,PostP,_74}> when 'true' -> {'true',{'load',{Mod,PreP,PostP}}}
<{'load_module',Mod,PreP,PostP,_75}> when 'true' -> {'true',{'load',{Mod,PreP,PostP}}}
<{'delete_module',Mod,_76}> when 'true' -> {'true',[{'remove',{Mod,'brutal_purge','brutal_purge'}}|[{'purge',[Mod|[]]}|[]]]}
<_77> when 'true' -> 'false' end in let <LoadRemoveInstrs0> = apply 'filtermap'/2 (_18,_1) in let <LoadRemoveInstrs> = call 'lists':'flatten' (LoadRemoveInstrs0) in let <_21> = call 'lists':'reverse' (LoadRemoveInstrs0) in let <RevLoadRemoveInstrs> = call 'lists':'flatten' (_21) in let <_26> = fun (_24) -> case _24 of <{'load',{Mod,_78,_79}}> when 'true' -> case apply 'get_lib'/2 (Mod,_2) of <{Lib,LibVsn}> when 'true' -> {'true',{'load_object_code',{Lib,LibVsn,[Mod|[]]}}}
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end
<_80> when 'true' -> 'false' end in let <LoadObjCodeInstrs> = apply 'filtermap'/2 (_26,LoadRemoveInstrs) in case <> of <> when call 'erlang':'=:=' (_0,'up') -> let <_30> = fun (_28) -> case _28 of <{'update',Mod,_81,_82,{'advanced',Extra},_83,_84,_85}> when 'true' -> {'true',{Mod,Extra}}
<_86> when 'true' -> 'false' end in let <CodeChangeMods> = apply 'filtermap'/2 (_30,_1) in let <_32> = case <> of <> when call 'erlang':'=:=' (CodeChangeMods,[]) -> []
<> when 'true' -> [{'code_change','up',CodeChangeMods}|[]] end in let <_34> = call 'erlang':'++' (_32,_14) in let <_35> = call 'erlang':'++' (RevLoadRemoveInstrs,_34) in let <_36> = call 'erlang':'++' (_8,_35) in {LoadObjCodeInstrs,_36}
<> when call 'erlang':'=:=' (_0,'dn') -> let <_41> = letrec 'lc$^5'/1 = fun (_39) -> case _39 of <[{'update',Mod,'dynamic',_87,{'advanced',Extra},_88,_89,_90}|_38]> when 'true' -> let <_40> = apply 'lc$^5'/1 (_38) in ([{Mod,Extra}|_40]-|['compiler_generated'] )
(<[_37|_38]> when 'true' -> apply 'lc$^5'/1 (_38)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_95> when 'true' -> (primop 'match_fail' ({'function_clause',_95})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in apply 'lc$^5'/1 (_1) in let <_43> = case <> of <> when call 'erlang':'=:=' (_41,[]) -> []
<> when 'true' -> [{'code_change','down',_41}|[]] end in let <_49> = letrec 'lc$^6'/1 = fun (_47) -> case _47 of <[{'update',Mod,'static',_91,{'advanced',Extra},_92,_93,_94}|_46]> when 'true' -> let <_48> = apply 'lc$^6'/1 (_46) in ([{Mod,Extra}|_48]-|['compiler_generated'] )
(<[_45|_46]> when 'true' -> apply 'lc$^6'/1 (_46)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_96> when 'true' -> (primop 'match_fail' ({'function_clause',_96})-|[{'function_name',{'lc$^6',1}}] )-|['compiler_generated'] ) end in apply 'lc$^6'/1 (_1) in let <_51> = case <> of <> when call 'erlang':'=:=' (_49,[]) -> []
<> when 'true' -> [{'code_change','down',_49}|[]] end in let <_53> = call 'erlang':'++' (_51,_14) in let <_54> = call 'erlang':'++' (LoadRemoveInstrs,_53) in let <_55> = call 'erlang':'++' (_43,_54) in let <_56> = call 'erlang':'++' (_8,_55) in {LoadObjCodeInstrs,_56}
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
'get_lib'/2 = fun (_0,_1) -> case <_0,_1> of <Mod,[{'application',Name,_5,Vsn,_6,_7,Modules,_8,_9,_10,_11,_12,_13,_14,_15,_16}|T]> when 'true' -> case call 'lists':'member' (Mod,Modules) of <'true'> when 'true' -> {Name,Vsn}
<'false'> when 'true' -> apply 'get_lib'/2 (Mod,T)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<Mod,[]> when 'true' -> call 'erlang':'throw' ({'error',{'no_such_module',Mod}})
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'get_lib',2}}] )-|['compiler_generated'] ) end
'merge_load_object_code'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'load_object_code',_7}> when 'true' -> 'true'
<_8> when 'true' -> 'false' end in case apply 'split'/2 (_3,_0) of <{Found,Rest}> when 'true' -> let <_5> = apply 'mlo'/1 (Found) in call 'erlang':'++' (_5,Rest)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'mlo'/1 = fun (_0) -> case _0 of <[{'load_object_code',{Lib,LibVsn,Mods}}|T]> when 'true' -> let <_5> = fun (_3) -> case _3 of <{'load_object_code',{Lib2,LibVsn2,_X_Mods2}}> when let <_1> = call 'erlang':'==' (Lib,Lib2) in let <_2> = call 'erlang':'==' (LibVsn,LibVsn2) in call 'erlang':'and' (_1,_2) -> 'true'
<{'load_object_code',{Lib2,LibVsn2,_X_Mods2}}> when call 'erlang':'==' (Lib,Lib2) -> call 'erlang':'throw' ({'error',{'conflicting_versions',Lib,LibVsn,LibVsn2}})
<_17> when 'true' -> 'false' end in case apply 'split'/2 (_5,T) of <{Same,Other}> when 'true' -> let <_12> = fun (_9,_8) -> case <_9,_8> of <{'load_object_code',{_18,_19,Ms}},Res> when 'true' -> apply 'union'/2 (Ms,Res)
(<_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10})-|[{'function_name',{'-mlo/1-fun-1-',2}}] )-|['compiler_generated'] ) end in let <OCode0> = call 'lists':'foldr' (_12,[],Same) in let <OCode1> = apply 'union'/2 (Mods,OCode0) in let <_15> = apply 'mlo'/1 (Other) in [{'load_object_code',{Lib,LibVsn,OCode1}}|_15]
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'mlo',1}}] )-|['compiler_generated'] ) end
'sort_emulator_restart'/3 = fun (_0,_1,_2) -> let <_15,_16> = case apply 'filter_out'/2 ('restart_new_emulator',_2) of <_13> when call 'erlang':'=:=' (_13,_2) -> <_1,_2>
<A1> when call 'erlang':'=:=' (_0,'up') -> <['restart_new_emulator'|_1],A1>
<A1> when call 'erlang':'=:=' (_0,'dn') -> let <_3> = call 'erlang':'++' (A1,['restart_emulator']) in <_1,_3>
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in let <_8> = case apply 'filter_out'/2 ('restart_emulator',(_16-|['compiler_generated'] )) of <_14> when call 'erlang':'=:=' (_14,(_16-|['compiler_generated'] )) -> (_16-|['compiler_generated'] )
<A2> when 'true' -> call 'erlang':'++' (A2,['restart_emulator']) end in {(_15-|['compiler_generated'] ),_8}
'filter_out'/2 = fun (_0,_1) -> let <_4> = fun (_2) -> case _2 of <X> when call 'erlang':'=:=' (_2,_0) -> 'false'
<_7> when 'true' -> 'true' end in call 'lists':'filter' (_4,_1)
'check_syntax'/1 = fun (_0) -> case _0 of <[H|T]> when 'true' -> do apply 'check_op'/1 (H) apply 'check_syntax'/1 (T)
<[]> when 'true' -> 'ok'
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'check_syntax',1}}] )-|['compiler_generated'] ) end
'check_op'/1 = fun (_0) -> case _0 of <'mnesia_backup'> when 'true' -> call 'erlang':'throw' ({'error',{'not_yet_implemented','mnesia_backup'}})
<{'update',Mod,Change,PrePurge,PostPurge,Mods}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_change'/1 (Change) do apply 'check_purge'/1 (PrePurge) do apply 'check_purge'/1 (PostPurge) do apply 'check_list'/1 (Mods) let <_3> = fun (_1) -> apply 'check_mod'/1 (_1) in call 'lists':'foreach' (_3,Mods)
<{'update',Mod,Timeout,Change,PrePurge,PostPurge,Mods}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_timeout'/1 (Timeout) do apply 'check_change'/1 (Change) do apply 'check_purge'/1 (PrePurge) do apply 'check_purge'/1 (PostPurge) do apply 'check_list'/1 (Mods) let <_6> = fun (_4) -> apply 'check_mod'/1 (_4) in call 'lists':'foreach' (_6,Mods)
<{'update',Mod,ModType,Timeout,Change,PrePurge,PostPurge,Mods}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_mod_type'/1 (ModType) do apply 'check_timeout'/1 (Timeout) do apply 'check_change'/1 (Change) do apply 'check_purge'/1 (PrePurge) do apply 'check_purge'/1 (PostPurge) do apply 'check_list'/1 (Mods) let <_9> = fun (_7) -> apply 'check_mod'/1 (_7) in call 'lists':'foreach' (_9,Mods)
<{'load_module',Mod,PrePurge,PostPurge,Mods}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_purge'/1 (PrePurge) do apply 'check_purge'/1 (PostPurge) do apply 'check_list'/1 (Mods) let <_12> = fun (_10) -> apply 'check_mod'/1 (_10) in call 'lists':'foreach' (_12,Mods)
<{'add_module',Mod}> when 'true' -> apply 'check_mod'/1 (Mod)
<{'add_module',Mod,Mods}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_list'/1 (Mods) let <_15> = fun (_13) -> apply 'check_mod'/1 (_13) in call 'lists':'foreach' (_15,Mods)
<{'delete_module',Mod}> when 'true' -> apply 'check_mod'/1 (Mod)
<{'delete_module',Mod,Mods}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_list'/1 (Mods) let <_18> = fun (_16) -> apply 'check_mod'/1 (_16) in call 'lists':'foreach' (_18,Mods)
<{'remove_application',Appl}> when 'true' -> apply 'check_appl'/1 (Appl)
<{'add_application',Appl,Type}> when 'true' -> do apply 'check_appl'/1 (Appl) apply 'check_start_type'/1 (Type)
<{'restart_application',Appl}> when 'true' -> apply 'check_appl'/1 (Appl)
<'restart'> when 'true' -> 'ok'
<'reboot'> when 'true' -> 'ok'
<{'load_object_code',{Lib,LibVsn,Mods}}> when 'true' -> do apply 'check_lib'/1 (Lib) do apply 'check_lib_vsn'/1 (LibVsn) do apply 'check_list'/1 (Mods) let <_21> = fun (_19) -> apply 'check_mod'/1 (_19) in call 'lists':'foreach' (_21,Mods)
<'point_of_no_return'> when 'true' -> 'ok'
<{'load',{Mod,PrePurge,PostPurge}}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_purge'/1 (PrePurge) apply 'check_purge'/1 (PostPurge)
<{'remove',{Mod,PrePurge,PostPurge}}> when 'true' -> do apply 'check_mod'/1 (Mod) do apply 'check_purge'/1 (PrePurge) apply 'check_purge'/1 (PostPurge)
<{'purge',Mods}> when 'true' -> do apply 'check_list'/1 (Mods) let <_24> = fun (_22) -> apply 'check_mod'/1 (_22) in call 'lists':'foreach' (_24,Mods)
<{'suspend',Mods}> when 'true' -> do apply 'check_list'/1 (Mods) let <_27> = fun (_25) -> case _25 of <{M,T}> when 'true' -> do apply 'check_mod'/1 (M) apply 'check_timeout'/1 (T)
<M> when 'true' -> apply 'check_mod'/1 (M) end in call 'lists':'foreach' (_27,Mods)
<{'resume',Mods}> when 'true' -> do apply 'check_list'/1 (Mods) let <_30> = fun (_28) -> apply 'check_mod'/1 (_28) in call 'lists':'foreach' (_30,Mods)
<{'code_change',Mods}> when 'true' -> do apply 'check_list'/1 (Mods) let <_33> = fun (_31) -> case _31 of <{M,_X_Extra}> when 'true' -> apply 'check_mod'/1 (M)
<X> when 'true' -> call 'erlang':'throw' ({'error',{'bad_code_change',X}}) end in call 'lists':'foreach' (_33,Mods)
<{'code_change',Mode,Mods}> when 'true' -> do apply 'check_list'/1 (Mods) do apply 'check_mode'/1 (Mode) let <_36> = fun (_34) -> case _34 of <{M,_X_Extra}> when 'true' -> apply 'check_mod'/1 (M)
<X> when 'true' -> call 'erlang':'throw' ({'error',{'bad_code_change',X}}) end in call 'lists':'foreach' (_36,Mods)
<{'stop',Mods}> when 'true' -> do apply 'check_list'/1 (Mods) let <_39> = fun (_37) -> apply 'check_mod'/1 (_37) in call 'lists':'foreach' (_39,Mods)
<{'start',Mods}> when 'true' -> do apply 'check_list'/1 (Mods) let <_42> = fun (_40) -> apply 'check_mod'/1 (_40) in call 'lists':'foreach' (_42,Mods)
<{'sync_nodes',_X_Id,{M,F,A}}> when 'true' -> do apply 'check_mod'/1 (M) do apply 'check_func'/1 (F) apply 'check_args'/1 (A)
<{'sync_nodes',_X_Id,Nodes}> when 'true' -> do apply 'check_list'/1 (Nodes) let <_45> = fun (_43) -> apply 'check_node'/1 (_43) in call 'lists':'foreach' (_45,Nodes)
<{'apply',{M,F,A}}> when 'true' -> do apply 'check_mod'/1 (M) do apply 'check_func'/1 (F) apply 'check_args'/1 (A)
<'restart_new_emulator'> when 'true' -> 'ok'
<'restart_emulator'> when 'true' -> 'ok'
<X> when 'true' -> call 'erlang':'throw' ({'error',{'bad_instruction',X}}) end
'check_mod'/1 = fun (_0) -> case _0 of <Mod> when call 'erlang':'is_atom' (_0) -> 'ok'
<Mod> when 'true' -> call 'erlang':'throw' ({'error',{'bad_module',Mod}}) end
'check_change'/1 = fun (_0) -> case _0 of <'soft'> when 'true' -> 'ok'
<{'advanced',_2}> when 'true' -> 'ok'
<Change> when 'true' -> call 'erlang':'throw' ({'error',{'bad_change',Change}}) end
'check_mod_type'/1 = fun (_0) -> case _0 of <'static'> when 'true' -> 'ok'
<'dynamic'> when 'true' -> 'ok'
<ModType> when 'true' -> call 'erlang':'throw' ({'error',{'bad_mod_type',ModType}}) end
'check_purge'/1 = fun (_0) -> case _0 of <'soft_purge'> when 'true' -> 'ok'
<'brutal_purge'> when 'true' -> 'ok'
<Purge> when 'true' -> call 'erlang':'throw' ({'error',{'bad_purge_method',Purge}}) end
'check_list'/1 = fun (_0) -> case _0 of <List> when call 'erlang':'is_list' (_0) -> 'ok'
<List> when 'true' -> call 'erlang':'throw' ({'error',{'bad_list',List}}) end
'check_args'/1 = fun (_0) -> case _0 of <Args> when call 'erlang':'is_list' (_0) -> 'ok'
<Args> when 'true' -> call 'erlang':'throw' ({'error',{'bad_args_list',Args}}) end
'check_node'/1 = fun (_0) -> case _0 of <Node> when call 'erlang':'is_atom' (_0) -> 'ok'
<Node> when 'true' -> call 'erlang':'throw' ({'error',{'bad_node',Node}}) end
'check_appl'/1 = fun (_0) -> case _0 of <Appl> when call 'erlang':'is_atom' (_0) -> 'ok'
<Appl> when 'true' -> call 'erlang':'throw' ({'error',{'bad_application',Appl}}) end
'check_start_type'/1 = fun (_0) -> case _0 of <'none'> when 'true' -> 'ok'
<'load'> when 'true' -> 'ok'
<'temporary'> when 'true' -> 'ok'
<'transient'> when 'true' -> 'ok'
<'permanent'> when 'true' -> 'ok'
<T> when 'true' -> call 'erlang':'throw' ({'error',{'bad_start_type',T}}) end
'check_func'/1 = fun (_0) -> case _0 of <Func> when call 'erlang':'is_atom' (_0) -> 'ok'
<Func> when 'true' -> call 'erlang':'throw' ({'error',{'bad_func',Func}}) end
'check_lib'/1 = fun (_0) -> case _0 of <Lib> when call 'erlang':'is_atom' (_0) -> 'ok'
<Lib> when 'true' -> call 'erlang':'throw' ({'error',{'bad_lib',Lib}}) end
'check_lib_vsn'/1 = fun (_0) -> case _0 of <LibVsn> when call 'erlang':'is_list' (_0) -> 'ok'
<LibVsn> when 'true' -> call 'erlang':'throw' ({'error',{'bad_lib_vsn',LibVsn}}) end
'check_timeout'/1 = fun (_0) -> case _0 of <'default'> when 'true' -> 'ok'
<'infinity'> when 'true' -> 'ok'
<Int> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>' (_0,0) in call 'erlang':'and' (_1,_2) -> 'ok'
<T> when 'true' -> call 'erlang':'throw' ({'error',{'bad_timeout',T}}) end
'check_mode'/1 = fun (_0) -> case _0 of <'up'> when 'true' -> 'ok'
<'down'> when 'true' -> 'ok'
<Mode> when 'true' -> call 'erlang':'throw' ({'error',{'bad_mode',Mode}}) end
'format_error'/1 = fun (_0) -> case _0 of <{'bad_op_before_point_of_no_return',Instruction}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[105|[110|[115|[116|[114|[117|[99|[116|[105|[111|[110|[32|[126|[112|[126|[110|[98|[101|[102|[111|[114|[101|[32|[112|[111|[105|[110|[116|[95|[111|[102|[95|[110|[111|[95|[114|[101|[116|[117|[114|[110|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Instruction|[]])
<{'no_object_code',Mod}> when 'true' -> call 'io_lib':'format' ([78|[111|[32|[108|[111|[97|[100|[95|[111|[98|[106|[101|[99|[116|[95|[99|[111|[100|[101|[32|[102|[111|[117|[110|[100|[32|[102|[111|[114|[32|[109|[111|[100|[117|[108|[101|[58|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Mod|[]])
<{'suspended_not_resumed',Mods}> when 'true' -> call 'io_lib':'format' ([83|[117|[115|[112|[101|[110|[100|[101|[100|[32|[98|[117|[116|[32|[110|[111|[116|[32|[114|[101|[115|[117|[109|[101|[100|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Mods|[]])
<{'resumed_not_suspended',Mods}> when 'true' -> call 'io_lib':'format' ([82|[101|[115|[117|[109|[101|[100|[32|[98|[117|[116|[32|[110|[111|[116|[32|[115|[117|[115|[112|[101|[110|[100|[101|[100|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Mods|[]])
<{'code_change_not_suspended',Mods}> when 'true' -> call 'io_lib':'format' ([67|[111|[100|[101|[32|[99|[104|[97|[110|[103|[101|[100|[32|[98|[117|[116|[32|[110|[111|[116|[32|[115|[117|[115|[112|[101|[110|[100|[101|[100|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Mods|[]])
<{'start_not_stop',Mods}> when 'true' -> call 'io_lib':'format' ([83|[116|[97|[114|[116|[101|[100|[32|[98|[117|[116|[32|[110|[111|[116|[32|[115|[116|[111|[112|[112|[101|[100|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Mods|[]])
<{'stop_not_start',Mods}> when 'true' -> call 'io_lib':'format' ([83|[116|[111|[112|[112|[101|[100|[32|[98|[117|[116|[32|[110|[111|[116|[32|[115|[116|[97|[114|[116|[101|[100|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Mods|[]])
<{'no_such_application',App}> when 'true' -> call 'io_lib':'format' ([83|[116|[97|[114|[116|[101|[100|[32|[117|[110|[100|[101|[102|[105|[110|[101|[100|[32|[97|[112|[112|[108|[105|[99|[97|[116|[105|[111|[110|[58|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[App|[]])
<{'removed_application_present',App}> when 'true' -> call 'io_lib':'format' ([82|[101|[109|[111|[118|[101|[100|[32|[97|[112|[112|[108|[105|[99|[97|[116|[105|[111|[110|[32|[112|[114|[101|[115|[101|[110|[116|[58|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[App|[]])
<'dup_mnesia_backup'> when 'true' -> call 'io_lib':'format' ([68|[117|[112|[108|[105|[99|[97|[116|[101|[32|[109|[110|[101|[115|[105|[97|[95|[98|[97|[99|[107|[117|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]],[])
<'bad_mnesia_backup'> when 'true' -> call 'io_lib':'format' ([109|[110|[101|[115|[105|[97|[95|[98|[97|[99|[107|[117|[112|[32|[105|[110|[32|[98|[97|[100|[32|[112|[111|[115|[105|[116|[105|[111|[110|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<{'conflicting_versions',Lib,V1,V2}> when 'true' -> call 'io_lib':'format' ([67|[111|[110|[102|[108|[105|[99|[116|[105|[110|[103|[32|[118|[101|[114|[115|[105|[111|[110|[115|[32|[102|[111|[114|[32|[126|[119|[44|[32|[126|[116|[115|[32|[97|[110|[100|[32|[126|[116|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Lib|[V1|[V2|[]]]])
<{'no_appl_vsn',Appl}> when 'true' -> call 'io_lib':'format' ([78|[111|[32|[118|[101|[114|[115|[105|[111|[110|[32|[115|[112|[101|[99|[105|[102|[105|[101|[100|[32|[102|[111|[114|[32|[97|[112|[112|[108|[105|[99|[97|[116|[105|[111|[110|[58|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Appl|[]])
<{'no_such_module',Mod}> when 'true' -> call 'io_lib':'format' ([78|[111|[32|[115|[117|[99|[104|[32|[109|[111|[100|[117|[108|[101|[58|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]],[Mod|[]])
<'too_many_point_of_no_return'> when 'true' -> call 'io_lib':'format' ([84|[111|[111|[32|[109|[97|[110|[121|[32|[112|[111|[105|[110|[116|[95|[111|[102|[95|[110|[111|[95|[114|[101|[116|[117|[114|[110|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<{'bad_instruction',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[105|[110|[115|[116|[114|[117|[99|[116|[105|[111|[110|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_module',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[109|[111|[100|[117|[108|[101|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[97|[116|[111|[109|[40|[41|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_code_change',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[99|[111|[100|[101|[95|[99|[104|[97|[110|[103|[101|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[123|[77|[111|[100|[44|[32|[69|[120|[116|[114|[97|[125|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_change',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[99|[104|[97|[110|[103|[101|[32|[115|[112|[101|[99|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[115|[111|[102|[116|[32|[124|[32|[123|[97|[100|[118|[97|[110|[99|[101|[100|[44|[32|[69|[125|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_mod_type',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[109|[111|[100|[117|[108|[101|[32|[116|[121|[112|[101|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[115|[116|[97|[116|[105|[99|[32|[124|[32|[100|[121|[110|[97|[109|[105|[99|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_purge_method',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[112|[117|[114|[103|[101|[32|[109|[101|[116|[104|[111|[100|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[115|[111|[102|[116|[95|[112|[117|[114|[103|[101|[32|[124|[32|[98|[114|[117|[116|[97|[108|[95|[112|[117|[114|[103|[101|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_list',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[108|[105|[115|[116|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]],[X|[]])
<{'bad_args_list',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[97|[114|[103|[117|[109|[101|[110|[116|[32|[108|[105|[115|[116|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_node',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[110|[111|[100|[101|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[97|[116|[111|[109|[40|[41|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_application',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[97|[112|[112|[108|[105|[99|[97|[116|[105|[111|[110|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[97|[116|[111|[109|[40|[41|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_func',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[102|[117|[110|[99|[116|[105|[111|[110|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[97|[116|[111|[109|[40|[41|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_lib',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[108|[105|[98|[114|[97|[114|[121|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[97|[116|[111|[109|[40|[41|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_lib_vsn',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[108|[105|[98|[114|[97|[114|[121|[32|[118|[101|[114|[115|[105|[111|[110|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[115|[116|[114|[105|[110|[103|[40|[41|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'bad_timeout',X}> when 'true' -> call 'io_lib':'format' ([66|[97|[100|[32|[116|[105|[109|[101|[111|[117|[116|[58|[32|[126|[116|[112|[40|[115|[104|[111|[117|[108|[100|[32|[98|[101|[32|[105|[110|[102|[105|[110|[105|[116|[121|[32|[124|[32|[105|[110|[116|[40|[41|[32|[62|[32|[48|[41|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]])
<{'undef_module',Mod}> when 'true' -> call 'io_lib':'format' ([85|[110|[100|[101|[102|[105|[110|[101|[100|[32|[109|[111|[100|[117|[108|[101|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]],[Mod|[]])
<{'muldef_module',Mod}> when 'true' -> call 'io_lib':'format' ([77|[117|[108|[116|[105|[112|[108|[121|[32|[100|[101|[102|[105|[110|[101|[100|[32|[109|[111|[100|[117|[108|[101|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Mod|[]])
<E> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[126|[110]]]]],[E|[]]) end
'filtermap'/2 = fun (_0,_1) -> call 'lists':'zf' (_0,_1)
'split'/2 = fun (_0,_1) -> case <_0,_1> of <Fun,[H|T]> when 'true' -> case apply 'split'/2 (Fun,T) of <{Found,Rest}> when 'true' -> case apply Fun (H) of <'true'> when 'true' -> {[H|Found],Rest}
<'false'> when 'true' -> {Found,[H|Rest]}
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<_X_Fun,[]> when 'true' -> {[],[]}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'split',2}}] )-|['compiler_generated'] ) end
'union'/2 = fun (_0,_1) -> case <_0,_1> of <[H|T],L> when 'true' -> case call 'lists':'member' (H,L) of <'true'> when 'true' -> apply 'union'/2 (T,L)
<'false'> when 'true' -> let <_2> = apply 'union'/2 (T,L) in [H|_2]
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<[],L> when 'true' -> L
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'union',2}}] )-|['compiler_generated'] ) end
'difference'/2 = fun (_0,_1) -> case <_0,_1> of <[H|T],L> when 'true' -> case call 'lists':'member' (H,L) of <'true'> when 'true' -> apply 'difference'/2 (T,L)
<'false'> when 'true' -> let <_2> = apply 'difference'/2 (T,L) in [H|_2]
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<[],_6> when 'true' -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'difference',2}}] )-|['compiler_generated'] ) end
'condensation'/1 = fun (_0) -> let <H> = call 'digraph':'new' () in let <HVs> = call 'digraph_utils':'strong_components' (_0) in let <_5> = fun (_3) -> call 'digraph':'add_vertex' (H,_3) in do call 'lists':'foreach' (_5,HVs) let <_14> = fun (_12) -> let <GRs> = call 'digraph_utils':'reachable' (_12,_0) in let <_11> = fun (_9) -> case <> of <> when call 'erlang':'/=' (_12,_9) -> let <_7> = call 'erlang':'hd' (_9) in case call 'lists':'member' (_7,GRs) of <'true'> when 'true' -> call 'digraph':'add_edge' (H,_12,_9)
<_16> when 'true' -> 'ok' end
<> when 'true' -> 'ok' end in call 'lists':'foreach' (_11,HVs) in do call 'lists':'foreach' (_14,HVs) H
'restriction'/2 = fun (_0,_1) -> let <H> = call 'digraph':'new' () in let <_6> = fun (_4) -> case call 'digraph':'vertex' (_1,_4) of <{_17,Data}> when call 'erlang':'=:=' (_17,_4) -> call 'digraph':'add_vertex' (H,_4,Data)
<_18> when 'true' -> 'ok' end in do call 'lists':'foreach' (_6,_0) let <GEs> = call 'digraph':'edges' (_1) in let <_14> = fun (_12) -> case call 'digraph':'edge' (_1,_12) of <{_19,GV1,GV2,GData}> when 'true' -> let <_10> = call 'digraph':'vertex' (H,GV1) in let <_9> = call 'digraph':'vertex' (H,GV2) in case <_10,_9> of <({_20,_21}-|['compiler_generated'] ),({_22,_23}-|['compiler_generated'] )> when let <_24> = call 'erlang':'=:=' (_20,GV1) in let <_25> = call 'erlang':'=:=' (_22,GV2) in call 'erlang':'and' (_24,_25) -> call 'digraph':'add_edge' (H,_12,GV1,GV2,GData)
<(_28-|['compiler_generated'] ),(_29-|['compiler_generated'] )> when 'true' -> 'ok' end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end in do call 'lists':'foreach' (_14,GEs) H
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('systools_rc')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('systools_rc',_0) end