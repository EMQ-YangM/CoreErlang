module 'gb_sets' ['add'/2,'add_element'/2,'balance'/1,'del_element'/2,'delete'/2,'delete_any'/2,'difference'/2,'empty'/0,'filter'/2,'fold'/3,'from_list'/1,'from_ordset'/1,'insert'/2,'intersection'/1,'intersection'/2,'is_disjoint'/2,'is_element'/2,'is_empty'/1,'is_member'/2,'is_set'/1,'is_subset'/2,'iterator'/1,'iterator_from'/2,'largest'/1,'module_info'/0,'module_info'/1,'new'/0,'next'/1,'singleton'/1,'size'/1,'smallest'/1,'subtract'/2,'take_largest'/1,'take_smallest'/1,'to_list'/1,'union'/1,'union'/2] attributes [ 'file' = [{[115|[114|[99|[47|[103|[98|[95|[115|[101|[116|[115|[46|[101|[114|[108]]]]]]]]]]]]]]],1}]
, 'export_type' = [{'set',0}|[{'set',1}|[{'iter',0}|[{'iter',1}]]]]
, 'type' = [{'gb_set_node',{'type',199,'union',[{'atom',199,'nil'}|[{'type',199,'tuple',[{'var',199,'Element'}|[{'var',199,'_'}|[{'var',199,'_'}]]]}]]},[{'var',199,'Element'}]}]
, 'opaque' = [{'set',{'type',200,'tuple',[{'type',200,'non_neg_integer',[]}|[{'user_type',200,'gb_set_node',[{'var',200,'Element'}]}]]},[{'var',200,'Element'}]}]
, 'type' = [{'set',{'user_type',201,'set',[{'var',201,'_'}]},[]}]
, 'opaque' = [{'iter',{'type',202,'list',[{'user_type',202,'gb_set_node',[{'var',202,'Element'}]}]},[{'var',202,'Element'}]}]
, 'type' = [{'iter',{'user_type',203,'iter',[{'var',203,'_'}]},[]}]
, 'spec' = [{{'empty',0},[{'type',207,'bounded_fun',[{'type',207,'fun',[{'type',207,'product',[]}|[{'var',207,'Set'}]]}|[[{'type',208,'constraint',[{'atom',208,'is_subtype'}|[[{'var',208,'Set'}|[{'user_type',208,'set',[]}]]]]}]]]}]}]
, 'spec' = [{{'new',0},[{'type',213,'bounded_fun',[{'type',213,'fun',[{'type',213,'product',[]}|[{'var',213,'Set'}]]}|[[{'type',214,'constraint',[{'atom',214,'is_subtype'}|[[{'var',214,'Set'}|[{'user_type',214,'set',[]}]]]]}]]]}]}]
, 'spec' = [{{'is_empty',1},[{'type',218,'bounded_fun',[{'type',218,'fun',[{'type',218,'product',[{'var',218,'Set'}]}|[{'type',218,'boolean',[]}]]}|[[{'type',219,'constraint',[{'atom',219,'is_subtype'}|[[{'var',219,'Set'}|[{'user_type',219,'set',[]}]]]]}]]]}]}]
, 'spec' = [{{'size',1},[{'type',226,'bounded_fun',[{'type',226,'fun',[{'type',226,'product',[{'var',226,'Set'}]}|[{'type',226,'non_neg_integer',[]}]]}|[[{'type',227,'constraint',[{'atom',227,'is_subtype'}|[[{'var',227,'Set'}|[{'user_type',227,'set',[]}]]]]}]]]}]}]
, 'spec' = [{{'singleton',1},[{'type',232,'fun',[{'type',232,'product',[{'var',232,'Element'}]}|[{'user_type',232,'set',[{'var',232,'Element'}]}]]}]}]
, 'spec' = [{{'is_element',2},[{'type',237,'bounded_fun',[{'type',237,'fun',[{'type',237,'product',[{'var',237,'Element'}|[{'var',237,'Set'}]]}|[{'type',237,'boolean',[]}]]}|[[{'type',238,'constraint',[{'atom',238,'is_subtype'}|[[{'var',238,'Set'}|[{'user_type',238,'set',[{'var',238,'Element'}]}]]]]}]]]}]}]
, 'spec' = [{{'is_member',2},[{'type',243,'bounded_fun',[{'type',243,'fun',[{'type',243,'product',[{'var',243,'Element'}|[{'var',243,'Set'}]]}|[{'type',243,'boolean',[]}]]}|[[{'type',244,'constraint',[{'atom',244,'is_subtype'}|[[{'var',244,'Set'}|[{'user_type',244,'set',[{'var',244,'Element'}]}]]]]}]]]}]}]
, 'spec' = [{{'insert',2},[{'type',258,'bounded_fun',[{'type',258,'fun',[{'type',258,'product',[{'var',258,'Element'}|[{'var',258,'Set1'}]]}|[{'var',258,'Set2'}]]}|[[{'type',259,'constraint',[{'atom',259,'is_subtype'}|[[{'var',259,'Set1'}|[{'user_type',259,'set',[{'var',259,'Element'}]}]]]]}|[{'type',260,'constraint',[{'atom',260,'is_subtype'}|[[{'var',260,'Set2'}|[{'user_type',260,'set',[{'var',260,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'balance',1},[{'type',316,'bounded_fun',[{'type',316,'fun',[{'type',316,'product',[{'var',316,'Set1'}]}|[{'var',316,'Set2'}]]}|[[{'type',317,'constraint',[{'atom',317,'is_subtype'}|[[{'var',317,'Set1'}|[{'user_type',317,'set',[{'var',317,'Element'}]}]]]]}|[{'type',318,'constraint',[{'atom',318,'is_subtype'}|[[{'var',318,'Set2'}|[{'user_type',318,'set',[{'var',318,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'add_element',2},[{'type',343,'bounded_fun',[{'type',343,'fun',[{'type',343,'product',[{'var',343,'Element'}|[{'var',343,'Set1'}]]}|[{'var',343,'Set2'}]]}|[[{'type',344,'constraint',[{'atom',344,'is_subtype'}|[[{'var',344,'Set1'}|[{'user_type',344,'set',[{'var',344,'Element'}]}]]]]}|[{'type',345,'constraint',[{'atom',345,'is_subtype'}|[[{'var',345,'Set2'}|[{'user_type',345,'set',[{'var',345,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'add',2},[{'type',350,'bounded_fun',[{'type',350,'fun',[{'type',350,'product',[{'var',350,'Element'}|[{'var',350,'Set1'}]]}|[{'var',350,'Set2'}]]}|[[{'type',351,'constraint',[{'atom',351,'is_subtype'}|[[{'var',351,'Set1'}|[{'user_type',351,'set',[{'var',351,'Element'}]}]]]]}|[{'type',352,'constraint',[{'atom',352,'is_subtype'}|[[{'var',352,'Set2'}|[{'user_type',352,'set',[{'var',352,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'from_list',1},[{'type',362,'bounded_fun',[{'type',362,'fun',[{'type',362,'product',[{'var',362,'List'}]}|[{'var',362,'Set'}]]}|[[{'type',363,'constraint',[{'atom',363,'is_subtype'}|[[{'var',363,'List'}|[{'type',363,'list',[{'var',363,'Element'}]}]]]]}|[{'type',364,'constraint',[{'atom',364,'is_subtype'}|[[{'var',364,'Set'}|[{'user_type',364,'set',[{'var',364,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'from_ordset',1},[{'type',369,'bounded_fun',[{'type',369,'fun',[{'type',369,'product',[{'var',369,'List'}]}|[{'var',369,'Set'}]]}|[[{'type',370,'constraint',[{'atom',370,'is_subtype'}|[[{'var',370,'List'}|[{'type',370,'list',[{'var',370,'Element'}]}]]]]}|[{'type',371,'constraint',[{'atom',371,'is_subtype'}|[[{'var',371,'Set'}|[{'user_type',371,'set',[{'var',371,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'del_element',2},[{'type',377,'bounded_fun',[{'type',377,'fun',[{'type',377,'product',[{'var',377,'Element'}|[{'var',377,'Set1'}]]}|[{'var',377,'Set2'}]]}|[[{'type',378,'constraint',[{'atom',378,'is_subtype'}|[[{'var',378,'Set1'}|[{'user_type',378,'set',[{'var',378,'Element'}]}]]]]}|[{'type',379,'constraint',[{'atom',379,'is_subtype'}|[[{'var',379,'Set2'}|[{'user_type',379,'set',[{'var',379,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'delete_any',2},[{'type',384,'bounded_fun',[{'type',384,'fun',[{'type',384,'product',[{'var',384,'Element'}|[{'var',384,'Set1'}]]}|[{'var',384,'Set2'}]]}|[[{'type',385,'constraint',[{'atom',385,'is_subtype'}|[[{'var',385,'Set1'}|[{'user_type',385,'set',[{'var',385,'Element'}]}]]]]}|[{'type',386,'constraint',[{'atom',386,'is_subtype'}|[[{'var',386,'Set2'}|[{'user_type',386,'set',[{'var',386,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'delete',2},[{'type',396,'bounded_fun',[{'type',396,'fun',[{'type',396,'product',[{'var',396,'Element'}|[{'var',396,'Set1'}]]}|[{'var',396,'Set2'}]]}|[[{'type',397,'constraint',[{'atom',397,'is_subtype'}|[[{'var',397,'Set1'}|[{'user_type',397,'set',[{'var',397,'Element'}]}]]]]}|[{'type',398,'constraint',[{'atom',398,'is_subtype'}|[[{'var',398,'Set2'}|[{'user_type',398,'set',[{'var',398,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'take_smallest',1},[{'type',420,'bounded_fun',[{'type',420,'fun',[{'type',420,'product',[{'var',420,'Set1'}]}|[{'type',420,'tuple',[{'var',420,'Element'}|[{'var',420,'Set2'}]]}]]}|[[{'type',421,'constraint',[{'atom',421,'is_subtype'}|[[{'var',421,'Set1'}|[{'user_type',421,'set',[{'var',421,'Element'}]}]]]]}|[{'type',422,'constraint',[{'atom',422,'is_subtype'}|[[{'var',422,'Set2'}|[{'user_type',422,'set',[{'var',422,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'smallest',1},[{'type',434,'bounded_fun',[{'type',434,'fun',[{'type',434,'product',[{'var',434,'Set'}]}|[{'var',434,'Element'}]]}|[[{'type',435,'constraint',[{'atom',435,'is_subtype'}|[[{'var',435,'Set'}|[{'user_type',435,'set',[{'var',435,'Element'}]}]]]]}]]]}]}]
, 'spec' = [{{'take_largest',1},[{'type',445,'bounded_fun',[{'type',445,'fun',[{'type',445,'product',[{'var',445,'Set1'}]}|[{'type',445,'tuple',[{'var',445,'Element'}|[{'var',445,'Set2'}]]}]]}|[[{'type',446,'constraint',[{'atom',446,'is_subtype'}|[[{'var',446,'Set1'}|[{'user_type',446,'set',[{'var',446,'Element'}]}]]]]}|[{'type',447,'constraint',[{'atom',447,'is_subtype'}|[[{'var',447,'Set2'}|[{'user_type',447,'set',[{'var',447,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'largest',1},[{'type',459,'bounded_fun',[{'type',459,'fun',[{'type',459,'product',[{'var',459,'Set'}]}|[{'var',459,'Element'}]]}|[[{'type',460,'constraint',[{'atom',460,'is_subtype'}|[[{'var',460,'Set'}|[{'user_type',460,'set',[{'var',460,'Element'}]}]]]]}]]]}]}]
, 'spec' = [{{'to_list',1},[{'type',470,'bounded_fun',[{'type',470,'fun',[{'type',470,'product',[{'var',470,'Set'}]}|[{'var',470,'List'}]]}|[[{'type',471,'constraint',[{'atom',471,'is_subtype'}|[[{'var',471,'Set'}|[{'user_type',471,'set',[{'var',471,'Element'}]}]]]]}|[{'type',472,'constraint',[{'atom',472,'is_subtype'}|[[{'var',472,'List'}|[{'type',472,'list',[{'var',472,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'iterator',1},[{'type',483,'bounded_fun',[{'type',483,'fun',[{'type',483,'product',[{'var',483,'Set'}]}|[{'var',483,'Iter'}]]}|[[{'type',484,'constraint',[{'atom',484,'is_subtype'}|[[{'var',484,'Set'}|[{'user_type',484,'set',[{'var',484,'Element'}]}]]]]}|[{'type',485,'constraint',[{'atom',485,'is_subtype'}|[[{'var',485,'Iter'}|[{'user_type',485,'iter',[{'var',485,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'iterator_from',2},[{'type',500,'bounded_fun',[{'type',500,'fun',[{'type',500,'product',[{'var',500,'Element'}|[{'var',500,'Set'}]]}|[{'var',500,'Iter'}]]}|[[{'type',501,'constraint',[{'atom',501,'is_subtype'}|[[{'var',501,'Set'}|[{'user_type',501,'set',[{'var',501,'Element'}]}]]]]}|[{'type',502,'constraint',[{'atom',502,'is_subtype'}|[[{'var',502,'Iter'}|[{'user_type',502,'iter',[{'var',502,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'next',1},[{'type',516,'bounded_fun',[{'type',516,'fun',[{'type',516,'product',[{'var',516,'Iter1'}]}|[{'type',516,'union',[{'type',516,'tuple',[{'var',516,'Element'}|[{'var',516,'Iter2'}]]}|[{'atom',516,'none'}]]}]]}|[[{'type',517,'constraint',[{'atom',517,'is_subtype'}|[[{'var',517,'Iter1'}|[{'user_type',517,'iter',[{'var',517,'Element'}]}]]]]}|[{'type',518,'constraint',[{'atom',518,'is_subtype'}|[[{'var',518,'Iter2'}|[{'user_type',518,'iter',[{'var',518,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'union',2},[{'type',548,'bounded_fun',[{'type',548,'fun',[{'type',548,'product',[{'var',548,'Set1'}|[{'var',548,'Set2'}]]}|[{'var',548,'Set3'}]]}|[[{'type',549,'constraint',[{'atom',549,'is_subtype'}|[[{'var',549,'Set1'}|[{'user_type',549,'set',[{'var',549,'Element'}]}]]]]}|[{'type',550,'constraint',[{'atom',550,'is_subtype'}|[[{'var',550,'Set2'}|[{'user_type',550,'set',[{'var',550,'Element'}]}]]]]}|[{'type',551,'constraint',[{'atom',551,'is_subtype'}|[[{'var',551,'Set3'}|[{'user_type',551,'set',[{'var',551,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'mk_set',2},[{'type',573,'fun',[{'type',573,'product',[{'type',573,'non_neg_integer',[]}|[{'user_type',573,'gb_set_node',[{'var',573,'T'}]}]]}|[{'user_type',573,'set',[{'var',573,'T'}]}]]}]}]
, 'spec' = [{{'union',1},[{'type',653,'bounded_fun',[{'type',653,'fun',[{'type',653,'product',[{'var',653,'SetList'}]}|[{'var',653,'Set'}]]}|[[{'type',654,'constraint',[{'atom',654,'is_subtype'}|[[{'var',654,'SetList'}|[{'type',654,'nonempty_list',[{'user_type',654,'set',[{'var',654,'Element'}]}]}]]]]}|[{'type',655,'constraint',[{'atom',655,'is_subtype'}|[[{'var',655,'Set'}|[{'user_type',655,'set',[{'var',655,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'intersection',2},[{'type',668,'bounded_fun',[{'type',668,'fun',[{'type',668,'product',[{'var',668,'Set1'}|[{'var',668,'Set2'}]]}|[{'var',668,'Set3'}]]}|[[{'type',669,'constraint',[{'atom',669,'is_subtype'}|[[{'var',669,'Set1'}|[{'user_type',669,'set',[{'var',669,'Element'}]}]]]]}|[{'type',670,'constraint',[{'atom',670,'is_subtype'}|[[{'var',670,'Set2'}|[{'user_type',670,'set',[{'var',670,'Element'}]}]]]]}|[{'type',671,'constraint',[{'atom',671,'is_subtype'}|[[{'var',671,'Set3'}|[{'user_type',671,'set',[{'var',671,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'intersection',1},[{'type',719,'bounded_fun',[{'type',719,'fun',[{'type',719,'product',[{'var',719,'SetList'}]}|[{'var',719,'Set'}]]}|[[{'type',720,'constraint',[{'atom',720,'is_subtype'}|[[{'var',720,'SetList'}|[{'type',720,'nonempty_list',[{'user_type',720,'set',[{'var',720,'Element'}]}]}]]]]}|[{'type',721,'constraint',[{'atom',721,'is_subtype'}|[[{'var',721,'Set'}|[{'user_type',721,'set',[{'var',721,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'is_disjoint',2},[{'type',730,'bounded_fun',[{'type',730,'fun',[{'type',730,'product',[{'var',730,'Set1'}|[{'var',730,'Set2'}]]}|[{'type',730,'boolean',[]}]]}|[[{'type',731,'constraint',[{'atom',731,'is_subtype'}|[[{'var',731,'Set1'}|[{'user_type',731,'set',[{'var',731,'Element'}]}]]]]}|[{'type',732,'constraint',[{'atom',732,'is_subtype'}|[[{'var',732,'Set2'}|[{'user_type',732,'set',[{'var',732,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'subtract',2},[{'type',760,'bounded_fun',[{'type',760,'fun',[{'type',760,'product',[{'var',760,'Set1'}|[{'var',760,'Set2'}]]}|[{'var',760,'Set3'}]]}|[[{'type',761,'constraint',[{'atom',761,'is_subtype'}|[[{'var',761,'Set1'}|[{'user_type',761,'set',[{'var',761,'Element'}]}]]]]}|[{'type',762,'constraint',[{'atom',762,'is_subtype'}|[[{'var',762,'Set2'}|[{'user_type',762,'set',[{'var',762,'Element'}]}]]]]}|[{'type',763,'constraint',[{'atom',763,'is_subtype'}|[[{'var',763,'Set3'}|[{'user_type',763,'set',[{'var',763,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'difference',2},[{'type',768,'bounded_fun',[{'type',768,'fun',[{'type',768,'product',[{'var',768,'Set1'}|[{'var',768,'Set2'}]]}|[{'var',768,'Set3'}]]}|[[{'type',769,'constraint',[{'atom',769,'is_subtype'}|[[{'var',769,'Set1'}|[{'user_type',769,'set',[{'var',769,'Element'}]}]]]]}|[{'type',770,'constraint',[{'atom',770,'is_subtype'}|[[{'var',770,'Set2'}|[{'user_type',770,'set',[{'var',770,'Element'}]}]]]]}|[{'type',771,'constraint',[{'atom',771,'is_subtype'}|[[{'var',771,'Set3'}|[{'user_type',771,'set',[{'var',771,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'is_subset',2},[{'type',819,'bounded_fun',[{'type',819,'fun',[{'type',819,'product',[{'var',819,'Set1'}|[{'var',819,'Set2'}]]}|[{'type',819,'boolean',[]}]]}|[[{'type',820,'constraint',[{'atom',820,'is_subtype'}|[[{'var',820,'Set1'}|[{'user_type',820,'set',[{'var',820,'Element'}]}]]]]}|[{'type',821,'constraint',[{'atom',821,'is_subtype'}|[[{'var',821,'Set2'}|[{'user_type',821,'set',[{'var',821,'Element'}]}]]]]}]]]]}]}]
, 'spec' = [{{'is_set',1},[{'type',862,'bounded_fun',[{'type',862,'fun',[{'type',862,'product',[{'var',862,'Term'}]}|[{'type',862,'boolean',[]}]]}|[[{'type',863,'constraint',[{'atom',863,'is_subtype'}|[[{'var',863,'Term'}|[{'type',863,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'filter',2},[{'type',869,'bounded_fun',[{'type',869,'fun',[{'type',869,'product',[{'var',869,'Pred'}|[{'var',869,'Set1'}]]}|[{'var',869,'Set2'}]]}|[[{'type',870,'constraint',[{'atom',870,'is_subtype'}|[[{'var',870,'Pred'}|[{'type',870,'fun',[{'type',870,'product',[{'var',870,'Element'}]}|[{'type',870,'boolean',[]}]]}]]]]}|[{'type',871,'constraint',[{'atom',871,'is_subtype'}|[[{'var',871,'Set1'}|[{'user_type',871,'set',[{'var',871,'Element'}]}]]]]}|[{'type',872,'constraint',[{'atom',872,'is_subtype'}|[[{'var',872,'Set2'}|[{'user_type',872,'set',[{'var',872,'Element'}]}]]]]}]]]]]}]}]
, 'spec' = [{{'fold',3},[{'type',877,'bounded_fun',[{'type',877,'fun',[{'type',877,'product',[{'var',877,'Function'}|[{'var',877,'Acc0'}|[{'var',877,'Set'}]]]}|[{'var',877,'Acc1'}]]}|[[{'type',878,'constraint',[{'atom',878,'is_subtype'}|[[{'var',878,'Function'}|[{'type',878,'fun',[{'type',878,'product',[{'var',878,'Element'}|[{'var',878,'AccIn'}]]}|[{'var',878,'AccOut'}]]}]]]]}|[{'type',879,'constraint',[{'atom',879,'is_subtype'}|[[{'var',879,'Acc0'}|[{'var',879,'Acc'}]]]]}|[{'type',880,'constraint',[{'atom',880,'is_subtype'}|[[{'var',880,'Acc1'}|[{'var',880,'Acc'}]]]]}|[{'type',881,'constraint',[{'atom',881,'is_subtype'}|[[{'var',881,'AccIn'}|[{'var',881,'Acc'}]]]]}|[{'type',882,'constraint',[{'atom',882,'is_subtype'}|[[{'var',882,'AccOut'}|[{'var',882,'Acc'}]]]]}|[{'type',883,'constraint',[{'atom',883,'is_subtype'}|[[{'var',883,'Set'}|[{'user_type',883,'set',[{'var',883,'Element'}]}]]]]}]]]]]]]]}]}] ] 'empty'/0 = fun () -> {0,'nil'}
'new'/0 = fun () -> apply 'empty'/0 ()
'is_empty'/1 = fun (_0) -> case _0 of <{0,'nil'}> when 'true' -> 'true'
<_2> when 'true' -> 'false' end
'size'/1 = fun (_0) -> case _0 of <{Size,_2}> when 'true' -> Size
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'size',1}}] )-|['compiler_generated'] ) end
'singleton'/1 = fun (_0) -> {1,{_0,'nil','nil'}}
'is_element'/2 = fun (_0,_1) -> apply 'is_member'/2 (_0,_1)
'is_member'/2 = fun (_0,_1) -> case <_0,_1> of <Key,{_4,T}> when 'true' -> apply 'is_member_1'/2 (Key,T)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'is_member',2}}] )-|['compiler_generated'] ) end
'is_member_1'/2 = fun (_0,_1) -> case <_0,_1> of <Key,{Key1,Smaller,_4}> when call 'erlang':'<' (Key,Key1) -> apply 'is_member_1'/2 (Key,Smaller)
<Key,{Key1,_5,Bigger}> when call 'erlang':'>' (Key,Key1) -> apply 'is_member_1'/2 (Key,Bigger)
<_6,{_7,_8,_9}> when 'true' -> 'true'
<_10,'nil'> when 'true' -> 'false'
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'is_member_1',2}}] )-|['compiler_generated'] ) end
'insert'/2 = fun (_0,_1) -> case <_0,_1> of <Key,{S,T}> when 'true' -> let <S1> = call 'erlang':'+' (S,1) in let <_3> = call 'erlang':'*' (S1,S1) in let <_4> = apply 'insert_1'/3 (Key,T,_3) in {S1,_4}
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'insert',2}}] )-|['compiler_generated'] ) end
'insert_1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Key,{Key1,Smaller,Bigger},S> when call 'erlang':'<' (Key,Key1) -> let <_3> = call 'erlang':'bsr' (S,1) in case apply 'insert_1'/3 (Key,Smaller,_3) of <{T1,H1,S1}> when call 'erlang':'is_integer' (H1) -> let <T> = {Key1,T1,Bigger} in case apply 'count'/1 (Bigger) of <{H2,S2}> when 'true' -> let <_6> = call 'erlang':'max' (H1,H2) in let <H> = call 'erlang':'bsl' (_6,1) in let <_8> = call 'erlang':'+' (S1,S2) in let <SS> = call 'erlang':'+' (_8,1) in let <P> = call 'erlang':'*' (SS,SS) in case <> of <> when call 'erlang':'>' (H,P) -> apply 'balance'/2 (T,SS)
<> when 'true' -> {T,H,SS} end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<T1> when 'true' -> {Key1,T1,Bigger} end
<Key,{Key1,Smaller,Bigger},S> when call 'erlang':'>' (Key,Key1) -> let <_12> = call 'erlang':'bsr' (S,1) in case apply 'insert_1'/3 (Key,Bigger,_12) of <{T1,H1,S1}> when call 'erlang':'is_integer' (H1) -> let <T> = {Key1,Smaller,T1} in case apply 'count'/1 (Smaller) of <{H2,S2}> when 'true' -> let <_15> = call 'erlang':'max' (H1,H2) in let <H> = call 'erlang':'bsl' (_15,1) in let <_17> = call 'erlang':'+' (S1,S2) in let <SS> = call 'erlang':'+' (_17,1) in let <P> = call 'erlang':'*' (SS,SS) in case <> of <> when call 'erlang':'>' (H,P) -> apply 'balance'/2 (T,SS)
<> when 'true' -> {T,H,SS} end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<T1> when 'true' -> {Key1,Smaller,T1} end
<Key,'nil',0> when 'true' -> {{Key,'nil','nil'},1,1}
<Key,'nil',_24> when 'true' -> {Key,'nil','nil'}
<Key,_25,_26> when 'true' -> call 'erlang':'error' ({'key_exists',Key}) end
'count'/1 = fun (_0) -> case _0 of <{_8,'nil','nil'}> when 'true' -> {1,1}
<{_9,Sm,Bi}> when 'true' -> case apply 'count'/1 (Sm) of <{H1,S1}> when 'true' -> case apply 'count'/1 (Bi) of <{H2,S2}> when 'true' -> let <_5> = call 'erlang':'max' (H1,H2) in let <_6> = call 'erlang':'bsl' (_5,1) in let <_3> = call 'erlang':'+' (S1,S2) in let <_4> = call 'erlang':'+' (_3,1) in {_6,_4}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
<'nil'> when 'true' -> {1,0}
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'count',1}}] )-|['compiler_generated'] ) end
'balance'/1 = fun (_0) -> case _0 of <{S,T}> when 'true' -> let <_1> = apply 'balance'/2 (T,S) in {S,_1}
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'balance',1}}] )-|['compiler_generated'] ) end
'balance'/2 = fun (_0,_1) -> let <_2> = apply 'to_list_1'/1 (_0) in apply 'balance_list'/2 (_2,_1)
'balance_list'/2 = fun (_0,_1) -> case apply 'balance_list_1'/2 (_0,_1) of <{T,_5}> when 'true' -> T
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'balance_list_1'/2 = fun (_0,_1) -> case <_0,_1> of <L,S> when call 'erlang':'>' (S,1) -> let <Sm> = call 'erlang':'-' (S,1) in let <S2> = call 'erlang':'div' (Sm,2) in let <S1> = call 'erlang':'-' (Sm,S2) in case apply 'balance_list_1'/2 (L,S1) of <{T1,[K|L1]}> when 'true' -> case apply 'balance_list_1'/2 (L1,S2) of <{T2,L2}> when 'true' -> let <T> = {K,T1,T2} in {T,L2}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<[Key|L],1> when 'true' -> {{Key,'nil','nil'},L}
<L,0> when 'true' -> {'nil',L}
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'balance_list_1',2}}] )-|['compiler_generated'] ) end
'add_element'/2 = fun (_0,_1) -> apply 'add'/2 (_0,_1)
'add'/2 = fun (_0,_1) -> case apply 'is_member'/2 (_0,_1) of <'true'> when 'true' -> _1
<'false'> when 'true' -> apply 'insert'/2 (_0,_1)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'from_list'/1 = fun (_0) -> let <_1> = call 'ordsets':'from_list' (_0) in apply 'from_ordset'/1 (_1)
'from_ordset'/1 = fun (_0) -> let <S> = call 'erlang':'length' (_0) in let <_2> = apply 'balance_list'/2 (_0,S) in {S,_2}
'del_element'/2 = fun (_0,_1) -> apply 'delete_any'/2 (_0,_1)
'delete_any'/2 = fun (_0,_1) -> case apply 'is_member'/2 (_0,_1) of <'true'> when 'true' -> apply 'delete'/2 (_0,_1)
<'false'> when 'true' -> _1
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'delete'/2 = fun (_0,_1) -> case <_0,_1> of <Key,{S,T}> when 'true' -> let <_3> = call 'erlang':'-' (S,1) in let <_2> = apply 'delete_1'/2 (Key,T) in {_3,_2}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'delete',2}}] )-|['compiler_generated'] ) end
'delete_1'/2 = fun (_0,_1) -> case <_0,_1> of <Key,{Key1,Smaller,Larger}> when call 'erlang':'<' (Key,Key1) -> let <Smaller1> = apply 'delete_1'/2 (Key,Smaller) in {Key1,Smaller1,Larger}
<Key,{Key1,Smaller,Bigger}> when call 'erlang':'>' (Key,Key1) -> let <Bigger1> = apply 'delete_1'/2 (Key,Bigger) in {Key1,Smaller,Bigger1}
<_6,{_7,Smaller,Larger}> when 'true' -> apply 'merge'/2 (Smaller,Larger)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'delete_1',2}}] )-|['compiler_generated'] ) end
'merge'/2 = fun (_0,_1) -> case <_0,_1> of <Smaller,'nil'> when 'true' -> Smaller
<'nil',Larger> when 'true' -> Larger
<Smaller,Larger> when 'true' -> case apply 'take_smallest1'/1 (Larger) of <{Key,Larger1}> when 'true' -> {Key,Smaller,Larger1}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end end
'take_smallest'/1 = fun (_0) -> case _0 of <{S,T}> when 'true' -> case apply 'take_smallest1'/1 (T) of <{Key,Larger}> when 'true' -> let <_2> = call 'erlang':'-' (S,1) in {Key,{_2,Larger}}
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'take_smallest',1}}] )-|['compiler_generated'] ) end
'take_smallest1'/1 = fun (_0) -> case _0 of <{Key,'nil',Larger}> when 'true' -> {Key,Larger}
<{Key,Smaller,Larger}> when 'true' -> case apply 'take_smallest1'/1 (Smaller) of <{Key1,Smaller1}> when 'true' -> {Key1,{Key,Smaller1,Larger}}
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'take_smallest1',1}}] )-|['compiler_generated'] ) end
'smallest'/1 = fun (_0) -> case _0 of <{_2,T}> when 'true' -> apply 'smallest_1'/1 (T)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'smallest',1}}] )-|['compiler_generated'] ) end
'smallest_1'/1 = fun (_0) -> case _0 of <{Key,'nil',_X_Larger}> when 'true' -> Key
<{_X_Key,Smaller,_X_Larger}> when 'true' -> apply 'smallest_1'/1 (Smaller)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'smallest_1',1}}] )-|['compiler_generated'] ) end
'take_largest'/1 = fun (_0) -> case _0 of <{S,T}> when 'true' -> case apply 'take_largest1'/1 (T) of <{Key,Smaller}> when 'true' -> let <_2> = call 'erlang':'-' (S,1) in {Key,{_2,Smaller}}
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'take_largest',1}}] )-|['compiler_generated'] ) end
'take_largest1'/1 = fun (_0) -> case _0 of <{Key,Smaller,'nil'}> when 'true' -> {Key,Smaller}
<{Key,Smaller,Larger}> when 'true' -> case apply 'take_largest1'/1 (Larger) of <{Key1,Larger1}> when 'true' -> {Key1,{Key,Smaller,Larger1}}
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'take_largest1',1}}] )-|['compiler_generated'] ) end
'largest'/1 = fun (_0) -> case _0 of <{_2,T}> when 'true' -> apply 'largest_1'/1 (T)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'largest',1}}] )-|['compiler_generated'] ) end
'largest_1'/1 = fun (_0) -> case _0 of <{Key,_X_Smaller,'nil'}> when 'true' -> Key
<{_X_Key,_X_Smaller,Larger}> when 'true' -> apply 'largest_1'/1 (Larger)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'largest_1',1}}] )-|['compiler_generated'] ) end
'to_list'/1 = fun (_0) -> case _0 of <{_2,T}> when 'true' -> apply 'to_list'/2 (T,[])
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'to_list',1}}] )-|['compiler_generated'] ) end
'to_list_1'/1 = fun (_0) -> apply 'to_list'/2 (_0,[])
'to_list'/2 = fun (_0,_1) -> case <_0,_1> of <{Key,Small,Big},L> when 'true' -> let <_2> = apply 'to_list'/2 (Big,L) in apply 'to_list'/2 (Small,[Key|_2])
<'nil',L> when 'true' -> L
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'to_list',2}}] )-|['compiler_generated'] ) end
'iterator'/1 = fun (_0) -> case _0 of <{_2,T}> when 'true' -> apply 'iterator'/2 (T,[])
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'iterator',1}}] )-|['compiler_generated'] ) end
'iterator'/2 = fun (_0,_1) -> case <_0,_1> of <T = {_4,'nil',_5},As> when 'true' -> [T|As]
<T = {_6,L,_7},As> when 'true' -> apply 'iterator'/2 (L,[T|As])
<'nil',As> when 'true' -> As
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'iterator',2}}] )-|['compiler_generated'] ) end
'iterator_from'/2 = fun (_0,_1) -> case <_0,_1> of <S,{_4,T}> when 'true' -> apply 'iterator_from'/3 (S,T,[])
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'iterator_from',2}}] )-|['compiler_generated'] ) end
'iterator_from'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <S,{K,_6,T},As> when call 'erlang':'<' (K,S) -> apply 'iterator_from'/3 (S,T,As)
<_7,T = {_8,'nil',_9},As> when 'true' -> [T|As]
<S,T = {_10,L,_11},As> when 'true' -> apply 'iterator_from'/3 (S,L,[T|As])
<_12,'nil',As> when 'true' -> As
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'iterator_from',3}}] )-|['compiler_generated'] ) end
'next'/1 = fun (_0) -> case _0 of <[{X,_3,T}|As]> when 'true' -> let <_1> = apply 'iterator'/2 (T,As) in {X,_1}
<[]> when 'true' -> 'none'
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'next',1}}] )-|['compiler_generated'] ) end
'union'/2 = fun (_0,_1) -> case <_0,_1> of <{N1,T1},{N2,T2}> when call 'erlang':'<' (N2,N1) -> let <_2> = apply 'to_list_1'/1 (T2) in apply 'union'/4 (_2,N2,T1,N1)
<{N1,T1},{N2,T2}> when 'true' -> let <_3> = apply 'to_list_1'/1 (T1) in apply 'union'/4 (_3,N1,T2,N2)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'union',2}}] )-|['compiler_generated'] ) end
'union'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L,N1,T2,N2> when call 'erlang':'<' (N2,10) -> let <_5> = apply 'to_list_1'/1 (T2) in let <_4> = call 'erlang':'+' (N1,N2) in apply 'union_2'/3 (L,_5,_4)
<L,N1,T2,N2> when 'true' -> let <_6> = call 'math':'log' (N2) in let <_7> = call 'erlang':'*' (1.46,_6) in let <_8> = call 'erlang':'round' (_7) in let <X> = call 'erlang':'*' (N1,_8) in case <> of <> when call 'erlang':'<' (N2,X) -> let <_11> = apply 'to_list_1'/1 (T2) in let <_10> = call 'erlang':'+' (N1,N2) in apply 'union_2'/3 (L,_11,_10)
<> when 'true' -> let <_12> = apply 'mk_set'/2 (N2,T2) in apply 'union_1'/2 (L,_12) end end
'mk_set'/2 = fun (_0,_1) -> {_0,_1}
'union_1'/2 = fun (_0,_1) -> case <_0,_1> of <[X|Xs],S> when 'true' -> let <_2> = apply 'add'/2 (X,S) in apply 'union_1'/2 (Xs,_2)
<[],S> when 'true' -> S
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'union_1',2}}] )-|['compiler_generated'] ) end
'union_2'/3 = fun (_0,_1,_2) -> apply 'union_2'/4 (_0,_1,[],_2)
'union_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[X|Xs1],Ys = [Y|_13],As,S> when call 'erlang':'<' (X,Y) -> apply 'union_2'/4 (Xs1,Ys,[X|As],S)
<Xs = [X|_14],[Y|Ys1],As,S> when call 'erlang':'>' (X,Y) -> apply 'union_2'/4 (Ys1,Xs,[Y|As],S)
<[X|Xs1],[_15|Ys1],As,S> when 'true' -> let <_4> = call 'erlang':'-' (S,1) in apply 'union_2'/4 (Xs1,Ys1,[X|As],_4)
<[],Ys,As,S> when 'true' -> let <_5> = apply 'push'/2 (Ys,As) in let <_6> = apply 'balance_revlist'/2 (_5,S) in {S,_6}
<Xs,[],As,S> when 'true' -> let <_7> = apply 'push'/2 (Xs,As) in let <_8> = apply 'balance_revlist'/2 (_7,S) in {S,_8}
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'union_2',4}}] )-|['compiler_generated'] ) end
'push'/2 = fun (_0,_1) -> case <_0,_1> of <[X|Xs],As> when 'true' -> apply 'push'/2 (Xs,[X|As])
<[],As> when 'true' -> As
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'push',2}}] )-|['compiler_generated'] ) end
'balance_revlist'/2 = fun (_0,_1) -> case apply 'balance_revlist_1'/2 (_0,_1) of <{T,_5}> when 'true' -> T
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'balance_revlist_1'/2 = fun (_0,_1) -> case <_0,_1> of <L,S> when call 'erlang':'>' (S,1) -> let <Sm> = call 'erlang':'-' (S,1) in let <S2> = call 'erlang':'div' (Sm,2) in let <S1> = call 'erlang':'-' (Sm,S2) in case apply 'balance_revlist_1'/2 (L,S1) of <{T2,[K|L1]}> when 'true' -> case apply 'balance_revlist_1'/2 (L1,S2) of <{T1,L2}> when 'true' -> let <T> = {K,T1,T2} in {T,L2}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<[Key|L],1> when 'true' -> {{Key,'nil','nil'},L}
<L,0> when 'true' -> {'nil',L}
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'balance_revlist_1',2}}] )-|['compiler_generated'] ) end
'union'/1 = fun (_0) -> case _0 of <[S|Ss]> when 'true' -> apply 'union_list'/2 (S,Ss)
<[]> when 'true' -> apply 'empty'/0 ()
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'union',1}}] )-|['compiler_generated'] ) end
'union_list'/2 = fun (_0,_1) -> case <_0,_1> of <S,[S1|Ss]> when 'true' -> let <_2> = apply 'union'/2 (S,S1) in apply 'union_list'/2 (_2,Ss)
<S,[]> when 'true' -> S
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'union_list',2}}] )-|['compiler_generated'] ) end
'intersection'/2 = fun (_0,_1) -> case <_0,_1> of <{N1,T1},{N2,T2}> when call 'erlang':'<' (N2,N1) -> let <_2> = apply 'to_list_1'/1 (T2) in apply 'intersection'/4 (_2,N2,T1,N1)
<{N1,T1},{N2,T2}> when 'true' -> let <_3> = apply 'to_list_1'/1 (T1) in apply 'intersection'/4 (_3,N1,T2,N2)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'intersection',2}}] )-|['compiler_generated'] ) end
'intersection'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L,_X_N1,T2,N2> when call 'erlang':'<' (N2,10) -> let <_4> = apply 'to_list_1'/1 (T2) in apply 'intersection_2'/2 (L,_4)
<L,N1,T2,N2> when 'true' -> let <_5> = call 'math':'log' (N2) in let <_6> = call 'erlang':'*' (1.46,_5) in let <_7> = call 'erlang':'round' (_6) in let <X> = call 'erlang':'*' (N1,_7) in case <> of <> when call 'erlang':'<' (N2,X) -> let <_9> = apply 'to_list_1'/1 (T2) in apply 'intersection_2'/2 (L,_9)
<> when 'true' -> apply 'intersection_1'/2 (L,T2) end end
'intersection_1'/2 = fun (_0,_1) -> apply 'intersection_1'/4 (_0,_1,[],0)
'intersection_1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[X|Xs],T,As,N> when 'true' -> case apply 'is_member_1'/2 (X,T) of <'true'> when 'true' -> let <_4> = call 'erlang':'+' (N,1) in apply 'intersection_1'/4 (Xs,T,[X|As],_4)
<'false'> when 'true' -> apply 'intersection_1'/4 (Xs,T,As,N)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<[],_11,As,N> when 'true' -> let <_6> = apply 'balance_revlist'/2 (As,N) in {N,_6}
(<_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7})-|[{'function_name',{'intersection_1',4}}] )-|['compiler_generated'] ) end
'intersection_2'/2 = fun (_0,_1) -> apply 'intersection_2'/4 (_0,_1,[],0)
'intersection_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[X|Xs1],Ys = [Y|_11],As,S> when call 'erlang':'<' (X,Y) -> apply 'intersection_2'/4 (Xs1,Ys,As,S)
<Xs = [X|_12],[Y|Ys1],As,S> when call 'erlang':'>' (X,Y) -> apply 'intersection_2'/4 (Ys1,Xs,As,S)
<[X|Xs1],[_13|Ys1],As,S> when 'true' -> let <_4> = call 'erlang':'+' (S,1) in apply 'intersection_2'/4 (Xs1,Ys1,[X|As],_4)
<[],_14,As,S> when 'true' -> let <_5> = apply 'balance_revlist'/2 (As,S) in {S,_5}
<_15,[],As,S> when 'true' -> let <_6> = apply 'balance_revlist'/2 (As,S) in {S,_6}
(<_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7})-|[{'function_name',{'intersection_2',4}}] )-|['compiler_generated'] ) end
'intersection'/1 = fun (_0) -> case _0 of <[S|Ss]> when 'true' -> apply 'intersection_list'/2 (S,Ss)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'intersection',1}}] )-|['compiler_generated'] ) end
'intersection_list'/2 = fun (_0,_1) -> case <_0,_1> of <S,[S1|Ss]> when 'true' -> let <_2> = apply 'intersection'/2 (S,S1) in apply 'intersection_list'/2 (_2,Ss)
<S,[]> when 'true' -> S
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'intersection_list',2}}] )-|['compiler_generated'] ) end
'is_disjoint'/2 = fun (_0,_1) -> case <_0,_1> of <{N1,T1},{N2,T2}> when call 'erlang':'<' (N1,N2) -> apply 'is_disjoint_1'/2 (T1,T2)
<{_4,T1},{_5,T2}> when 'true' -> apply 'is_disjoint_1'/2 (T2,T1)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'is_disjoint',2}}] )-|['compiler_generated'] ) end
'is_disjoint_1'/2 = fun (_0,_1) -> case <_0,_1> of <{K1,Smaller1,Bigger},Tree = {K2,Smaller2,_14}> when call 'erlang':'<' (K1,K2) -> (case apply 'is_member_1'/2 (K1,Smaller2) of (<'false'> when 'true' -> (case apply 'is_disjoint_1'/2 (Smaller1,Smaller2) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_disjoint_1'/2 (Bigger,Tree)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_4> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_4}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<'true'> when 'true' -> 'false'-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['compiler_generated'] )
<{K1,Smaller,Bigger1},Tree = {K2,_15,Bigger2}> when call 'erlang':'>' (K1,K2) -> (case apply 'is_member_1'/2 (K1,Bigger2) of (<'false'> when 'true' -> (case apply 'is_disjoint_1'/2 (Bigger1,Bigger2) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_disjoint_1'/2 (Smaller,Tree)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_9}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<'true'> when 'true' -> 'false'-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['compiler_generated'] )
<{_X_K1,_16,_17},{_X_K2,_18,_19}> when 'true' -> 'false'
<'nil',_20> when 'true' -> 'true'
<_21,'nil'> when 'true' -> 'true'
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'is_disjoint_1',2}}] )-|['compiler_generated'] ) end
'subtract'/2 = fun (_0,_1) -> apply 'difference'/2 (_0,_1)
'difference'/2 = fun (_0,_1) -> case <_0,_1> of <{N1,T1},{N2,T2}> when 'true' -> let <_2> = apply 'to_list_1'/1 (T1) in apply 'difference'/4 (_2,N1,T2,N2)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'difference',2}}] )-|['compiler_generated'] ) end
'difference'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L,N1,T2,N2> when call 'erlang':'<' (N2,10) -> let <_4> = apply 'to_list_1'/1 (T2) in apply 'difference_2'/3 (L,_4,N1)
<L,N1,T2,N2> when 'true' -> let <_5> = call 'math':'log' (N2) in let <_6> = call 'erlang':'*' (1.46,_5) in let <_7> = call 'erlang':'round' (_6) in let <X> = call 'erlang':'*' (N1,_7) in case <> of <> when call 'erlang':'<' (N2,X) -> let <_9> = apply 'to_list_1'/1 (T2) in apply 'difference_2'/3 (L,_9,N1)
<> when 'true' -> apply 'difference_1'/2 (L,T2) end end
'difference_1'/2 = fun (_0,_1) -> apply 'difference_1'/4 (_0,_1,[],0)
'difference_1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[X|Xs],T,As,N> when 'true' -> case apply 'is_member_1'/2 (X,T) of <'true'> when 'true' -> apply 'difference_1'/4 (Xs,T,As,N)
<'false'> when 'true' -> let <_4> = call 'erlang':'+' (N,1) in apply 'difference_1'/4 (Xs,T,[X|As],_4)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<[],_11,As,N> when 'true' -> let <_6> = apply 'balance_revlist'/2 (As,N) in {N,_6}
(<_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7})-|[{'function_name',{'difference_1',4}}] )-|['compiler_generated'] ) end
'difference_2'/3 = fun (_0,_1,_2) -> apply 'difference_2'/4 (_0,_1,[],_2)
'difference_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[X|Xs1],Ys = [Y|_12],As,S> when call 'erlang':'<' (X,Y) -> apply 'difference_2'/4 (Xs1,Ys,[X|As],S)
<Xs = [X|_13],[Y|Ys1],As,S> when call 'erlang':'>' (X,Y) -> apply 'difference_2'/4 (Xs,Ys1,As,S)
<[_X_X|Xs1],[_X_Y|Ys1],As,S> when 'true' -> let <_4> = call 'erlang':'-' (S,1) in apply 'difference_2'/4 (Xs1,Ys1,As,_4)
<[],_X_Ys,As,S> when 'true' -> let <_5> = apply 'balance_revlist'/2 (As,S) in {S,_5}
<Xs,[],As,S> when 'true' -> let <_6> = apply 'push'/2 (Xs,As) in let <_7> = apply 'balance_revlist'/2 (_6,S) in {S,_7}
(<_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8})-|[{'function_name',{'difference_2',4}}] )-|['compiler_generated'] ) end
'is_subset'/2 = fun (_0,_1) -> case <_0,_1> of <{N1,T1},{N2,T2}> when 'true' -> let <_2> = apply 'to_list_1'/1 (T1) in apply 'is_subset'/4 (_2,N1,T2,N2)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'is_subset',2}}] )-|['compiler_generated'] ) end
'is_subset'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L,_X_N1,T2,N2> when call 'erlang':'<' (N2,10) -> let <_4> = apply 'to_list_1'/1 (T2) in apply 'is_subset_2'/2 (L,_4)
<L,N1,T2,N2> when 'true' -> let <_5> = call 'math':'log' (N2) in let <_6> = call 'erlang':'*' (1.46,_5) in let <_7> = call 'erlang':'round' (_6) in let <X> = call 'erlang':'*' (N1,_7) in case <> of <> when call 'erlang':'<' (N2,X) -> let <_9> = apply 'to_list_1'/1 (T2) in apply 'is_subset_2'/2 (L,_9)
<> when 'true' -> apply 'is_subset_1'/2 (L,T2) end end
'is_subset_1'/2 = fun (_0,_1) -> case <_0,_1> of <[X|Xs],T> when 'true' -> case apply 'is_member_1'/2 (X,T) of <'true'> when 'true' -> apply 'is_subset_1'/2 (Xs,T)
<'false'> when 'true' -> 'false'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<[],_5> when 'true' -> 'true'
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'is_subset_1',2}}] )-|['compiler_generated'] ) end
'is_subset_2'/2 = fun (_0,_1) -> case <_0,_1> of <[X|_4],[Y|_5]> when call 'erlang':'<' (X,Y) -> 'false'
<Xs = [X|_6],[Y|Ys1]> when call 'erlang':'>' (X,Y) -> apply 'is_subset_2'/2 (Xs,Ys1)
<[_7|Xs1],[_8|Ys1]> when 'true' -> apply 'is_subset_2'/2 (Xs1,Ys1)
<[],_9> when 'true' -> 'true'
<_10,[]> when 'true' -> 'false'
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'is_subset_2',2}}] )-|['compiler_generated'] ) end
'is_set'/1 = fun (_0) -> case _0 of <{0,'nil'}> when 'true' -> 'true'
<{N,{_4,_5,_6}}> when let <_1> = call 'erlang':'is_integer' (N) in let <_2> = call 'erlang':'>=' (N,0) in call 'erlang':'and' (_1,_2) -> 'true'
<_7> when 'true' -> 'false' end
'filter'/2 = fun (_0,_1) -> let <_8> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[X|_3]> when 'true' -> (case apply _0 (X) of <'true'> when 'true' -> let <_6> = apply 'lc$^0'/1 (_3) in ([X|_6]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end-|['list_comprehension'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_4> = apply 'to_list'/1 (_1) in apply 'lc$^0'/1 (_4) in apply 'from_ordset'/1 (_8)
'fold'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F,A,{_6,T}> when call 'erlang':'is_function' (F,2) -> apply 'fold_1'/3 (F,A,T)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'fold',3}}] )-|['compiler_generated'] ) end
'fold_1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F,Acc0,{Key,Small,Big}> when 'true' -> let <Acc1> = apply 'fold_1'/3 (F,Acc0,Small) in let <Acc> = apply F (Key,Acc1) in apply 'fold_1'/3 (F,Acc,Big)
<_8,Acc,_9> when 'true' -> Acc end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('gb_sets')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('gb_sets',_0) end