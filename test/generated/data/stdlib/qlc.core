module 'qlc' ['all_selections'/1,'append'/1,'append'/2,'aux_name'/3,'cursor'/1,'cursor'/2,'delete_cursor'/1,'e'/1,'e'/2,'eval'/1,'eval'/2,'fold'/3,'fold'/4,'format_error'/1,'info'/1,'info'/2,'keysort'/2,'keysort'/3,'module_info'/0,'module_info'/1,'name_suffix'/2,'next_answers'/1,'next_answers'/2,'parse_transform'/2,'q'/1,'q'/2,'sort'/1,'sort'/2,'string_to_handle'/1,'string_to_handle'/2,'string_to_handle'/3,'table'/2,'template_state'/0,'transform_from_evaluator'/2,'var_fold'/3,'var_ufold'/2,'vars'/1] attributes [ 'file' = [{[115|[114|[99|[47|[113|[108|[99|[46|[101|[114|[108]]]]]]]]]]],1}]
, 'compile' = [{'no_auto_import',[{'error',1}]}]
, 'dialyzer' = ['no_improper_lists']
, 'record' = [{'qlc_append',[{'record_field',61,{'atom',61,'hl'}}]}]
, 'record' = [{'qlc_table',[{'record_field',65,{'atom',65,'trav_fun'}}|[{'record_field',66,{'atom',66,'trav_MS'}}|[{'record_field',67,{'atom',67,'pre_fun'}}|[{'record_field',68,{'atom',68,'post_fun'}}|[{'record_field',69,{'atom',69,'info_fun'}}|[{'record_field',70,{'atom',70,'format_fun'}}|[{'record_field',71,{'atom',71,'lookup_fun'}}|[{'record_field',72,{'atom',72,'parent_fun'}}|[{'record_field',73,{'atom',73,'key_equality'}}|[{'record_field',74,{'atom',74,'lu_vals'}}|[{'record_field',75,{'atom',75,'ms'},{'atom',75,'no_match_spec'}}]]]]]]]]]]]}]
, 'record' = [{'qlc_sort',[{'record_field',80,{'atom',80,'h'}}|[{'record_field',81,{'atom',81,'keypos'}}|[{'record_field',82,{'atom',82,'unique'}}|[{'record_field',83,{'atom',83,'compressed'}}|[{'record_field',84,{'atom',84,'order'}}|[{'record_field',85,{'atom',85,'fs_opts'}}|[{'record_field',86,{'atom',86,'tmpdir_usage'},{'atom',86,'allowed'}}|[{'record_field',88,{'atom',88,'tmpdir'}}]]]]]]]]}]
, 'record' = [{'qlc_lc',[{'record_field',93,{'atom',93,'lc'}}|[{'record_field',94,{'atom',94,'opt'}}]]}]
, 'record' = [{'qlc_list',[{'record_field',98,{'atom',98,'l'}}|[{'record_field',99,{'atom',99,'ms'},{'atom',99,'no_match_spec'}}]]}]
, 'record' = [{'qlc_join',[{'record_field',103,{'atom',103,'kind'}}|[{'record_field',105,{'atom',105,'opt'}}|[{'record_field',106,{'atom',106,'h1'}}|[{'record_field',106,{'atom',106,'q1'}}|[{'record_field',106,{'atom',106,'c1'}}|[{'record_field',107,{'atom',107,'h2'}}|[{'record_field',107,{'atom',107,'q2'}}|[{'record_field',107,{'atom',107,'c2'}}]]]]]]]]}]
, 'record' = [{'qlc_cursor',[{'record_field',113,{'atom',113,'c'}}]}]
, 'record' = [{'qlc_opt',[{'record_field',116,{'atom',116,'unique'},{'atom',116,'false'}}|[{'record_field',117,{'atom',117,'cache'},{'atom',117,'false'}}|[{'record_field',118,{'atom',118,'max_lookup'},{'op',118,'-',{'integer',118,1}}}|[{'record_field',119,{'atom',119,'join'},{'atom',119,'any'}}|[{'record_field',120,{'atom',120,'tmpdir'},{'string',120,[]}}|[{'record_field',121,{'atom',121,'lookup'},{'atom',121,'any'}}|[{'record_field',122,{'atom',122,'max_list'},{'op',122,'*',{'integer',122,512},{'integer',122,1024}}}|[{'record_field',123,{'atom',123,'tmpdir_usage'},{'atom',123,'allowed'}}]]]]]]]]}]
, 'record' = [{'setup',[{'record_field',127,{'atom',127,'parent'}}]}]
, 'export_type' = [{'query_cursor',0}|[{'query_handle',0}]]
, 'record' = [{'qlc_handle',[{'record_field',136,{'atom',136,'h'}}]}]
, 'type' = [{'query_list_comprehension',{'type',152,'term',[]},[]}]
, 'opaque' = [{'query_cursor',{'type',153,'tuple',[{'atom',153,'qlc_cursor'}|[{'type',153,'term',[]}]]},[]}]
, 'opaque' = [{'query_handle',{'type',154,'tuple',[{'atom',154,'qlc_handle'}|[{'type',154,'term',[]}]]},[]}]
, 'type' = [{'query_handle_or_list',{'type',155,'union',[{'user_type',155,'query_handle',[]}|[{'type',155,'list',[]}]]},[]}]
, 'type' = [{'answers',{'type',156,'list',[{'user_type',156,'answer',[]}]},[]}]
, 'type' = [{'answer',{'type',157,'term',[]},[]}]
, 'type' = [{'abstract_expr',{'remote_type',158,[{'atom',158,'erl_parse'}|[{'atom',158,'abstract_expr'}|[[]]]]},[]}]
, 'type' = [{'match_expression',{'remote_type',159,[{'atom',159,'ets'}|[{'atom',159,'match_spec'}|[[]]]]},[]}]
, 'type' = [{'spawn_options',{'type',160,'union',[{'atom',160,'default'}|[{'type',160,'list',[{'remote_type',160,[{'atom',160,'proc_lib'}|[{'atom',160,'spawn_option'}|[[]]]]}]}]]},[]}]
, 'type' = [{'sort_options',{'type',161,'union',[{'type',161,'list',[{'user_type',161,'sort_option',[]}]}|[{'user_type',161,'sort_option',[]}]]},[]}]
, 'type' = [{'sort_option',{'type',162,'union',[{'type',162,'tuple',[{'atom',162,'compressed'}|[{'type',162,'boolean',[]}]]}|[{'type',163,'tuple',[{'atom',163,'no_files'}|[{'user_type',163,'no_files',[]}]]}|[{'type',164,'tuple',[{'atom',164,'order'}|[{'user_type',164,'order',[]}]]}|[{'type',165,'tuple',[{'atom',165,'size'}|[{'type',165,'pos_integer',[]}]]}|[{'type',166,'tuple',[{'atom',166,'tmpdir'}|[{'user_type',166,'tmp_directory',[]}]]}|[{'type',167,'tuple',[{'atom',167,'unique'}|[{'type',167,'boolean',[]}]]}]]]]]]},[]}]
, 'type' = [{'order',{'type',168,'union',[{'atom',168,'ascending'}|[{'atom',168,'descending'}|[{'user_type',168,'order_fun',[]}]]]},[]}]
, 'type' = [{'order_fun',{'type',169,'fun',[{'type',169,'product',[{'type',169,'term',[]}|[{'type',169,'term',[]}]]}|[{'type',169,'boolean',[]}]]},[]}]
, 'type' = [{'tmp_directory',{'type',170,'union',[{'type',170,'nil',[]}|[{'remote_type',170,[{'atom',170,'file'}|[{'atom',170,'name'}|[[]]]]}]]},[]}]
, 'type' = [{'no_files',{'type',171,'pos_integer',[]},[]}]
, 'type' = [{'key_pos',{'type',172,'union',[{'type',172,'pos_integer',[]}|[{'type',172,'list',[{'type',172,'pos_integer',[]}]}]]},[]}]
, 'type' = [{'max_list_size',{'type',173,'non_neg_integer',[]},[]}]
, 'type' = [{'cache',{'type',174,'union',[{'atom',174,'ets'}|[{'atom',174,'list'}|[{'atom',174,'no'}]]]},[]}]
, 'type' = [{'tmp_file_usage',{'type',175,'union',[{'atom',175,'allowed'}|[{'atom',175,'not_allowed'}|[{'atom',175,'info_msg'}|[{'atom',176,'warning_msg'}|[{'atom',176,'error_msg'}]]]]]},[]}]
, 'spec' = [{{'append',1},[{'type',178,'bounded_fun',[{'type',178,'fun',[{'type',178,'product',[{'var',178,'QHL'}]}|[{'var',178,'QH'}]]}|[[{'type',179,'constraint',[{'atom',179,'is_subtype'}|[[{'var',179,'QHL'}|[{'type',179,'list',[{'user_type',179,'query_handle_or_list',[]}]}]]]]}|[{'type',180,'constraint',[{'atom',180,'is_subtype'}|[[{'var',180,'QH'}|[{'user_type',180,'query_handle',[]}]]]]}]]]]}]}]
, 'spec' = [{{'append',2},[{'type',188,'bounded_fun',[{'type',188,'fun',[{'type',188,'product',[{'var',188,'QH1'}|[{'var',188,'QH2'}]]}|[{'var',188,'QH3'}]]}|[[{'type',189,'constraint',[{'atom',189,'is_subtype'}|[[{'var',189,'QH1'}|[{'user_type',189,'query_handle_or_list',[]}]]]]}|[{'type',190,'constraint',[{'atom',190,'is_subtype'}|[[{'var',190,'QH2'}|[{'user_type',190,'query_handle_or_list',[]}]]]]}|[{'type',191,'constraint',[{'atom',191,'is_subtype'}|[[{'var',191,'QH3'}|[{'user_type',191,'query_handle',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'cursor',1},[{'type',199,'bounded_fun',[{'type',199,'fun',[{'type',199,'product',[{'var',199,'QH'}]}|[{'var',199,'Cursor'}]]}|[[{'type',200,'constraint',[{'atom',200,'is_subtype'}|[[{'var',200,'QH'}|[{'user_type',200,'query_handle_or_list',[]}]]]]}|[{'type',201,'constraint',[{'atom',201,'is_subtype'}|[[{'var',201,'Cursor'}|[{'user_type',201,'query_cursor',[]}]]]]}]]]]}]}]
, 'spec' = [{{'cursor',2},[{'type',205,'bounded_fun',[{'type',205,'fun',[{'type',205,'product',[{'var',205,'QH'}|[{'var',205,'Options'}]]}|[{'var',205,'Cursor'}]]}|[[{'type',206,'constraint',[{'atom',206,'is_subtype'}|[[{'var',206,'QH'}|[{'user_type',206,'query_handle_or_list',[]}]]]]}|[{'type',207,'constraint',[{'atom',207,'is_subtype'}|[[{'var',207,'Options'}|[{'type',207,'union',[{'type',207,'list',[{'var',207,'Option'}]}|[{'var',207,'Option'}]]}]]]]}|[{'type',208,'constraint',[{'atom',208,'is_subtype'}|[[{'var',208,'Option'}|[{'type',208,'union',[{'type',208,'tuple',[{'atom',208,'cache_all'}|[{'user_type',208,'cache',[]}]]}|[{'atom',208,'cache_all'}|[{'type',209,'tuple',[{'atom',209,'max_list_size'}|[{'user_type',209,'max_list_size',[]}]]}|[{'type',210,'tuple',[{'atom',210,'spawn_options'}|[{'user_type',210,'spawn_options',[]}]]}|[{'type',211,'tuple',[{'atom',211,'tmpdir_usage'}|[{'user_type',211,'tmp_file_usage',[]}]]}|[{'type',212,'tuple',[{'atom',212,'tmpdir'}|[{'user_type',212,'tmp_directory',[]}]]}|[{'type',213,'tuple',[{'atom',213,'unique_all'}|[{'type',213,'boolean',[]}]]}|[{'atom',213,'unique_all'}]]]]]]]]}]]]]}|[{'type',214,'constraint',[{'atom',214,'is_subtype'}|[[{'var',214,'Cursor'}|[{'user_type',214,'query_cursor',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'delete_cursor',1},[{'type',233,'bounded_fun',[{'type',233,'fun',[{'type',233,'product',[{'var',233,'QueryCursor'}]}|[{'atom',233,'ok'}]]}|[[{'type',234,'constraint',[{'atom',234,'is_subtype'}|[[{'var',234,'QueryCursor'}|[{'user_type',234,'query_cursor',[]}]]]]}]]]}]}]
, 'spec' = [{{'e',1},[{'type',242,'bounded_fun',[{'type',242,'fun',[{'type',242,'product',[{'var',242,'QH'}]}|[{'type',242,'union',[{'var',242,'Answers'}|[{'var',242,'Error'}]]}]]}|[[{'type',243,'constraint',[{'atom',243,'is_subtype'}|[[{'var',243,'QH'}|[{'user_type',243,'query_handle_or_list',[]}]]]]}|[{'type',244,'constraint',[{'atom',244,'is_subtype'}|[[{'var',244,'Answers'}|[{'user_type',244,'answers',[]}]]]]}|[{'type',245,'constraint',[{'atom',245,'is_subtype'}|[[{'var',245,'Error'}|[{'type',245,'tuple',[{'atom',245,'error'}|[{'type',245,'module',[]}|[{'var',245,'Reason'}]]]}]]]]}|[{'type',246,'constraint',[{'atom',246,'is_subtype'}|[[{'var',246,'Reason'}|[{'remote_type',246,[{'atom',246,'file_sorter'}|[{'atom',246,'reason'}|[[]]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'e',2},[{'type',250,'bounded_fun',[{'type',250,'fun',[{'type',250,'product',[{'var',250,'QH'}|[{'var',250,'Options'}]]}|[{'type',250,'union',[{'var',250,'Answers'}|[{'var',250,'Error'}]]}]]}|[[{'type',251,'constraint',[{'atom',251,'is_subtype'}|[[{'var',251,'QH'}|[{'user_type',251,'query_handle_or_list',[]}]]]]}|[{'type',252,'constraint',[{'atom',252,'is_subtype'}|[[{'var',252,'Options'}|[{'type',252,'union',[{'type',252,'list',[{'var',252,'Option'}]}|[{'var',252,'Option'}]]}]]]]}|[{'type',253,'constraint',[{'atom',253,'is_subtype'}|[[{'var',253,'Option'}|[{'type',253,'union',[{'type',253,'tuple',[{'atom',253,'cache_all'}|[{'user_type',253,'cache',[]}]]}|[{'atom',253,'cache_all'}|[{'type',254,'tuple',[{'atom',254,'max_list_size'}|[{'user_type',254,'max_list_size',[]}]]}|[{'type',255,'tuple',[{'atom',255,'tmpdir_usage'}|[{'user_type',255,'tmp_file_usage',[]}]]}|[{'type',256,'tuple',[{'atom',256,'tmpdir'}|[{'user_type',256,'tmp_directory',[]}]]}|[{'type',257,'tuple',[{'atom',257,'unique_all'}|[{'type',257,'boolean',[]}]]}|[{'atom',257,'unique_all'}]]]]]]]}]]]]}|[{'type',258,'constraint',[{'atom',258,'is_subtype'}|[[{'var',258,'Answers'}|[{'user_type',258,'answers',[]}]]]]}|[{'type',259,'constraint',[{'atom',259,'is_subtype'}|[[{'var',259,'Error'}|[{'type',259,'tuple',[{'atom',259,'error'}|[{'type',259,'module',[]}|[{'var',259,'Reason'}]]]}]]]]}|[{'type',260,'constraint',[{'atom',260,'is_subtype'}|[[{'var',260,'Reason'}|[{'remote_type',260,[{'atom',260,'file_sorter'}|[{'atom',260,'reason'}|[[]]]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'eval',1},[{'type',264,'bounded_fun',[{'type',264,'fun',[{'type',264,'product',[{'var',264,'QH'}]}|[{'type',264,'union',[{'var',264,'Answers'}|[{'var',264,'Error'}]]}]]}|[[{'type',265,'constraint',[{'atom',265,'is_subtype'}|[[{'var',265,'QH'}|[{'user_type',265,'query_handle_or_list',[]}]]]]}|[{'type',266,'constraint',[{'atom',266,'is_subtype'}|[[{'var',266,'Answers'}|[{'user_type',266,'answers',[]}]]]]}|[{'type',267,'constraint',[{'atom',267,'is_subtype'}|[[{'var',267,'Error'}|[{'type',267,'tuple',[{'atom',267,'error'}|[{'type',267,'module',[]}|[{'var',267,'Reason'}]]]}]]]]}|[{'type',268,'constraint',[{'atom',268,'is_subtype'}|[[{'var',268,'Reason'}|[{'remote_type',268,[{'atom',268,'file_sorter'}|[{'atom',268,'reason'}|[[]]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'eval',2},[{'type',272,'bounded_fun',[{'type',272,'fun',[{'type',272,'product',[{'var',272,'QH'}|[{'var',272,'Options'}]]}|[{'type',272,'union',[{'var',272,'Answers'}|[{'var',272,'Error'}]]}]]}|[[{'type',273,'constraint',[{'atom',273,'is_subtype'}|[[{'var',273,'QH'}|[{'user_type',273,'query_handle_or_list',[]}]]]]}|[{'type',274,'constraint',[{'atom',274,'is_subtype'}|[[{'var',274,'Answers'}|[{'user_type',274,'answers',[]}]]]]}|[{'type',275,'constraint',[{'atom',275,'is_subtype'}|[[{'var',275,'Options'}|[{'type',275,'union',[{'type',275,'list',[{'var',275,'Option'}]}|[{'var',275,'Option'}]]}]]]]}|[{'type',276,'constraint',[{'atom',276,'is_subtype'}|[[{'var',276,'Option'}|[{'type',276,'union',[{'type',276,'tuple',[{'atom',276,'cache_all'}|[{'user_type',276,'cache',[]}]]}|[{'atom',276,'cache_all'}|[{'type',277,'tuple',[{'atom',277,'max_list_size'}|[{'user_type',277,'max_list_size',[]}]]}|[{'type',278,'tuple',[{'atom',278,'tmpdir_usage'}|[{'user_type',278,'tmp_file_usage',[]}]]}|[{'type',279,'tuple',[{'atom',279,'tmpdir'}|[{'user_type',279,'tmp_directory',[]}]]}|[{'type',280,'tuple',[{'atom',280,'unique_all'}|[{'type',280,'boolean',[]}]]}|[{'atom',280,'unique_all'}]]]]]]]}]]]]}|[{'type',281,'constraint',[{'atom',281,'is_subtype'}|[[{'var',281,'Error'}|[{'type',281,'tuple',[{'atom',281,'error'}|[{'type',281,'module',[]}|[{'var',281,'Reason'}]]]}]]]]}|[{'type',282,'constraint',[{'atom',282,'is_subtype'}|[[{'var',282,'Reason'}|[{'remote_type',282,[{'atom',282,'file_sorter'}|[{'atom',282,'reason'}|[[]]]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'fold',3},[{'type',314,'bounded_fun',[{'type',314,'fun',[{'type',314,'product',[{'var',314,'Function'}|[{'var',314,'Acc0'}|[{'var',314,'QH'}]]]}|[{'type',315,'union',[{'var',315,'Acc1'}|[{'var',315,'Error'}]]}]]}|[[{'type',316,'constraint',[{'atom',316,'is_subtype'}|[[{'var',316,'QH'}|[{'user_type',316,'query_handle_or_list',[]}]]]]}|[{'type',317,'constraint',[{'atom',317,'is_subtype'}|[[{'var',317,'Function'}|[{'type',317,'fun',[{'type',317,'product',[{'user_type',317,'answer',[]}|[{'var',317,'AccIn'}]]}|[{'var',317,'AccOut'}]]}]]]]}|[{'type',318,'constraint',[{'atom',318,'is_subtype'}|[[{'var',318,'Acc0'}|[{'type',318,'term',[]}]]]]}|[{'type',319,'constraint',[{'atom',319,'is_subtype'}|[[{'var',319,'Acc1'}|[{'type',319,'term',[]}]]]]}|[{'type',320,'constraint',[{'atom',320,'is_subtype'}|[[{'var',320,'AccIn'}|[{'type',320,'term',[]}]]]]}|[{'type',321,'constraint',[{'atom',321,'is_subtype'}|[[{'var',321,'AccOut'}|[{'type',321,'term',[]}]]]]}|[{'type',322,'constraint',[{'atom',322,'is_subtype'}|[[{'var',322,'Error'}|[{'type',322,'tuple',[{'atom',322,'error'}|[{'type',322,'module',[]}|[{'var',322,'Reason'}]]]}]]]]}|[{'type',323,'constraint',[{'atom',323,'is_subtype'}|[[{'var',323,'Reason'}|[{'remote_type',323,[{'atom',323,'file_sorter'}|[{'atom',323,'reason'}|[[]]]]}]]]]}]]]]]]]]]]}]}]
, 'spec' = [{{'fold',4},[{'type',327,'bounded_fun',[{'type',327,'fun',[{'type',327,'product',[{'var',327,'Function'}|[{'var',327,'Acc0'}|[{'var',327,'QH'}|[{'var',327,'Options'}]]]]}|[{'type',328,'union',[{'var',328,'Acc1'}|[{'var',328,'Error'}]]}]]}|[[{'type',329,'constraint',[{'atom',329,'is_subtype'}|[[{'var',329,'QH'}|[{'user_type',329,'query_handle_or_list',[]}]]]]}|[{'type',330,'constraint',[{'atom',330,'is_subtype'}|[[{'var',330,'Function'}|[{'type',330,'fun',[{'type',330,'product',[{'user_type',330,'answer',[]}|[{'var',330,'AccIn'}]]}|[{'var',330,'AccOut'}]]}]]]]}|[{'type',331,'constraint',[{'atom',331,'is_subtype'}|[[{'var',331,'Acc0'}|[{'type',331,'term',[]}]]]]}|[{'type',332,'constraint',[{'atom',332,'is_subtype'}|[[{'var',332,'Acc1'}|[{'type',332,'term',[]}]]]]}|[{'type',333,'constraint',[{'atom',333,'is_subtype'}|[[{'var',333,'AccIn'}|[{'type',333,'term',[]}]]]]}|[{'type',334,'constraint',[{'atom',334,'is_subtype'}|[[{'var',334,'AccOut'}|[{'type',334,'term',[]}]]]]}|[{'type',335,'constraint',[{'atom',335,'is_subtype'}|[[{'var',335,'Options'}|[{'type',335,'union',[{'type',335,'list',[{'var',335,'Option'}]}|[{'var',335,'Option'}]]}]]]]}|[{'type',336,'constraint',[{'atom',336,'is_subtype'}|[[{'var',336,'Option'}|[{'type',336,'union',[{'type',336,'tuple',[{'atom',336,'cache_all'}|[{'user_type',336,'cache',[]}]]}|[{'atom',336,'cache_all'}|[{'type',337,'tuple',[{'atom',337,'max_list_size'}|[{'user_type',337,'max_list_size',[]}]]}|[{'type',338,'tuple',[{'atom',338,'tmpdir_usage'}|[{'user_type',338,'tmp_file_usage',[]}]]}|[{'type',339,'tuple',[{'atom',339,'tmpdir'}|[{'user_type',339,'tmp_directory',[]}]]}|[{'type',340,'tuple',[{'atom',340,'unique_all'}|[{'type',340,'boolean',[]}]]}|[{'atom',340,'unique_all'}]]]]]]]}]]]]}|[{'type',341,'constraint',[{'atom',341,'is_subtype'}|[[{'var',341,'Error'}|[{'type',341,'tuple',[{'atom',341,'error'}|[{'type',341,'module',[]}|[{'var',341,'Reason'}]]]}]]]]}|[{'type',342,'constraint',[{'atom',342,'is_subtype'}|[[{'var',342,'Reason'}|[{'remote_type',342,[{'atom',342,'file_sorter'}|[{'atom',342,'reason'}|[[]]]]}]]]]}]]]]]]]]]]]]}]}]
, 'spec' = [{{'format_error',1},[{'type',372,'bounded_fun',[{'type',372,'fun',[{'type',372,'product',[{'var',372,'Error'}]}|[{'var',372,'Chars'}]]}|[[{'type',373,'constraint',[{'atom',373,'is_subtype'}|[[{'var',373,'Error'}|[{'type',373,'tuple',[{'atom',373,'error'}|[{'type',373,'module',[]}|[{'type',373,'term',[]}]]]}]]]]}|[{'type',374,'constraint',[{'atom',374,'is_subtype'}|[[{'var',374,'Chars'}|[{'remote_type',374,[{'atom',374,'io_lib'}|[{'atom',374,'chars'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'info',1},[{'type',412,'bounded_fun',[{'type',412,'fun',[{'type',412,'product',[{'var',412,'QH'}]}|[{'var',412,'Info'}]]}|[[{'type',413,'constraint',[{'atom',413,'is_subtype'}|[[{'var',413,'QH'}|[{'user_type',413,'query_handle_or_list',[]}]]]]}|[{'type',414,'constraint',[{'atom',414,'is_subtype'}|[[{'var',414,'Info'}|[{'type',414,'union',[{'user_type',414,'abstract_expr',[]}|[{'type',414,'string',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'info',2},[{'type',418,'bounded_fun',[{'type',418,'fun',[{'type',418,'product',[{'var',418,'QH'}|[{'var',418,'Options'}]]}|[{'var',418,'Info'}]]}|[[{'type',419,'constraint',[{'atom',419,'is_subtype'}|[[{'var',419,'QH'}|[{'user_type',419,'query_handle_or_list',[]}]]]]}|[{'type',420,'constraint',[{'atom',420,'is_subtype'}|[[{'var',420,'Options'}|[{'type',420,'union',[{'type',420,'list',[{'var',420,'Option'}]}|[{'var',420,'Option'}]]}]]]]}|[{'type',421,'constraint',[{'atom',421,'is_subtype'}|[[{'var',421,'Option'}|[{'type',421,'union',[{'var',421,'EvalOption'}|[{'var',421,'ReturnOption'}]]}]]]]}|[{'type',422,'constraint',[{'atom',422,'is_subtype'}|[[{'var',422,'EvalOption'}|[{'type',422,'union',[{'type',422,'tuple',[{'atom',422,'cache_all'}|[{'user_type',422,'cache',[]}]]}|[{'atom',422,'cache_all'}|[{'type',423,'tuple',[{'atom',423,'max_list_size'}|[{'user_type',423,'max_list_size',[]}]]}|[{'type',424,'tuple',[{'atom',424,'tmpdir_usage'}|[{'user_type',424,'tmp_file_usage',[]}]]}|[{'type',425,'tuple',[{'atom',425,'tmpdir'}|[{'user_type',425,'tmp_directory',[]}]]}|[{'type',426,'tuple',[{'atom',426,'unique_all'}|[{'type',426,'boolean',[]}]]}|[{'atom',426,'unique_all'}]]]]]]]}]]]]}|[{'type',427,'constraint',[{'atom',427,'is_subtype'}|[[{'var',427,'ReturnOption'}|[{'type',427,'union',[{'type',427,'tuple',[{'atom',427,'depth'}|[{'var',427,'Depth'}]]}|[{'type',428,'tuple',[{'atom',428,'flat'}|[{'type',428,'boolean',[]}]]}|[{'type',429,'tuple',[{'atom',429,'format'}|[{'var',429,'Format'}]]}|[{'type',430,'tuple',[{'atom',430,'n_elements'}|[{'var',430,'NElements'}]]}]]]]}]]]]}|[{'type',431,'constraint',[{'atom',431,'is_subtype'}|[[{'var',431,'Depth'}|[{'type',431,'union',[{'atom',431,'infinity'}|[{'type',431,'non_neg_integer',[]}]]}]]]]}|[{'type',432,'constraint',[{'atom',432,'is_subtype'}|[[{'var',432,'Format'}|[{'type',432,'union',[{'atom',432,'abstract_code'}|[{'atom',432,'string'}]]}]]]]}|[{'type',433,'constraint',[{'atom',433,'is_subtype'}|[[{'var',433,'NElements'}|[{'type',433,'union',[{'atom',433,'infinity'}|[{'type',433,'pos_integer',[]}]]}]]]]}|[{'type',434,'constraint',[{'atom',434,'is_subtype'}|[[{'var',434,'Info'}|[{'type',434,'union',[{'user_type',434,'abstract_expr',[]}|[{'type',434,'string',[]}]]}]]]]}]]]]]]]]]]]}]}]
, 'spec' = [{{'keysort',2},[{'type',470,'bounded_fun',[{'type',470,'fun',[{'type',470,'product',[{'var',470,'KeyPos'}|[{'var',470,'QH1'}]]}|[{'var',470,'QH2'}]]}|[[{'type',471,'constraint',[{'atom',471,'is_subtype'}|[[{'var',471,'KeyPos'}|[{'user_type',471,'key_pos',[]}]]]]}|[{'type',472,'constraint',[{'atom',472,'is_subtype'}|[[{'var',472,'QH1'}|[{'user_type',472,'query_handle_or_list',[]}]]]]}|[{'type',473,'constraint',[{'atom',473,'is_subtype'}|[[{'var',473,'QH2'}|[{'user_type',473,'query_handle',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'keysort',3},[{'type',477,'bounded_fun',[{'type',477,'fun',[{'type',477,'product',[{'var',477,'KeyPos'}|[{'var',477,'QH1'}|[{'var',477,'SortOptions'}]]]}|[{'var',477,'QH2'}]]}|[[{'type',478,'constraint',[{'atom',478,'is_subtype'}|[[{'var',478,'KeyPos'}|[{'user_type',478,'key_pos',[]}]]]]}|[{'type',479,'constraint',[{'atom',479,'is_subtype'}|[[{'var',479,'SortOptions'}|[{'user_type',479,'sort_options',[]}]]]]}|[{'type',480,'constraint',[{'atom',480,'is_subtype'}|[[{'var',480,'QH1'}|[{'user_type',480,'query_handle_or_list',[]}]]]]}|[{'type',481,'constraint',[{'atom',481,'is_subtype'}|[[{'var',481,'QH2'}|[{'user_type',481,'query_handle',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'next_answers',1},[{'type',500,'bounded_fun',[{'type',500,'fun',[{'type',500,'product',[{'var',500,'QueryCursor'}]}|[{'type',501,'union',[{'var',501,'Answers'}|[{'var',501,'Error'}]]}]]}|[[{'type',502,'constraint',[{'atom',502,'is_subtype'}|[[{'var',502,'QueryCursor'}|[{'user_type',502,'query_cursor',[]}]]]]}|[{'type',503,'constraint',[{'atom',503,'is_subtype'}|[[{'var',503,'Answers'}|[{'user_type',503,'answers',[]}]]]]}|[{'type',504,'constraint',[{'atom',504,'is_subtype'}|[[{'var',504,'Error'}|[{'type',504,'tuple',[{'atom',504,'error'}|[{'type',504,'module',[]}|[{'var',504,'Reason'}]]]}]]]]}|[{'type',505,'constraint',[{'atom',505,'is_subtype'}|[[{'var',505,'Reason'}|[{'remote_type',505,[{'atom',505,'file_sorter'}|[{'atom',505,'reason'}|[[]]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'next_answers',2},[{'type',509,'bounded_fun',[{'type',509,'fun',[{'type',509,'product',[{'var',509,'QueryCursor'}|[{'var',509,'NumberOfAnswers'}]]}|[{'type',510,'union',[{'var',510,'Answers'}|[{'var',510,'Error'}]]}]]}|[[{'type',511,'constraint',[{'atom',511,'is_subtype'}|[[{'var',511,'QueryCursor'}|[{'user_type',511,'query_cursor',[]}]]]]}|[{'type',512,'constraint',[{'atom',512,'is_subtype'}|[[{'var',512,'Answers'}|[{'user_type',512,'answers',[]}]]]]}|[{'type',513,'constraint',[{'atom',513,'is_subtype'}|[[{'var',513,'NumberOfAnswers'}|[{'type',513,'union',[{'atom',513,'all_remaining'}|[{'type',513,'pos_integer',[]}]]}]]]]}|[{'type',514,'constraint',[{'atom',514,'is_subtype'}|[[{'var',514,'Error'}|[{'type',514,'tuple',[{'atom',514,'error'}|[{'type',514,'module',[]}|[{'var',514,'Reason'}]]]}]]]]}|[{'type',515,'constraint',[{'atom',515,'is_subtype'}|[[{'var',515,'Reason'}|[{'remote_type',515,[{'atom',515,'file_sorter'}|[{'atom',515,'reason'}|[[]]]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'parse_transform',2},[{'type',529,'bounded_fun',[{'type',529,'fun',[{'type',529,'product',[{'var',529,'Forms'}|[{'var',529,'Options'}]]}|[{'var',529,'Forms2'}]]}|[[{'type',530,'constraint',[{'atom',530,'is_subtype'}|[[{'var',530,'Forms'}|[{'type',530,'list',[{'remote_type',530,[{'atom',530,'erl_parse'}|[{'atom',530,'abstract_form'}|[[]]]]}]}]]]]}|[{'type',531,'constraint',[{'atom',531,'is_subtype'}|[[{'var',531,'Forms2'}|[{'type',531,'list',[{'remote_type',531,[{'atom',531,'erl_parse'}|[{'atom',531,'abstract_form'}|[[]]]]}]}]]]]}|[{'type',532,'constraint',[{'atom',532,'is_subtype'}|[[{'var',532,'Options'}|[{'type',532,'list',[{'var',532,'Option'}]}]]]]}|[{'type',533,'constraint',[{'atom',533,'is_subtype'}|[[{'var',533,'Option'}|[{'type',533,'union',[{'atom',533,'type_checker'}|[{'remote_type',533,[{'atom',533,'compile'}|[{'atom',533,'option'}|[[]]]]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'q',1},[{'type',540,'bounded_fun',[{'type',540,'fun',[{'type',540,'product',[{'var',540,'QLC'}]}|[{'var',540,'QH'}]]}|[[{'type',541,'constraint',[{'atom',541,'is_subtype'}|[[{'var',541,'QLC'}|[{'user_type',541,'query_list_comprehension',[]}]]]]}|[{'type',542,'constraint',[{'atom',542,'is_subtype'}|[[{'var',542,'QH'}|[{'user_type',542,'query_handle',[]}]]]]}]]]]}]}]
, 'spec' = [{{'q',2},[{'type',546,'bounded_fun',[{'type',546,'fun',[{'type',546,'product',[{'var',546,'QLC'}|[{'var',546,'Options'}]]}|[{'var',546,'QH'}]]}|[[{'type',547,'constraint',[{'atom',547,'is_subtype'}|[[{'var',547,'QH'}|[{'user_type',547,'query_handle',[]}]]]]}|[{'type',548,'constraint',[{'atom',548,'is_subtype'}|[[{'var',548,'Options'}|[{'type',548,'union',[{'type',548,'list',[{'var',548,'Option'}]}|[{'var',548,'Option'}]]}]]]]}|[{'type',549,'constraint',[{'atom',549,'is_subtype'}|[[{'var',549,'Option'}|[{'type',549,'union',[{'type',549,'tuple',[{'atom',549,'max_lookup'}|[{'var',549,'MaxLookup'}]]}|[{'type',550,'tuple',[{'atom',550,'cache'}|[{'user_type',550,'cache',[]}]]}|[{'atom',550,'cache'}|[{'type',551,'tuple',[{'atom',551,'join'}|[{'var',551,'Join'}]]}|[{'type',552,'tuple',[{'atom',552,'lookup'}|[{'var',552,'Lookup'}]]}|[{'type',553,'tuple',[{'atom',553,'unique'}|[{'type',553,'boolean',[]}]]}|[{'atom',553,'unique'}]]]]]]]}]]]]}|[{'type',554,'constraint',[{'atom',554,'is_subtype'}|[[{'var',554,'MaxLookup'}|[{'type',554,'union',[{'type',554,'non_neg_integer',[]}|[{'atom',554,'infinity'}]]}]]]]}|[{'type',555,'constraint',[{'atom',555,'is_subtype'}|[[{'var',555,'Join'}|[{'type',555,'union',[{'atom',555,'any'}|[{'atom',555,'lookup'}|[{'atom',555,'merge'}|[{'atom',555,'nested_loop'}]]]]}]]]]}|[{'type',556,'constraint',[{'atom',556,'is_subtype'}|[[{'var',556,'Lookup'}|[{'type',556,'union',[{'type',556,'boolean',[]}|[{'atom',556,'any'}]]}]]]]}|[{'type',557,'constraint',[{'atom',557,'is_subtype'}|[[{'var',557,'QLC'}|[{'user_type',557,'query_list_comprehension',[]}]]]]}]]]]]]]]]}]}]
, 'spec' = [{{'sort',1},[{'type',570,'bounded_fun',[{'type',570,'fun',[{'type',570,'product',[{'var',570,'QH1'}]}|[{'var',570,'QH2'}]]}|[[{'type',571,'constraint',[{'atom',571,'is_subtype'}|[[{'var',571,'QH1'}|[{'user_type',571,'query_handle_or_list',[]}]]]]}|[{'type',572,'constraint',[{'atom',572,'is_subtype'}|[[{'var',572,'QH2'}|[{'user_type',572,'query_handle',[]}]]]]}]]]]}]}]
, 'spec' = [{{'sort',2},[{'type',576,'bounded_fun',[{'type',576,'fun',[{'type',576,'product',[{'var',576,'QH1'}|[{'var',576,'SortOptions'}]]}|[{'var',576,'QH2'}]]}|[[{'type',577,'constraint',[{'atom',577,'is_subtype'}|[[{'var',577,'SortOptions'}|[{'user_type',577,'sort_options',[]}]]]]}|[{'type',578,'constraint',[{'atom',578,'is_subtype'}|[[{'var',578,'QH1'}|[{'user_type',578,'query_handle_or_list',[]}]]]]}|[{'type',579,'constraint',[{'atom',579,'is_subtype'}|[[{'var',579,'QH2'}|[{'user_type',579,'query_handle',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'string_to_handle',1},[{'type',593,'bounded_fun',[{'type',593,'fun',[{'type',593,'product',[{'var',593,'QueryString'}]}|[{'type',593,'union',[{'var',593,'QH'}|[{'var',593,'Error'}]]}]]}|[[{'type',594,'constraint',[{'atom',594,'is_subtype'}|[[{'var',594,'QueryString'}|[{'type',594,'string',[]}]]]]}|[{'type',595,'constraint',[{'atom',595,'is_subtype'}|[[{'var',595,'QH'}|[{'user_type',595,'query_handle',[]}]]]]}|[{'type',596,'constraint',[{'atom',596,'is_subtype'}|[[{'var',596,'Error'}|[{'type',596,'tuple',[{'atom',596,'error'}|[{'type',596,'module',[]}|[{'var',596,'Reason'}]]]}]]]]}|[{'type',597,'constraint',[{'atom',597,'is_subtype'}|[[{'var',597,'Reason'}|[{'type',597,'union',[{'remote_type',597,[{'atom',597,'erl_parse'}|[{'atom',597,'error_info'}|[[]]]]}|[{'remote_type',597,[{'atom',597,'erl_scan'}|[{'atom',597,'error_info'}|[[]]]]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'string_to_handle',2},[{'type',601,'bounded_fun',[{'type',601,'fun',[{'type',601,'product',[{'var',601,'QueryString'}|[{'var',601,'Options'}]]}|[{'type',601,'union',[{'var',601,'QH'}|[{'var',601,'Error'}]]}]]}|[[{'type',602,'constraint',[{'atom',602,'is_subtype'}|[[{'var',602,'QueryString'}|[{'type',602,'string',[]}]]]]}|[{'type',603,'constraint',[{'atom',603,'is_subtype'}|[[{'var',603,'Options'}|[{'type',603,'union',[{'type',603,'list',[{'var',603,'Option'}]}|[{'var',603,'Option'}]]}]]]]}|[{'type',604,'constraint',[{'atom',604,'is_subtype'}|[[{'var',604,'Option'}|[{'type',604,'union',[{'type',604,'tuple',[{'atom',604,'max_lookup'}|[{'var',604,'MaxLookup'}]]}|[{'type',605,'tuple',[{'atom',605,'cache'}|[{'user_type',605,'cache',[]}]]}|[{'atom',605,'cache'}|[{'type',606,'tuple',[{'atom',606,'join'}|[{'var',606,'Join'}]]}|[{'type',607,'tuple',[{'atom',607,'lookup'}|[{'var',607,'Lookup'}]]}|[{'type',608,'tuple',[{'atom',608,'unique'}|[{'type',608,'boolean',[]}]]}|[{'atom',608,'unique'}]]]]]]]}]]]]}|[{'type',609,'constraint',[{'atom',609,'is_subtype'}|[[{'var',609,'MaxLookup'}|[{'type',609,'union',[{'type',609,'non_neg_integer',[]}|[{'atom',609,'infinity'}]]}]]]]}|[{'type',610,'constraint',[{'atom',610,'is_subtype'}|[[{'var',610,'Join'}|[{'type',610,'union',[{'atom',610,'any'}|[{'atom',610,'lookup'}|[{'atom',610,'merge'}|[{'atom',610,'nested_loop'}]]]]}]]]]}|[{'type',611,'constraint',[{'atom',611,'is_subtype'}|[[{'var',611,'Lookup'}|[{'type',611,'union',[{'type',611,'boolean',[]}|[{'atom',611,'any'}]]}]]]]}|[{'type',612,'constraint',[{'atom',612,'is_subtype'}|[[{'var',612,'QH'}|[{'user_type',612,'query_handle',[]}]]]]}|[{'type',613,'constraint',[{'atom',613,'is_subtype'}|[[{'var',613,'Error'}|[{'type',613,'tuple',[{'atom',613,'error'}|[{'type',613,'module',[]}|[{'var',613,'Reason'}]]]}]]]]}|[{'type',614,'constraint',[{'atom',614,'is_subtype'}|[[{'var',614,'Reason'}|[{'type',614,'union',[{'remote_type',614,[{'atom',614,'erl_parse'}|[{'atom',614,'error_info'}|[[]]]]}|[{'remote_type',614,[{'atom',614,'erl_scan'}|[{'atom',614,'error_info'}|[[]]]]}]]}]]]]}]]]]]]]]]]]}]}]
, 'spec' = [{{'string_to_handle',3},[{'type',618,'bounded_fun',[{'type',618,'fun',[{'type',618,'product',[{'var',618,'QueryString'}|[{'var',618,'Options'}|[{'var',618,'Bindings'}]]]}|[{'type',618,'union',[{'var',618,'QH'}|[{'var',618,'Error'}]]}]]}|[[{'type',619,'constraint',[{'atom',619,'is_subtype'}|[[{'var',619,'QueryString'}|[{'type',619,'string',[]}]]]]}|[{'type',620,'constraint',[{'atom',620,'is_subtype'}|[[{'var',620,'Options'}|[{'type',620,'union',[{'type',620,'list',[{'var',620,'Option'}]}|[{'var',620,'Option'}]]}]]]]}|[{'type',621,'constraint',[{'atom',621,'is_subtype'}|[[{'var',621,'Option'}|[{'type',621,'union',[{'type',621,'tuple',[{'atom',621,'max_lookup'}|[{'var',621,'MaxLookup'}]]}|[{'type',622,'tuple',[{'atom',622,'cache'}|[{'user_type',622,'cache',[]}]]}|[{'atom',622,'cache'}|[{'type',623,'tuple',[{'atom',623,'join'}|[{'var',623,'Join'}]]}|[{'type',624,'tuple',[{'atom',624,'lookup'}|[{'var',624,'Lookup'}]]}|[{'type',625,'tuple',[{'atom',625,'unique'}|[{'type',625,'boolean',[]}]]}|[{'atom',625,'unique'}]]]]]]]}]]]]}|[{'type',626,'constraint',[{'atom',626,'is_subtype'}|[[{'var',626,'MaxLookup'}|[{'type',626,'union',[{'type',626,'non_neg_integer',[]}|[{'atom',626,'infinity'}]]}]]]]}|[{'type',627,'constraint',[{'atom',627,'is_subtype'}|[[{'var',627,'Join'}|[{'type',627,'union',[{'atom',627,'any'}|[{'atom',627,'lookup'}|[{'atom',627,'merge'}|[{'atom',627,'nested_loop'}]]]]}]]]]}|[{'type',628,'constraint',[{'atom',628,'is_subtype'}|[[{'var',628,'Lookup'}|[{'type',628,'union',[{'type',628,'boolean',[]}|[{'atom',628,'any'}]]}]]]]}|[{'type',629,'constraint',[{'atom',629,'is_subtype'}|[[{'var',629,'Bindings'}|[{'remote_type',629,[{'atom',629,'erl_eval'}|[{'atom',629,'binding_struct'}|[[]]]]}]]]]}|[{'type',630,'constraint',[{'atom',630,'is_subtype'}|[[{'var',630,'QH'}|[{'user_type',630,'query_handle',[]}]]]]}|[{'type',631,'constraint',[{'atom',631,'is_subtype'}|[[{'var',631,'Error'}|[{'type',631,'tuple',[{'atom',631,'error'}|[{'type',631,'module',[]}|[{'var',631,'Reason'}]]]}]]]]}|[{'type',632,'constraint',[{'atom',632,'is_subtype'}|[[{'var',632,'Reason'}|[{'type',632,'union',[{'remote_type',632,[{'atom',632,'erl_parse'}|[{'atom',632,'error_info'}|[[]]]]}|[{'remote_type',632,[{'atom',632,'erl_scan'}|[{'atom',632,'error_info'}|[[]]]]}]]}]]]]}]]]]]]]]]]]]}]}]
, 'spec' = [{{'table',2},[{'type',676,'bounded_fun',[{'type',676,'fun',[{'type',676,'product',[{'var',676,'TraverseFun'}|[{'var',676,'Options'}]]}|[{'var',676,'QH'}]]}|[[{'type',677,'constraint',[{'atom',677,'is_subtype'}|[[{'var',677,'TraverseFun'}|[{'type',677,'union',[{'var',677,'TraverseFun0'}|[{'var',677,'TraverseFun1'}]]}]]]]}|[{'type',678,'constraint',[{'atom',678,'is_subtype'}|[[{'var',678,'TraverseFun0'}|[{'type',678,'fun',[{'type',678,'product',[]}|[{'var',678,'TraverseResult'}]]}]]]]}|[{'type',679,'constraint',[{'atom',679,'is_subtype'}|[[{'var',679,'TraverseFun1'}|[{'type',679,'fun',[{'type',679,'product',[{'user_type',679,'match_expression',[]}]}|[{'var',679,'TraverseResult'}]]}]]]]}|[{'type',680,'constraint',[{'atom',680,'is_subtype'}|[[{'var',680,'TraverseResult'}|[{'type',680,'union',[{'var',680,'Objects'}|[{'type',680,'term',[]}]]}]]]]}|[{'type',681,'constraint',[{'atom',681,'is_subtype'}|[[{'var',681,'Objects'}|[{'type',681,'union',[{'type',681,'nil',[]}|[{'type',681,'list',[{'type',681,'union',[{'type',681,'term',[]}|[{'var',681,'ObjectList'}]]}]}]]}]]]]}|[{'type',682,'constraint',[{'atom',682,'is_subtype'}|[[{'var',682,'ObjectList'}|[{'type',682,'union',[{'var',682,'TraverseFun0'}|[{'var',682,'Objects'}]]}]]]]}|[{'type',683,'constraint',[{'atom',683,'is_subtype'}|[[{'var',683,'Options'}|[{'type',683,'union',[{'type',683,'list',[{'var',683,'Option'}]}|[{'var',683,'Option'}]]}]]]]}|[{'type',684,'constraint',[{'atom',684,'is_subtype'}|[[{'var',684,'Option'}|[{'type',684,'union',[{'type',684,'tuple',[{'atom',684,'format_fun'}|[{'var',684,'FormatFun'}]]}|[{'type',685,'tuple',[{'atom',685,'info_fun'}|[{'var',685,'InfoFun'}]]}|[{'type',686,'tuple',[{'atom',686,'lookup_fun'}|[{'var',686,'LookupFun'}]]}|[{'type',687,'tuple',[{'atom',687,'parent_fun'}|[{'var',687,'ParentFun'}]]}|[{'type',688,'tuple',[{'atom',688,'post_fun'}|[{'var',688,'PostFun'}]]}|[{'type',689,'tuple',[{'atom',689,'pre_fun'}|[{'var',689,'PreFun'}]]}|[{'type',690,'tuple',[{'atom',690,'key_equality'}|[{'var',690,'KeyComparison'}]]}]]]]]]]}]]]]}|[{'type',691,'constraint',[{'atom',691,'is_subtype'}|[[{'var',691,'FormatFun'}|[{'type',691,'union',[{'atom',691,'undefined'}|[{'type',691,'fun',[{'type',691,'product',[{'var',691,'SelectedObjects'}]}|[{'var',691,'FormatedTable'}]]}]]}]]]]}|[{'type',692,'constraint',[{'atom',692,'is_subtype'}|[[{'var',692,'SelectedObjects'}|[{'type',692,'union',[{'atom',692,'all'}|[{'type',693,'tuple',[{'atom',693,'all'}|[{'var',693,'NElements'}|[{'var',693,'DepthFun'}]]]}|[{'type',694,'tuple',[{'atom',694,'match_spec'}|[{'user_type',694,'match_expression',[]}]]}|[{'type',695,'tuple',[{'atom',695,'lookup'}|[{'var',695,'Position'}|[{'var',695,'Keys'}]]]}|[{'type',696,'tuple',[{'atom',696,'lookup'}|[{'var',696,'Position'}|[{'var',696,'Keys'}|[{'var',696,'NElements'}|[{'var',696,'DepthFun'}]]]]]}]]]]]}]]]]}|[{'type',697,'constraint',[{'atom',697,'is_subtype'}|[[{'var',697,'NElements'}|[{'type',697,'union',[{'atom',697,'infinity'}|[{'type',697,'pos_integer',[]}]]}]]]]}|[{'type',698,'constraint',[{'atom',698,'is_subtype'}|[[{'var',698,'DepthFun'}|[{'type',698,'fun',[{'type',698,'product',[{'type',698,'term',[]}]}|[{'type',698,'term',[]}]]}]]]]}|[{'type',699,'constraint',[{'atom',699,'is_subtype'}|[[{'var',699,'FormatedTable'}|[{'type',699,'union',[{'type',699,'tuple',[{'var',699,'Mod'}|[{'var',699,'Fun'}|[{'var',699,'Args'}]]]}|[{'user_type',700,'abstract_expr',[]}|[{'type',701,'string',[]}]]]}]]]]}|[{'type',702,'constraint',[{'atom',702,'is_subtype'}|[[{'var',702,'InfoFun'}|[{'type',702,'union',[{'atom',702,'undefined'}|[{'type',702,'fun',[{'type',702,'product',[{'var',702,'InfoTag'}]}|[{'var',702,'InfoValue'}]]}]]}]]]]}|[{'type',703,'constraint',[{'atom',703,'is_subtype'}|[[{'var',703,'InfoTag'}|[{'type',703,'union',[{'atom',703,'indices'}|[{'atom',703,'is_unique_objects'}|[{'atom',703,'keypos'}|[{'atom',703,'num_of_objects'}]]]]}]]]]}|[{'type',704,'constraint',[{'atom',704,'is_subtype'}|[[{'var',704,'InfoValue'}|[{'type',704,'union',[{'atom',704,'undefined'}|[{'type',704,'term',[]}]]}]]]]}|[{'type',705,'constraint',[{'atom',705,'is_subtype'}|[[{'var',705,'LookupFun'}|[{'type',705,'union',[{'atom',705,'undefined'}|[{'type',705,'fun',[{'type',705,'product',[{'var',705,'Position'}|[{'var',705,'Keys'}]]}|[{'var',705,'LookupResult'}]]}]]}]]]]}|[{'type',706,'constraint',[{'atom',706,'is_subtype'}|[[{'var',706,'LookupResult'}|[{'type',706,'union',[{'type',706,'list',[{'type',706,'term',[]}]}|[{'type',706,'term',[]}]]}]]]]}|[{'type',707,'constraint',[{'atom',707,'is_subtype'}|[[{'var',707,'ParentFun'}|[{'type',707,'union',[{'atom',707,'undefined'}|[{'type',707,'fun',[{'type',707,'product',[]}|[{'var',707,'ParentFunValue'}]]}]]}]]]]}|[{'type',708,'constraint',[{'atom',708,'is_subtype'}|[[{'var',708,'PostFun'}|[{'type',708,'union',[{'atom',708,'undefined'}|[{'type',708,'fun',[{'type',708,'product',[]}|[{'type',708,'term',[]}]]}]]}]]]]}|[{'type',709,'constraint',[{'atom',709,'is_subtype'}|[[{'var',709,'PreFun'}|[{'type',709,'union',[{'atom',709,'undefined'}|[{'type',709,'fun',[{'type',709,'product',[{'var',709,'PreArgs'}]}|[{'type',709,'term',[]}]]}]]}]]]]}|[{'type',710,'constraint',[{'atom',710,'is_subtype'}|[[{'var',710,'PreArgs'}|[{'type',710,'list',[{'var',710,'PreArg'}]}]]]]}|[{'type',711,'constraint',[{'atom',711,'is_subtype'}|[[{'var',711,'PreArg'}|[{'type',711,'union',[{'type',711,'tuple',[{'atom',711,'parent_value'}|[{'var',711,'ParentFunValue'}]]}|[{'type',711,'tuple',[{'atom',711,'stop_fun'}|[{'var',711,'StopFun'}]]}]]}]]]]}|[{'type',712,'constraint',[{'atom',712,'is_subtype'}|[[{'var',712,'ParentFunValue'}|[{'type',712,'union',[{'atom',712,'undefined'}|[{'type',712,'term',[]}]]}]]]]}|[{'type',713,'constraint',[{'atom',713,'is_subtype'}|[[{'var',713,'StopFun'}|[{'type',713,'union',[{'atom',713,'undefined'}|[{'type',713,'fun',[{'type',713,'product',[]}|[{'type',713,'term',[]}]]}]]}]]]]}|[{'type',714,'constraint',[{'atom',714,'is_subtype'}|[[{'var',714,'KeyComparison'}|[{'type',714,'union',[{'atom',714,'=:='}|[{'atom',714,'=='}]]}]]]]}|[{'type',715,'constraint',[{'atom',715,'is_subtype'}|[[{'var',715,'Position'}|[{'type',715,'pos_integer',[]}]]]]}|[{'type',716,'constraint',[{'atom',716,'is_subtype'}|[[{'var',716,'Keys'}|[{'type',716,'list',[{'type',716,'term',[]}]}]]]]}|[{'type',717,'constraint',[{'atom',717,'is_subtype'}|[[{'var',717,'Mod'}|[{'type',717,'atom',[]}]]]]}|[{'type',718,'constraint',[{'atom',718,'is_subtype'}|[[{'var',718,'Fun'}|[{'type',718,'atom',[]}]]]]}|[{'type',719,'constraint',[{'atom',719,'is_subtype'}|[[{'var',719,'Args'}|[{'type',719,'list',[{'type',719,'term',[]}]}]]]]}|[{'type',720,'constraint',[{'atom',720,'is_subtype'}|[[{'var',720,'QH'}|[{'user_type',720,'query_handle',[]}]]]]}]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]}]}]
, 'spec' = [{{'transform_from_evaluator',2},[{'type',746,'bounded_fun',[{'type',746,'fun',[{'type',746,'product',[{'var',746,'LC'}|[{'var',746,'Bs'}]]}|[{'var',746,'Return'}]]}|[[{'type',747,'constraint',[{'atom',747,'is_subtype'}|[[{'var',747,'LC'}|[{'user_type',747,'abstract_expr',[]}]]]]}|[{'type',748,'constraint',[{'atom',748,'is_subtype'}|[[{'var',748,'Bs'}|[{'remote_type',748,[{'atom',748,'erl_eval'}|[{'atom',748,'binding_struct'}|[[]]]]}]]]]}|[{'type',749,'constraint',[{'atom',749,'is_subtype'}|[[{'var',749,'Return'}|[{'type',749,'union',[{'type',749,'tuple',[{'atom',749,'ok'}|[{'user_type',749,'abstract_expr',[]}]]}|[{'type',750,'tuple',[{'atom',750,'not_ok'}|[{'type',750,'tuple',[{'atom',750,'error'}|[{'type',750,'module',[]}|[{'ann_type',750,[{'var',750,'Reason'}|[{'type',750,'term',[]}]]}]]]}]]}]]}]]]]}]]]]]}]}]
, 'record' = [{'optz',[{'record_field',1006,{'atom',1006,'unique'},{'atom',1006,'false'}}|[{'record_field',1007,{'atom',1007,'cache'},{'atom',1007,'false'}}|[{'record_field',1008,{'atom',1008,'join_option'},{'atom',1008,'any'}}|[{'record_field',1009,{'atom',1009,'fast_join'},{'atom',1009,'no'}}|[{'record_field',1010,{'atom',1010,'opt'}}]]]]]}]
, 'record' = [{'qlc',[{'record_field',1015,{'atom',1015,'lcf'}}|[{'record_field',1016,{'atom',1016,'codef'}}|[{'record_field',1017,{'atom',1017,'qdata'}}|[{'record_field',1018,{'atom',1018,'init_value'}}|[{'record_field',1019,{'atom',1019,'optz'}}]]]]]}]
, 'record' = [{'simple_qlc',[{'record_field',1024,{'atom',1024,'p'}}|[{'record_field',1025,{'atom',1025,'le'}}|[{'typed_record_field',{'record_field',1026,{'atom',1026,'line'}},{'remote_type',1026,[{'atom',1026,'erl_anno'}|[{'atom',1026,'anno'}|[[]]]]}}|[{'record_field',1027,{'atom',1027,'init_value'}}|[{'record_field',1028,{'atom',1028,'optz'}}]]]]]}]
, 'record' = [{'prepared',[{'record_field',1032,{'atom',1032,'qh'}}|[{'record_field',1034,{'atom',1034,'sorted'},{'atom',1034,'no'}}|[{'record_field',1035,{'atom',1035,'sort_info'},{'nil',1035}}|[{'record_field',1036,{'atom',1036,'sort_info2'},{'nil',1036}}|[{'record_field',1037,{'atom',1037,'lu_skip_quals'},{'nil',1037}}|[{'record_field',1038,{'atom',1038,'join'},{'tuple',1038,[{'nil',1038}|[{'nil',1038}]]}}|[{'record_field',1039,{'atom',1039,'n_objs'},{'atom',1039,'undefined'}}|[{'record_field',1040,{'atom',1040,'is_unique_objects'},{'atom',1040,'false'}}|[{'record_field',1041,{'atom',1041,'is_cached'},{'atom',1041,'false'}}]]]]]]]]]}]
, 'record' = [{'join',[{'record_field',1445,{'atom',1445,'op'}}|[{'record_field',1445,{'atom',1445,'q1'}}|[{'record_field',1445,{'atom',1445,'q2'}}|[{'record_field',1445,{'atom',1445,'wh1'}}|[{'record_field',1445,{'atom',1445,'wh2'}}|[{'record_field',1445,{'atom',1445,'cs_fun'}}]]]]]]}]
, 'record' = [{'m',[{'record_field',3335,{'atom',3335,'id'}}|[{'record_field',3335,{'atom',3335,'tmpdir'}}|[{'record_field',3335,{'atom',3335,'max_list'}}|[{'record_field',3335,{'atom',3335,'tmp_usage'}}]]]]}]
, 'spec' = [{{'throw_file_error',2},[{'type',3833,'fun',[{'type',3833,'product',[{'type',3833,'string',[]}|[{'type',3833,'tuple',[{'atom',3833,'error'}|[{'type',3833,'atom',[]}]]}]]}|[{'type',3833,'no_return',[]}]]}]}]
, 'spec' = [{{'throw_reason',1},[{'type',3838,'fun',[{'type',3838,'product',[{'type',3838,'term',[]}]}|[{'type',3838,'no_return',[]}]]}]}]
, 'spec' = [{{'throw_error',1},[{'type',3843,'fun',[{'type',3843,'product',[{'type',3843,'term',[]}]}|[{'type',3843,'no_return',[]}]]}]}] ] 'get_handle'/1 = fun (_0) -> case _0 of <{'qlc_handle',H = {'qlc_lc',_6,{'qlc_opt',U,C,M}}}> when 'true' -> let <_rec0> = {'qlc_opt',U,C,M,'any',[],'any',524288,'allowed'} in case H of <{'qlc_lc',_7,_8}> when 'true' -> call 'erlang':'setelement' (3,H,_rec0)
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_lc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<{'qlc_handle',H}> when 'true' -> H
<L> when call 'erlang':'is_list' (_0) -> L
<_10> when 'true' -> 'badarg' end
'append'/1 = fun (_0) -> let <_7> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[QH|_2]> when 'true' -> let <_5> = case apply 'get_handle'/1 (QH) of <'badarg'> when 'true' -> call 'erlang':'error' ('badarg',[_0|[]])
<H> when 'true' -> H end in let <_6> = apply 'lc$^0'/1 (_2) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in {'qlc_handle',{'qlc_append',_7}}
'append'/2 = fun (_0,_1) -> let <_8> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[QH|_3]> when 'true' -> let <_6> = case apply 'get_handle'/1 (QH) of <'badarg'> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[]]])
<H> when 'true' -> H end in let <_7> = apply 'lc$^0'/1 (_3) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([_0|[_1|[]]]) in {'qlc_handle',{'qlc_append',_8}}
'cursor'/1 = fun (_0) -> apply 'cursor'/2 (_0,[])
'cursor'/2 = fun (_0,_1) -> let <_3> = apply 'options'/2 (_1,['unique_all'|['cache_all'|['tmpdir'|['spawn_options'|['max_list_size'|['tmpdir_usage']]]]]]) in let <_2> = apply 'get_handle'/1 (_0) in case <_3,_2> of <B1,B2> when let <_4> = call 'erlang':'=:=' (B1,'badarg') in let <_5> = call 'erlang':'=:=' (B2,'badarg') in call 'erlang':'or' (_4,_5) -> call 'erlang':'error' ('badarg',[_0|[_1|[]]])
<([GUnique|([GCache|([TmpDir|([SpawnOptions0|([MaxList|([TmpUsage|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] ),H> when 'true' -> let <SpawnOptions> = apply 'spawn_options'/1 (SpawnOptions0) in case apply 'cursor_process'/7 (H,GUnique,GCache,TmpDir,SpawnOptions,MaxList,TmpUsage) of <Pid> when call 'erlang':'is_pid' (Pid) -> let <_7> = call 'erlang':'self' () in {'qlc_cursor',{Pid,_7}}
<Error> when 'true' -> Error end
(<(_12-|['compiler_generated'] ),(_13-|['compiler_generated'] )> when 'true' -> let <_9> = {(_12-|['compiler_generated'] ),(_13-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
'delete_cursor'/1 = fun (_0) -> case _0 of <C = {'qlc_cursor',{_3,Owner}}> when try let <_1> = call 'erlang':'self' () in call 'erlang':'=/=' (Owner,_1) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'error' ('not_cursor_owner',[C|[]])
<{'qlc_cursor',{Pid,_4}}> when 'true' -> apply 'stop_cursor'/1 (Pid)
<T> when 'true' -> call 'erlang':'error' ('badarg',[T|[]]) end
'e'/1 = fun (_0) -> apply 'eval'/2 (_0,[])
'e'/2 = fun (_0,_1) -> apply 'eval'/2 (_0,_1)
'eval'/1 = fun (_0) -> apply 'eval'/2 (_0,[])
'eval'/2 = fun (_0,_1) -> let <_3> = apply 'options'/2 (_1,['unique_all'|['cache_all'|['tmpdir'|['max_list_size'|['tmpdir_usage']]]]]) in let <_2> = apply 'get_handle'/1 (_0) in case <_3,_2> of <B1,B2> when let <_4> = call 'erlang':'=:=' (B1,'badarg') in let <_5> = call 'erlang':'=:=' (B2,'badarg') in call 'erlang':'or' (_4,_5) -> call 'erlang':'error' ('badarg',[_0|[_1|[]]])
<([GUnique|([GCache|([TmpDir|([MaxList|([TmpUsage|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] ),Handle> when 'true' -> try let <Prep> = apply 'prepare_qlc'/7 (Handle,[],GUnique,GCache,TmpDir,MaxList,TmpUsage) in let <_7> = call 'erlang':'self' () in case apply 'setup_qlc'/2 (Prep,{'setup',_7}) of <{L,Post,_X_LocalPost}> when call 'erlang':'is_list' (L) -> do apply 'post_funs'/1 (Post) L
<{Objs,Post,_X_LocalPost}> when call 'erlang':'is_function' (Objs) -> letrec 'after$^0'/0 = fun () -> apply 'post_funs'/1 (Post) in try apply 'collect'/1 (Objs) of <_8> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) _8 catch <_11,_10,_9> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) primop 'raise' (_9,_10)
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end of <_13> -> _13 catch <_16,_15,_14> -> case <_16,_15,_14> of <('throw'-|['compiler_generated'] ),Term,_33> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_33) in case Stacktrace of <[{'qlc','throw_error',_21,_22}|_23]> when 'true' -> Term
<_24> when 'true' -> call 'erlang':'raise' ('throw',Term,Stacktrace) end
(<_34,_35,_36> when 'true' -> primop 'raise' (_36,_35)-|['compiler_generated'] ) end
(<(_25-|['compiler_generated'] ),(_26-|['compiler_generated'] )> when 'true' -> let <_18> = {(_25-|['compiler_generated'] ),(_26-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end
'fold'/3 = fun (_0,_1,_2) -> apply 'fold'/4 (_0,_1,_2,[])
'fold'/4 = fun (_0,_1,_2,_3) -> let <_5> = apply 'options'/2 (_3,['unique_all'|['cache_all'|['tmpdir'|['max_list_size'|['tmpdir_usage']]]]]) in let <_4> = apply 'get_handle'/1 (_2) in case <_5,_4> of <B1,B2> when let <_6> = call 'erlang':'=:=' (B1,'badarg') in let <_7> = call 'erlang':'=:=' (B2,'badarg') in call 'erlang':'or' (_6,_7) -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[_3|[]]]]])
<([GUnique|([GCache|([TmpDir|([MaxList|([TmpUsage|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] ),Handle> when 'true' -> try let <Prep> = apply 'prepare_qlc'/7 (Handle,'not_a_list',GUnique,GCache,TmpDir,MaxList,TmpUsage) in let <_9> = call 'erlang':'self' () in case apply 'setup_qlc'/2 (Prep,{'setup',_9}) of <{Objs,Post,_X_LocalPost}> when let <_10> = call 'erlang':'is_function' (Objs) in let <_11> = call 'erlang':'is_list' (Objs) in call 'erlang':'or' (_10,_11) -> letrec 'after$^0'/0 = fun () -> apply 'post_funs'/1 (Post) in try apply 'fold_loop'/3 (_0,Objs,_1) of <_12> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) _12 catch <_15,_14,_13> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) primop 'raise' (_13,_14)
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end of <_17> -> _17 catch <_20,_19,_18> -> case <_20,_19,_18> of <('throw'-|['compiler_generated'] ),Term,_39> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_39) in case Stacktrace of <[{'qlc','throw_error',_27,_28}|_29]> when 'true' -> Term
<_30> when 'true' -> call 'erlang':'raise' ('throw',Term,Stacktrace) end
(<_40,_41,_42> when 'true' -> primop 'raise' (_42,_41)-|['compiler_generated'] ) end
(<(_31-|['compiler_generated'] ),(_32-|['compiler_generated'] )> when 'true' -> let <_22> = {(_31-|['compiler_generated'] ),(_32-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end
'format_error'/1 = fun (_0) -> case _0 of <'not_a_query_list_comprehension'> when 'true' -> call 'io_lib':'format' ([97|[114|[103|[117|[109|[101|[110|[116|[32|[105|[115|[32|[110|[111|[116|[32|[97|[32|[113|[117|[101|[114|[121|[32|[108|[105|[115|[116|[32|[99|[111|[109|[112|[114|[101|[104|[101|[110|[115|[105|[111|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<{'used_generator_variable',V}> when 'true' -> call 'io_lib':'format' ([103|[101|[110|[101|[114|[97|[116|[101|[100|[32|[118|[97|[114|[105|[97|[98|[108|[101|[32|[126|[119|[32|[109|[117|[115|[116|[32|[110|[111|[116|[32|[98|[101|[32|[117|[115|[101|[100|[32|[105|[110|[32|[108|[105|[115|[116|[32|[101|[120|[112|[114|[101|[115|[115|[105|[111|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[V|[]])
<'binary_generator'> when 'true' -> call 'io_lib':'format' ([99|[97|[110|[110|[111|[116|[32|[104|[97|[110|[100|[108|[101|[32|[98|[105|[110|[97|[114|[121|[32|[103|[101|[110|[101|[114|[97|[116|[111|[114|[115]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<'too_complex_join'> when 'true' -> call 'io_lib':'format' ([99|[97|[110|[110|[111|[116|[32|[104|[97|[110|[100|[108|[101|[32|[106|[111|[105|[110|[32|[111|[102|[32|[116|[104|[114|[101|[101|[32|[111|[114|[32|[109|[111|[114|[101|[32|[103|[101|[110|[101|[114|[97|[116|[111|[114|[115|[32|[101|[102|[102|[105|[99|[105|[101|[110|[116|[108|[121]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<'too_many_joins'> when 'true' -> call 'io_lib':'format' ([99|[97|[110|[110|[111|[116|[32|[104|[97|[110|[100|[108|[101|[32|[109|[111|[114|[101|[32|[116|[104|[97|[110|[32|[111|[110|[101|[32|[106|[111|[105|[110|[32|[101|[102|[102|[105|[99|[105|[101|[110|[116|[108|[121]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<'nomatch_pattern'> when 'true' -> call 'io_lib':'format' ([112|[97|[116|[116|[101|[114|[110|[32|[99|[97|[110|[110|[111|[116|[32|[112|[111|[115|[115|[105|[98|[108|[121|[32|[109|[97|[116|[99|[104]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<'nomatch_filter'> when 'true' -> call 'io_lib':'format' ([102|[105|[108|[116|[101|[114|[32|[101|[118|[97|[108|[117|[97|[116|[101|[115|[32|[116|[111|[32|[39|[102|[97|[108|[115|[101|[39]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<{Line,Mod,Reason}> when call 'erlang':'is_integer' (Line) -> let <_1> = call Mod:'format_error' (Reason) in let <_2> = call 'lists':'flatten' (_1) in call 'io_lib':'format' ([126|[112|[58|[32|[126|[116|[115|[126|[110]]]]]]]]],[Line|[_2|[]]])
<{'bad_object',FileName}> when 'true' -> call 'io_lib':'format' ([116|[104|[101|[32|[116|[101|[109|[112|[111|[114|[97|[114|[121|[32|[102|[105|[108|[101|[32|[34|[126|[116|[115|[34|[32|[104|[111|[108|[100|[105|[110|[103|[32|[97|[110|[115|[119|[101|[114|[115|[32|[105|[115|[32|[99|[111|[114|[114|[117|[112|[116]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[FileName|[]])
<'bad_object'> when 'true' -> call 'io_lib':'format' ([116|[104|[101|[32|[107|[101|[121|[115|[32|[99|[111|[117|[108|[100|[32|[110|[111|[116|[32|[98|[101|[32|[101|[120|[116|[114|[97|[99|[116|[101|[100|[32|[102|[114|[111|[109|[32|[115|[111|[109|[101|[32|[116|[101|[114|[109]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[])
<{'file_error',FileName,Reason}> when 'true' -> let <_3> = call 'file':'format_error' (Reason) in call 'io_lib':'format' ([34|[126|[116|[115|[34|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]],[FileName|[_3|[]]])
<{'premature_eof',FileName}> when 'true' -> call 'io_lib':'format' ([34|[126|[116|[115|[34|[58|[32|[101|[110|[100|[45|[111|[102|[45|[102|[105|[108|[101|[32|[119|[97|[115|[32|[101|[110|[99|[111|[117|[110|[116|[101|[114|[101|[100|[32|[105|[110|[115|[105|[100|[101|[32|[115|[111|[109|[101|[32|[98|[105|[110|[97|[114|[121|[32|[116|[101|[114|[109]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[FileName|[]])
<{'tmpdir_usage',Why}> when 'true' -> call 'io_lib':'format' ([116|[101|[109|[112|[111|[114|[97|[114|[121|[32|[102|[105|[108|[101|[32|[119|[97|[115|[32|[110|[101|[101|[100|[101|[100|[32|[102|[111|[114|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Why|[]])
<{'error',Module,Reason}> when 'true' -> call Module:'format_error' (Reason)
<E> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[126|[110]]]]],[E|[]]) end
'info'/1 = fun (_0) -> apply 'info'/2 (_0,[])
'info'/2 = fun (_0,_1) -> let <_3> = apply 'options'/2 (_1,['unique_all'|['cache_all'|['flat'|['format'|['n_elements'|['depth'|['tmpdir'|['max_list_size'|['tmpdir_usage']]]]]]]]]) in let <_2> = apply 'get_handle'/1 (_0) in case <_3,_2> of <B1,B2> when let <_4> = call 'erlang':'=:=' (B1,'badarg') in let <_5> = call 'erlang':'=:=' (B2,'badarg') in call 'erlang':'or' (_4,_5) -> call 'erlang':'error' ('badarg',[_0|[_1|[]]])
<([GUnique|([GCache|([Flat|([Format|([NElements|([Depth|([TmpDir|([MaxList|([TmpUsage|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] ),H> when 'true' -> try let <Prep> = apply 'prepare_qlc'/7 (H,[],GUnique,GCache,TmpDir,MaxList,TmpUsage) in let <Info> = apply 'le_info'/2 (Prep,{NElements,Depth}) in let <AbstractCode> = apply 'abstract'/4 (Info,Flat,NElements,Depth) in case Format of <'abstract_code'> when 'true' -> apply 'abstract_code'/1 (AbstractCode)
<'string'> when 'true' -> let <Hook> = fun (_12,_11,_10,_9) -> case <_12,_11,_10,_9> of <{'special',_X_Line,String},_X_I,_X_P,_X_F> when 'true' -> String
(<_16,_15,_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14,_13})-|[{'function_name',{'-info/2-fun-0-',4}}] )-|['compiler_generated'] ) end in let <_18> = call 'erl_pp':'expr' (AbstractCode,0,Hook) in call 'lists':'flatten' (_18)
<'debug'> when 'true' -> Info
(<_19> when 'true' -> primop 'match_fail' ({'case_clause',_19})-|['compiler_generated'] ) end of <_20> -> _20 catch <_23,_22,_21> -> case <_23,_22,_21> of <('throw'-|['compiler_generated'] ),Term,_34> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_34) in case Stacktrace of <[{'qlc','throw_error',_28,_29}|_30]> when 'true' -> Term
<_31> when 'true' -> call 'erlang':'raise' ('throw',Term,Stacktrace) end
(<_35,_36,_37> when 'true' -> primop 'raise' (_37,_36)-|['compiler_generated'] ) end
(<(_32-|['compiler_generated'] ),(_33-|['compiler_generated'] )> when 'true' -> let <_25> = {(_32-|['compiler_generated'] ),(_33-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end
'keysort'/2 = fun (_0,_1) -> apply 'keysort'/3 (_0,_1,[])
'keysort'/3 = fun (_0,_1,_2) -> let <_5> = apply 'is_keypos'/1 (_0) in let <_4> = apply 'options'/2 (_2,['tmpdir'|['order'|['unique'|['compressed'|['size'|['no_files']]]]]]) in let <_3> = apply 'get_handle'/1 (_1) in case <_5,_4,_3> of <('true'-|['compiler_generated'] ),([TmpDir|([Order|([Unique|([Compressed|_11]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] ),H> when call 'erlang':'=/=' (H,'badarg') -> let <_6> = apply 'listify'/1 (_2) in {'qlc_handle',{'qlc_sort',H,{'keysort',_0},Unique,Compressed,Order,_6,'allowed',TmpDir}}
<(_13-|['compiler_generated'] ),(_14-|['compiler_generated'] ),(_15-|['compiler_generated'] )> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[]]]]) end
'next_answers'/1 = fun (_0) -> apply 'next_answers'/2 (_0,10)
'next_answers'/2 = fun (_0,_1) -> case <_0,_1> of <C = {'qlc_cursor',{_10,Owner}},NumOfAnswers> when try let <_2> = call 'erlang':'self' () in call 'erlang':'=/=' (Owner,_2) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'error' ('not_cursor_owner',[C|[NumOfAnswers|[]]])
<C = {'qlc_cursor',{Pid,_11}},NumOfAnswers> when 'true' -> let <_6> = case NumOfAnswers of <'all_remaining'> when 'true' -> -1
<_12> when let <_3> = call 'erlang':'is_integer' (NumOfAnswers) in let <_4> = call 'erlang':'>' (NumOfAnswers,0) in call 'erlang':'and' (_3,_4) -> NumOfAnswers
<_13> when 'true' -> call 'erlang':'error' ('badarg',[C|[NumOfAnswers|[]]]) end in apply 'next_loop'/3 (Pid,[],_6)
<T1,T2> when 'true' -> call 'erlang':'error' ('badarg',[T1|[T2|[]]]) end
'parse_transform'/2 = fun (_0,_1) -> call 'qlc_pt':'parse_transform' (_0,_1)
'q'/1 = fun (_0) -> apply 'q'/2 (_0,[])
'q'/2 = fun (_0,_1) -> case <_0,_1> of <QLC_lc = {'qlc_lc',_10,_11},Options> when 'true' -> case apply 'options'/2 (Options,['unique'|['cache'|['max_lookup'|['join'|['lookup']]]]]) of <[Unique|[Cache|[Max|[Join|[Lookup|[]]]]]]> when 'true' -> let <Opt> = {'qlc_opt',Unique,Cache,Max,Join,[],Lookup,524288,'allowed'} in case QLC_lc of <{'qlc_lc',_12,_13}> when 'true' -> let <_6> = call 'erlang':'setelement' (3,QLC_lc,Opt) in {'qlc_handle',_6}
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_lc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<_15> when 'true' -> call 'erlang':'error' ('badarg',[QLC_lc|[Options|[]]]) end
<T1,T2> when 'true' -> call 'erlang':'error' ('badarg',[T1|[T2|[]]]) end
'sort'/1 = fun (_0) -> apply 'sort'/2 (_0,[])
'sort'/2 = fun (_0,_1) -> let <_3> = apply 'options'/2 (_1,['tmpdir'|['order'|['unique'|['compressed'|['size'|['no_files']]]]]]) in let <_2> = apply 'get_handle'/1 (_0) in case <_3,_2> of <B1,B2> when let <_4> = call 'erlang':'=:=' (B1,'badarg') in let <_5> = call 'erlang':'=:=' (B2,'badarg') in call 'erlang':'or' (_4,_5) -> call 'erlang':'error' ('badarg',[_0|[_1|[]]])
<([TD|([Order|([Unique|([Compressed|_10]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] ),H> when 'true' -> let <_6> = apply 'listify'/1 (_1) in {'qlc_handle',{'qlc_sort',H,'sort',Unique,Compressed,Order,_6,'allowed',TD}}
(<(_11-|['compiler_generated'] ),(_12-|['compiler_generated'] )> when 'true' -> let <_7> = {(_11-|['compiler_generated'] ),(_12-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
'string_to_handle'/1 = fun (_0) -> apply 'string_to_handle'/2 (_0,[])
'string_to_handle'/2 = fun (_0,_1) -> let <_2> = call 'erl_eval':'new_bindings' () in apply 'string_to_handle'/3 (_0,_1,_2)
'string_to_handle'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Str,Options,Bindings> when call 'erlang':'is_list' (Str) -> case apply 'options'/2 (Options,['unique'|['cache'|['max_lookup'|['join'|['lookup']]]]]) of <'badarg'> when 'true' -> call 'erlang':'error' ('badarg',[Str|[Options|[Bindings|[]]]])
<[Unique|[Cache|[MaxLookup|[Join|[Lookup|[]]]]]]> when 'true' -> case call 'erl_scan':'string' (Str,1,['text']) of <{'ok',Tokens,_20}> when 'true' -> let <_4> = case call 'erl_eval':'extended_parse_exprs' (Tokens) of <{'ok',[Expr0|[]],SBs}> when 'true' -> {'ok',Expr0,SBs}
<{'ok',_X_ExprList,_X_SBs}> when 'true' -> call 'erlang':'error' ('badarg',[Str|[Options|[Bindings|[]]]])
<E> when 'true' -> E end in case _4 of <{'ok',Expr,XBs}> when 'true' -> let <Bs1> = apply 'merge_binding_structs'/2 (Bindings,XBs) in case call 'qlc_pt':'transform_expression' (Expr,Bs1) of <{'ok',{'call',_21,_X_QlcQ,Handle}}> when 'true' -> case call 'erl_eval':'exprs' (Handle,Bs1) of <{'value',QLC_lc,_22}> when 'true' -> let <O> = {'qlc_opt',Unique,Cache,MaxLookup,Join,[],Lookup,524288,'allowed'} in case QLC_lc of <{'qlc_lc',_23,_24}> when 'true' -> let <_12> = call 'erlang':'setelement' (3,QLC_lc,O) in {'qlc_handle',_12}
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_lc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<{'not_ok',[{'error',Error}|_26]}> when 'true' -> apply 'error'/1 (Error)
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<{'error',ErrorInfo}> when 'true' -> apply 'error'/1 (ErrorInfo)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
<{'error',ErrorInfo,_X_EndLine}> when 'true' -> apply 'error'/1 (ErrorInfo)
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end
<T1,T2,T3> when 'true' -> call 'erlang':'error' ('badarg',[T1|[T2|[T3|[]]]]) end
'table'/2 = fun (_0,_1) -> case <_0,_1> of <TraverseFun,Options> when call 'erlang':'is_function' (TraverseFun) -> let <_4> = call 'erlang':'is_function' (TraverseFun,0) in let <_3> = call 'erlang':'is_function' (TraverseFun,1) in case <_4,_3> of <'false','false'> when 'true' -> call 'erlang':'error' ('badarg',[TraverseFun|[Options|[]]])
<(_11-|['compiler_generated'] ),(_12-|['compiler_generated'] )> when 'true' -> case apply 'options'/2 (Options,['pre_fun'|['post_fun'|['info_fun'|['format_fun'|['lookup_fun'|['parent_fun'|['key_equality']]]]]]]) of <[PreFun|[PostFun|[InfoFun|[FormatFun|[LookupFun|[ParentFun|[KeyEquality|[]]]]]]]]> when 'true' -> let <T> = {'qlc_table',TraverseFun,_3,PreFun,PostFun,InfoFun,FormatFun,LookupFun,ParentFun,KeyEquality,'undefined','no_match_spec'} in {'qlc_handle',T}
<'badarg'> when 'true' -> call 'erlang':'error' ('badarg',[TraverseFun|[Options|[]]])
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end end
<T1,T2> when 'true' -> call 'erlang':'error' ('badarg',[T1|[T2|[]]]) end
'transform_from_evaluator'/2 = fun (_0,_1) -> call 'qlc_pt':'transform_from_evaluator' (_0,_1)
'template_state'/0 = fun () -> 1
'aux_name'/3 = fun (_0,_1,_2) -> case apply 'aux_name1'/3 (_0,_1,_2) of <{VN,_7}> when 'true' -> VN
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'name_suffix'/2 = fun (_0,_1) -> let <_2> = call 'lists':'concat' ([_0|[_1|[]]]) in call 'erlang':'list_to_atom' (_2)
'vars'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'var',_X_L,V}> when 'true' -> V
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-vars/1-fun-0-',1}}] )-|['compiler_generated'] ) end in apply 'var_ufold'/2 (_3,_0)
'var_ufold'/2 = fun (_0,_1) -> let <_2> = apply 'var_fold'/3 (_0,[],_1) in call 'ordsets':'from_list' (_2)
'all_selections'/1 = fun (_0) -> case _0 of <[]> when 'true' -> [[]]
<[{I,Cs}|ICs]> when 'true' -> (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[C|_2]> when 'true' -> (letrec 'lc$^1'/1 = fun (_7) -> case _7 of <[L|_4]> when 'true' -> let <_8> = apply 'lc$^1'/1 (_4) in ([[{I,C}|L]|_8]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_2)
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_5> = apply 'all_selections'/1 (ICs) in apply 'lc$^1'/1 (_5)-|['list_comprehension'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Cs)-|['list_comprehension'] )
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'all_selections',1}}] )-|['compiler_generated'] ) end
'merge_binding_structs'/2 = fun (_0,_1) -> let <_7> = fun (_4,_3) -> case <_4,_3> of <{N,V},Bs> when 'true' -> call 'erl_eval':'add_binding' (N,V,Bs)
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'-merge_binding_structs/2-fun-0-',2}}] )-|['compiler_generated'] ) end in let <_2> = call 'erl_eval':'bindings' (_1) in call 'lists':'foldl' (_7,_0,_2)
'aux_name1'/3 = fun (_0,_1,_2) -> let <SN> = apply 'name_suffix'/2 (_0,_1) in case call 'gb_sets':'is_member' (SN,_2) of <'true'> when 'true' -> let <_4> = call 'erlang':'+' (_1,1) in apply 'aux_name1'/3 (_0,_4,_2)
<'false'> when 'true' -> {SN,_1}
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'var_fold'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F,A,Var = {'var',_9,V}> when call 'erlang':'=/=' (V,'_') -> let <_3> = apply F (Var) in [_3|A]
<F,A,T> when call 'erlang':'is_tuple' (T) -> let <_4> = call 'erlang':'tuple_to_list' (T) in apply 'var_fold'/3 (F,A,_4)
<F,A,[E|Es]> when 'true' -> let <_5> = apply 'var_fold'/3 (F,A,E) in apply 'var_fold'/3 (F,_5,Es)
<_X_F,A,_X_T> when 'true' -> A end
'options'/2 = fun (_0,_1) -> case <_0,_1> of <Options,Keys> when call 'erlang':'is_list' (Options) -> apply 'options'/3 (Options,Keys,[])
<Option,Keys> when 'true' -> apply 'options'/3 ([Option|[]],Keys,[]) end
'options'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Options0,[Key|Keys],L> when call 'erlang':'is_list' (Options0) -> let <_6> = case call 'lists':'member' (Key,Options0) of <'true'> when 'true' -> let <_3> = apply 'atom_option'/1 (Key) in let <_4> = call 'lists':'delete' (Key,Options0) in [_3|_4]
<'false'> when 'true' -> Options0
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end in let <_51> = case call 'lists':'keyfind' (Key,1,_6) of <{'format_fun',U = 'undefined'}> when 'true' -> {'ok',U}
<{'info_fun',U = 'undefined'}> when 'true' -> {'ok',U}
<{'lookup_fun',U = 'undefined'}> when 'true' -> {'ok',U}
<{'parent_fun',U = 'undefined'}> when 'true' -> {'ok',U}
<{'post_fun',U = 'undefined'}> when 'true' -> {'ok',U}
<{'pre_fun',U = 'undefined'}> when 'true' -> {'ok',U}
<{'info_fun',Fun}> when call 'erlang':'is_function' (Fun,1) -> {'ok',Fun}
<{'pre_fun',Fun}> when call 'erlang':'is_function' (Fun,1) -> {'ok',Fun}
<{'post_fun',Fun}> when call 'erlang':'is_function' (Fun,0) -> {'ok',Fun}
<{'lookup_fun',Fun}> when call 'erlang':'is_function' (Fun,2) -> {'ok',Fun}
<{'max_lookup',Max}> when let <_8> = call 'erlang':'is_integer' (Max) in let <_9> = call 'erlang':'>=' (Max,0) in call 'erlang':'and' (_8,_9) -> {'ok',Max}
<{'max_lookup','infinity'}> when 'true' -> {'ok',-1}
<{'format_fun',Fun}> when call 'erlang':'is_function' (Fun,1) -> {'ok',Fun}
<{'parent_fun',Fun}> when call 'erlang':'is_function' (Fun,0) -> {'ok',Fun}
<{'key_equality',KE = '=='}> when 'true' -> {'ok',KE}
<{'key_equality',KE = '=:='}> when 'true' -> {'ok',KE}
<{'join',J = 'any'}> when 'true' -> {'ok',J}
<{'join',J = 'nested_loop'}> when 'true' -> {'ok',J}
<{'join',J = 'merge'}> when 'true' -> {'ok',J}
<{'join',J = 'lookup'}> when 'true' -> {'ok',J}
<{'lookup',LookUp}> when let <_11> = call 'erlang':'is_boolean' (LookUp) in let <_12> = call 'erlang':'=:=' (LookUp,'any') in call 'erlang':'or' (_11,_12) -> {'ok',LookUp}
<{'max_list_size',Max}> when let <_13> = call 'erlang':'is_integer' (Max) in let <_14> = call 'erlang':'>=' (Max,0) in call 'erlang':'and' (_13,_14) -> {'ok',Max}
<{'tmpdir_usage',TmpUsage}> when let <_15> = call 'erlang':'=:=' (TmpUsage,'allowed') in let <_16> = call 'erlang':'=:=' (TmpUsage,'not_allowed') in let <_17> = call 'erlang':'=:=' (TmpUsage,'info_msg') in let <_18> = call 'erlang':'=:=' (TmpUsage,'warning_msg') in let <_19> = call 'erlang':'=:=' (TmpUsage,'error_msg') in let <_20> = call 'erlang':'or' (_18,_19) in let <_21> = call 'erlang':'or' (_17,_20) in let <_22> = call 'erlang':'or' (_16,_21) in call 'erlang':'or' (_15,_22) -> {'ok',TmpUsage}
<{'unique',Unique}> when call 'erlang':'is_boolean' (Unique) -> {'ok',Unique}
<{'cache',Cache}> when let <_23> = call 'erlang':'is_boolean' (Cache) in let <_24> = call 'erlang':'=:=' (Cache,'list') in call 'erlang':'or' (_23,_24) -> {'ok',Cache}
<{'cache','ets'}> when 'true' -> {'ok','true'}
<{'cache','no'}> when 'true' -> {'ok','false'}
<{'unique_all',UniqueAll}> when call 'erlang':'is_boolean' (UniqueAll) -> {'ok',UniqueAll}
<{'cache_all',CacheAll}> when let <_25> = call 'erlang':'is_boolean' (CacheAll) in let <_26> = call 'erlang':'=:=' (CacheAll,'list') in call 'erlang':'or' (_25,_26) -> {'ok',CacheAll}
<{'cache_all','ets'}> when 'true' -> {'ok','true'}
<{'cache_all','no'}> when 'true' -> {'ok','false'}
<{'spawn_options','default'}> when 'true' -> {'ok','default'}
<{'spawn_options',SpawnOptions}> when 'true' -> case apply 'is_proper_list'/1 (SpawnOptions) of <'true'> when 'true' -> {'ok',SpawnOptions}
<'false'> when 'true' -> 'badarg'
(<_27> when 'true' -> primop 'match_fail' ({'case_clause',_27})-|['compiler_generated'] ) end
<{'flat',Flat}> when call 'erlang':'is_boolean' (Flat) -> {'ok',Flat}
<{'format',Format}> when let <_28> = call 'erlang':'=:=' (Format,'string') in let <_29> = call 'erlang':'=:=' (Format,'abstract_code') in let <_30> = call 'erlang':'=:=' (Format,'debug') in let <_31> = call 'erlang':'or' (_29,_30) in call 'erlang':'or' (_28,_31) -> {'ok',Format}
<{'n_elements',NElements}> when let <_32> = call 'erlang':'=:=' (NElements,'infinity') in let <_33> = call 'erlang':'is_integer' (NElements) in let <_34> = call 'erlang':'>' (NElements,0) in let <_35> = call 'erlang':'and' (_33,_34) in call 'erlang':'or' (_32,_35) -> {'ok',NElements}
<{'depth',Depth}> when let <_36> = call 'erlang':'=:=' (Depth,'infinity') in let <_37> = call 'erlang':'is_integer' (Depth) in let <_38> = call 'erlang':'>=' (Depth,0) in let <_39> = call 'erlang':'and' (_37,_38) in call 'erlang':'or' (_36,_39) -> {'ok',Depth}
<{'order',Order}> when let <_40> = call 'erlang':'is_function' (Order,2) in let <_41> = call 'erlang':'=:=' (Order,'ascending') in let <_42> = call 'erlang':'=:=' (Order,'descending') in let <_43> = call 'erlang':'or' (_41,_42) in call 'erlang':'or' (_40,_43) -> {'ok',Order}
<{'compressed',Comp}> when (call 'erlang':'=:=' (Comp,'true')-|['compiler_generated'] ) -> {'ok',['compressed']}
<{'compressed',Comp}> when (call 'erlang':'=:=' (Comp,'false')-|['compiler_generated'] ) -> {'ok',[]}
<{'tmpdir',T}> when 'true' -> {'ok',T}
<{'size',Size}> when let <_45> = call 'erlang':'is_integer' (Size) in let <_46> = call 'erlang':'>' (Size,0) in call 'erlang':'and' (_45,_46) -> {'ok',Size}
<{'no_files',NoFiles}> when let <_47> = call 'erlang':'is_integer' (NoFiles) in let <_48> = call 'erlang':'>' (NoFiles,1) in call 'erlang':'and' (_47,_48) -> {'ok',NoFiles}
<{_58,_59}> when call 'erlang':'=:=' (_58,Key) -> 'badarg'
<'false'> when 'true' -> let <Default> = apply 'default_option'/1 (Key) in {'ok',Default}
(<_50> when 'true' -> primop 'match_fail' ({'case_clause',_50})-|['compiler_generated'] ) end in case _51 of <'badarg'> when 'true' -> 'badarg'
<{'ok',Value}> when 'true' -> let <NewOptions> = call 'lists':'keydelete' (Key,1,_6) in apply 'options'/3 (NewOptions,Keys,[Value|L])
(<_54> when 'true' -> primop 'match_fail' ({'case_clause',_54})-|['compiler_generated'] ) end
<[],[],L> when 'true' -> call 'lists':'reverse' (L)
<_X_Options,_60,_X_L> when 'true' -> 'badarg' end
'default_option'/1 = fun (_0) -> case _0 of <'pre_fun'> when 'true' -> 'undefined'
<'post_fun'> when 'true' -> 'undefined'
<'info_fun'> when 'true' -> 'undefined'
<'format_fun'> when 'true' -> 'undefined'
<'lookup_fun'> when 'true' -> 'undefined'
<'max_lookup'> when 'true' -> -1
<'join'> when 'true' -> 'any'
<'lookup'> when 'true' -> 'any'
<'parent_fun'> when 'true' -> 'undefined'
<'key_equality'> when 'true' -> '=:='
<'spawn_options'> when 'true' -> 'default'
<'flat'> when 'true' -> 'true'
<'format'> when 'true' -> 'string'
<'n_elements'> when 'true' -> 'infinity'
<'depth'> when 'true' -> 'infinity'
<'max_list_size'> when 'true' -> 524288
<'tmpdir_usage'> when 'true' -> 'allowed'
<'cache'> when 'true' -> 'false'
<'cache_all'> when 'true' -> 'false'
<'unique'> when 'true' -> 'false'
<'unique_all'> when 'true' -> 'false'
<'order'> when 'true' -> 'ascending'
<'compressed'> when 'true' -> []
<'tmpdir'> when 'true' -> []
<'size'> when 'true' -> 524288
<'no_files'> when 'true' -> 16
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'default_option',1}}] )-|['compiler_generated'] ) end
'atom_option'/1 = fun (_0) -> case _0 of <'cache'> when 'true' -> {'cache','true'}
<'unique'> when 'true' -> {'unique','true'}
<'cache_all'> when 'true' -> {'cache_all','true'}
<'unique_all'> when 'true' -> {'unique_all','true'}
<'lookup'> when 'true' -> {'lookup','true'}
<'flat'> when 'true' -> {'flat','true'}
<Key> when 'true' -> Key end
'is_proper_list'/1 = fun (_0) -> case _0 of <[_2|L]> when 'true' -> apply 'is_proper_list'/1 (L)
<L> when 'true' -> call 'erlang':'=:=' (L,[]) end
'spawn_options'/1 = fun (_0) -> case _0 of <'default'> when 'true' -> ['link']
<SpawnOptions> when 'true' -> let <_2> = case call 'lists':'member' ('link',SpawnOptions) of <'true'> when 'true' -> SpawnOptions
<'false'> when 'true' -> ['link'|SpawnOptions]
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end in call 'lists':'delete' ('monitor',_2) end
'is_keypos'/1 = fun (_0) -> case _0 of <Keypos> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>' (_0,0) in call 'erlang':'and' (_1,_2) -> 'true'
<[]> when 'true' -> 'false'
<L> when 'true' -> apply 'is_keyposs'/1 (L) end
'is_keyposs'/1 = fun (_0) -> case _0 of <[Kp|Kps]> when let <_1> = call 'erlang':'is_integer' (Kp) in let <_2> = call 'erlang':'>' (Kp,0) in call 'erlang':'and' (_1,_2) -> apply 'is_keyposs'/1 (Kps)
<Kps> when 'true' -> call 'erlang':'=:=' (Kps,[]) end
'listify'/1 = fun (_0) -> case _0 of <L> when call 'erlang':'is_list' (_0) -> L
<T> when 'true' -> [T|[]] end
'cursor_process'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <Parent> = call 'erlang':'self' () in let <Setup> = {'setup',Parent} in let <CF> = fun () -> do call 'erlang':'process_flag' ('trap_exit','true') let <MonRef> = call 'erlang':'monitor' ('process',Parent) in let <_16> = try let <Prep> = apply 'prepare_qlc'/7 (_0,'not_a_list',_1,_2,_3,_5,_6) in apply 'setup_qlc'/2 (Prep,Setup) of <_11> -> _11 catch <_14,_13,_12> -> let <_15> = call 'erlang':'self' () in let <Stacktrace> = primop 'build_stacktrace' (_12) in do call 'erlang':'!' (Parent,{_15,{'caught',_14,_13,Stacktrace}}) call 'erlang':'exit' ('normal') in case _16 of <{Objs,Post,_X_LocalPost}> when 'true' -> let <_18> = call 'erlang':'self' () in do call 'erlang':'!' (Parent,{_18,'ok'}) do apply 'wait_for_request'/3 (Parent,MonRef,Post) apply 'reply'/4 (Parent,MonRef,Post,Objs)
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end in let <Pid> = call 'erlang':'spawn_opt' (CF,_4) in apply 'parent_fun'/2 (Pid,Parent)
'parent_fun'/2 = fun (_0,_1) -> receive <{_11,'ok'}> when call 'erlang':'=:=' (_11,_0) -> _0
<{TPid,{'parent_fun',Fun}}> when 'true' -> let <_7> = try let <_2> = apply Fun () in {'value',_2} of <_3> -> _3 catch <_6,_5,_4> -> let <Stacktrace> = primop 'build_stacktrace' (_4) in {'parent_fun_caught',_6,_5,Stacktrace} in do call 'erlang':'!' (TPid,{_1,_7}) apply 'parent_fun'/2 (_0,_1)
<{_12,{'caught','throw',Error,[{'qlc','throw_error',_13,_14}|_15]}}> when call 'erlang':'=:=' (_12,_0) -> Error
<{_16,{'caught',Class,Reason,Stacktrace}}> when call 'erlang':'=:=' (_16,_0) -> call 'erlang':'raise' (Class,Reason,Stacktrace) after 'infinity' -> 'true'
'reply'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Parent,MonRef,Post,[]> when 'true' -> apply 'no_more'/3 (Parent,MonRef,Post)
<Parent,MonRef,Post,[Answer|Cont]> when 'true' -> let <_4> = call 'erlang':'self' () in do call 'erlang':'!' (Parent,{_4,{'answer',Answer}}) do apply 'wait_for_request'/3 (Parent,MonRef,Post) apply 'reply'/4 (Parent,MonRef,Post,Cont)
<Parent,MonRef,Post,Cont> when 'true' -> let <_11> = try case <> of <> when call 'erlang':'is_function' (Cont) -> apply Cont ()
<> when 'true' -> apply 'throw_error'/1 (Cont) end of <_5> -> _5 catch <_8,_7,_6> -> do apply 'post_funs'/1 (Post) let <Stacktrace> = primop 'build_stacktrace' (_6) in let <Message> = {'caught',_8,_7,Stacktrace} in let <_10> = call 'erlang':'self' () in do call 'erlang':'!' (Parent,{_10,Message}) call 'erlang':'exit' ('normal') in apply 'reply'/4 (Parent,MonRef,Post,_11) end
'no_more'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'self' () in do call 'erlang':'!' (_0,{_3,'no_more'}) do apply 'wait_for_request'/3 (_0,_1,_2) apply 'no_more'/3 (_0,_1,_2)
'wait_for_request'/3 = fun (_0,_1,_2) -> receive <{_8,'stop'}> when call 'erlang':'=:=' (_8,_0) -> do apply 'post_funs'/1 (_2) call 'erlang':'exit' ('normal')
<{_9,'more'}> when call 'erlang':'=:=' (_9,_0) -> 'ok'
<{'EXIT',_10,_X_Reason}> when call 'erlang':'=:=' (_10,_0) -> do apply 'post_funs'/1 (_2) call 'erlang':'exit' ('normal')
<{'DOWN',_11,'process',_12,_X_Info}> when let <_13> = call 'erlang':'=:=' (_11,_1) in let <_14> = call 'erlang':'=:=' (_12,_0) in call 'erlang':'and' (_13,_14) -> do apply 'post_funs'/1 (_2) call 'erlang':'exit' ('normal')
<{'EXIT',Pid,_X_Reason}> when try let <_3> = call 'erlang':'self' () in call 'erlang':'=:=' (Pid,_3) of <Try> -> Try catch <T,R> -> 'false' -> apply 'wait_for_request'/3 (_0,_1,_2)
<Other> when 'true' -> let <_4> = call 'erlang':'self' () in do call 'error_logger':'error_msg' ([84|[104|[101|[32|[113|[108|[99|[32|[99|[117|[114|[115|[111|[114|[32|[126|[119|[32|[114|[101|[99|[101|[105|[118|[101|[100|[32|[97|[110|[32|[117|[110|[101|[120|[112|[101|[99|[116|[101|[100|[32|[109|[101|[115|[115|[97|[103|[101|[58|[10|[126|[116|[112|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_4|[Other|[]]]) apply 'wait_for_request'/3 (_0,_1,_2) after 'infinity' -> 'true'
'abstract_code'/1 = fun (_0) -> case _0 of <{'special',Line,String}> when 'true' -> {'string',Line,String}
<Tuple> when call 'erlang':'is_tuple' (_0) -> let <_1> = call 'erlang':'tuple_to_list' (Tuple) in let <_2> = apply 'abstract_code'/1 (_1) in call 'erlang':'list_to_tuple' (_2)
<[H|T]> when 'true' -> let <_3> = apply 'abstract_code'/1 (H) in let <_4> = apply 'abstract_code'/1 (T) in [_3|_4]
<Term> when 'true' -> Term end
'abstract'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Info,_X_Flat = 'false',NElements,Depth> when 'true' -> apply 'abstract'/3 (Info,NElements,Depth)
<Info,_X_Flat = 'true',NElements,Depth> when 'true' -> let <Abstract> = apply 'abstract'/3 (Info,NElements,Depth) in let <Vars> = apply 'abstract_vars'/1 (Abstract) in case apply 'flatten_abstr'/4 (Abstract,1,Vars,[]) of <{_16,Body0,Expr}> when 'true' -> case Body0 of <[]> when 'true' -> Expr
<[{'match',_17,_18,Q}|[]]> when call 'erlang':'=:=' (_18,Expr) -> Q
<[{'match',_19,_20,Q}|Body]> when call 'erlang':'=:=' (_20,Expr) -> let <_8> = apply 'anno0'/0 () in let <_7> = call 'lists':'reverse' (Body,[Q|[]]) in {'block',_8,_7}
<_21> when 'true' -> let <_10> = apply 'anno0'/0 () in let <_9> = call 'lists':'reverse' (Body0,[Expr|[]]) in {'block',_10,_9} end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_15,_14,_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12})-|[{'function_name',{'abstract',4}}] )-|['compiler_generated'] ) end
'abstract'/3 = fun (_0,_1,_2) -> let <_3> = apply 'anno1'/0 () in apply 'abstract1'/4 (_0,_1,_2,_3)
'abstract1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <{'qlc',E0,Qs0,Opt},NElements,Depth,A> when 'true' -> let <_8> = fun (_6) -> case _6 of <{'generate',P,LE}> when 'true' -> let <_5> = call 'erlang':'binary_to_term' (P) in let <_4> = apply 'abstract1'/4 (LE,NElements,Depth,A) in {'generate',A,_5,_4}
<F> when 'true' -> call 'erlang':'binary_to_term' (F) end in let <Qs> = call 'lists':'map' (_8,Qs0) in let <E> = call 'erlang':'binary_to_term' (E0) in let <_13> = case Opt of <[]> when 'true' -> []
<_58> when 'true' -> let <_11> = apply 'abstract_term'/2 (Opt,1) in [_11|[]] end in {'call',A,{'remote',A,{'atom',A,'qlc'},{'atom',A,'q'}},[{'lc',A,E,Qs}|_13]}
<{'table',{M,F,As0}},_X_NElements,_X_Depth,Anno> when try let <_15> = call 'erlang':'is_atom' (M) in let <_16> = call 'erlang':'is_atom' (F) in let <_17> = call 'erlang':'is_list' (As0) in let <_18> = call 'erlang':'and' (_16,_17) in call 'erlang':'and' (_15,_18) of <Try> -> Try catch <T,R> -> 'false' -> let <_24> = letrec 'lc$^1'/1 = fun (_21) -> case _21 of <[A|_20]> when 'true' -> let <_22> = apply 'abstract_term'/2 (A,1) in let <_23> = apply 'lc$^1'/1 (_20) in ([_22|_23]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_60> when 'true' -> (primop 'match_fail' ({'function_clause',_60})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (As0) in {'call',Anno,{'remote',Anno,{'atom',Anno,M},{'atom',Anno,F}},_24}
<{'table',TableDesc},_X_NElements,_X_Depth,_X_A> when 'true' -> case call 'io_lib':'deep_char_list' (TableDesc) of <'true'> when 'true' -> let <_26> = call 'erlang':'++' (TableDesc,[46]) in let <_27> = call 'lists':'flatten' (_26) in case call 'erl_scan':'string' (_27,1,['text']) of <{'ok',Tokens,_59}> when 'true' -> case call 'erl_eval':'extended_parse_exprs' (Tokens) of <{'ok',Es,Bs}> when 'true' -> case call 'erl_eval':'subst_values_for_vars' (Es,Bs) of <[Expr|[]]> when 'true' -> apply 'special'/1 (Expr)
(<_30> when 'true' -> primop 'match_fail' ({'badmatch',_30})-|['compiler_generated'] ) end
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end
(<_28> when 'true' -> primop 'match_fail' ({'badmatch',_28})-|['compiler_generated'] ) end
<'false'> when 'true' -> TableDesc
(<_31> when 'true' -> primop 'match_fail' ({'case_clause',_31})-|['compiler_generated'] ) end
<{'append',Infos},NElements,Depth,A> when 'true' -> let <_37> = fun (_34,_33) -> let <_32> = apply 'abstract1'/4 (_34,NElements,Depth,A) in {'cons',A,_32,_33} in let <As> = call 'lists':'foldr' (_37,{'nil',A},Infos) in {'call',A,{'remote',A,{'atom',A,'qlc'},{'atom',A,'append'}},[As|[]]}
<{'sort',Info,SortOptions},NElements,Depth,A> when 'true' -> let <_39> = apply 'abstract1'/4 (Info,NElements,Depth,A) in let <_40> = apply 'abstract_term'/2 (SortOptions,1) in {'call',A,{'remote',A,{'atom',A,'qlc'},{'atom',A,'sort'}},[_39|[_40|[]]]}
<{'keysort',Info,Kp,SortOptions},NElements,Depth,A> when 'true' -> let <_41> = apply 'abstract_term'/2 (Kp,1) in let <_42> = apply 'abstract1'/4 (Info,NElements,Depth,A) in let <_43> = apply 'abstract_term'/2 (SortOptions,1) in {'call',A,{'remote',A,{'atom',A,'qlc'},{'atom',A,'keysort'}},[_41|[_42|[_43|[]]]]}
<{'list',L,MS},NElements,Depth,A> when 'true' -> let <_44> = apply 'abstract1'/4 (L,NElements,Depth,A) in let <_45> = apply 'depth'/2 (MS,Depth) in let <_46> = apply 'abstract_term'/2 (_45,1) in {'call',A,{'remote',A,{'atom',A,'ets'},{'atom',A,'match_spec_run'}},[_44|[{'call',A,{'remote',A,{'atom',A,'ets'},{'atom',A,'match_spec_compile'}},[_46|[]]}|[]]]}
<{'list',L},NElements,Depth,_X_A> when let <_47> = call 'erlang':'=:=' (NElements,'infinity') in let <_49> = try let <_48> = call 'erlang':'length' (L) in call 'erlang':'>=' (NElements,_48) of <Try> -> Try catch <T,R> -> 'false' in call 'erlang':'or' (_47,_49) -> let <_50> = apply 'depth'/2 (L,Depth) in apply 'abstract_term'/2 (_50,1)
<{'list',L},NElements,Depth,_X_A> when 'true' -> let <_51> = call 'lists':'sublist' (L,NElements) in let <_52> = apply 'depth'/2 (_51,Depth) in let <_53> = call 'erlang':'++' (_52,'...') in apply 'abstract_term'/2 (_53,1)
(<_57,_56,_55,_54> when 'true' -> (primop 'match_fail' ({'function_clause',_57,_56,_55,_54})-|[{'function_name',{'abstract1',4}}] )-|['compiler_generated'] ) end
'special'/1 = fun (_0) -> case _0 of <{'value',_6,Thing}> when 'true' -> apply 'abstract_term'/1 (Thing)
<Tuple> when call 'erlang':'is_tuple' (_0) -> let <_1> = call 'erlang':'tuple_to_list' (Tuple) in let <_2> = apply 'special'/1 (_1) in call 'erlang':'list_to_tuple' (_2)
<[E|Es]> when 'true' -> let <_3> = apply 'special'/1 (E) in let <_4> = apply 'special'/1 (Es) in [_3|_4]
<Expr> when 'true' -> Expr end
'depth'/2 = fun (_0,_1) -> case <_0,_1> of <List,'infinity'> when 'true' -> List
<List,Depth> when 'true' -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[E|_3]> when 'true' -> let <_5> = apply 'depth1'/2 (E,Depth) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (List)-|['list_comprehension'] ) end
'depth_fun'/1 = fun (_0) -> case _0 of <_X_Depth = 'infinity'> when 'true' -> (fun (_1) -> _1-|[{'id',{0,0,'-depth_fun/1-fun-0-'}}] )
<Depth> when 'true' -> (fun (_3) -> apply 'depth1'/2 (_3,Depth)-|[{'id',{0,0,'-depth_fun/1-fun-1-'}}] ) end
'depth1'/2 = fun (_0,_1) -> case <_0,_1> of <L = [],_X_D> when 'true' -> L
<_X_Term,0> when 'true' -> '...'
<Tuple,D> when call 'erlang':'is_tuple' (Tuple) -> let <_3> = call 'erlang':'tuple_size' (Tuple) in let <_2> = call 'erlang':'-' (D,1) in apply 'depth_tuple'/5 (Tuple,_3,1,_2,[])
<List,D> when call 'erlang':'is_list' (List) -> case <> of <> when call 'erlang':'=:=' (D,1) -> ['...']
<> when 'true' -> let <_4> = call 'erlang':'-' (D,1) in apply 'depth_list'/2 (List,_4) end
<Binary,D> when try let <_6> = call 'erlang':'byte_size' (Binary) in let <_5> = call 'erlang':'-' (D,1) in call 'erlang':'>' (_6,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <D1> = call 'erlang':'-' (D,1) in case Binary of <#{#<Bin>(D1,8,'binary',['unsigned'|['big']]),#<_11>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> #{#<Bin>('all',8,'binary',['unsigned'|['big']]),#<3026478>(24,1,'integer',['unsigned'|['big']])}#
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<T,_X_Depth> when 'true' -> T end
'depth_list'/2 = fun (_0,_1) -> case <_0,_1> of <L = [],_X_D> when 'true' -> L
<_X_L,0> when 'true' -> '...'
<[E|Es],D> when 'true' -> let <_2> = apply 'depth1'/2 (E,D) in let <_3> = call 'erlang':'-' (D,1) in let <_4> = apply 'depth_list'/2 (Es,_3) in [_2|_4]
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'depth_list',2}}] )-|['compiler_generated'] ) end
'depth_tuple'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_X_Tuple,Sz,I,_X_D,L> when call 'erlang':'>' (I,Sz) -> let <_5> = call 'lists':'reverse' (L) in call 'erlang':'list_to_tuple' (_5)
<_X_L,_X_Sz,_X_I,0,L> when 'true' -> let <_6> = call 'lists':'reverse' (L,['...']) in call 'erlang':'list_to_tuple' (_6)
<Tuple,Sz,I,D,L> when 'true' -> let <_7> = call 'erlang':'element' (I,Tuple) in let <E> = apply 'depth1'/2 (_7,D) in let <_10> = call 'erlang':'+' (I,1) in let <_9> = call 'erlang':'-' (D,1) in apply 'depth_tuple'/5 (Tuple,Sz,_10,_9,[E|L]) end
'abstract_term'/1 = fun (_0) -> apply 'abstract_term'/2 (_0,0)
'abstract_term'/2 = fun (_0,_1) -> let <_2> = apply 'anno'/1 (_1) in apply 'abstr_term'/2 (_0,_2)
'abstr_term'/2 = fun (_0,_1) -> case <_0,_1> of <Tuple,Line> when call 'erlang':'is_tuple' (Tuple) -> let <_8> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[E|_3]> when 'true' -> let <_6> = apply 'abstr_term'/2 (E,Line) in let <_7> = apply 'lc$^0'/1 (_3) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_35> when 'true' -> (primop 'match_fail' ({'function_clause',_35})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_4> = call 'erlang':'tuple_to_list' (Tuple) in apply 'lc$^0'/1 (_4) in {'tuple',Line,_8}
<L = [_33|_34],Line> when 'true' -> case call 'io_lib':'char_list' (L) of <'true'> when 'true' -> let <_9> = call 'erl_anno':'line' (Line) in call 'erl_parse':'abstract' (L,_9)
<'false'> when 'true' -> apply 'abstr_list'/2 (L,Line)
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<Fun,Line> when call 'erlang':'is_function' (Fun) -> case call 'erl_eval':'fun_data' (Fun) of <{'fun_data',_X_Bs,Cs}> when 'true' -> {'fun',Line,{'clauses',Cs}}
<{'named_fun_data',_X_Bs,Name,Cs}> when 'true' -> {'named_fun',Line,Name,Cs}
<'false'> when 'true' -> case call 'erlang':'fun_info' (Fun,'name') of <{'name',Name}> when 'true' -> case call 'erlang':'fun_info' (Fun,'arity') of <{'arity',Arity}> when 'true' -> case call 'erlang':'fun_info' (Fun,'type') of <{'type','external'}> when 'true' -> case call 'erlang':'fun_info' (Fun,'module') of <{'module',Module}> when 'true' -> {'fun',Line,{'function',{'atom',Line,Module},{'atom',Line,Name},{'integer',Line,Arity}}}
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<{'type','local'}> when 'true' -> {'fun',Line,{'function',Name,Arity}}
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
<PPR,Line> when let <_16> = call 'erlang':'is_pid' (PPR) in let <_17> = call 'erlang':'is_port' (PPR) in let <_18> = call 'erlang':'is_reference' (PPR) in let <_19> = call 'erlang':'or' (_17,_18) in call 'erlang':'or' (_16,_19) -> let <_20> = call 'io_lib':'write' (PPR) in let <_21> = call 'lists':'flatten' (_20) in {'special',Line,_21}
<Map,Line> when call 'erlang':'is_map' (Map) -> let <_29> = letrec 'lc$^1'/1 = fun (_25) -> case _25 of <[{K,V}|_23]> when 'true' -> let <_27> = apply 'abstr_term'/2 (K,Line) in let <_26> = apply 'abstr_term'/2 (V,Line) in let <_28> = apply 'lc$^1'/1 (_23) in ([{'map_field_assoc',Line,_27,_26}|_28]-|['compiler_generated'] )
(<[_22|_23]> when 'true' -> apply 'lc$^1'/1 (_23)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_36> when 'true' -> (primop 'match_fail' ({'function_clause',_36})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_24> = call 'maps':'to_list' (Map) in apply 'lc$^1'/1 (_24) in {'map',Line,_29}
<Simple,Line> when 'true' -> let <_30> = call 'erl_anno':'line' (Line) in call 'erl_parse':'abstract' (Simple,_30) end
'abstr_list'/2 = fun (_0,_1) -> case <_0,_1> of <[H|T],Line> when 'true' -> let <_3> = apply 'abstr_term'/2 (H,Line) in let <_2> = apply 'abstr_list'/2 (T,Line) in {'cons',Line,_3,_2}
<T,Line> when 'true' -> apply 'abstr_term'/2 (T,Line) end
'flatten_abstr'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <{'call',L1,_@r0 = {'remote',L2,{'atom',L3,'qlc'},{'atom',L4,'q'}},[LC0|Os]},VN0,Vars,Body0> when 'true' -> case LC0 of <{'lc',L,E,Qs0}> when 'true' -> let <F> = fun (_7,_6) -> case <_7,_6> of <{'generate',Ln,P,LE0},{VN1,Body1}> when 'true' -> case apply 'flatten_abstr'/4 (LE0,VN1,Vars,Body1) of <{VN2,Body2,LE}> when 'true' -> {{'generate',Ln,P,LE},{VN2,Body2}}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<Fil,VN_Body> when 'true' -> {Fil,VN_Body} end in case call 'lists':'mapfoldl' (F,{VN0,Body0},Qs0) of <{Qs,{VN3,Body}}> when 'true' -> let <LC> = {'lc',L,E,Qs} in case apply 'aux_name1'/3 ('V',VN3,Vars) of <{V,VN}> when 'true' -> let <Var> = {'var',L1,V} in let <QLC> = {'call',L1,_@r0,[LC|Os]} in let <_16> = call 'erlang':'+' (VN,1) in {_16,[{'match',L1,Var,QLC}|Body],Var}
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<T0,VN0,Vars,Body0> when call 'erlang':'is_tuple' (T0) -> let <_17> = call 'erlang':'tuple_to_list' (T0) in case apply 'flatten_abstr'/4 (_17,VN0,Vars,Body0) of <{VN,Body,L}> when 'true' -> let <_19> = call 'erlang':'list_to_tuple' (L) in {VN,Body,_19}
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
<[E0|Es0],VN0,Vars,Body0> when 'true' -> case apply 'flatten_abstr'/4 (E0,VN0,Vars,Body0) of <{VN1,Body1,E}> when 'true' -> case apply 'flatten_abstr'/4 (Es0,VN1,Vars,Body1) of <{VN,Body,Es}> when 'true' -> {VN,Body,[E|Es]}
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
<E,VN,_X_Vars,Body> when 'true' -> {VN,Body,E} end
'abstract_vars'/1 = fun (_0) -> let <_1> = apply 'vars'/1 (_0) in let <_2> = call 'ordsets':'to_list' (_1) in call 'gb_sets':'from_list' (_2)
'collect'/1 = fun (_0) -> case _0 of <L = []> when 'true' -> L
<[Answer|Cont]> when 'true' -> let <_1> = apply 'collect'/1 (Cont) in [Answer|_1]
<Cont> when 'true' -> case apply Cont () of <Answers> when call 'erlang':'is_list' (Answers) -> apply 'collect'/1 (Answers)
<Term> when 'true' -> apply 'throw_error'/1 (Term) end end
'fold_loop'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Fun,[Obj|Cont],Acc> when 'true' -> let <_3> = apply Fun (Obj,Acc) in apply 'fold_loop'/3 (Fun,Cont,_3)
<_X_Fun,[],Acc> when 'true' -> Acc
<Fun,Cont,Acc> when 'true' -> case apply Cont () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'fold_loop'/3 (Fun,Objects,Acc)
<Term> when 'true' -> Term end end
'next_loop'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Pid,L,N> when call 'erlang':'=/=' (N,0) -> case apply 'monitor_request'/2 (Pid,'more') of <'no_more'> when 'true' -> call 'lists':'reverse' (L)
<{'answer',Answer}> when 'true' -> let <_3> = call 'erlang':'-' (N,1) in apply 'next_loop'/3 (Pid,[Answer|L],_3)
<{'caught','throw',Error,[{'qlc','throw_error',_11,_12}|_13]}> when 'true' -> Error
<{'caught',Class,Reason,Stacktrace}> when 'true' -> let <_4> = call 'erlang':'self' () in case call 'erlang':'process_info' (_4,'current_stacktrace') of <{'current_stacktrace',CurrentStacktrace}> when 'true' -> let <_6> = call 'erlang':'++' (Stacktrace,CurrentStacktrace) in call 'erlang':'raise' (Class,Reason,_6)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<'error'> when 'true' -> call 'erlang':'error' ({'qlc_cursor_pid_no_longer_exists',Pid})
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<_X_Pid,L,_X_N> when 'true' -> call 'lists':'reverse' (L) end
'stop_cursor'/1 = fun (_0) -> do call 'erlang':'monitor' ('process',_0) do call 'erlang':'unlink' (_0) receive <{'EXIT',_3,_X_Reason}> when call 'erlang':'=:=' (_3,_0) -> receive <{'DOWN',_4,'process',_5,_6}> when call 'erlang':'=:=' (_5,_0) -> 'ok' after 'infinity' -> 'true' after 0 -> let <_1> = call 'erlang':'self' () in do call 'erlang':'!' (_0,{_1,'stop'}) receive <{'DOWN',_7,'process',_8,_9}> when call 'erlang':'=:=' (_8,_0) -> 'ok' after 'infinity' -> 'true'
'monitor_request'/2 = fun (_0,_1) -> let <Ref> = call 'erlang':'monitor' ('process',_0) in let <_3> = call 'erlang':'self' () in do call 'erlang':'!' (_0,{_3,_1}) receive <{'DOWN',_6,'process',_7,_X_Info}> when let <_8> = call 'erlang':'=:=' (_6,Ref) in let <_9> = call 'erlang':'=:=' (_7,_0) in call 'erlang':'and' (_8,_9) -> do receive <{'EXIT',_10,_X_Reason}> when call 'erlang':'=:=' (_10,_0) -> 'ok' after 1 -> 'ok' 'error'
<{'EXIT',_11,_X_Reason}> when call 'erlang':'=:=' (_11,_0) -> receive <{'DOWN',_12,'process',_13,_14}> when call 'erlang':'=:=' (_13,_0) -> 'error' after 'infinity' -> 'true'
<{_15,Reply}> when call 'erlang':'=:=' (_15,_0) -> do call 'erlang':'demonitor' (Ref,['flush']) Reply after 'infinity' -> 'true'
'le_info'/2 = fun (_0,_1) -> case <_0,_1> of <{'prepared',{'simple_qlc',P,LE,L,_54,Optz},_55,_56,_57,_58,_59,_60,_61,_62},InfOpt> when 'true' -> let <QVar> = call 'erlang':'term_to_binary' ({'var',L,P}) in let <_4> = apply 'le_info'/2 (LE,InfOpt) in let <_3> = apply 'opt_info'/1 (Optz) in {'qlc',QVar,[{'generate',QVar,_4}|[]],_3}
<{'prepared',{'qlc',_63,CodeF,Qdata,_64,Optz},_65,_66,_67,_68,_69,_70,_71,_72},InfOpt> when 'true' -> let <Code> = apply CodeF () in let <TemplateState> = apply 'template_state'/0 () in let <E> = call 'erlang':'element' (TemplateState,Code) in let <QualInfo0> = apply 'qual_info'/3 (Qdata,Code,InfOpt) in (case Optz of (<({'optz',_73,_74,_75,_rec4,_76}-|['compiler_generated'] )> when 'true' -> let <_12> = case _rec4 of <Join = {'qlc_join',_78,_79,_80,_81,_82,_83,_84,_85}> when 'true' -> apply 'join_info'/4 (Join,QualInfo0,Qdata,Code)
<'no'> when 'true' -> QualInfo0
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end in let <_18> = letrec 'lc$^0'/1 = fun (_16) -> case _16 of <[I|_15]> when call 'erlang':'=/=' (I,'skip') -> let <_17> = apply 'lc$^0'/1 (_15) in ([I|_17]-|['compiler_generated'] )
(<[I|_15]> when 'true' -> apply 'lc$^0'/1 (_15)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_166> when 'true' -> (primop 'match_fail' ({'function_clause',_166})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_12) in let <_20> = apply 'opt_info'/1 (Optz) in {'qlc',E,_18,_20}-|['compiler_generated'] )
(<_77> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<{'prepared',{'qlc_table',_86,TravMS,_87,_88,_89,FormatFun,_90,_91,_92,LuVals,MS},_93,_94,_95,_96,_97,_98,_99,_100},InfOpt> when 'true' -> case InfOpt of <{NElements,Depth}> when 'true' -> let <DepthFun> = apply 'depth_fun'/1 (Depth) in case LuVals of <_101> when call 'erlang':'=:=' (FormatFun,'undefined') -> {'table',{'$MOD','$FUN',[]}}
<{Pos,Vals}> when 'true' -> let <_27> = try apply FormatFun ({'lookup',Pos,Vals,NElements,DepthFun}) of <_23> -> _23 catch <_26,_25,_24> -> apply FormatFun ({'lookup',Pos,Vals}) in case <> of <> when call 'erlang':'=:=' (MS,'no_match_spec') -> {'table',_27}
<> when 'true' -> let <_29> = apply 'depth'/2 (MS,Depth) in {'list',{'table',_27},_29} end
<_105> when let <_30> = call 'erlang':'=:=' (TravMS,'true') in let <_31> = call 'erlang':'is_list' (MS) in call 'erlang':'and' (_30,_31) -> let <_32> = apply 'depth'/2 (MS,Depth) in let <_33> = apply FormatFun ({'match_spec',_32}) in {'table',_33}
<_106> when call 'erlang':'=:=' (MS,'no_match_spec') -> try let <_34> = apply FormatFun ({'all',NElements,DepthFun}) in {'table',_34} of <_35> -> _35 catch <_38,_37,_36> -> let <_39> = apply FormatFun ('all') in {'table',_39}
(<_40> when 'true' -> primop 'match_fail' ({'case_clause',_40})-|['compiler_generated'] ) end
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
<{'prepared',{'qlc_append',HL},_110,_111,_112,_113,_114,_115,_116,_117},InfOpt> when 'true' -> let <_46> = letrec 'lc$^1'/1 = fun (_43) -> case _43 of <[H|_42]> when 'true' -> let <_44> = apply 'le_info'/2 (H,InfOpt) in let <_45> = apply 'lc$^1'/1 (_42) in ([_44|_45]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_173> when 'true' -> (primop 'match_fail' ({'function_clause',_173})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (HL) in {'append',_46}
<{'prepared',{'qlc_sort',H,'sort',_118,_119,_120,SortOptions0,_121,TmpDir},_122,_123,_124,_125,_126,_127,_128,_129},InfOpt> when 'true' -> let <SortOptions> = apply 'sort_options_global_tmp'/2 (SortOptions0,TmpDir) in let <_48> = apply 'le_info'/2 (H,InfOpt) in {'sort',_48,SortOptions}
<{'prepared',{'qlc_sort',H,{'keysort',Kp},_130,_131,_132,SortOptions0,_133,TmpDir},_134,_135,_136,_137,_138,_139,_140,_141},InfOpt> when 'true' -> let <SortOptions> = apply 'sort_options_global_tmp'/2 (SortOptions0,TmpDir) in let <_50> = apply 'le_info'/2 (H,InfOpt) in {'keysort',_50,Kp,SortOptions}
<{'prepared',{'qlc_list',L,'no_match_spec'},_142,_143,_144,_145,_146,_147,_148,_149},_X_InfOpt> when 'true' -> {'list',L}
<{'prepared',{'qlc_list',L,MS},_150,_151,_152,_153,_154,_155,_156,_157},_X_InfOpt> when call 'erlang':'is_list' (L) -> {'list',{'list',L},MS}
<{'prepared',{'qlc_list',L,MS},_158,_159,_160,_161,_162,_163,_164,_165},InfOpt> when 'true' -> let <_51> = apply 'le_info'/2 (L,InfOpt) in {'list',_51,MS}
(<_53,_52> when 'true' -> (primop 'match_fail' ({'function_clause',_53,_52})-|[{'function_name',{'le_info',2}}] )-|['compiler_generated'] ) end
'qual_info'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{_X_QNum,_X_GoI,-1,'fil'}|Qdata],Code,InfOpt> when 'true' -> let <_3> = apply 'qual_info'/3 (Qdata,Code,InfOpt) in ['skip'|_3]
<[{QNum,_X_GoI,_X_SI,'fil'}|Qdata],Code,InfOpt> when 'true' -> let <_4> = call 'erlang':'+' (QNum,1) in let <_5> = call 'erlang':'element' (_4,Code) in let <_6> = apply 'qual_info'/3 (Qdata,Code,InfOpt) in [_5|_6]
<[{_X_QNum,_X_GoI,_X_SI,{'gen',{'join',_15,_16,_17,_18,_19,_20}}}|Qdata],Code,InfOpt> when 'true' -> let <_7> = apply 'qual_info'/3 (Qdata,Code,InfOpt) in ['skip'|_7]
<[{QNum,_X_GoI,_X_SI,{'gen',LE}}|Qdata],Code,InfOpt> when 'true' -> let <_9> = call 'erlang':'+' (QNum,1) in let <_10> = call 'erlang':'element' (_9,Code) in let <_8> = apply 'le_info'/2 (LE,InfOpt) in let <_11> = apply 'qual_info'/3 (Qdata,Code,InfOpt) in [{'generate',_10,_8}|_11]
<[],_X_Code,_X_InfOpt> when 'true' -> []
(<_14,_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12})-|[{'function_name',{'qual_info',3}}] )-|['compiler_generated'] ) end
'join_info'/4 = fun (_0,_1,_2,_3) -> case _0 of <{'qlc_join',Kind,Opt,_57,QNum1a,C1,_58,QNum2a,C2}> when 'true' -> case apply 'find_join_data'/3 (_2,QNum1a,QNum2a) of <{{JQNum,_59,_60,_61},Rev,QNum1,QNum2,_X_WH1,_X_WH2,CsFun}> when 'true' -> case apply CsFun () of <{Cs1_0,Cs2_0,Compat}> when 'true' -> let <_22> = case Compat of <[]> when 'true' -> (letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[CVs|_8]> when 'true' -> let <_19> = letrec 'lc$^1'/1 = fun (_12) -> case _12 of <[{C,Vs}|_11]> when 'true' -> let <_17> = letrec 'lc$^2'/1 = fun (_15) -> case _15 of <[V|_14]> when 'true' -> let <_16> = apply 'lc$^2'/1 (_14) in ([{V,'=:='}|_16]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_67> when 'true' -> (primop 'match_fail' ({'function_clause',_67})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (Vs) in let <_18> = apply 'lc$^1'/1 (_11) in ([{C,_17}|_18]-|['compiler_generated'] )
(<[_10|_11]> when 'true' -> apply 'lc$^1'/1 (_11)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_68> when 'true' -> (primop 'match_fail' ({'function_clause',_68})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (CVs) in let <_20> = apply 'lc$^0'/1 (_8) in ([_19|_20]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_69> when 'true' -> (primop 'match_fail' ({'function_clause',_69})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([Cs1_0|[Cs2_0|[]]])-|['list_comprehension'] )
<_62> when 'true' -> [Cs1_0|[Cs2_0|[]]] end in case _22 of <[Cs1|[Cs2|[]]]> when 'true' -> let <L> = apply 'anno0'/0 () in let <G1_0> = {'var',L,'G1'} in let <G2_0> = {'var',L,'G2'} in let <_27> = call 'erlang':'+' (JQNum,1) in let <JP> = call 'erlang':'element' (_27,_3) in let <_70,_71,_72> = case Kind of <{'merge',_63}> when 'true' -> case apply 'join_merge_info'/5 (QNum1,_1,_3,G1_0,Cs1) of <{JG1,QInfo1}> when 'true' -> case apply 'join_merge_info'/5 (QNum2,_1,_3,G2_0,Cs2) of <{JG2,QInfo2}> when 'true' -> let <_31> = call 'erlang':'++' (QInfo1,QInfo2) in <JG1,JG2,_31>
(<_30> when 'true' -> primop 'match_fail' ({'badmatch',_30})-|['compiler_generated'] ) end
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end
<_64> when (call 'erlang':'=:=' (Rev,'true')-|['compiler_generated'] ) -> case apply 'join_merge_info'/5 (QNum2,_1,_3,G2_0,Cs2) of <{JG2,QInfo2}> when 'true' -> case apply 'join_lookup_info'/3 (QNum1,_1,G1_0) of <{J1,QInfo1}> when 'true' -> let <_34> = call 'erlang':'++' (QInfo2,[QInfo1|[]]) in <{J1,G1_0},JG2,_34>
(<_33> when 'true' -> primop 'match_fail' ({'badmatch',_33})-|['compiler_generated'] ) end
(<_32> when 'true' -> primop 'match_fail' ({'badmatch',_32})-|['compiler_generated'] ) end
<_65> when 'true' -> case apply 'join_merge_info'/5 (QNum1,_1,_3,G1_0,Cs1) of <{JG1,QInfo1}> when 'true' -> case apply 'join_lookup_info'/3 (QNum2,_1,G2_0) of <{J2,QInfo2}> when 'true' -> let <_37> = call 'erlang':'++' (QInfo1,[QInfo2|[]]) in <JG1,{J2,G2_0},_37>
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end
(<_35> when 'true' -> primop 'match_fail' ({'badmatch',_35})-|['compiler_generated'] ) end end in case (<(_70-|['compiler_generated'] ),(_71-|['compiler_generated'] ),(_72-|['compiler_generated'] )>-|['compiler_generated'] ) of <({I1,G1}-|['compiler_generated'] ),({I2,G2}-|['compiler_generated'] ),QInfoL> when 'true' -> case apply 'kind2op'/1 (Kind) of <{JOptVal,JOp}> when 'true' -> let <_42> = apply 'join_unique_cache'/1 (Opt) in let <_43> = apply 'opt_info'/1 (_42) in let <JOpt> = [{'join',JOptVal}|_43] in let <JFil> = call 'erlang':'term_to_binary' ({'op',L,JOp,{'call',L,{'atom',L,'element'},[{'integer',L,C1}|[G1|[]]]},{'call',L,{'atom',L,'element'},[{'integer',L,C2}|[G2|[]]]}}) in let <P> = call 'erlang':'term_to_binary' ({'cons',L,G1,G2}) in let <_47> = call 'erlang':'++' (QInfoL,[JFil|[]]) in let <JInfo> = {'generate',JP,{'qlc',P,_47,JOpt}} in let <_49> = call 'erlang':'-' (QNum1,1) in case call 'lists':'split' (_49,_1) of <{Before,[_66|After]}> when call 'erlang':'=:=' (_66,I1) -> let <_51> = call 'lists':'delete' (I2,After) in let <_52> = [JInfo|_51] in call 'erlang':'++' (Before,_52)
(<_50> when 'true' -> primop 'match_fail' ({'badmatch',_50})-|['compiler_generated'] ) end
(<_41> when 'true' -> primop 'match_fail' ({'badmatch',_41})-|['compiler_generated'] ) end
(<(_73-|['compiler_generated'] ),(_74-|['compiler_generated'] ),(_75-|['compiler_generated'] )> when 'true' -> let <_40> = {(_73-|['compiler_generated'] ),(_74-|['compiler_generated'] ),(_75-|['compiler_generated'] )} in primop 'match_fail' ({'badmatch',_40})-|['compiler_generated'] ) end
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'kind2op'/1 = fun (_0) -> case _0 of <{'merge',_X_KE}> when 'true' -> {'merge','=='}
<{'lookup',KE,_X_LU_fun}> when 'true' -> {'lookup',KE}
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'kind2op',1}}] )-|['compiler_generated'] ) end
'join_merge_info'/5 = fun (_0,_1,_2,_3,_4) -> case call 'lists':'nth' (_0,_1) of <I = {'generate',_44,LEInfo}> when 'true' -> let <_6> = call 'erlang':'+' (_0,1) in let <_7> = call 'erlang':'element' (_6,_2) in let <P> = call 'erlang':'binary_to_term' (_7) in case <P,_4> of <({('var'-|['compiler_generated'] ),_45,_46}-|['compiler_generated'] ),([]-|['compiler_generated'] )> when 'true' -> let <TP> = call 'erlang':'term_to_binary' (_3) in let <I2> = {'generate',TP,LEInfo} in {{I,_3},[I2|[]]}
<(_52-|['compiler_generated'] ),(_53-|['compiler_generated'] )> when 'true' -> let <_56,_57> = case P of <{'var',_48,_49}> when 'true' -> <P,P>
<_50> when 'true' -> let <_11> = apply 'abstract_vars'/1 (P) in case apply 'aux_name1'/3 ('P',0,_11) of <{PV,_51}> when 'true' -> let <L> = call 'erl_anno':'new' (0) in let <V> = {'var',L,PV} in <V,{'match',L,V,P}>
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end end in let <DQP> = call 'erlang':'term_to_binary' ((_56-|['compiler_generated'] )) in let <_19> = call 'erlang':'term_to_binary' ((_57-|['compiler_generated'] )) in let <LEI> = {'generate',_19,LEInfo} in let <TP> = call 'erlang':'term_to_binary' (_3) in let <_36> = letrec 'lc$^0'/1 = fun (_24) -> case _24 of <[{Col,ConstOps}|_23]> when 'true' -> let <A> = apply 'anno0'/0 () in let <Call> = {'call',A,{'atom',A,'element'},[{'integer',A,Col}|[(_56-|['compiler_generated'] )|[]]]} in let <_32> = letrec 'lc$^1'/1 = fun (_29) -> case _29 of <[{Con,Op}|_28]> when 'true' -> let <_30> = apply 'abstract_term'/1 (Con) in let <_31> = apply 'lc$^1'/1 (_28) in ([{'op',A,Op,_30,Call}|_31]-|['compiler_generated'] )
(<[_27|_28]> when 'true' -> apply 'lc$^1'/1 (_28)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_60> when 'true' -> (primop 'match_fail' ({'function_clause',_60})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (ConstOps) in let <F> = apply 'list2op'/3 (_32,'or',A) in let <_34> = call 'erlang':'term_to_binary' (F) in let <_35> = apply 'lc$^0'/1 (_23) in ([_34|_35]-|['compiler_generated'] )
(<[_22|_23]> when 'true' -> apply 'lc$^0'/1 (_23)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_61> when 'true' -> (primop 'match_fail' ({'function_clause',_61})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_4) in {{I,_3},[{'generate',TP,{'qlc',DQP,[LEI|_36],[]}}|[]]} end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'list2op'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|[]],_X_Op,_X_Anno> when 'true' -> E
<[E|Es],Op,Anno> when 'true' -> let <_3> = apply 'list2op'/3 (Es,Op,Anno) in {'op',Anno,Op,E,_3}
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'list2op',3}}] )-|['compiler_generated'] ) end
'join_lookup_info'/3 = fun (_0,_1,_2) -> case call 'lists':'nth' (_0,_1) of <I = {'generate',_8,LEInfo}> when 'true' -> let <TP> = call 'erlang':'term_to_binary' (_2) in {I,{'generate',TP,LEInfo}}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'opt_info'/1 = fun (_0) -> case _0 of <{'optz',Unique,Cache0,JoinOption,_15,_16}> when 'true' -> let <_1> = case <> of <> when (call 'erlang':'=:=' (Cache0,'true')-|['compiler_generated'] ) -> 'ets'
<> when 'true' -> Cache0 end in let <_7> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[_@r0 = {T,V}|_4]> when call 'erlang':'=:=' (V,'nested_loop') -> let <_6> = apply 'lc$^0'/1 (_4) in ([_@r0|_6]-|['compiler_generated'] )
(<[_3|_4]> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([{'join',JoinOption}|[]]) in (letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[_@r1 = {T,V}|_9]> when 'true' -> let <_10> = apply 'default_option'/1 (T) in (case <> of <> when call 'erlang':'=/=' (V,_10) -> let <_12> = apply 'lc$^1'/1 (_9) in ([_@r1|_12]-|['compiler_generated'] )
(<> when 'true' -> apply 'lc$^1'/1 (_9)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_8|_9]> when 'true' -> apply 'lc$^1'/1 (_9)-|['compiler_generated'] )
<[]> when 'true' -> _7
(<_18> when 'true' -> (primop 'match_fail' ({'function_clause',_18})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 ([{'cache',_1}|[{'unique',Unique}|[]]])-|['list_comprehension'] )
(<_14> when 'true' -> (primop 'match_fail' ({'function_clause',_14})-|[{'function_name',{'opt_info',1}}] )-|['compiler_generated'] ) end
'prepare_qlc'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <GOpt> = {'qlc_opt',_2,_3,-1,'any',_4,'any',_5,_6} in let <_9> = apply 'prep_le'/2 (_0,GOpt) in case apply 'opt_le'/2 (_9,1) of <Prep = {'prepared',QLC = {'qlc',_30,_31,_32,_33,_34},_35,_36,_37,_38,_39,_40,_41,_42}> when 'true' -> case QLC of <{'qlc',_43,_44,_45,_46,_47}> when 'true' -> let <_12> = call 'erlang':'setelement' (5,QLC,_1) in case Prep of <{'prepared',_49,_50,_51,_52,_53,_54,_55,_56,_57}> when 'true' -> call 'erlang':'setelement' (2,Prep,_12)
(<_58> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_48> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<Prep = {'prepared',SimpleQLC = {'simple_qlc',_59,_60,_61,_62,_63},_64,_65,_66,_67,_68,_69,_70,_71}> when 'true' -> case SimpleQLC of <{'simple_qlc',_72,_73,_74,_75,_76}> when 'true' -> let <_18> = call 'erlang':'setelement' (5,SimpleQLC,_1) in case Prep of <{'prepared',_78,_79,_80,_81,_82,_83,_84,_85,_86}> when 'true' -> call 'erlang':'setelement' (2,Prep,_18)
(<_87> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_77> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','simple_qlc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<Prep> when 'true' -> Prep end
'prep_le'/2 = fun (_0,_1) -> case <_0,_1> of <H = {'qlc_lc',LC_fun,Opt0 = {'qlc_opt',_83,_84,_85,_86,_87,_88,_89,_90}},GOpt> when 'true' -> case GOpt of <{'qlc_opt',GUnique,GCache,_91,_92,TmpDir,_93,MaxList,TmpUsage}> when 'true' -> (case Opt0 of (<({'qlc_opt',_rec11,_94,_95,_96,_97,_98,_99,_100}-|['compiler_generated'] )> when 'true' -> let <Unique> = call 'erlang':'or' (_rec11,GUnique) in let <_8> = case <> of <> when (call 'erlang':'=:=' (GCache,'false')-|['compiler_generated'] ) -> (case Opt0 of (<({'qlc_opt',_102,_rec12,_103,_104,_105,_106,_107,_108}-|['compiler_generated'] )> when 'true' -> _rec12-|['compiler_generated'] )
(<_109> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_opt'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<> when 'true' -> GCache end in case Opt0 of <{'qlc_opt',_rec14,_rec15,_rec16,_rec17,_rec18,_rec19,_rec20,_rec21}> when 'true' -> let <_12> = {'qlc_opt',Unique,_8,_rec16,_rec17,TmpDir,_rec19,MaxList,TmpUsage} in let <_14> = apply LC_fun () in apply 'prep_qlc_lc'/4 (_14,_12,GOpt,H)
(<_110> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_opt'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_101> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_opt'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<T = {'qlc_table',_111,_112,_113,_114,IF,_115,_116,_117,_118,_119,_120},GOpt> when 'true' -> case apply 'table_sort_info'/1 (T) of <{SortInfo,Sorted}> when 'true' -> let <IsUnique> = apply 'grd'/2 (IF,'is_unique_objects') in let <Prep> = {'prepared',T,Sorted,SortInfo,[],[],{[],[]},'undefined',IsUnique,'false'} in let <_43> = case <> of <> when try let <_18> = call 'erlang':'=:=' (IsUnique,'true') in (let <_21> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (GOpt,('qlc_opt'-|['compiler_generated'] ),(9-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_19-|['compiler_generated'] )> when 'true' -> (_19-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_22> = call 'erlang':'=:=' ((_21-|['compiler_generated'] ),'true') in let <_23> = call 'erlang':'element' (2,GOpt) in let <_24> = call 'erlang':'=:=' (_23,'true') in let <_25> = call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_22,_24) in let <_26> = call 'erlang':'not' (_25) in let <_27> = call 'erlang':'or' (_18,_26) in (let <_30> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (T,('qlc_table'-|['compiler_generated'] ),(12-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_28-|['compiler_generated'] )> when 'true' -> (_28-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_31> = call 'erlang':'=:=' ((_30-|['compiler_generated'] ),'true') in let <_32> = call 'erlang':'element' (12,T) in let <_33> = call 'erlang':'=:=' (_32,'no_match_spec') in let <_34> = call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_31,_33) in let <_35> = call 'erlang':'and' (_27,_34) in let <_36> = call 'erlang':'is_boolean' (_23) in let <_37> = call 'erlang':'and' (_35,_36) in let <_38> = call 'erlang':'is_boolean' (_21) in let <_39> = call 'erlang':'and' (_37,_38) in let <_40> = call 'erlang':'is_boolean' (IsUnique) in (call 'erlang':'and' (_39,_40)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> case GOpt of <{'qlc_opt',_121,_122,_123,_124,_125,_126,_127,_128}> when 'true' -> call 'erlang':'setelement' (3,GOpt,'false')
(<_129> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_opt'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<> when 'true' -> GOpt end in apply 'may_create_simple'/2 (_43,Prep)
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<{'qlc_append',HL},GOpt> when 'true' -> let <_53> = fun (_51) -> case _51 of <{'prepared',{'qlc_list',[],_130},_131,_132,_133,_134,_135,_136,_137,_138}> when 'true' -> []
<{'prepared',{'qlc_append',HL1},_139,_140,_141,_142,_143,_144,_145,_146}> when 'true' -> HL1
<H> when 'true' -> [H|[]] end in let <_50> = letrec 'lc$^0'/1 = fun (_47) -> case _47 of <[H|_46]> when 'true' -> let <_48> = apply 'prep_le'/2 (H,GOpt) in let <_49> = apply 'lc$^0'/1 (_46) in ([_48|_49]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_183> when 'true' -> (primop 'match_fail' ({'function_clause',_183})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (HL) in case call 'lists':'flatmap' (_53,_50) of <Nil = []> when 'true' -> apply 'short_list'/1 (Nil)
<[Prep|[]]> when 'true' -> Prep
<PrepL> when 'true' -> let <_56> = fun (_54) -> case _54 of <{'prepared',_147,_148,_149,_150,_151,_152,_153,_154,IsC}> when 'true' -> call 'erlang':'=/=' (IsC,'false')
(<_55> when 'true' -> (primop 'match_fail' ({'function_clause',_55})-|[{'function_name',{'-prep_le/2-fun-2-',1}}] )-|['compiler_generated'] ) end in let <Cache> = call 'lists':'all' (_56,PrepL) in let <Prep> = {'prepared',{'qlc_append',PrepL},'no',[],[],[],{[],[]},'undefined','false',Cache} in apply 'may_create_simple'/2 (GOpt,Prep) end
<Q0 = {'qlc_sort',H0,_155,_156,_157,_158,_159,_160,_161},GOpt> when 'true' -> let <_rec23> = apply 'prep_le'/2 (H0,GOpt) in case Q0 of <{'qlc_sort',_162,_163,_164,_165,_166,_167,_168,_169}> when 'true' -> let <_63> = call 'erlang':'setelement' (2,Q0,_rec23) in apply 'prep_sort'/2 (_63,GOpt)
(<_170> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_sort'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<L = [_171|[_172|_173]],GOpt> when 'true' -> let <Prep> = {'prepared',{'qlc_list',L,'no_match_spec'},'no',[],[],[],{[],[]},'undefined','false','true'} in let <_79> = case <> of <> when try (let <_68> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (GOpt,('qlc_opt'-|['compiler_generated'] ),(9-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_66-|['compiler_generated'] )> when 'true' -> (_66-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_69> = call 'erlang':'=:=' ((_68-|['compiler_generated'] ),'true') in let <_70> = call 'erlang':'element' (2,GOpt) in let <_71> = call 'erlang':'=:=' (_70,'true') in let <_72> = call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_69,_71) in let <_73> = call 'erlang':'not' (_72) in let <_74> = call 'erlang':'is_boolean' (_70) in let <_75> = call 'erlang':'and' (_73,_74) in let <_76> = call 'erlang':'is_boolean' (_68) in (call 'erlang':'and' (_75,_76)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> case GOpt of <{'qlc_opt',_174,_175,_176,_177,_178,_179,_180,_181}> when 'true' -> call 'erlang':'setelement' (3,GOpt,'false')
(<_182> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_opt'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<> when 'true' -> GOpt end in apply 'may_create_simple'/2 (_79,Prep)
<L,_X_GOpt> when call 'erlang':'is_list' (L) -> apply 'short_list'/1 (L)
<T,_X_GOpt> when 'true' -> call 'erlang':'error' ({'unsupported_qlc_handle',{'qlc_handle',T}}) end
'eval_le'/2 = fun (_0,_1) -> case apply _0 () of <Error = {'error','qlc',_6}> when 'true' -> apply 'throw_error'/1 (Error)
<R> when 'true' -> case apply 'get_handle'/1 (R) of <'badarg'> when 'true' -> call 'erlang':'error' ('badarg',[R|[]])
<H> when 'true' -> apply 'prep_le'/2 (H,_1) end end
'prep_qlc_lc'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <{'simple_v1',PVar,LE_fun,L},Opt,GOpt,_X_H> when 'true' -> do apply 'check_lookup_option'/2 (Opt,'false') let <_5> = apply 'anno'/1 (L) in let <_4> = apply 'eval_le'/2 (LE_fun,GOpt) in apply 'prep_simple_qlc'/4 (PVar,_5,_4,Opt)
<{'qlc_v1',QFun,CodeF,Qdata0,QOpt},Opt,GOpt,_X_H> when 'true' -> let <F> = fun (_9,_8) -> case <_9,_8> of <QualData = {_X_QNum,_X_GoI,_X_SI,'fil'},ModGens> when 'true' -> {QualData,ModGens}
<QualData = {_X_QNum,_X_GoI,_X_SI,{'gen',{'join',_29,_30,_31,_32,_33,_34}}},ModGens> when 'true' -> {QualData,ModGens}
<{QNum,GoI,SI,{'gen',LE_fun}},ModGens0> when 'true' -> let <Prep1> = apply 'eval_le'/2 (LE_fun,GOpt) in case apply 'prep_generator'/5 (QNum,Prep1,QOpt,Opt,ModGens0) of <{Prep,ModGens}> when 'true' -> {{QNum,GoI,SI,{'gen',Prep}},ModGens}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10})-|[{'function_name',{'-prep_qlc_lc/4-fun-0-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'mapfoldl' (F,[],Qdata0) of <{Qdata,ModGens}> when 'true' -> let <SomeLookUp> = call 'lists':'keymember' ('true',2,ModGens) in do apply 'check_lookup_option'/2 (Opt,SomeLookUp) case ModGens of <[{_X_QNum,_X_LookUp,'all',OnePrep}|[]]> when 'true' -> do apply 'check_join_option'/1 (Opt) OnePrep
<_35> when 'true' -> let <Prep0> = apply 'prep_qlc'/5 (QFun,CodeF,Qdata,QOpt,Opt) in let <_18> = fun (_16) -> case _16 of <{QNum,_X_LookUp,Fs,_X_Prep}> when 'true' -> [{QNum,Fs}|[]]
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'-prep_qlc_lc/4-fun-1-',1}}] )-|['compiler_generated'] ) end in let <LU_SkipQuals> = call 'lists':'flatmap' (_18,ModGens) in case Prep0 of <{'prepared',_36,_37,_38,_39,_40,_41,_42,_43,_44}> when 'true' -> let <_22> = call 'erlang':'setelement' (6,Prep0,LU_SkipQuals) in apply 'prep_join'/3 (_22,QOpt,Opt)
(<_45> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<_46,_X_Opt,_X_GOpt,H> when 'true' -> call 'erlang':'error' ({'unsupported_qlc_handle',{'qlc_handle',H}}) end
'prep_generator'/5 = fun (_0,_1,_2,_3,_4) -> let <PosFun> = fun (_5) -> apply 'pos_fun'/3 (_5,_2,_0) in let <_9> = case apply 'match_specs'/2 (_2,_0) of <'undefined'> when 'true' -> {'no_match_spec',[]}
<MSFs0 = {_18,_19}> when 'true' -> MSFs0
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end in case _1 of <{'prepared',LE,_20,_21,_22,_23,_24,_25,_26,_27}> when 'true' -> case apply 'prep_gen'/5 (LE,_1,PosFun,_9,_3) of <{'replace',Fs,LookUp,Prep}> when 'true' -> {Prep,[{_0,LookUp,Fs,Prep}|_4]}
<{'skip',SkipFils,LookUp,Prep}> when 'true' -> {Prep,[{_0,LookUp,SkipFils,Prep}|_4]}
<{'no',_X_Fs,_X_LookUp,Prep}> when 'true' -> {Prep,_4}
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
'pos_fun'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'undefined',QOpt,QNum> when 'true' -> let <_3> = apply 'constants'/2 (QOpt,QNum) in {'=:=',_3}
<'=:=',QOpt,QNum> when 'true' -> let <_4> = apply 'constants'/2 (QOpt,QNum) in {'=:=',_4}
<'==',QOpt,QNum> when 'true' -> try let <_5> = apply 'equal_constants'/2 (QOpt,QNum) in {'==',_5} of <_6> -> _6 catch <_9,_8,_7> -> let <_10> = apply 'constants'/2 (QOpt,QNum) in {'=:=',_10}
(<_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11})-|[{'function_name',{'pos_fun',3}}] )-|['compiler_generated'] ) end
'prep_gen'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <LE0 = {'qlc_table',_64,TravMS,_65,_66,IF,_67,LU_fun,_68,KeyEquality,LuV0,MS0},Prep0,PosFun0,{MS,Fs},Opt> when 'true' -> let <PosFun> = apply PosFun0 (KeyEquality) in case apply 'find_const_positions'/4 (IF,LU_fun,PosFun,Opt) of <{LuV,{STag,SkipFils}}> when 'true' -> let <LU> = call 'erlang':'=/=' (LuV,'false') in case <> of <> when let <_8> = call 'erlang':'=/=' (LuV0,'undefined') in let <_9> = call 'erlang':'=/=' (MS0,'no_match_spec') in call 'erlang':'or' (_8,_9) -> {'no',[],'false',Prep0}
<> when try let <_10> = call 'erlang':'=/=' (MS,'no_match_spec') in call 'erlang':'and' (_10,LU) of <Try> -> Try catch <T,R> -> 'false' -> let <_15> = case <> of <> when let <_12> = call 'erlang':'=:=' (Fs,SkipFils) in let <_13> = call 'erlang':'=:=' (STag,Fs) in call 'erlang':'or' (_12,_13) -> case MS of <[{'$1',_X_Guard,['$1']}|[]]> when 'true' -> 'no_match_spec'
<[{Head,_X_Guard,Body}|[]]> when 'true' -> [{Head,[],Body}|[]]
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
<> when 'true' -> MS end in case LE0 of <{'qlc_table',_69,_70,_71,_72,_73,_74,_75,_76,_77,_78,_79}> when 'true' -> let <_18> = call 'erlang':'setelement' (12,LE0,_15) in let <_20> = call 'erlang':'setelement' (11,_18,LuV) in case Prep0 of <{'prepared',_81,_82,_83,_84,_85,_86,_87,_88,_89}> when 'true' -> let <_24> = call 'erlang':'setelement' (2,Prep0,_20) in {'replace',Fs,LU,_24}
(<_90> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_80> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_table'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<> when LU -> case LE0 of <{'qlc_table',_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101}> when 'true' -> let <_28> = call 'erlang':'setelement' (11,LE0,LuV) in case Prep0 of <{'prepared',_103,_104,_105,_106,_107,_108,_109,_110,_111}> when 'true' -> let <_32> = call 'erlang':'setelement' (2,Prep0,_28) in {'skip',SkipFils,LU,_32}
(<_112> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_102> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_table'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<> when let <_34> = call 'erlang':'=:=' (TravMS,'true') in let <_35> = call 'erlang':'=/=' (MS,'no_match_spec') in call 'erlang':'and' (_34,_35) -> case LE0 of <{'qlc_table',_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123}> when 'true' -> let <_38> = call 'erlang':'setelement' (12,LE0,MS) in case Prep0 of <{'prepared',_125,_126,_127,_128,_129,_130,_131,_132,_133}> when 'true' -> let <_41> = call 'erlang':'setelement' (9,Prep0,'false') in let <_43> = call 'erlang':'setelement' (2,_41,_38) in let <_45> = apply 'may_create_simple'/2 (Opt,_43) in {'replace',Fs,'false',_45}
(<_134> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_124> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_table'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<> when 'true' -> {'no',[],'false',Prep0} end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<{'qlc_list',[],_135},Prep0,_X_PosFun,{_X_MS,Fs},_X_Opt> when 'true' -> {'replace',Fs,'false',Prep0}
<LE0 = {'qlc_list',_136,'no_match_spec'},Prep0,_X_PosFun,{MS,Fs},Opt> when call 'erlang':'=/=' (MS,'no_match_spec') -> case LE0 of <{'qlc_list',_137,_138}> when 'true' -> let <_48> = call 'erlang':'setelement' (3,LE0,MS) in case Prep0 of <{'prepared',_140,_141,_142,_143,_144,_145,_146,_147,_148}> when 'true' -> let <_51> = call 'erlang':'setelement' (10,Prep0,'false') in let <_53> = call 'erlang':'setelement' (2,_51,_48) in let <_55> = apply 'may_create_simple'/2 (Opt,_53) in {'replace',Fs,'false',_55}
(<_149> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_139> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_list'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<{'qlc_list',_150,_151},Prep0,_X_PosFun,{MS,Fs},Opt> when call 'erlang':'=/=' (MS,'no_match_spec') -> let <ListMS> = {'qlc_list',Prep0,MS} in let <LE> = {'prepared',ListMS,'no',[],[],[],{[],[]},'undefined','false','false'} in let <_58> = apply 'may_create_simple'/2 (Opt,LE) in {'replace',Fs,'false',_58}
<_X_LE0,Prep0,_X_PosFun,_X_MSFs,_X_Opt> when 'true' -> {'no',[],'false',Prep0} end
'may_create_simple'/2 = fun (_0,_1) -> case <_0,_1> of <Opt = {'qlc_opt',Unique,Cache,_11,_12,_13,_14,_15,_16},Prep = {'prepared',_17,_18,_19,_20,_21,_22,_23,IsUnique,IsCached}> when 'true' -> case <> of <> when let <_2> = call 'erlang':'=:=' (Unique,'true') in let <_3> = call 'erlang':'=:=' (IsUnique,'false') in let <_4> = call 'erlang':'and' (_2,_3) in let <_5> = call 'erlang':'=/=' (Cache,'false') in let <_6> = call 'erlang':'=:=' (IsCached,'false') in let <_7> = call 'erlang':'and' (_5,_6) in call 'erlang':'or' (_4,_7) -> let <_8> = apply 'anno'/1 (1) in apply 'prep_simple_qlc'/4 ('SQV',_8,Prep,Opt)
<> when 'true' -> Prep end
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'may_create_simple',2}}] )-|['compiler_generated'] ) end
'prep_simple_qlc'/4 = fun (_0,_1,_2,_3) -> do apply 'check_join_option'/1 (_3) case _2 of <{'prepared',_20,Sorted,SortInfo,_21,_22,_23,_24,IsUnique,IsCached}> when 'true' -> case _3 of <{'qlc_opt',Unique,Cache,_25,_26,_27,_28,_29,_30}> when 'true' -> let <_7> = case <> of <> when (call 'erlang':'=:=' (Unique,'true')-|['compiler_generated'] ) -> Cache
<> when (call 'erlang':'=:=' (IsCached,'false')-|['compiler_generated'] ) -> Cache
<> when 'true' -> 'false' end in let <_9> = call 'erlang':'not' (IsUnique) in let <_10> = call 'erlang':'and' (Unique,_9) in let <Optz> = {'optz',_10,_7,'any','no',_3} in let <QLC> = {'simple_qlc',_0,_2,_1,'not_a_list',Optz} in let <_15> = call 'erlang':'or' (IsUnique,Unique) in let <_13> = call 'erlang':'=/=' (_7,'false') in let <_14> = call 'erlang':'or' (IsCached,_13) in {'prepared',QLC,Sorted,SortInfo,[],[],{[],[]},'undefined',_15,_14}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'prep_sort'/2 = fun (_0,_1) -> case <_0,_1> of <{'qlc_sort',Prep = {'prepared',_17,'yes',_18,_19,_20,_21,_22,_23,_24},_25,_26,_27,_28,_29,_30,_31},_X_GOpt> when 'true' -> Prep
<Q = {'qlc_sort',{'prepared',_32,_33,_34,_35,_36,_37,_38,IsUniqueObjs,_39},_40,_41,_42,_43,_44,_45,_46},GOpt> when 'true' -> let <S1> = apply 'sort_unique'/2 (IsUniqueObjs,Q) in let <S2> = apply 'sort_tmpdir'/2 (S1,GOpt) in (case GOpt of (<({'qlc_opt',_47,_48,_49,_50,_51,_52,_53,_rec41}-|['compiler_generated'] )> when 'true' -> case S2 of <{'qlc_sort',_55,_56,_57,_58,_59,_60,_61,_62}> when 'true' -> let <_9> = call 'erlang':'setelement' (8,S2,_rec41) in case apply 'sort_sort_info'/1 (_9) of <{SortInfo,Sorted}> when 'true' -> (case _9 of (<({'qlc_sort',_64,_65,_rec42,_66,_67,_68,_69,_70}-|['compiler_generated'] )> when 'true' -> let <_14> = call 'erlang':'or' (_rec42,IsUniqueObjs) in {'prepared',_9,Sorted,SortInfo,[],[],{[],[]},'undefined',_14,'true'}-|['compiler_generated'] )
(<_71> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_sort'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_63> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_sort'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_54> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_opt'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15})-|[{'function_name',{'prep_sort',2}}] )-|['compiler_generated'] ) end
'prep_qlc'/5 = fun (_0,_1,_2,_3,_4) -> case _4 of <{'qlc_opt',Unique,Cache,_15,Join,_16,_17,_18,_19}> when 'true' -> let <Optz> = {'optz',Unique,Cache,Join,'no',_4} in case apply 'qlc_sort_info'/2 (_2,_3) of <{Qdata,SortInfo}> when 'true' -> let <QLC> = {'qlc',_0,_1,Qdata,'not_a_list',Optz} in let <_9> = call 'erlang':'=/=' (Cache,'false') in {'prepared',QLC,'no',SortInfo,[],[],{[],[]},'undefined',Unique,_9}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'qlc_sort_info'/2 = fun (_0,_1) -> let <F> = fun (_17,_16) -> case <_17,_16> of <Qd = {_X_QNum,_X_GoI,_X_SI,'fil'},Info> when 'true' -> {Qd,Info}
<Qd = {_X_QNum,_X_GoI,_X_SI,{'gen',{'join',_37,_38,_39,_40,_41,_42}}},Info> when 'true' -> {Qd,Info}
<{QNum,GoI,SI,{'gen',PrepLE0}},Info> when 'true' -> let <PrepLE> = apply 'sort_info'/3 (PrepLE0,QNum,_1) in let <Qd> = {QNum,GoI,SI,{'gen',PrepLE}} in let <_14> = letrec 'lc$^0'/1 = fun (_11) -> case _11 of <[{{C,Order},What}|_5]> when call 'erlang':'=:=' (What,[]) -> (letrec 'lc$^1'/1 = fun (_12) -> case _12 of <[Column|_9]> when 'true' -> let <_13> = apply 'lc$^1'/1 (_9) in ([{{Column,Order},[{'traverse',QNum,C}|[]]}|_13]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_5)
(<_52> when 'true' -> (primop 'match_fail' ({'function_clause',_52})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_10> = apply 'equal_template_columns'/2 (_1,{QNum,C}) in apply 'lc$^1'/1 (_10)-|['list_comprehension'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_53> when 'true' -> (primop 'match_fail' ({'function_clause',_53})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in (case PrepLE of (<({'prepared',_43,_44,_45,_rec43,_46,_47,_48,_49,_50}-|['compiler_generated'] )> when 'true' -> apply 'lc$^0'/1 (_rec43)-|['compiler_generated'] )
(<_51> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) in {Qd,[_14|Info]}
(<_19,_18> when 'true' -> (primop 'match_fail' ({'function_clause',_19,_18})-|[{'function_name',{'-qlc_sort_info/2-fun-2-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'mapfoldl' (F,[],_0) of <{Qdata,SortInfoL}> when 'true' -> let <_22> = call 'lists':'append' (SortInfoL) in let <_32> = letrec 'lc$^3'/1 = fun (_29) -> case _29 of <[Pos|_24]> when 'true' -> (letrec 'lc$^4'/1 = fun (_30) -> case _30 of <[Ord|_27]> when 'true' -> let <_31> = apply 'lc$^4'/1 (_27) in ([{{Pos,Ord},['template']}|_31]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^3'/1 (_24)
(<_54> when 'true' -> (primop 'match_fail' ({'function_clause',_54})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in let <_28> = apply 'orders'/1 ('yes') in apply 'lc$^4'/1 (_28)-|['list_comprehension'] )
<[]> when 'true' -> _22
(<_55> when 'true' -> (primop 'match_fail' ({'function_clause',_55})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_25> = apply 'constant_columns'/2 (_1,0) in apply 'lc$^3'/1 (_25) in let <SortInfo> = apply 'family_union'/1 (_32) in {Qdata,SortInfo}
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
'sort_info'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Prep = {'prepared',_41,S,SI,_42,_43,_44,_45,_46,_47},QNum,QOpt> when 'true' -> let <_7> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[{PosOrd,_48}|_4]> when 'true' -> let <_6> = apply 'lc$^0'/1 (_4) in ([{PosOrd,[]}|_6]-|['compiler_generated'] )
(<[_3|_4]> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_59> when 'true' -> (primop 'match_fail' ({'function_clause',_59})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (SI) in let <_17> = letrec 'lc$^1'/1 = fun (_14) -> case _14 of <[Pos|_9]> when 'true' -> (letrec 'lc$^2'/1 = fun (_15) -> case _15 of <[Ord|_12]> when 'true' -> let <_16> = apply 'lc$^2'/1 (_12) in ([{{Pos,Ord},[]}|_16]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^1'/1 (_9)
(<_60> when 'true' -> (primop 'match_fail' ({'function_clause',_60})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in let <_13> = apply 'orders'/1 ('yes') in apply 'lc$^2'/1 (_13)-|['list_comprehension'] )
<[]> when 'true' -> _7
(<_61> when 'true' -> (primop 'match_fail' ({'function_clause',_61})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_10> = apply 'constant_columns'/2 (QOpt,QNum) in apply 'lc$^1'/1 (_10) in let <_33> = case <> of <> when call 'erlang':'=/=' (S,'no') -> let <_19> = apply 'size_of_qualifier'/2 (QOpt,QNum) in (case <> of <> when call 'erlang':'is_integer' (_19) -> (case <> of <> when call 'erlang':'>' (_19,0) -> let <_21> = apply 'size_of_constant_prefix'/2 (QOpt,QNum) in (case <> of <> when call 'erlang':'<' (_21,_19) -> (letrec 'lc$^3'/1 = fun (_28) -> case _28 of <[C|_23]> when 'true' -> (letrec 'lc$^4'/1 = fun (_29) -> case _29 of <[Ord|_26]> when 'true' -> let <_30> = apply 'lc$^4'/1 (_26) in ([{{C,Ord},[]}|_30]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^3'/1 (_23)
(<_62> when 'true' -> (primop 'match_fail' ({'function_clause',_62})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in let <_27> = apply 'orders'/1 (S) in apply 'lc$^4'/1 (_27)-|['list_comprehension'] )
<[]> when 'true' -> _17
(<_63> when 'true' -> (primop 'match_fail' ({'function_clause',_63})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_24> = call 'erlang':'+' (_21,1) in apply 'lc$^3'/1 ([_24|[]])-|['list_comprehension'] )
(<> when 'true' -> _17-|['compiler_generated'] ) end-|['list_comprehension'] )
(<> when 'true' -> _17-|['compiler_generated'] ) end-|['list_comprehension'] )
(<> when 'true' -> _17-|['compiler_generated'] ) end-|['list_comprehension'] )
(<> when 'true' -> _17-|['compiler_generated'] ) end in let <SI2> = call 'lists':'usort' (_33) in case Prep of <{'prepared',_49,_50,_51,_52,_53,_54,_55,_56,_57}> when 'true' -> call 'erlang':'setelement' (5,Prep,SI2)
(<_58> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_40,_39,_38> when 'true' -> (primop 'match_fail' ({'function_clause',_40,_39,_38})-|[{'function_name',{'sort_info',3}}] )-|['compiler_generated'] ) end
'orders'/1 = fun (_0) -> case _0 of <O = 'ascending'> when 'true' -> [O|[]]
<'yes'> when 'true' -> ['ascending']
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'orders',1}}] )-|['compiler_generated'] ) end
'sort_unique'/2 = fun (_0,_1) -> case <_0,_1> of <'true',Sort = {'qlc_sort',_9,'sort',_10,_11,_12,SortOptions,_13,_14}> when 'true' -> let <_2> = call 'lists':'delete' ('unique',SortOptions) in let <_rec45> = call 'lists':'keydelete' ('unique',1,_2) in case Sort of <{'qlc_sort',_15,_16,_17,_18,_19,_20,_21,_22}> when 'true' -> let <_5> = call 'erlang':'setelement' (7,Sort,_rec45) in call 'erlang':'setelement' (4,_5,'false')
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_sort'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<_24,Sort> when 'true' -> Sort end
'sort_tmpdir'/2 = fun (_0,_1) -> case <_0,_1> of <S,{'qlc_opt',_9,_10,_11,_12,[],_13,_14,_15}> when 'true' -> S
<S,Opt> when 'true' -> (case Opt of (<({'qlc_opt',_16,_17,_18,_19,_rec49,_20,_21,_22}-|['compiler_generated'] )> when 'true' -> case S of <{'qlc_sort',_24,_25,_26,_27,_28,_29,_30,_31}> when 'true' -> call 'erlang':'setelement' (9,S,_rec49)
(<_32> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_sort'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_opt'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'short_list'/1 = fun (_0) -> {'prepared',{'qlc_list',_0,'no_match_spec'},'yes',[],[],[],{[],[]},'undefined','true','true'}
'find_const_positions'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <IF,LU_fun,{KeyEquality,PosFun},{'qlc_opt',_19,_20,Max,_21,_22,Lookup,_23,_24}> when try let <_4> = call 'erlang':'is_function' (LU_fun) in let <_5> = call 'erlang':'is_function' (PosFun) in let <_6> = call 'erlang':'is_function' (IF) in let <_7> = call 'erlang':'=/=' (Lookup,'false') in let <_8> = call 'erlang':'and' (_6,_7) in let <_9> = call 'erlang':'and' (_5,_8) in call 'erlang':'and' (_4,_9) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'call'/4 (IF,'keypos','undefined',[]) of <'undefined'> when 'true' -> let <Indices> = apply 'call'/4 (IF,'indices','undefined',[]) in apply 'find_const_position_idx'/5 (Indices,KeyEquality,PosFun,Max,[])
<KeyPos> when 'true' -> let <_11> = apply PosFun (KeyPos) in case apply 'pos_vals'/4 (KeyPos,KeyEquality,_11,Max) of <'false'> when 'true' -> let <_12> = apply IF ('indices') in apply 'find_const_position_idx'/5 (_12,KeyEquality,PosFun,Max,[])
<PosValuesSkip> when 'true' -> PosValuesSkip end end
<_X_IF,_X_LU_fun,_X_KE_PosFun,_X_Opt0> when 'true' -> {'false',{'some',[]}} end
'find_const_position_idx'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[I|Is],KeyEquality,PosFun,Max,L0> when 'true' -> let <_5> = apply PosFun (I) in case apply 'pos_vals'/4 (I,KeyEquality,_5,Max) of <'false'> when 'true' -> apply 'find_const_position_idx'/5 (Is,KeyEquality,PosFun,Max,L0)
<PosValuesFils = {{_X_Pos,Values},_X_SkipFils}> when 'true' -> let <_6> = call 'erlang':'length' (Values) in let <L> = [{_6,PosValuesFils}|L0] in apply 'find_const_position_idx'/5 (Is,KeyEquality,PosFun,Max,L)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<_15,_X_KeyEquality,_X_PosFun,_X_Max,[]> when 'true' -> {'false',{'some',[]}}
<_16,_X_KeyEquality,_X_PosFun,_X_Max,L> when 'true' -> case call 'lists':'sort' (L) of <[{_17,PVF}|_18]> when 'true' -> PVF
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end end
'pos_vals'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Pos,'==',{'usort_needed',Values,SkipFils},Max> when 'true' -> let <_4> = call 'lists':'usort' (Values) in apply 'pos_vals_max'/4 (Pos,_4,SkipFils,Max)
<Pos,'=:=',{'usort_needed',Values,SkipFils},Max> when 'true' -> let <_5> = apply 'nub'/1 (Values) in let <_6> = call 'lists':'sort' (_5) in apply 'pos_vals_max'/4 (Pos,_6,SkipFils,Max)
<Pos,_X_KeyEquality,{'values',Values,SkipFils},Max> when 'true' -> apply 'pos_vals_max'/4 (Pos,Values,SkipFils,Max)
<_X_Pos,_X_KeyEquality,_X_T,_X_Max> when 'true' -> 'false' end
'nub'/1 = fun (_0) -> case _0 of <[]> when 'true' -> []
<[E|L]> when 'true' -> let <_2> = apply 'nub'/1 (L) in case call 'lists':'member' (E,_2) of <'true'> when 'true' -> _2
<'false'> when 'true' -> [E|_2]
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'nub',1}}] )-|['compiler_generated'] ) end
'pos_vals_max'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Pos,Values,Skip,Max> when let <_5> = call 'erlang':'=:=' (Max,-1) in let <_7> = try let <_6> = call 'erlang':'length' (Values) in call 'erlang':'>=' (Max,_6) of <Try> -> Try catch <T,R> -> 'false' in call 'erlang':'or' (_5,_7) -> {{Pos,Values},Skip}
<_X_Pos,_X_Value,_X_Skip,_X_Max> when 'true' -> 'false' end
'prep_join'/3 = fun (_0,_1,_2) -> case apply 'join_opt'/1 (_1) of <'undefined'> when 'true' -> do apply 'check_join_option'/1 (_2) _0
<EqualMatch> when 'true' -> let <_4> = case EqualMatch of <{NEqual,NMatch}> when 'true' -> apply 'pref_join'/5 (NEqual,NMatch,_0,_1,_2)
<EM> when 'true' -> apply 'pref_join'/5 (EM,EM,_0,_1,_2) end in case _4 of <_@r0 = {Ix,M}> when 'true' -> (case _0 of (<({'prepared',_18,_19,_rec50,_20,_21,_22,_23,_24,_25}-|['compiler_generated'] )> when 'true' -> let <_8> = call 'erlang':'++' (_rec50,M) in let <SI> = apply 'family_union'/1 (_8) in let <_rec51> = _@r0 in case _0 of <{'prepared',_27,_28,_29,_30,_31,_32,_33,_34,_35}> when 'true' -> let <_12> = call 'erlang':'setelement' (7,_0,_rec51) in call 'erlang':'setelement' (4,_12,SI)
(<_36> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_26> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end end
'pref_join'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Equal,Match,Prep,QOpt,{'qlc_opt',_43,_44,_45,JoinOpt,_46,_47,_48,_49}> when 'true' -> let <_12> = letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[{KeyEquality,QCsL}|_6]> when 'true' -> (letrec 'lc$^1'/1 = fun (_10) -> case _10 of <[QCs|_8]> when 'true' -> let <_11> = apply 'lc$^1'/1 (_8) in ([{KeyEquality,QCs}|_11]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_6)
(<_50> when 'true' -> (primop 'match_fail' ({'function_clause',_50})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (QCsL)-|['list_comprehension'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_51> when 'true' -> (primop 'match_fail' ({'function_clause',_51})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([{'==',Equal}|[{'=:=',Match}|[]]]) in let <_22> = case <> of <> when try (let <_16> = case call 'erlang':'=:=' (JoinOpt,'any') of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=:=' (JoinOpt,'lookup')-|['compiler_generated'] )
(<_14> when 'true' -> _14-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_16-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> (letrec 'lc$^2'/1 = fun (_19) -> case _19 of <[{KE,QCs}|_18]> when 'true' -> let <_20> = apply 'pref_lookup_join'/4 (KE,QCs,Prep,QOpt) in let <_21> = apply 'lc$^2'/1 (_18) in ([_20|_21]-|['compiler_generated'] )
(<[_17|_18]> when 'true' -> apply 'lc$^2'/1 (_18)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_52> when 'true' -> (primop 'match_fail' ({'function_clause',_52})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (_12)-|['list_comprehension'] )
(<> when 'true' -> []-|['compiler_generated'] ) end in let <_32> = case <> of <> when try (let <_26> = case call 'erlang':'=:=' (JoinOpt,'any') of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=:=' (JoinOpt,'merge')-|['compiler_generated'] )
(<_24> when 'true' -> _24-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_26-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> (letrec 'lc$^3'/1 = fun (_29) -> case _29 of <[{KE,QCs}|_28]> when 'true' -> let <_30> = apply 'pref_merge_join'/4 (KE,QCs,Prep,QOpt) in let <_31> = apply 'lc$^3'/1 (_28) in ([_30|_31]-|['compiler_generated'] )
(<[_27|_28]> when 'true' -> apply 'lc$^3'/1 (_28)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_53> when 'true' -> (primop 'match_fail' ({'function_clause',_53})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (_12)-|['list_comprehension'] )
(<> when 'true' -> []-|['compiler_generated'] ) end in let <_36> = call 'lists':'append' (_22) in let <_37> = call 'lists':'usort' (_36) in let <_34> = call 'lists':'append' (_32) in let <_35> = call 'lists':'usort' (_34) in {_37,_35}
(<_42,_41,_40,_39,_38> when 'true' -> (primop 'match_fail' ({'function_clause',_42,_41,_40,_39,_38})-|[{'function_name',{'pref_join',5}}] )-|['compiler_generated'] ) end
'pref_lookup_join'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <KeyEquality,{[{Q1,C1}|[{Q2,C2}|[]]],Skip},Prep,QOpt> when let <_4> = call 'erlang':'is_integer' (C1) in let <_5> = call 'erlang':'is_integer' (C2) in call 'erlang':'and' (_4,_5) -> case Prep of <{'prepared',{'qlc',_37,_38,QData,_39,_40},_41,_42,_43,_44,_45,_46,_47,_48}> when 'true' -> let <Is1> = apply 'lookup_qual_data'/3 (QData,Q1,KeyEquality) in let <_13> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[IC1|_9]> when call 'erlang':'=:=' (IC1,C1) -> let <_11> = apply 'pref_lookup_join2'/7 (Q2,C2,Q1,C1,Skip,QOpt,KeyEquality) in let <_12> = apply 'lc$^0'/1 (_9) in ([_11|_12]-|['compiler_generated'] )
(<[IC1|_9]> when 'true' -> apply 'lc$^0'/1 (_9)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_51> when 'true' -> (primop 'match_fail' ({'function_clause',_51})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Is1) in let <Is2> = apply 'lookup_qual_data'/3 (QData,Q2,KeyEquality) in let <_21> = letrec 'lc$^1'/1 = fun (_18) -> case _18 of <[IC2|_17]> when call 'erlang':'=:=' (IC2,C2) -> let <_19> = apply 'pref_lookup_join2'/7 (Q1,C1,Q2,C2,Skip,QOpt,KeyEquality) in let <_20> = apply 'lc$^1'/1 (_17) in ([_19|_20]-|['compiler_generated'] )
(<[IC2|_17]> when 'true' -> apply 'lc$^1'/1 (_17)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_52> when 'true' -> (primop 'match_fail' ({'function_clause',_52})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Is2) in let <_23> = call 'erlang':'++' (_21,_13) in apply 'family'/1 (_23)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<KE,L = [{_49,Cs1}|[{_50,Cs2}|[]]],Prep,QOpt> when let <_24> = call 'erlang':'is_list' (Cs1) in let <_25> = call 'erlang':'is_list' (Cs2) in call 'erlang':'and' (_24,_25) -> let <_32> = letrec 'lc$^2'/1 = fun (_29) -> case _29 of <[QC|_27]> when 'true' -> let <_30> = apply 'pref_lookup_join'/4 (KE,QC,Prep,QOpt) in let <_31> = apply 'lc$^2'/1 (_27) in ([_30|_31]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_53> when 'true' -> (primop 'match_fail' ({'function_clause',_53})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in let <_28> = apply 'selections_no_skip'/1 (L) in apply 'lc$^2'/1 (_28) in call 'lists':'append' (_32)
(<_36,_35,_34,_33> when 'true' -> (primop 'match_fail' ({'function_clause',_36,_35,_34,_33})-|[{'function_name',{'pref_lookup_join',4}}] )-|['compiler_generated'] ) end
'lookup_qual_data'/3 = fun (_0,_1,_2) -> case call 'lists':'keysearch' (_1,1,_0) of <{'value',{_7,_8,_9,{'gen',PrepLE}}}> when call 'erlang':'=:=' (_7,_1) -> apply 'join_indices'/2 (PrepLE,_2)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'join_indices'/2 = fun (_0,_1) -> case <_0,_1> of <{'prepared',{'qlc_table',_16,_17,_18,_19,IF,_20,LU_fun,_21,KeyEquality,'undefined',_22},_23,_24,_25,_26,_27,_28,_29,_30},KE> when try let <_2> = call 'erlang':'is_function' (LU_fun) in (let <_7> = case call 'erlang':'=:=' (KE,KeyEquality) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> (case call 'erlang':'=:=' (KE,'=:=') of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=:=' (KeyEquality,'undefined')-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_4> when 'true' -> _4-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when 'true' -> _3-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in call 'erlang':'and' (_2,_8)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_10> = case apply 'call'/4 (IF,'keypos','undefined',[]) of <'undefined'> when 'true' -> []
<Kp> when 'true' -> [Kp|[]] end in case apply 'call'/4 (IF,'indices','undefined',[]) of <'undefined'> when 'true' -> _10
<Is0> when 'true' -> let <_12> = call 'erlang':'++' (_10,Is0) in call 'lists':'usort' (_12) end
<_X_Prep,_X_KeyEquality> when 'true' -> [] end
'pref_lookup_join2'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <TemplCols> = apply 'compared_template_columns'/3 (_5,{_0,_1},_6) in {{_0,_1,_2,_3},{'lookup_join',TemplCols,_6,_4}}
'pref_merge_join'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <KE,{[{Q1,C1}|[{Q2,C2}|[]]],Skip},Prep,QOpt> when let <_4> = call 'erlang':'is_integer' (C1) in let <_5> = call 'erlang':'is_integer' (C2) in call 'erlang':'and' (_4,_5) -> case Prep of <{'prepared',{'qlc',_23,_24,QData,_25,_26},_27,_28,_29,_30,_31,_32,_33,_34}> when 'true' -> let <Sort1> = apply 'merge_qual_data'/2 (QData,Q1) in let <Sort2> = apply 'merge_qual_data'/2 (QData,Q2) in let <Merge> = apply 'pref_merge'/9 (KE,Q1,C1,Q2,C2,Skip,Sort1,Sort2,QOpt) in apply 'family_union'/1 (Merge)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<KE,L = [{_35,Cs1}|[{_36,Cs2}|[]]],Prep,QOpt> when let <_10> = call 'erlang':'is_list' (Cs1) in let <_11> = call 'erlang':'is_list' (Cs2) in call 'erlang':'and' (_10,_11) -> let <_18> = letrec 'lc$^0'/1 = fun (_15) -> case _15 of <[QC|_13]> when 'true' -> let <_16> = apply 'pref_merge_join'/4 (KE,QC,Prep,QOpt) in let <_17> = apply 'lc$^0'/1 (_13) in ([_16|_17]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_37> when 'true' -> (primop 'match_fail' ({'function_clause',_37})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_14> = apply 'selections_no_skip'/1 (L) in apply 'lc$^0'/1 (_14) in call 'lists':'append' (_18)
(<_22,_21,_20,_19> when 'true' -> (primop 'match_fail' ({'function_clause',_22,_21,_20,_19})-|[{'function_name',{'pref_merge_join',4}}] )-|['compiler_generated'] ) end
'selections_no_skip'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[C|_2]> when 'true' -> let <_5> = apply 'lc$^0'/1 (_2) in ([{C,{'some',[]}}|_5]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_3> = apply 'all_selections'/1 (_0) in apply 'lc$^0'/1 (_3)-|['list_comprehension'] )
'merge_qual_data'/2 = fun (_0,_1) -> case call 'lists':'keysearch' (_1,1,_0) of <{'value',{_6,_7,_8,{'gen',PrepLE}}}> when call 'erlang':'=:=' (_6,_1) -> case PrepLE of <{'prepared',_9,_10,_11,SortInfo,_12,_13,_14,_15,_16}> when 'true' -> SortInfo
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'pref_merge'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> let <Col1> = {_1,_2} in let <Col2> = {_3,_4} in let <_17> = letrec 'lc$^0'/1 = fun (_14) -> case _14 of <[{QC = {_X_QNum,Col},SortL}|_12]> when 'true' -> let <_13> = call 'lists':'keymember' ({Col,'ascending'},1,SortL) in (case <> of <> when call 'erlang':'=:=' (_13,'false') -> let <_15> = apply 'lc$^0'/1 (_12) in ([QC|_15]-|['compiler_generated'] )
(<> when 'true' -> apply 'lc$^0'/1 (_12)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_11|_12]> when 'true' -> apply 'lc$^0'/1 (_12)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_34> when 'true' -> (primop 'match_fail' ({'function_clause',_34})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([{Col1,_6}|[{Col2,_7}|[]]]) in let <J> = [{{_1,_2,_3,_4},{'merge_join',_17,_0,_5}}|[]] in (letrec 'lc$^1'/1 = fun (_23) -> case _23 of <[Column|_21]> when 'true' -> let <_24> = apply 'lc$^1'/1 (_21) in ([{{Column,'ascending'},J}|_24]-|['compiler_generated'] )
<[]> when 'true' -> [{'other',J}|[]]
(<_35> when 'true' -> (primop 'match_fail' ({'function_clause',_35})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_22> = apply 'equal_template_columns'/2 (_8,Col1) in apply 'lc$^1'/1 (_22)-|['list_comprehension'] )
'table_sort_info'/1 = fun (_0) -> case _0 of <{'qlc_table',_4,_5,_6,_7,IF,_8,_9,_10,_11,_12,_13}> when 'true' -> case apply 'call'/4 (IF,'is_sorted_key','undefined',[]) of <'undefined'> when 'true' -> {[],'no'}
<'false'> when 'true' -> {[],'no'}
<'true'> when 'true' -> case apply 'call'/4 (IF,'keypos','undefined',[]) of <'undefined'> when 'true' -> {[],'no'}
<KeyPos> when 'true' -> {[{{KeyPos,'ascending'},[]}|[]],'no'} end
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'table_sort_info',1}}] )-|['compiler_generated'] ) end
'sort_sort_info'/1 = fun (_0) -> case _0 of <{'qlc_sort',_7,'sort',_8,_9,Ord0,_10,_11,_12}> when 'true' -> let <_1> = apply 'sort_order'/1 (Ord0) in {[],_1}
<{'qlc_sort',_13,{'keysort',Kp0},_14,_15,Ord0,_16,_17,_18}> when 'true' -> let <_3> = case Kp0 of <[Pos|_19]> when 'true' -> Pos
<_20> when 'true' -> Kp0 end in let <_5> = apply 'sort_order'/1 (Ord0) in {[{{_3,_5},[]}|[]],'no'}
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'sort_sort_info',1}}] )-|['compiler_generated'] ) end
'sort_order'/1 = fun (_0) -> case _0 of <F> when call 'erlang':'is_function' (_0) -> 'no'
<Order> when 'true' -> Order end
'check_join_option'/1 = fun (_0) -> case _0 of <{'qlc_opt',_2,_3,_4,'any',_5,_6,_7,_8}> when 'true' -> 'ok'
<{'qlc_opt',_9,_10,_11,Join,_12,_13,_14,_15}> when 'true' -> call 'erlang':'error' ('no_join_to_carry_out',[{'join',Join}|[]])
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'check_join_option',1}}] )-|['compiler_generated'] ) end
'check_lookup_option'/2 = fun (_0,_1) -> case <_0,_1> of <{'qlc_opt',_4,_5,_6,_7,_8,'true',_9,_10},'false'> when 'true' -> call 'erlang':'error' ('no_lookup_to_carry_out',[{'lookup','true'}])
<_X_QOpt,_X_LuV> when 'true' -> 'ok' end
'compared_template_columns'/3 = fun (_0,_1,_2) -> let <_3> = apply _0 ('template') in apply _3 (_1,_2)
'equal_template_columns'/2 = fun (_0,_1) -> let <_2> = apply _0 ('template') in apply _2 (_1,'==')
'size_of_constant_prefix'/2 = fun (_0,_1) -> let <_2> = apply _0 ('n_leading_constant_columns') in apply _2 (_1)
'constants'/2 = fun (_0,_1) -> let <_2> = apply _0 ('constants') in apply _2 (_1)
'equal_constants'/2 = fun (_0,_1) -> let <_2> = apply _0 ('equal_constants') in apply _2 (_1)
'join_opt'/1 = fun (_0) -> apply _0 ('join')
'match_specs'/2 = fun (_0,_1) -> let <_2> = apply _0 ('match_specs') in apply _2 (_1)
'constant_columns'/2 = fun (_0,_1) -> let <_2> = apply _0 ('constant_columns') in apply _2 (_1)
'size_of_qualifier'/2 = fun (_0,_1) -> let <_2> = apply _0 ('size') in apply _2 (_1)
'opt_le'/2 = fun (_0,_1) -> case <_0,_1> of <Prep0 = {'prepared',QLC = {'simple_qlc',_100,LE0,_101,_102,Optz0},_103,_104,_105,_106,_107,_108,_109,_110},GenNum> when 'true' -> case LE0 of <{'prepared',{'simple_qlc',LE_Pvar,LE2,_111,_112,Optz2},_113,_114,_115,_116,_117,_118,_119,_120}> when 'true' -> (case Optz2 of (<({'optz',_121,_rec53,_122,_123,_124}-|['compiler_generated'] )> when 'true' -> let <_6> = case _rec53 of <'false'> when 'true' -> (case Optz0 of (<({'optz',_126,_rec54,_127,_128,_129}-|['compiler_generated'] )> when 'true' -> _rec54-|['compiler_generated'] )
(<_130> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Cache2> when 'true' -> Cache2 end in (case Optz0 of (<({'optz',_rec57,_131,_132,_133,_134}-|['compiler_generated'] )> when 'true' -> (case Optz2 of (<({'optz',_rec58,_136,_137,_138,_139}-|['compiler_generated'] )> when 'true' -> let <_rec55> = call 'erlang':'or' (_rec57,_rec58) in case Optz0 of <{'optz',_141,_142,_143,_144,_145}> when 'true' -> let <_14> = call 'erlang':'setelement' (3,Optz0,_6) in let <_16> = call 'erlang':'setelement' (2,_14,_rec55) in let <_19> = case <> of <> when call 'erlang':'=:=' (LE_Pvar,'SQV') -> (case QLC of (<({'simple_qlc',_rec59,_147,_148,_149,_150}-|['compiler_generated'] )> when 'true' -> _rec59-|['compiler_generated'] )
(<_151> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','simple_qlc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<> when 'true' -> LE_Pvar end in case QLC of <{'simple_qlc',_rec63,_rec64,_rec65,_rec66,_rec67}> when 'true' -> let <_23> = {'simple_qlc',_19,LE2,_rec65,_rec66,_16} in case Prep0 of <{'prepared',_153,_154,_155,_156,_157,_158,_159,_160,_161}> when 'true' -> let <_27> = call 'erlang':'setelement' (2,Prep0,_23) in apply 'opt_le'/2 (_27,GenNum)
(<_162> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_152> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','simple_qlc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_146> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_140> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_135> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_125> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_163> when 'true' -> let <Optz1> = apply 'no_cache_of_first_generator'/2 (Optz0,GenNum) in let <_30> = apply 'opt_le'/2 (LE0,1) in case <_30,Optz1> of <LE,({('optz'-|['compiler_generated'] ),('false'-|['compiler_generated'] ),('false'-|['compiler_generated'] ),_164,_165,_166}-|['compiler_generated'] )> when 'true' -> LE
<LE,_167> when 'true' -> case QLC of <{'simple_qlc',_168,_169,_170,_171,_172}> when 'true' -> let <_32> = call 'erlang':'setelement' (6,QLC,Optz1) in let <_34> = call 'erlang':'setelement' (3,_32,LE) in case Prep0 of <{'prepared',_174,_175,_176,_177,_178,_179,_180,_181,_182}> when 'true' -> call 'erlang':'setelement' (2,Prep0,_34)
(<_183> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_173> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','simple_qlc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end end end
<Prep0 = {'prepared',{'qlc',_184,_185,_186,_187,_188},_189,_190,_191,LU_SkipQuals0,_192,_193,_194,_195},GenNum> when 'true' -> case Prep0 of <{'prepared',QLC = {'qlc',_196,_197,Qdata0,_198,Optz0},_199,_200,_201,_202,_203,_204,_205,_206}> when 'true' -> case Optz0 of <{'optz',_207,_208,JoinOption,_209,Opt}> when 'true' -> (case Optz0 of (<({'optz',_210,_211,_rec71,_212,_213}-|['compiler_generated'] )> when 'true' -> case _rec71 of <_215> when call 'erlang':'=:=' (_rec71,JoinOption) -> (case Prep0 of (<({'prepared',_216,_217,_218,_219,_220,_rec72,_221,_222,_223}-|['compiler_generated'] )> when 'true' -> case apply 'opt_join'/5 (_rec72,JoinOption,Qdata0,Opt,LU_SkipQuals0) of <{LU_QNum,Join,JoinSkipFs,DoSort}> when 'true' -> let <_50> = fun (_48) -> case _48 of <{QNum,_X_Fs}> when 'true' -> call 'erlang':'=:=' (QNum,LU_QNum)
(<_49> when 'true' -> (primop 'match_fail' ({'function_clause',_49})-|[{'function_name',{'-opt_le/2-fun-0-',1}}] )-|['compiler_generated'] ) end in case call 'lists':'partition' (_50,LU_SkipQuals0) of <{LU_Skip,LU_SkipQuals}> when 'true' -> let <_54> = fun (_52) -> case _52 of <{_X_QNum,Fs}> when 'true' -> Fs
(<_53> when 'true' -> (primop 'match_fail' ({'function_clause',_53})-|[{'function_name',{'-opt_le/2-fun-1-',1}}] )-|['compiler_generated'] ) end in let <LU_SkipFs> = call 'lists':'flatmap' (_54,LU_SkipQuals) in let <_56> = case <> of <> when call 'erlang':'=:=' (LU_Skip,[]) -> Qdata0
<> when 'true' -> apply 'activate_join_lookup_filter'/2 (LU_QNum,Qdata0) end in let <_58> = call 'erlang':'++' (LU_SkipFs,JoinSkipFs) in let <Qdata2> = apply 'skip_lookup_filters'/2 (_56,_58) in let <F> = fun (_64,_63) -> case <_64,_63> of <{QNum,GoI,SI,{'gen',PrepLE = {'prepared',_225,_226,_227,_228,_229,_230,_231,_232,_233}}},GenNum1> when 'true' -> let <NewPrepLE> = apply 'maybe_sort'/4 (PrepLE,QNum,DoSort,Opt) in let <_62> = apply 'opt_le'/2 (NewPrepLE,GenNum1) in let <_61> = call 'erlang':'+' (GenNum1,1) in {{QNum,GoI,SI,{'gen',_62}},_61}
<Qd,GenNum1> when 'true' -> {Qd,GenNum1} end in case call 'lists':'mapfoldl' (F,1,Qdata2) of <{Qdata,_234}> when 'true' -> let <Optz1> = apply 'no_cache_of_first_generator'/2 (Optz0,GenNum) in case Optz1 of <{'optz',_235,_236,_237,_238,_239}> when 'true' -> let <_72> = call 'erlang':'setelement' (5,Optz1,Join) in case QLC of <{'qlc',_241,_242,_243,_244,_245}> when 'true' -> let <_75> = call 'erlang':'setelement' (6,QLC,_72) in let <_77> = call 'erlang':'setelement' (4,_75,Qdata) in case Prep0 of <{'prepared',_247,_248,_249,_250,_251,_252,_253,_254,_255}> when 'true' -> call 'erlang':'setelement' (2,Prep0,_77)
(<_256> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_246> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_240> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_68> when 'true' -> primop 'match_fail' ({'badmatch',_68})-|['compiler_generated'] ) end
(<_51> when 'true' -> primop 'match_fail' ({'badmatch',_51})-|['compiler_generated'] ) end
(<_47> when 'true' -> primop 'match_fail' ({'badmatch',_47})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_224> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_44> when 'true' -> primop 'match_fail' ({'badmatch',_44})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_214> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_41> when 'true' -> primop 'match_fail' ({'badmatch',_41})-|['compiler_generated'] ) end
(<_40> when 'true' -> primop 'match_fail' ({'badmatch',_40})-|['compiler_generated'] ) end
<Prep = {'prepared',{'qlc_append',HL},_257,_258,_259,_260,_261,_262,_263,_264},GenNum> when 'true' -> let <_86> = letrec 'lc$^3'/1 = fun (_83) -> case _83 of <[H|_82]> when 'true' -> let <_84> = apply 'opt_le'/2 (H,GenNum) in let <_85> = apply 'lc$^3'/1 (_82) in ([_84|_85]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_311> when 'true' -> (primop 'match_fail' ({'function_clause',_311})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (HL) in let <_rec77> = {'qlc_append',_86} in case Prep of <{'prepared',_265,_266,_267,_268,_269,_270,_271,_272,_273}> when 'true' -> call 'erlang':'setelement' (2,Prep,_rec77)
(<_274> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<Prep = {'prepared',Sort = {'qlc_sort',H,_275,_276,_277,_278,_279,_280,_281},_282,_283,_284,_285,_286,_287,_288,_289},GenNum> when 'true' -> let <_rec81> = apply 'opt_le'/2 (H,GenNum) in case Sort of <{'qlc_sort',_290,_291,_292,_293,_294,_295,_296,_297}> when 'true' -> let <_94> = call 'erlang':'setelement' (2,Sort,_rec81) in case Prep of <{'prepared',_299,_300,_301,_302,_303,_304,_305,_306,_307}> when 'true' -> call 'erlang':'setelement' (2,Prep,_94)
(<_308> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_298> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_sort'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<Prep,_X_GenNum> when 'true' -> Prep end
'no_cache_of_first_generator'/2 = fun (_0,_1) -> case <_0,_1> of <Optz,GenNum> when call 'erlang':'>' (GenNum,1) -> Optz
<Optz,1> when 'true' -> case Optz of <{'optz',_6,_7,_8,_9,_10}> when 'true' -> call 'erlang':'setelement' (3,Optz,'false')
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'no_cache_of_first_generator',2}}] )-|['compiler_generated'] ) end
'maybe_sort'/4 = fun (_0,_1,_2,_3) -> case call 'lists':'keyfind' (_1,1,_2) of <{_17,Col}> when call 'erlang':'=:=' (_17,_1) -> case _3 of <{'qlc_opt',_18,_19,_20,_21,TmpDir,_22,_23,TmpUsage}> when 'true' -> let <_9> = letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[Dir|_6]> when call 'erlang':'=/=' (Dir,[]) -> let <_8> = apply 'lc$^0'/1 (_6) in ([{'tmpdir',Dir}|_8]-|['compiler_generated'] )
(<[Dir|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_24> when 'true' -> (primop 'match_fail' ({'function_clause',_24})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([TmpDir|[]]) in let <Sort> = {'qlc_sort',_0,{'keysort',Col},'false',[],'ascending',_9,TmpUsage,TmpDir} in {'prepared',Sort,'no',[],[],[],'no','undefined','false','false'}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<'false'> when 'true' -> _0
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
'skip_lookup_filters'/2 = fun (_0,_1) -> case <_0,_1> of <Qdata,[]> when 'true' -> Qdata
<Qdata0,LU_SkipFs> when 'true' -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[Qd = {QNum,GoI,_11,_12}|_3]> when 'true' -> let <_7> = case call 'lists':'member' (QNum,LU_SkipFs) of <'true'> when 'true' -> {QNum,GoI,-1,'fil'}
<'false'> when 'true' -> Qd
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end in let <_8> = apply 'lc$^0'/1 (_3) in ([_7|_8]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_13> when 'true' -> (primop 'match_fail' ({'function_clause',_13})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Qdata0)-|['list_comprehension'] ) end
'activate_join_lookup_filter'/2 = fun (_0,_1) -> case call 'lists':'keyfind' (_0,1,_1) of <{_16,GoI2,SI2,{'gen',Prep2}}> when 'true' -> (case Prep2 of (<({'prepared',_rec84,_17,_18,_19,_20,_21,_22,_23,_24}-|['compiler_generated'] )> when 'true' -> case _rec84 of <{'qlc_table',_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36}> when 'true' -> let <_8> = call 'erlang':'setelement' (12,_rec84,'no_match_spec') in case Prep2 of <{'prepared',_38,_39,_40,_41,_42,_43,_44,_45,_46}> when 'true' -> let <_12> = call 'erlang':'setelement' (2,Prep2,_8) in call 'lists':'keyreplace' (_0,1,_1,{_0,GoI2,SI2,{'gen',_12}})
(<_47> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_37> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qlc_table'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'opt_join'/5 = fun (_0,_1,_2,_3,_4) -> case _0 of <{Ix0,M0}> when 'true' -> let <Ix1> = apply 'opt_join_lu'/3 (Ix0,_2,_4) in let <_7> = call 'lists':'keysort' (2,Ix1) in case call 'lists':'reverse' (_7) of <[{{Q1,C1,Q2,C2},Skip,KE,LU_fun}|_19]> when 'true' -> let <J> = {'qlc_join',{'lookup',KE,LU_fun},_3,'undefined',Q1,C1,'undefined',Q2,C2} in {Q2,J,Skip,[]}
<[]> when 'true' -> case apply 'opt_join_merge'/1 (M0) of <[{{Q1,C1,Q2,C2},{'merge_join',DoSort,KE,Skip}}|_20]> when 'true' -> let <J> = {'qlc_join',{'merge',KE},_3,'undefined',Q1,C1,'undefined',Q2,C2} in {'not_a_qnum',J,Skip,DoSort}
<[]> when call 'erlang':'=:=' (_1,'nested_loop') -> {'not_a_qnum','no',[],[]}
<_21> when call 'erlang':'=/=' (_1,'any') -> call 'erlang':'error' ('cannot_carry_out_join',[_1|[]])
<_22> when 'true' -> {'not_a_qnum','no',[],[]} end
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'opt_join_lu'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{J = {_X_Q1,_X_C1,Q2,_X_C2},[{'lookup_join',_X_KEols,JKE,Skip0}|_17]}|LJ],Qdata,LU_SkipQuals> when 'true' -> case call 'lists':'keyfind' (Q2,1,Qdata) of <{_18,_19,_20,{'gen',Prep2}}> when call 'erlang':'=:=' (_18,Q2) -> (case Prep2 of (<({'prepared',_rec88,_21,_22,_23,_24,_25,_26,_27,_28}-|['compiler_generated'] )> when 'true' -> case _rec88 of <{'qlc_table',_30,_31,_32,_33,_34,_35,LU_fun,_36,KE,_37,MS}> when 'true' -> let <_10> = case <> of (<> when call 'erlang':'=/=' (MS,'no_match_spec') -> let <_8> = call 'lists':'keymember' (Q2,1,LU_SkipQuals) in call 'erlang':'=:=' (_8,'false')-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end in case _10 of <'true'> when 'true' -> apply 'opt_join_lu'/3 (LJ,Qdata,LU_SkipQuals)
<'false'> when 'true' -> let <Skip> = apply 'skip_if_possible'/3 (JKE,KE,Skip0) in let <_12> = apply 'opt_join_lu'/3 (LJ,Qdata,LU_SkipQuals) in [{J,Skip,KE,LU_fun}|_12]
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','prepared'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<[],_X_Qdata,_X_LU_SkipQuals> when 'true' -> []
(<_16,_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14})-|[{'function_name',{'opt_join_lu',3}}] )-|['compiler_generated'] ) end
'opt_join_merge'/1 = fun (_0) -> let <_15> = letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[{_X_KpOrder_or_other,MJ}|_2]> when 'true' -> (letrec 'lc$^1'/1 = fun (_9) -> case _9 of <[{QCs,{'merge_join',DoSort,KE,Skip0}}|_4]> when 'true' -> (letrec 'lc$^2'/1 = fun (_10) -> case _10 of <[Skip|_6]> when 'true' -> let <_12> = call 'erlang':'length' (DoSort) in let <_13> = call 'erlang':'-' (_12) in let <_11> = call 'erlang':'length' (Skip) in let <_14> = apply 'lc$^2'/1 (_6) in ([{_13,_11,{QCs,{'merge_join',DoSort,KE,Skip}}}|_14]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^1'/1 (_4)
(<_26> when 'true' -> (primop 'match_fail' ({'function_clause',_26})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in let <_7> = apply 'skip_if_possible'/3 (KE,'==',Skip0) in apply 'lc$^2'/1 ([_7|[]])-|['list_comprehension'] )
(<[_3|_4]> when 'true' -> apply 'lc$^1'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_2)
(<_27> when 'true' -> (primop 'match_fail' ({'function_clause',_27})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (MJ)-|['list_comprehension'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_28> when 'true' -> (primop 'match_fail' ({'function_clause',_28})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <_22> = letrec 'lc$^3'/1 = fun (_20) -> case _20 of <[{_24,_25,J}|_18]> when 'true' -> let <_21> = apply 'lc$^3'/1 (_18) in ([J|_21]-|['compiler_generated'] )
(<[_17|_18]> when 'true' -> apply 'lc$^3'/1 (_18)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_29> when 'true' -> (primop 'match_fail' ({'function_clause',_29})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_19> = call 'lists':'sort' (_15) in apply 'lc$^3'/1 (_19) in call 'lists':'reverse' (_22)
'skip_if_possible'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'=:=','==',_6> when 'true' -> []
<_7,_8,{_X_SkipTag,Skip}> when 'true' -> Skip
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'skip_if_possible',3}}] )-|['compiler_generated'] ) end
'setup_qlc'/2 = fun (_0,_1) -> apply 'setup_le'/3 (_0,[],_1)
'setup_le'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'prepared',{'simple_qlc',_35,LE,_36,_37,Optz},_38,_39,_40,_41,_42,_43,_44,_45},Post0,Setup> when 'true' -> case apply 'setup_le'/3 (LE,Post0,Setup) of <{Objs,Post,LocalPost}> when 'true' -> apply 'unique_cache'/4 (Objs,Post,LocalPost,Optz)
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<{'prepared',{'qlc',QFun,_46,Qdata,V,Optz},_47,_48,_49,_50,_51,_52,_53,_54},Post0,Setup> when 'true' -> case apply 'setup_quals'/4 (Qdata,Post0,Setup,Optz) of <{GoTo,FirstState,Post,LocalPost}> when 'true' -> let <Objs> = fun () -> apply QFun (FirstState,V,GoTo) in apply 'unique_cache'/4 (Objs,Post,LocalPost,Optz)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<{'prepared',Table = {'qlc_table',_55,_56,_57,PostFun,_58,_59,_60,_61,_62,_63,_64},_65,_66,_67,_68,_69,_70,_71,_72},Post,Setup> when 'true' -> let <H> = apply 'table_handle'/3 (Table,Post,Setup) in {H,[PostFun|Post],[]}
<{'prepared',{'qlc_append',PrepL},_73,_74,_75,_76,_77,_78,_79,_80},Post0,Setup> when 'true' -> let <F> = fun (_10,_9) -> case <_10,_9> of <Prep,{Post1,LPost1}> when 'true' -> case apply 'setup_le'/3 (Prep,Post1,Setup) of <{Objs,Post2,LPost2}> when 'true' -> let <_8> = call 'erlang':'++' (LPost1,LPost2) in {Objs,{Post2,_8}}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'-setup_le/3-fun-1-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'mapfoldl' (F,{Post0,[]},PrepL) of <{ObjsL,{Post,LocalPost}}> when 'true' -> let <_15> = fun () -> apply 'append_loop'/2 (ObjsL,0) in {_15,Post,LocalPost}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<{'prepared',{'qlc_sort',Prep,Kp,Unique,Compressed,Order,SortOptions0,TmpUsage,TmpDir},_81,_82,_83,_84,_85,_86,_87,_88},Post0,Setup> when 'true' -> let <SortOptions> = apply 'sort_options_global_tmp'/2 (SortOptions0,TmpDir) in let <LF> = fun (_17) -> apply 'sort_list'/6 (_17,Order,Unique,Kp,SortOptions,Post0) in case apply 'setup_le'/3 (Prep,Post0,Setup) of <{L,Post,LocalPost}> when call 'erlang':'is_list' (L) -> let <_20> = apply LF (L) in {_20,Post,LocalPost}
<{Objs,Post,LocalPost}> when 'true' -> let <FF> = fun (_21) -> apply 'file_sort_handle'/7 (_21,Kp,SortOptions,TmpDir,Compressed,Post,LocalPost) in apply 'sort_handle'/7 (Objs,LF,FF,SortOptions,Post,LocalPost,{TmpUsage,'sorting'})
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end
<{'prepared',{'qlc_list',L,MS},_89,_90,_91,_92,_93,_94,_95,_96},Post,_X_Setup> when let <_25> = call 'erlang':'=:=' ('no_match_spec',MS) in let <_26> = call 'erlang':'=:=' (L,[]) in call 'erlang':'or' (_25,_26) -> {L,Post,[]}
<{'prepared',{'qlc_list',L,MS},_97,_98,_99,_100,_101,_102,_103,_104},Post,_X_Setup> when call 'erlang':'is_list' (L) -> let <_27> = call 'ets':'match_spec_compile' (MS) in let <_28> = call 'ets':'match_spec_run' (L,_27) in {_28,Post,[]}
<{'prepared',{'qlc_list',H0,MS},_105,_106,_107,_108,_109,_110,_111,_112},Post0,Setup> when 'true' -> case apply 'setup_le'/3 (H0,Post0,Setup) of <{Objs0,Post,LocalPost}> when 'true' -> let <_30> = call 'ets':'match_spec_compile' (MS) in let <Objs> = call 'ets':'match_spec_run' (Objs0,_30) in {Objs,Post,LocalPost}
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end
(<_34,_33,_32> when 'true' -> (primop 'match_fail' ({'function_clause',_34,_33,_32})-|[{'function_name',{'setup_le',3}}] )-|['compiler_generated'] ) end
'setup_quals'/4 = fun (_0,_1,_2,_3) -> case apply 'setup_quals'/6 (0,_0,[],_1,[],_2) of <{GoTo0,Post1,LocalPost0}> when 'true' -> let <GoTo1> = call 'lists':'keysort' (1,GoTo0) in let <FirstState0> = apply 'next_state'/1 (_0) in (case _3 of (<({'optz',_38,_39,_40,_rec89,_41}-|['compiler_generated'] )> when 'true' -> let <_30> = case _rec89 of <MJ = {'qlc_join',{'merge',_X_KE},Opt,_43,_44,C1,_45,_46,C2}> when 'true' -> let <MF> = fun (_13,_12,_11) -> case <_13,_12,_11> of <_X_Rev,{H1,WH1},{H2,WH2}> when 'true' -> (fun () -> let <_10> = apply WH1 (H1) in let <_9> = apply WH2 (H2) in apply 'merge_join'/5 (_10,C1,_9,C2,Opt)-|[{'id',{0,0,'-setup_quals/4-fun-0-'}}] )
(<_16,_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14})-|[{'function_name',{'-setup_quals/4-fun-1-',3}}] )-|['compiler_generated'] ) end in apply 'setup_join'/6 (MJ,_0,GoTo1,FirstState0,MF,Post1)
<LJ = {'qlc_join',{'lookup',_X_KE,LuF},_47,_48,_49,C1,_50,_51,C2}> when 'true' -> let <LF> = fun (_23,_22,_21) -> case <_23,_22,_21> of <Rev,{H1,WH1},{H2,WH2}> when 'true' -> let <_52,_53> = case <> of <> when (call 'erlang':'=:=' (Rev,'true')-|['compiler_generated'] ) -> <H2,WH2>
<> when 'true' -> <H1,WH1> end in (fun () -> let <_20> = apply (_53-|['compiler_generated'] ) ((_52-|['compiler_generated'] )) in apply 'lookup_join'/5 (_20,C1,LuF,C2,Rev)-|[{'id',{0,0,'-setup_quals/4-fun-2-'}}] )
(<_26,_25,_24> when 'true' -> (primop 'match_fail' ({'function_clause',_26,_25,_24})-|[{'function_name',{'-setup_quals/4-fun-3-',3}}] )-|['compiler_generated'] ) end in apply 'setup_join'/6 (LJ,_0,GoTo1,FirstState0,LF,Post1)
<'no'> when 'true' -> let <_28> = apply 'flat_goto'/1 (GoTo1) in {_28,FirstState0,Post1,[]}
(<_29> when 'true' -> primop 'match_fail' ({'case_clause',_29})-|['compiler_generated'] ) end in case _30 of <{GoTo2,FirstState,Post,LocalPost1}> when 'true' -> let <GoTo> = call 'erlang':'list_to_tuple' (GoTo2) in let <_33> = call 'erlang':'++' (LocalPost0,LocalPost1) in {GoTo,FirstState,Post,_33}
(<_31> when 'true' -> primop 'match_fail' ({'badmatch',_31})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_42> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'setup_quals'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <GenLoopS,[{_X_QNum,GoI,-1,'fil'}|Qdata],Gs,P,LP,Setup> when 'true' -> apply 'setup_quals'/6 (GenLoopS,Qdata,[{GoI,[-1|[-1]]}|Gs],P,LP,Setup)
<GenLoopS,[{_X_QNum,GoI,_X_SI,'fil'}|Qdata],Gs,P,LP,Setup> when 'true' -> let <_8> = apply 'next_state'/1 (Qdata) in apply 'setup_quals'/6 (GenLoopS,Qdata,[{GoI,[GenLoopS|[_8|[]]]}|Gs],P,LP,Setup)
<GenLoopS,[{_X_QNum,GoI,_X_SI,{'gen',{'join',_22,_23,_24,_25,_26,_27}}}|Qdata],Gs,P,LP,Setup> when 'true' -> apply 'setup_quals'/6 (GenLoopS,Qdata,[{GoI,[-1|[-1|[-1]]]}|Gs],P,LP,Setup)
<GenLoopS,[{_X_QNum,GoI,SI,{'gen',LE}}|Qdata],Gs,P,LP,Setup> when 'true' -> case apply 'setup_le'/3 (LE,P,Setup) of <{V,NP,LP1}> when 'true' -> let <_15> = call 'erlang':'+' (SI,1) in let <_14> = apply 'next_state'/1 (Qdata) in let <_13> = call 'erlang':'++' (LP,LP1) in apply 'setup_quals'/6 (_15,Qdata,[{GoI,[GenLoopS|[_14|[V|[]]]]}|Gs],NP,_13,Setup)
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<GenLoopS,[],Gs,P,LP,_X_Setup> when 'true' -> {[{1,[GenLoopS|[]]}|Gs],P,LP}
(<_21,_20,_19,_18,_17,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_21,_20,_19,_18,_17,_16})-|[{'function_name',{'setup_quals',6}}] )-|['compiler_generated'] ) end
'setup_join'/6 = fun (_0,_1,_2,_3,_4,_5) -> case _0 of <{'qlc_join',_70,Opt,_71,QNum1a,_72,_73,QNum2a,_74}> when 'true' -> case apply 'find_join_data'/3 (_1,QNum1a,QNum2a) of <{{_X_QN,JGoI,JSI,_75},Rev,QNum1,QNum2,WH1,WH2,_X_CsFun}> when 'true' -> let <_12> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[{QNum,GoI,SI,_76}|_9]> when call 'erlang':'=:=' (QNum,QNum1) -> let <_11> = apply 'lc$^0'/1 (_9) in ([{GoI,SI}|_11]-|['compiler_generated'] )
(<[_8|_9]> when 'true' -> apply 'lc$^0'/1 (_9)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_82> when 'true' -> (primop 'match_fail' ({'function_clause',_82})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1) in case _12 of <[{GoI1,SI1}|[]]> when 'true' -> let <_18> = letrec 'lc$^1'/1 = fun (_16) -> case _16 of <[{QNum,GoI,SI,_77}|_15]> when call 'erlang':'=:=' (QNum,QNum2) -> let <_17> = apply 'lc$^1'/1 (_15) in ([{GoI,SI}|_17]-|['compiler_generated'] )
(<[_14|_15]> when 'true' -> apply 'lc$^1'/1 (_15)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_83> when 'true' -> (primop 'match_fail' ({'function_clause',_83})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_1) in case _18 of <[{GoI2,SI2}|[]]> when 'true' -> let <_24> = letrec 'lc$^2'/1 = fun (_22) -> case _22 of <[{GoI,[_X_Back|[_X_Forth|[H|[]]]]}|_21]> when call 'erlang':'=:=' (GoI,GoI1) -> let <_23> = apply 'lc$^2'/1 (_21) in ([H|_23]-|['compiler_generated'] )
(<[_20|_21]> when 'true' -> apply 'lc$^2'/1 (_21)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_84> when 'true' -> (primop 'match_fail' ({'function_clause',_84})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (_2) in case _24 of <[H1|[]]> when 'true' -> let <_30> = letrec 'lc$^3'/1 = fun (_28) -> case _28 of <[{GoI,[Back|[_X_Forth|[H|[]]]]}|_27]> when call 'erlang':'=:=' (GoI,GoI2) -> let <_29> = apply 'lc$^3'/1 (_27) in ([{Back,H}|_29]-|['compiler_generated'] )
(<[_26|_27]> when 'true' -> apply 'lc$^3'/1 (_27)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_85> when 'true' -> (primop 'match_fail' ({'function_clause',_85})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (_2) in case _30 of <[{BackH2,H2}|[]]> when 'true' -> let <H0> = apply _4 (Rev,{H1,WH1},{H2,WH2}) in let <_33> = apply 'join_unique_cache'/1 (Opt) in case apply 'unique_cache'/4 (H0,_5,[],_33) of <{H,Post,LocalPost}> when 'true' -> let <_39> = letrec 'lc$^4'/1 = fun (_37) -> case _37 of <[{GoI,[Back|[_78|[_79|[]]]]}|_36]> when call 'erlang':'=:=' (GoI,GoI1) -> let <_38> = apply 'lc$^4'/1 (_36) in ([Back|_38]-|['compiler_generated'] )
(<[_35|_36]> when 'true' -> apply 'lc$^4'/1 (_36)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_86> when 'true' -> (primop 'match_fail' ({'function_clause',_86})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in apply 'lc$^4'/1 (_2) in case _39 of <[JBack|[]]> when 'true' -> let <JForth> = apply 'next_after'/3 (_1,SI1,QNum2) in let <_49> = fun (_47) -> case _47 of <{GoI,_80}> when call 'erlang':'=:=' (GoI,JGoI) -> {JGoI,[JBack|[JForth|[H|[]]]]}
<{GoI,_81}> when let <_42> = call 'erlang':'=:=' (GoI,GoI1) in let <_43> = call 'erlang':'=:=' (GoI,GoI2) in call 'erlang':'or' (_42,_43) -> {GoI,[-1|[-1|[-1]]]}
<Go> when 'true' -> Go end in let <GoTo1> = call 'lists':'map' (_49,_2) in let <_60> = fun (_58) -> case _58 of <S> when call 'erlang':'=:=' (_58,SI1) -> JSI
<S> when call 'erlang':'=:=' (_58,SI2) -> apply 'next_after'/3 (_1,S,QNum2)
<S> when try let <_52> = call 'erlang':'+' (SI1,1) in call 'erlang':'=:=' (_58,_52) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (JSI,1)
<S> when try let <_53> = call 'erlang':'+' (SI2,1) in let <_54> = call 'erlang':'=:=' (_58,_53) in let <_55> = call 'erlang':'+' (SI1,1) in let <_56> = call 'erlang':'=:=' (_55,BackH2) in call 'erlang':'and' (_54,_56) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (JSI,1)
<S> when try let <_57> = call 'erlang':'+' (SI2,1) in call 'erlang':'=:=' (_58,_57) of <Try> -> Try catch <T,R> -> 'false' -> BackH2
<S> when 'true' -> S end in let <_51> = apply 'flat_goto'/1 (GoTo1) in let <GoTo> = call 'lists':'map' (_60,_51) in let <_62> = case <> of <> when call 'erlang':'=:=' (SI1,_3) -> JSI
<> when 'true' -> _3 end in {GoTo,_62,Post,LocalPost}
(<_40> when 'true' -> primop 'match_fail' ({'badmatch',_40})-|['compiler_generated'] ) end
(<_34> when 'true' -> primop 'match_fail' ({'badmatch',_34})-|['compiler_generated'] ) end
(<_31> when 'true' -> primop 'match_fail' ({'badmatch',_31})-|['compiler_generated'] ) end
(<_25> when 'true' -> primop 'match_fail' ({'badmatch',_25})-|['compiler_generated'] ) end
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'join_unique_cache'/1 = fun (_0) -> case _0 of <Opt = {'qlc_opt',Unique,Cache,_2,_3,_4,_5,_6,_7}> when 'true' -> {'optz',Unique,Cache,'any','no',Opt}
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'join_unique_cache',1}}] )-|['compiler_generated'] ) end
'flat_goto'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{_5,L}> when 'true' -> L
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-flat_goto/1-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'flatmap' (_3,_0)
'next_after'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{_7,_8,S,_9}|Qdata],_10,QNum2> when call 'erlang':'=:=' (_10,S) -> case Qdata of <[{_11,_12,_13,_14}|Qdata1]> when call 'erlang':'=:=' (_11,QNum2) -> apply 'next_state'/1 (Qdata1)
<_15> when 'true' -> apply 'next_state'/1 (Qdata) end
<[_16|Qdata],S,QNum2> when 'true' -> apply 'next_after'/3 (Qdata,S,QNum2)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'next_after',3}}] )-|['compiler_generated'] ) end
'next_state'/1 = fun (_0) -> case _0 of <[{_2,_3,_4,{'gen',{'join',_5,_6,_7,_8,_9,_10}}}|Qdata]> when 'true' -> apply 'next_state'/1 (Qdata)
<[{_11,_12,-1,'fil'}|Qdata]> when 'true' -> apply 'next_state'/1 (Qdata)
<[{_13,_14,S,_15}|_16]> when 'true' -> S
<[]> when 'true' -> apply 'template_state'/0 ()
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'next_state',1}}] )-|['compiler_generated'] ) end
'find_join_data'/3 = fun (_0,_1,_2) -> let <_17> = letrec 'lc$^0'/1 = fun (_14) -> case _14 of <[Q = {_X_QN,_X_GoI,_X_SI,{'gen',{'join',_22,QN1,QN2,H1,H2,CsF}}}|_4]> when 'true' -> let <_13,Rev> = case <> of <> when let <_5> = call 'erlang':'=:=' (QN1,_1) in let <_6> = call 'erlang':'=:=' (QN2,_2) in call 'erlang':'and' (_5,_6) -> <'true',('false'-|['compiler_generated'] )>
<> when let <_9> = call 'erlang':'=:=' (QN1,_2) in let <_10> = call 'erlang':'=:=' (QN2,_1) in call 'erlang':'and' (_9,_10) -> <'true','true'>
<> when 'true' -> <'false','false'> end in (case _13 of <'true'> when 'true' -> let <_15> = apply 'lc$^0'/1 (_4) in ([{Q,Rev,QN1,QN2,H1,H2,CsF}|_15]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_3|_4]> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_24> when 'true' -> (primop 'match_fail' ({'function_clause',_24})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in case _17 of <[QRev|[]]> when 'true' -> QRev
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
'table_handle'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'qlc_table',TraverseFun,TravMS,PreFun,_27,_28,_29,LuF,ParentFun,_30,LuVals,MS},Post,Setup> when 'true' -> case Setup of <{'setup',Parent}> when 'true' -> let <_10> = case <> of <> when call 'erlang':'=:=' (ParentFun,'undefined') -> 'undefined'
<> when try let <_4> = call 'erlang':'self' () in call 'erlang':'=:=' (Parent,_4) of <Try> -> Try catch <T,R> -> 'false' -> try apply ParentFun () of <_5> -> _5 catch <_8,_7,_6> -> do apply 'post_funs'/1 (Post) primop 'raw_raise' (_8,_7,_6)
<> when 'true' -> case apply 'monitor_request'/2 (Parent,{'parent_fun',ParentFun}) of <'error'> when 'true' -> do apply 'post_funs'/1 (Post) call 'erlang':'exit' ('normal')
<{'value',Value}> when 'true' -> Value
<{'parent_fun_caught',Class,Reason,Stacktrace}> when 'true' -> do apply 'post_funs'/1 (Post) call 'erlang':'raise' (Class,Reason,Stacktrace)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end end in let <_15> = case <> of <> when try let <_12> = call 'erlang':'self' () in call 'erlang':'=:=' (Parent,_12) of <Try> -> Try catch <T,R> -> 'false' -> 'undefined'
<> when 'true' -> let <_13> = call 'erlang':'self' () in let <Cursor> = {'qlc_cursor',{_13,Parent}} in (fun () -> apply 'delete_cursor'/1 (Cursor)-|[{'id',{0,0,'-table_handle/3-fun-0-'}}] ) end in let <PreFunArgs> = [{'parent_value',_10}|[{'stop_fun',_15}|[]]] in do apply 'call'/4 (PreFun,PreFunArgs,('ok'-|['result_not_wanted'] ),Post) case LuVals of <{Pos,Vals}> when call 'erlang':'=:=' (MS,'no_match_spec') -> apply LuF (Pos,Vals)
<{Pos,Vals}> when 'true' -> case apply LuF (Pos,Vals) of <[]> when 'true' -> []
<Objs> when call 'erlang':'is_list' (Objs) -> let <_19> = call 'ets':'match_spec_compile' (MS) in call 'ets':'match_spec_run' (Objs,_19)
<Error> when 'true' -> do apply 'post_funs'/1 (Post) apply 'throw_error'/1 (Error) end
<_31> when (call 'erlang':'=:=' (TravMS,'false')-|['compiler_generated'] ) -> case <> of <> when call 'erlang':'=:=' (('no_match_spec'-|['compiler_generated'] ),MS) -> TraverseFun
(<> when 'true' -> primop 'match_fail' ({'badmatch','no_match_spec'})-|['compiler_generated'] ) end
<_33> when call 'erlang':'=:=' (MS,'no_match_spec') -> (fun () -> apply TraverseFun ([{'$1',[],['$1']}])-|[{'id',{0,0,'-table_handle/3-fun-1-'}}] )
<_34> when 'true' -> (fun () -> apply TraverseFun (MS)-|[{'id',{0,0,'-table_handle/3-fun-2-'}}] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_26,_25,_24> when 'true' -> (primop 'match_fail' ({'function_clause',_26,_25,_24})-|[{'function_name',{'table_handle',3}}] )-|['compiler_generated'] ) end
'open_file'/3 = fun (_0,_1,_2) -> case call 'file':'open' (_0,['read'|['raw'|['binary'|_1]]]) of <{'ok',Fd}> when 'true' -> let <_10> = fun () -> case call 'file':'position' (Fd,'bof') of <{'ok',0}> when 'true' -> let <TF> = fun (_4,_3) -> case <_4,_3> of <[],_15> when 'true' -> []
<Ts,C> when call 'erlang':'is_list' (Ts) -> call 'lists':'reverse' (Ts,C)
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'-open_file/3-fun-0-',2}}] )-|['compiler_generated'] ) end in apply 'file_loop_read'/4 (#{}#,65536,{Fd,_0},TF)
<Error> when 'true' -> apply 'file_error'/2 (_0,Error) end in {_10,Fd}
<Error> when 'true' -> do apply 'post_funs'/1 (_2) apply 'throw_file_error'/2 (_0,Error) end
'file_loop'/4 = fun (_0,_1,_2,_3) -> let <_9> = try apply 'file_loop2'/2 (_0,_2) of <_4> -> _4 catch <_7,_6,_5> -> case _1 of <{_X_Fd,FileName}> when 'true' -> apply 'error'/1 ({'bad_object',FileName})
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end in case _9 of <{'terms',Bin = #{#<Size>(4,8,'integer',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}#,[]}> when 'true' -> let <_10> = call 'erlang':'byte_size' (B) in let <_11> = call 'erlang':'-' (Size,_10) in let <_12> = call 'erlang':'+' (_11,4) in apply 'file_loop_read'/4 (Bin,_12,_1,_3)
<{'terms',Bin = #{#<Size>(4,8,'integer',['unsigned'|['big']]),#<_25>('all',8,'binary',['unsigned'|['big']])}#,Ts}> when 'true' -> let <C> = fun () -> let <_13> = call 'erlang':'+' (Size,4) in apply 'file_loop_read'/4 (Bin,_13,_1,_3) in apply _3 (Ts,C)
<{'terms',B,Ts}> when 'true' -> let <C> = fun () -> apply 'file_loop_read'/4 (B,65536,_1,_3) in apply _3 (Ts,C)
<Error> when 'true' -> Error end
'file_loop2'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<Size>(4,8,'integer',['unsigned'|['big']]),#<B>(Size,8,'binary',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,Ts> when 'true' -> let <_2> = call 'erlang':'binary_to_term' (B) in apply 'file_loop2'/2 (Bin,[_2|Ts])
<Bin,Ts> when 'true' -> {'terms',Bin,Ts} end
'file_loop_read'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <B,MinBytesToRead,Fd_FName = {Fd,FileName},TF> when 'true' -> let <BytesToRead> = call 'erlang':'max' (65536,MinBytesToRead) in case call 'file':'read' (Fd,BytesToRead) of <{'ok',Bin}> when try let <_6> = call 'erlang':'byte_size' (B) in call 'erlang':'=:=' (_6,0) of <Try> -> Try catch <T,R> -> 'false' -> apply 'file_loop'/4 (Bin,Fd_FName,[],TF)
<{'ok',Bin}> when 'true' -> case B of <#{#<Size>(4,8,'integer',['unsigned'|['big']]),#<Tl>('all',8,'binary',['unsigned'|['big']])}#> when try let <_8> = call 'erlang':'byte_size' (Bin) in let <_7> = call 'erlang':'byte_size' (Tl) in let <_9> = call 'erlang':'+' (_8,_7) in call 'erlang':'>=' (_9,Size) of <Try> -> Try catch <T,R> -> 'false' -> let <_10> = call 'erlang':'byte_size' (Tl) in let <_11> = call 'erlang':'-' (Size,_10) in case call 'erlang':'split_binary' (Bin,_11) of <{B1,B2}> when 'true' -> let <Foo> = fun (_14,_13) -> case <_14,_13> of <[T|[]],Fun> when 'true' -> [T|Fun]
(<_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15})-|[{'function_name',{'-file_loop_read/4-fun-0-',2}}] )-|['compiler_generated'] ) end in let <_18> = call 'erlang':'list_to_binary' ([B|[B1|[]]]) in case apply 'file_loop'/4 (_18,Fd_FName,[],Foo) of <[T|Fun]> when 'true' -> case call 'erlang':'is_function' (Fun) of <'true'> when 'true' -> apply 'file_loop'/4 (B2,Fd_FName,[T|[]],TF)
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<Error> when 'true' -> Error end
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<_29> when 'true' -> let <_21> = call 'erlang':'list_to_binary' ([B|[Bin|[]]]) in apply 'file_loop'/4 (_21,Fd_FName,[],TF) end
<'eof'> when try let <_23> = call 'erlang':'byte_size' (B) in call 'erlang':'=:=' (_23,0) of <Try> -> Try catch <T,R> -> 'false' -> apply TF ([],'foo')
<'eof'> when 'true' -> apply 'error'/1 ({'bad_object',FileName})
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end
(<_28,_27,_26,_25> when 'true' -> (primop 'match_fail' ({'function_clause',_28,_27,_26,_25})-|[{'function_name',{'file_loop_read',4}}] )-|['compiler_generated'] ) end
'sort_cursor_input'/2 = fun (_0,_1) -> (fun (_2) -> case _2 of <'close'> when 'true' -> 'ok'
<'read'> when 'true' -> apply 'sort_cursor_input_read'/2 (_0,_1)
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'-sort_cursor_input/2-fun-0-',1}}] )-|['compiler_generated'] ) end-|[{'id',{0,0,'-sort_cursor_input/2-fun-0-'}}] )
'sort_cursor_list_output'/3 = fun (_0,_1,_2) -> (fun (_11) -> case _11 of <'close'> when 'true' -> {'terms',[]}
<{'value',NoObjects}> when 'true' -> (fun (_9) -> case _9 of <BTerms> when let <_3> = call 'erlang':'=:=' (_2,'true') in let <_5> = try let <_4> = call 'erlang':'length' (_9) in call 'erlang':'=:=' (_4,NoObjects) of <Try> -> Try catch <T,R> -> 'false' in call 'erlang':'or' (_3,_5) -> (fun (_7) -> case _7 of <'close'> when 'true' -> {'terms',BTerms}
<BTerms1> when 'true' -> let <_6> = call 'erlang':'++' (BTerms,BTerms1) in apply 'sort_cursor_file'/3 (_6,_0,_1) end-|[{'id',{0,0,'-sort_cursor_list_output/3-fun-0-'}}] )
<BTerms> when 'true' -> apply 'sort_cursor_file'/3 (BTerms,_0,_1) end-|[{'id',{0,0,'-sort_cursor_list_output/3-fun-1-'}}] )
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'-sort_cursor_list_output/3-fun-2-',1}}] )-|['compiler_generated'] ) end-|[{'id',{0,0,'-sort_cursor_list_output/3-fun-2-'}}] )
'sort_cursor_file'/3 = fun (_0,_1,_2) -> let <FName> = apply 'tmp_filename'/1 (_1) in case call 'file':'open' (FName,['write'|['raw'|['binary'|_2]]]) of <{'ok',Fd}> when 'true' -> let <WFun> = apply 'write_terms'/2 (FName,Fd) in apply WFun (_0)
<Error> when 'true' -> apply 'throw_file_error'/2 (FName,Error) end
'sort_options_global_tmp'/2 = fun (_0,_1) -> case <_0,_1> of <S,[]> when 'true' -> S
<S,TmpDir> when 'true' -> let <_2> = call 'lists':'keydelete' ('tmpdir',1,S) in [{'tmpdir',TmpDir}|_2] end
'tmp_filename'/1 = fun (_0) -> let <Node> = call 'erlang':'node' () in let <Pid> = call 'os':'getpid' () in let <Unique> = call 'erlang':'unique_integer' () in let <F> = call 'lists':'concat' (['qlc'|[[95]|[Node|[[95]|[Pid|[[95]|[Unique|[]]]]]]]]) in let <_8> = case _0 of <[]> when 'true' -> case call 'file':'get_cwd' () of <{'ok',CurDir}> when 'true' -> CurDir
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<TDir> when 'true' -> TDir end in let <_10> = call 'filename':'absname' (_8) in call 'filename':'join' (_10,F)
'write_terms'/2 = fun (_0,_1) -> (fun (_6) -> case _6 of <'close'> when 'true' -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (_1)-|['result_not_wanted'] ) {'file',_0}
<BTerms> when 'true' -> let <_3> = apply 'size_bin'/2 (BTerms,[]) in case call 'file':'write' (_1,_3) of <'ok'> when 'true' -> apply 'write_terms'/2 (_0,_1)
<Error> when 'true' -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (_1)-|['result_not_wanted'] ) apply 'throw_file_error'/2 (_0,Error) end end-|[{'id',{0,0,'-write_terms/2-fun-0-'}}] )
'size_bin'/2 = fun (_0,_1) -> case <_0,_1> of <[],L> when 'true' -> L
<[BinTerm|BinTerms],L> when 'true' -> let <_2> = call 'erlang':'byte_size' (BinTerm) in let <_3> = #{#<_2>(4,8,'integer',['unsigned'|['big']])}# in apply 'size_bin'/2 (BinTerms,[L|[_3|BinTerm]])
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'size_bin',2}}] )-|['compiler_generated'] ) end
'sort_cursor_input_read'/2 = fun (_0,_1) -> case <_0,_1> of <[],NoObjects> when 'true' -> {'end_of_input',NoObjects}
<[Object|Cont],NoObjects> when 'true' -> let <_4> = call 'erlang':'term_to_binary' (Object) in let <_2> = call 'erlang':'+' (NoObjects,1) in let <_3> = apply 'sort_cursor_input'/2 (Cont,_2) in {[_4|[]],_3}
<F,NoObjects> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'sort_cursor_input_read'/2 (Objects,NoObjects)
<Term> when 'true' -> apply 'throw_error'/1 (Term) end end
'unique_cache'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L,Post,LocalPost,Optz> when call 'erlang':'is_list' (L) -> (case Optz of (<({'optz',_rec90,_56,_57,_58,_59}-|['compiler_generated'] )> when 'true' -> case _rec90 of <'true'> when 'true' -> let <_6> = apply 'unique_sort_list'/1 (L) in {_6,Post,LocalPost}
<'false'> when 'true' -> {L,Post,LocalPost}
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_60> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<H,Post,LocalPost,{'optz','false','false',_61,_62,_63}> when 'true' -> {H,Post,LocalPost}
<H,Post,LocalPost,{'optz','true','false',_64,_65,_66}> when 'true' -> let <E> = call 'ets':'new' ('qlc',['set'|['private']]) in let <_10> = fun () -> apply 'no_dups'/2 (H,E) in let <_9> = apply 'del_table'/1 (E) in {_10,[_9|Post],LocalPost}
<H,Post,LocalPost,{'optz','false','true',_67,_68,_69}> when 'true' -> let <E> = call 'ets':'new' ('qlc',['set'|['private']]) in case apply 'unique_cache_post'/1 (E) of <{L,P}> when 'true' -> let <_13> = fun () -> apply 'cache'/3 (H,E,LocalPost) in {_13,[P|Post],[L|[]]}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<H,Post,LocalPost,{'optz','true','true',_70,_71,_72}> when 'true' -> let <UT> = call 'ets':'new' ('qlc',['bag'|['private']]) in let <MT> = call 'ets':'new' ('qlc',['set'|['private']]) in case apply 'unique_cache_post'/1 (UT) of <{L1,P1}> when 'true' -> case apply 'unique_cache_post'/1 (MT) of <{L2,P2}> when 'true' -> let <_18> = fun () -> apply 'ucache'/4 (H,UT,MT,LocalPost) in {_18,[P1|[P2|Post]],[L1|[L2|[]]]}
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
<H,Post,LocalPost,Optz = {'optz','false','list',_73,_74,_75}> when 'true' -> let <Ref> = call 'erlang':'make_ref' () in let <F> = apply 'del_lcache'/1 (Ref) in (case Optz of (<({'optz',_76,_77,_78,_79,_rec91}-|['compiler_generated'] )> when 'true' -> case _rec91 of <{'qlc_opt',_81,_82,_83,_84,TmpDir,_85,MaxList,TmpUsage}> when 'true' -> let <_24> = fun () -> apply 'lcache'/6 (H,Ref,LocalPost,TmpDir,MaxList,TmpUsage) in {_24,[F|Post],[F|[]]}
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_80> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<H,Post0,LocalPost0,Optz = {'optz','true','list',_86,_87,_88}> when 'true' -> (case Optz of (<({'optz',_89,_90,_91,_92,_rec92}-|['compiler_generated'] )> when 'true' -> case _rec92 of <{'qlc_opt',_94,_95,_96,_97,TmpDir,_98,MaxList,TmpUsage}> when 'true' -> let <_30> = case <> of <> when call 'erlang':'>=' (MaxList,2147483648) -> 2147483647
<> when call 'erlang':'=:=' (MaxList,0) -> 1
<> when 'true' -> MaxList end in let <SortOptions> = [{'size',_30}|[{'tmpdir',TmpDir}|[]]] in let <USortOptions> = [{'unique','true'}|SortOptions] in let <TmpUsageM> = {TmpUsage,'caching'} in let <LF1> = fun (_35) -> call 'lists':'ukeysort' (1,_35) in let <FF1> = fun (_38) -> apply 'file_sort_handle'/7 (_38,{'keysort',1},USortOptions,TmpDir,[],Post0,LocalPost0) in let <_41> = apply 'tag_objects'/2 (H,1) in case apply 'sort_handle'/7 (_41,LF1,FF1,USortOptions,Post0,LocalPost0,TmpUsageM) of <{UH,Post1,LocalPost1}> when 'true' -> let <LF2> = fun (_43) -> call 'lists':'keysort' (2,_43) in let <FF2> = fun (_46) -> apply 'file_sort_handle'/7 (_46,{'keysort',2},SortOptions,TmpDir,[],Post1,LocalPost1) in case apply 'sort_handle'/7 (UH,LF2,FF2,SortOptions,Post1,LocalPost1,TmpUsageM) of <{SH,Post,LocalPost}> when 'true' -> case <> of <> when call 'erlang':'is_list' (SH) -> let <_50> = apply 'untag_objects2'/1 (SH) in {_50,Post,LocalPost}
<> when 'true' -> let <_51> = fun () -> apply 'untag_objects'/1 (SH) in {_51,Post,LocalPost} end
(<_49> when 'true' -> primop 'match_fail' ({'badmatch',_49})-|['compiler_generated'] ) end
(<_42> when 'true' -> primop 'match_fail' ({'badmatch',_42})-|['compiler_generated'] ) end
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_93> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','optz'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_55,_54,_53,_52> when 'true' -> (primop 'match_fail' ({'function_clause',_55,_54,_53,_52})-|[{'function_name',{'unique_cache',4}}] )-|['compiler_generated'] ) end
'unique_cache_post'/1 = fun (_0) -> let <_2> = apply 'empty_table'/1 (_0) in let <_1> = apply 'del_table'/1 (_0) in {_2,_1}
'unique_sort_list'/1 = fun (_0) -> let <E> = call 'ets':'new' ('qlc',['set'|['private']]) in apply 'unique_list'/2 (_0,E)
'unique_list'/2 = fun (_0,_1) -> case <_0,_1> of <[],E> when 'true' -> case call 'ets':'delete' (E) of <'true'> when 'true' -> []
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[Object|Objects],E> when 'true' -> case call 'ets':'member' (E,Object) of <'false'> when 'true' -> case call 'ets':'insert' (E,{Object}) of <'true'> when 'true' -> let <_4> = apply 'unique_list'/2 (Objects,E) in [Object|_4]
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'true'> when 'true' -> apply 'unique_list'/2 (Objects,E)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'unique_list',2}}] )-|['compiler_generated'] ) end
'sort_list'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <L,CFun,'true','sort',_X_SortOptions,_X_Post> when call 'erlang':'is_function' (CFun) -> call 'lists':'usort' (CFun,L)
<L,CFun,'false','sort',_X_SortOptions,_X_Post> when call 'erlang':'is_function' (CFun) -> call 'lists':'sort' (CFun,L)
<L,'ascending','true','sort',_X_SortOptions,_X_Post> when 'true' -> call 'lists':'usort' (L)
<L,'descending','true','sort',_X_SortOptions,_X_Post> when 'true' -> let <_6> = call 'lists':'usort' (L) in call 'lists':'reverse' (_6)
<L,'ascending','false','sort',_X_SortOptions,_X_Post> when 'true' -> call 'lists':'sort' (L)
<L,'descending','false','sort',_X_SortOptions,_X_Post> when 'true' -> let <_7> = call 'lists':'sort' (L) in call 'lists':'reverse' (_7)
<L,Order,Unique,{'keysort',Kp},_X_SortOptions,_X_Post> when let <_8> = call 'erlang':'is_integer' (Kp) in let <_9> = call 'erlang':'is_atom' (Order) in call 'erlang':'and' (_8,_9) -> case <Order,Unique> of <'ascending','true'> when 'true' -> call 'lists':'ukeysort' (Kp,L)
<'ascending','false'> when 'true' -> call 'lists':'keysort' (Kp,L)
<'descending','true'> when 'true' -> let <_10> = call 'lists':'ukeysort' (Kp,L) in call 'lists':'reverse' (_10)
<'descending','false'> when 'true' -> let <_11> = call 'lists':'keysort' (Kp,L) in call 'lists':'reverse' (_11)
(<(_29-|['compiler_generated'] ),(_30-|['compiler_generated'] )> when 'true' -> let <_12> = {(_29-|['compiler_generated'] ),(_30-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
<L,_X_Order,_X_Unique,Sort,SortOptions,Post> when 'true' -> let <In> = fun (_16) -> let <_15> = fun (_13) -> 'end_of_input' in {L,_15} in let <Out> = apply 'sort_list_output'/1 ([]) in let <TSortOptions> = [{'format','term'}|SortOptions] in apply 'do_sort'/5 (In,Out,Sort,TSortOptions,Post) end
'sort_list_output'/1 = fun (_0) -> (fun (_2) -> case _2 of <'close'> when 'true' -> let <_1> = call 'lists':'reverse' (_0) in call 'lists':'append' (_1)
<Terms> when call 'erlang':'is_list' (_2) -> apply 'sort_list_output'/1 ([Terms|_0])
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'-sort_list_output/1-fun-0-',1}}] )-|['compiler_generated'] ) end-|[{'id',{0,0,'-sort_list_output/1-fun-0-'}}] )
'sort_handle'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <_8> = case call 'lists':'keyfind' ('size',1,_3) of <{'size',Size0}> when 'true' -> Size0
<'false'> when 'true' -> apply 'default_option'/1 ('size')
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end in apply 'sort_cache'/4 (_0,[],_8,{_1,_2,_4,_5,_6})
'sort_cache'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],CL,_X_Sz,{LF,_X_FF,Post,LocalPost,_X_TmpUsageM}> when 'true' -> let <_4> = call 'lists':'reverse' (CL) in let <_5> = apply LF (_4) in {_5,Post,LocalPost}
<Objs,CL,Sz,C> when call 'erlang':'<' (Sz,0) -> apply 'sort_cache2'/4 (Objs,CL,'false',C)
<[Object|Cont],CL,Sz0,C> when 'true' -> let <Sz> = apply 'decr_list_size'/2 (Sz0,Object) in apply 'sort_cache'/4 (Cont,[Object|CL],Sz,C)
<F,CL,Sz,C> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'sort_cache'/4 (Objects,CL,Sz,C)
<Term> when 'true' -> case C of <{_X_LF,_X_FF,Post,_X_LocalPost,_X_TmpUsageM}> when 'true' -> do apply 'post_funs'/1 (Post) apply 'throw_error'/1 (Term)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end end end
'sort_cache2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],CL,_X_X,{LF,_X_FF,Post,LocalPost,_X_TmpUsageM}> when 'true' -> let <_4> = call 'lists':'reverse' (CL) in let <_5> = apply LF (_4) in {_5,Post,LocalPost}
<[Object|Cont],CL,_13,C> when 'true' -> apply 'sort_cache2'/4 (Cont,[Object|CL],'true',C)
<F,CL,'false',C> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'sort_cache2'/4 (Objects,CL,'true',C)
<Term> when 'true' -> case C of <{_X_LF,_X_FF,Post,_X_LocalPost,_X_TmpUsageM}> when 'true' -> do apply 'post_funs'/1 (Post) apply 'throw_error'/1 (Term)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end end
<_X_Cont,_X_CL,'true',{_X_LF,_X_FF,Post,_X_LocalPost,{'not_allowed',M}}> when 'true' -> do apply 'post_funs'/1 (Post) apply 'throw_reason'/1 ({'tmpdir_usage',M})
<Cont,CL,'true',{_X_LF,FF,_X_Post,_X_LocalPost,{TmpUsage,M}}> when 'true' -> do apply 'maybe_error_logger'/2 (TmpUsage,M) let <_8> = call 'lists':'reverse' (CL,Cont) in apply FF (_8)
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'sort_cache2',4}}] )-|['compiler_generated'] ) end
'file_sort_handle'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <In> = apply 'sort_cursor_input'/2 (_0,0) in let <_10> = case call 'lists':'member' ('unique',_2) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> call 'lists':'keymember' ('unique',1,_2)-|['compiler_generated'] )
(<_8> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_8}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <Out> = apply 'sort_cursor_list_output'/3 (_3,_4,_10) in case apply 'do_sort'/5 (In,Out,_1,_2,_5) of <{'file',FileName}> when 'true' -> case apply 'open_file'/3 (FileName,_4,_5) of <{F,Fd}> when 'true' -> let <P> = fun () -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (Fd)-|['result_not_wanted'] ) (call ('file'-|['result_not_wanted'] ):('delete'-|['result_not_wanted'] ) (FileName)-|['result_not_wanted'] ) in {F,[P|_5],_6}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<{'terms',BTerms}> when 'true' -> try let <_23> = letrec 'lc$^1'/1 = fun (_20) -> case _20 of <[B|_19]> when 'true' -> let <_21> = call 'erlang':'binary_to_term' (B) in let <_22> = apply 'lc$^1'/1 (_19) in ([_21|_22]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_39> when 'true' -> (primop 'match_fail' ({'function_clause',_39})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (BTerms) in {_23,_5,_6} of <_24> -> _24 catch <_27,_26,_25> -> do apply 'post_funs'/1 (_5) primop 'raw_raise' (_27,_26,_25)
(<_28> when 'true' -> primop 'match_fail' ({'case_clause',_28})-|['compiler_generated'] ) end
'do_sort'/5 = fun (_0,_1,_2,_3,_4) -> try case apply 'do_sort'/4 (_0,_1,_2,_3) of <{'error',Reason}> when 'true' -> apply 'throw_reason'/1 (Reason)
<Reply> when 'true' -> Reply end of <_6> -> _6 catch <_9,_8,_7> -> do apply 'post_funs'/1 (_4) primop 'raw_raise' (_9,_8,_7)
'do_sort'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <In,Out,'sort',SortOptions> when 'true' -> call 'file_sorter':'sort' (In,Out,SortOptions)
<In,Out,{'keysort',KeyPos},SortOptions> when 'true' -> call 'file_sorter':'keysort' (KeyPos,In,Out,SortOptions)
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'do_sort',4}}] )-|['compiler_generated'] ) end
'del_table'/1 = fun (_0) -> (fun () -> let <_3> = call 'ets':'delete' (_0) in case _3 of <'true'> when 'true' -> (_3-|['compiler_generated'] )
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end-|[{'id',{0,0,'-del_table/1-fun-0-'}}] )
'empty_table'/1 = fun (_0) -> (fun () -> let <_3> = call 'ets':'delete_all_objects' (_0) in case _3 of <'true'> when 'true' -> (_3-|['compiler_generated'] )
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end-|[{'id',{0,0,'-empty_table/1-fun-0-'}}] )
'append_loop'/2 = fun (_0,_1) -> case <_0,_1> of <[L = [_4|_5]|[]],_X_N> when 'true' -> L
<[F|[]],_X_N> when 'true' -> apply F ()
<[L|Hs],N> when 'true' -> apply 'append_loop'/3 (L,N,Hs)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'append_loop',2}}] )-|['compiler_generated'] ) end
'append_loop'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],N,Hs> when 'true' -> apply 'append_loop'/2 (Hs,N)
<[Object|Cont],N,Hs> when 'true' -> let <_3> = call 'erlang':'+' (N,1) in let <_4> = apply 'append_loop'/3 (Cont,_3,Hs) in [Object|_4]
<F,0,Hs> when 'true' -> case apply F () of <[]> when 'true' -> apply 'append_loop'/2 (Hs,0)
<[Object|Cont]> when 'true' -> let <_5> = apply 'append_loop'/3 (Cont,1,Hs) in [Object|_5]
<Term> when 'true' -> Term end
<F,_X_N,Hs> when 'true' -> (fun () -> apply 'append_loop'/3 (F,0,Hs)-|[{'id',{0,0,'-append_loop/3-fun-0-'}}] ) end
'no_dups'/2 = fun (_0,_1) -> case <_0,_1> of <Cont = [],UTab> when 'true' -> case call 'ets':'delete_all_objects' (UTab) of <'true'> when 'true' -> Cont
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[Object|Cont],UTab> when 'true' -> case call 'ets':'member' (UTab,Object) of <'false'> when 'true' -> case call 'ets':'insert' (UTab,{Object}) of <'true'> when 'true' -> let <_4> = fun () -> apply 'no_dups'/2 (Cont,UTab) in [Object|_4]
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'true'> when 'true' -> apply 'no_dups'/2 (Cont,UTab)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<F,UTab> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'no_dups'/2 (Objects,UTab)
<Term> when 'true' -> Term end end
'cache'/3 = fun (_0,_1,_2) -> case call 'ets':'member' (_1,0) of <'false'> when 'true' -> case call 'ets':'insert' (_1,{0}) of <'true'> when 'true' -> apply 'cache'/4 (_0,_1,1,_2)
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'true'> when 'true' -> apply 'cache_recall'/2 (_1,1)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'cache'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Cont = [],_X_MTab,_X_SeqNo,LocalPost> when 'true' -> do apply 'local_post'/1 (LocalPost) Cont
<[Object|Cont],MTab,SeqNo,LocalPost> when 'true' -> case call 'ets':'insert' (MTab,{SeqNo,Object}) of <'true'> when 'true' -> let <_6> = fun () -> let <_5> = call 'erlang':'+' (SeqNo,1) in apply 'cache'/4 (Cont,MTab,_5,LocalPost) in [Object|_6]
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<F,MTab,SeqNo,LocalPost> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'cache'/4 (Objects,MTab,SeqNo,LocalPost)
<Term> when 'true' -> Term end end
'cache_recall'/2 = fun (_0,_1) -> case call 'ets':'lookup' (_0,_1) of <Cont = []> when 'true' -> Cont
<[{_7,Object}|[]]> when call 'erlang':'=:=' (_7,_1) -> let <_3> = fun () -> let <_2> = call 'erlang':'+' (_1,1) in apply 'cache_recall'/2 (_0,_2) in [Object|_3]
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'ucache'/4 = fun (_0,_1,_2,_3) -> case call 'ets':'member' (_2,0) of <'false'> when 'true' -> case call 'ets':'insert' (_2,{0}) of <'true'> when 'true' -> apply 'ucache'/5 (_0,_1,_2,1,_3)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<'true'> when 'true' -> apply 'ucache_recall'/3 (_1,_2,1)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'ucache'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Cont = [],_X_UTab,_X_MTab,_X_SeqNo,LocalPost> when 'true' -> do apply 'local_post'/1 (LocalPost) Cont
<[Object|Cont],UTab,MTab,SeqNo,LocalPost> when 'true' -> let <Hash> = call 'erlang':'phash2' (Object) in case call 'ets':'lookup' (UTab,Hash) of <[]> when 'true' -> apply 'ucache3'/7 (Object,Cont,Hash,UTab,MTab,SeqNo,LocalPost)
<HashSeqObjects> when 'true' -> case call 'lists':'keymember' (Object,3,HashSeqObjects) of <'true'> when 'true' -> apply 'ucache'/5 (Cont,UTab,MTab,SeqNo,LocalPost)
<'false'> when 'true' -> apply 'ucache3'/7 (Object,Cont,Hash,UTab,MTab,SeqNo,LocalPost)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end end
<F,UTab,MTab,SeqNo,LocalPost> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'ucache'/5 (Objects,UTab,MTab,SeqNo,LocalPost)
<Term> when 'true' -> Term end end
'ucache3'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case call 'ets':'insert' (_3,{_2,_5,_0}) of <'true'> when 'true' -> case call 'ets':'insert' (_4,{_5,_2}) of <'true'> when 'true' -> let <_10> = fun () -> let <_9> = call 'erlang':'+' (_5,1) in apply 'ucache'/5 (_1,_3,_4,_9,_6) in [_0|_10]
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
'ucache_recall'/3 = fun (_0,_1,_2) -> case call 'ets':'lookup' (_1,_2) of <Cont = []> when 'true' -> Cont
<[{_13,Hash}|[]]> when call 'erlang':'=:=' (_13,_2) -> let <_5> = case call 'ets':'lookup' (_0,Hash) of <[{_14,_15,Object0}|[]]> when let <_16> = call 'erlang':'=:=' (_14,Hash) in let <_17> = call 'erlang':'=:=' (_15,_2) in call 'erlang':'and' (_16,_17) -> Object0
<HashSeqObjects> when 'true' -> case call 'lists':'keyfind' (_2,2,HashSeqObjects) of <{_18,_19,Object0}> when let <_20> = call 'erlang':'=:=' (_18,Hash) in let <_21> = call 'erlang':'=:=' (_19,_2) in call 'erlang':'and' (_20,_21) -> Object0
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end end in let <_8> = fun () -> let <_7> = call 'erlang':'+' (_2,1) in apply 'ucache_recall'/3 (_0,_1,_7) in [_5|_8]
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
'lcache'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <Key> = {_1,'$_qlc_cache_tmpfiles_'} in case call 'erlang':'get' (Key) of <'undefined'> when 'true' -> apply 'lcache1'/4 (_0,{Key,_2,_3,_4,_5},_4,[])
<{'file',_X_Fd,_X_TmpFile,F}> when 'true' -> apply F ()
<L> when call 'erlang':'is_list' (L) -> L
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
'lcache1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Cont = [],{Key,LocalPost,_X_TmpDir,_X_MaxList,_X_TmpUsage},_X_Sz,Acc> when 'true' -> do apply 'local_post'/1 (LocalPost) case call 'erlang':'get' (Key) of <'undefined'> when 'true' -> let <_4> = call 'lists':'reverse' (Acc) in do call 'erlang':'put' (Key,_4) Cont
<{'file',Fd,TmpFile,_X_F}> when 'true' -> case apply 'lcache_write'/3 (Fd,TmpFile,Acc) of <'ok'> when 'true' -> Cont
<Error> when 'true' -> Error end
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<H,State,Sz,Acc> when call 'erlang':'<' (Sz,0) -> case State of <{Key,LocalPost,TmpDir,MaxList,TmpUsage}> when 'true' -> let <_11> = case call 'erlang':'get' (Key) of <{'file',Fd0,TmpFile,_X_F}> when 'true' -> {TmpFile,Fd0}
<'undefined'> when call 'erlang':'=:=' (TmpUsage,'not_allowed') -> apply 'error'/1 ({'tmpdir_usage','caching'})
<'undefined'> when 'true' -> do apply 'maybe_error_logger'/2 (TmpUsage,'caching') let <FName> = apply 'tmp_filename'/1 (TmpDir) in case apply 'open_file'/3 (FName,['write'],LocalPost) of <{F,Fd0}> when 'true' -> do call 'erlang':'put' (Key,{'file',Fd0,FName,F}) {FName,Fd0}
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end in case _11 of <{FileName,Fd}> when 'true' -> case apply 'lcache_write'/3 (Fd,FileName,Acc) of <'ok'> when 'true' -> apply 'lcache1'/4 (H,State,MaxList,[])
<Error> when 'true' -> Error end
<Error> when 'true' -> Error end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<[Object|Cont],State,Sz0,Acc> when 'true' -> let <Sz> = apply 'decr_list_size'/2 (Sz0,Object) in let <_16> = apply 'lcache2'/4 (Cont,State,Sz,[Object|Acc]) in [Object|_16]
<F,State,Sz,Acc> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'lcache1'/4 (Objects,State,Sz,Acc)
<Term> when 'true' -> Term end end
'lcache2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[Object|Cont],State,Sz0,Acc> when call 'erlang':'>=' (Sz0,0) -> let <Sz> = apply 'decr_list_size'/2 (Sz0,Object) in let <_5> = apply 'lcache2'/4 (Cont,State,Sz,[Object|Acc]) in [Object|_5]
<Cont,State,Sz,Acc> when 'true' -> (fun () -> apply 'lcache1'/4 (Cont,State,Sz,Acc)-|[{'id',{0,0,'-lcache2/4-fun-0-'}}] ) end
'lcache_write'/3 = fun (_0,_1,_2) -> let <_3> = apply 't2b'/2 (_2,[]) in apply 'write_binary_terms'/3 (_3,_0,_1)
't2b'/2 = fun (_0,_1) -> case <_0,_1> of <[],Bs> when 'true' -> Bs
<[T|Ts],Bs> when 'true' -> let <_2> = call 'erlang':'term_to_binary' (T) in apply 't2b'/2 (Ts,[_2|Bs])
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'t2b',2}}] )-|['compiler_generated'] ) end
'del_lcache'/1 = fun (_0) -> (fun () -> let <Key> = {_0,'$_qlc_cache_tmpfiles_'} in case call 'erlang':'get' (Key) of <'undefined'> when 'true' -> 'ok'
<{'file',Fd,TmpFile,_X_F}> when 'true' -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (Fd)-|['result_not_wanted'] ) do (call ('file'-|['result_not_wanted'] ):('delete'-|['result_not_wanted'] ) (TmpFile)-|['result_not_wanted'] ) call 'erlang':'erase' (Key)
<_X_L> when 'true' -> call 'erlang':'erase' (Key) end-|[{'id',{0,0,'-del_lcache/1-fun-0-'}}] )
'tag_objects'/2 = fun (_0,_1) -> case <_0,_1> of <[Object|Cont],T> when 'true' -> let <_2> = call 'erlang':'+' (T,1) in let <_3> = apply 'tag_objects2'/2 (Cont,_2) in [{Object,T}|_3]
<Cont = [],_X_T> when 'true' -> Cont
<F,T> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'tag_objects'/2 (Objects,T)
<Term> when 'true' -> Term end end
'tag_objects2'/2 = fun (_0,_1) -> case <_0,_1> of <[Object|Cont],T> when 'true' -> let <_2> = call 'erlang':'+' (T,1) in let <_3> = apply 'tag_objects2'/2 (Cont,_2) in [{Object,T}|_3]
<Objects,T> when 'true' -> (fun () -> apply 'tag_objects'/2 (Objects,T)-|[{'id',{0,0,'-tag_objects2/2-fun-0-'}}] ) end
'untag_objects'/1 = fun (_0) -> case _0 of <Objs = []> when 'true' -> Objs
<[{Object,_X_N}|Cont]> when 'true' -> let <_1> = apply 'untag_objects2'/1 (Cont) in [Object|_1]
<F> when 'true' -> case apply F () of <Objects> when call 'erlang':'is_list' (Objects) -> apply 'untag_objects'/1 (Objects)
<Term> when 'true' -> Term end end
'untag_objects2'/1 = fun (_0) -> case _0 of <[{Object,_X_N}|Cont]> when 'true' -> let <_1> = apply 'untag_objects2'/1 (Cont) in [Object|_1]
<Cont = []> when 'true' -> Cont
<Objects> when 'true' -> (fun () -> apply 'untag_objects'/1 (Objects)-|[{'id',{0,0,'-untag_objects2/1-fun-0-'}}] ) end
'merge_join'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Cont = [],_X_C1,_X_T2,_X_C2,_X_Opt> when 'true' -> Cont
<[E1|L1],C1,L2,C2,Opt> when 'true' -> case Opt of <{'qlc_opt',_15,_16,_17,_18,TmpDir,_19,MaxList,TmpUsage}> when 'true' -> let <_6> = apply 'merge_join_id'/0 () in let <M> = {'m',_6,TmpDir,MaxList,TmpUsage} in let <_8> = call 'erlang':'element' (C1,E1) in apply 'merge_join2'/7 (E1,_8,L1,C1,L2,C2,M)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<F1,C1,L2,C2,Opt> when 'true' -> case apply F1 () of <L1> when call 'erlang':'is_list' (L1) -> apply 'merge_join'/5 (L1,C1,L2,C2,Opt)
<T1> when 'true' -> T1 end end
'merge_join1'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <_X_E2,_X_K2,Cont = [],_X_C1,_X_L2,_X_C2,M> when 'true' -> apply 'end_merge_join'/2 (Cont,M)
<E2,K2,[E1|L1],C1,L2,C2,M> when 'true' -> let <K1> = call 'erlang':'element' (C1,E1) in case <> of <> when call 'erlang':'==' (K1,K2) -> apply 'same_keys2'/8 (E1,K1,L1,C1,L2,C2,E2,M)
<> when call 'erlang':'>' (K1,K2) -> apply 'merge_join2'/7 (E1,K1,L1,C1,L2,C2,M)
<> when 'true' -> apply 'merge_join1'/7 (E2,K2,L1,C1,L2,C2,M) end
<E2,K2,F1,C1,L2,C2,M> when 'true' -> case apply F1 () of <L1> when call 'erlang':'is_list' (L1) -> apply 'merge_join1'/7 (E2,K2,L1,C1,L2,C2,M)
<T1> when 'true' -> T1 end end
'merge_join2'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <_X_E1,_X_K1,_X_L1,_X_C1,Cont = [],_X_C2,M> when 'true' -> apply 'end_merge_join'/2 (Cont,M)
<E1,K1,L1,C1,[E2|L2],C2,M> when 'true' -> let <K2> = call 'erlang':'element' (C2,E2) in case <> of <> when call 'erlang':'==' (K1,K2) -> apply 'same_keys2'/8 (E1,K1,L1,C1,L2,C2,E2,M)
<> when call 'erlang':'>' (K1,K2) -> apply 'merge_join2'/7 (E1,K1,L1,C1,L2,C2,M)
<> when 'true' -> apply 'merge_join1'/7 (E2,K2,L1,C1,L2,C2,M) end
<E1,K1,L1,C1,F2,C2,M> when 'true' -> case apply F2 () of <L2> when call 'erlang':'is_list' (L2) -> apply 'merge_join2'/7 (E1,K1,L1,C1,L2,C2,M)
<T2> when 'true' -> T2 end end
'same_keys2'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case <_0,_1,_2,_3,_4,_5,_6,_7> of <E1,K1,L1,C1,[],_X_C2,E2_0,M> when 'true' -> let <Cont> = fun (_8) -> apply 'end_merge_join'/2 ([],M) in apply 'loop_same_keys'/7 (E1,K1,L1,C1,[E2_0|[]],Cont,M)
<E1,K1,L1,C1,L2_0 = [E2|L2],C2,E2_0,M> when 'true' -> let <K2> = call 'erlang':'element' (C2,E2) in case <> of <> when call 'erlang':'==' (K1,K2) -> apply 'same_keys1'/9 (E1,K1,L1,C1,E2,C2,E2_0,L2,M)
<> when call 'erlang':'<' (K1,K2) -> let <_12> = fun () -> apply 'same_loop1'/7 (L1,K1,C1,E2_0,L2_0,C2,M) in [[E1|E2_0]|_12]
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<E1,K1,L1,C1,F2,C2,E2_0,M> when 'true' -> case apply F2 () of <L2> when call 'erlang':'is_list' (L2) -> apply 'same_keys2'/8 (E1,K1,L1,C1,L2,C2,E2_0,M)
<T2> when 'true' -> let <Cont> = fun (_13) -> T2 in apply 'loop_same_keys'/7 (E1,K1,L1,C1,[E2_0|[]],Cont,M) end end
'same_loop1'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[],_X_K1_0,_X_C1,_X_E2_0,_X_L2,_X_C2,M> when 'true' -> apply 'end_merge_join'/2 ([],M)
<[E1|L1],K1_0,C1,E2_0,L2,C2,M> when 'true' -> let <K1> = call 'erlang':'element' (C1,E1) in case <> of <> when call 'erlang':'==' (K1,K1_0) -> let <_8> = fun () -> apply 'same_loop1'/7 (L1,K1_0,C1,E2_0,L2,C2,M) in [[E1|E2_0]|_8]
<> when call 'erlang':'<' (K1_0,K1) -> apply 'merge_join2'/7 (E1,K1,L1,C1,L2,C2,M)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<F1,K1_0,C1,E2_0,L2,C2,M> when 'true' -> case apply F1 () of <L1> when call 'erlang':'is_list' (L1) -> apply 'same_loop1'/7 (L1,K1_0,C1,E2_0,L2,C2,M)
<T1> when 'true' -> T1 end end
'same_keys1'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> case <_0,_1,_2,_3,_4,_5,_6,_7,_8> of <E1_0,K1_0,L1 = [],C1,E2,C2,E2_0,L2,M> when 'true' -> let <_9> = fun () -> apply 'same_keys'/7 (K1_0,E1_0,L1,C1,L2,C2,M) in [[E1_0|E2_0]|[[E1_0|E2]|_9]]
<E1_0,K1_0,L1 = [E1|_27],C1,E2,C2,E2_0,L2,M> when 'true' -> let <K1> = call 'erlang':'element' (C1,E1) in case <> of <> when call 'erlang':'==' (K1_0,K1) -> let <E2s> = [E2|[E2_0|[]]] in (case M of (<({'m',_28,_29,_rec93,_30}-|['compiler_generated'] )> when 'true' -> let <Sz0> = apply 'decr_list_size'/2 (_rec93,E2s) in apply 'same_keys_cache'/9 (E1_0,K1_0,L1,C1,L2,C2,E2s,Sz0,M)-|['compiler_generated'] )
(<_31> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','m'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<> when call 'erlang':'<' (K1_0,K1) -> let <_15> = fun () -> apply 'same_keys'/7 (K1_0,E1_0,L1,C1,L2,C2,M) in [[E1_0|E2_0]|[[E1_0|E2]|_15]]
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<E1_0,K1_0,F1,C1,E2,C2,E2_0,L2,M> when 'true' -> case apply F1 () of <L1> when call 'erlang':'is_list' (L1) -> apply 'same_keys1'/9 (E1_0,K1_0,L1,C1,E2,C2,E2_0,L2,M)
<T1> when 'true' -> let <Cont> = fun () -> T1 in apply 'loop_same'/3 (E1_0,[E2|[E2_0|[]]],Cont) end end
'same_keys'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <_X_K1,_X_E1,_X_L1,_X_C1,Cont = [],_X_C2,M> when 'true' -> apply 'end_merge_join'/2 (Cont,M)
<K1,E1,L1,C1,[E2|L2],C2,M> when 'true' -> let <K2> = call 'erlang':'element' (C2,E2) in case <> of <> when call 'erlang':'==' (K1,K2) -> let <_8> = fun () -> apply 'same_keys'/7 (K1,E1,L1,C1,L2,C2,M) in [[E1|E2]|_8]
<> when call 'erlang':'<' (K1,K2) -> apply 'merge_join1'/7 (E2,K2,L1,C1,L2,C2,M)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<K1,E1,L1,C1,F2,C2,M> when 'true' -> case apply F2 () of <L2> when call 'erlang':'is_list' (L2) -> apply 'same_keys'/7 (K1,E1,L1,C1,L2,C2,M)
<T2> when 'true' -> T2 end end
'same_keys_cache'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> case <_0,_1,_2,_3,_4,_5,_6,_7,_8> of <E1,K1,L1,C1,[],_X_C2,E2s,_X_Sz,M> when 'true' -> let <Cont> = fun (_9) -> apply 'end_merge_join'/2 ([],M) in apply 'loop_same_keys'/7 (E1,K1,L1,C1,E2s,Cont,M)
<E1,K1,L1,C1,L2,C2,E2s,Sz0,M> when call 'erlang':'<' (Sz0,0) -> case apply 'init_merge_join'/1 (M) of <'ok'> when 'true' -> (case M of (<({'m',_35,_36,_rec94,_37}-|['compiler_generated'] )> when 'true' -> let <C> = fun () -> apply 'same_keys_file'/9 (E1,K1,L1,C1,L2,C2,[],_rec94,M) in apply 'write_same_keys'/4 (E1,E2s,M,C)-|['compiler_generated'] )
(<_38> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','m'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Error> when 'true' -> Error end
<E1,K1,L1,C1,[E2|L2],C2,E2s,Sz0,M> when 'true' -> let <K2> = call 'erlang':'element' (C2,E2) in case <> of <> when call 'erlang':'==' (K1,K2) -> let <Sz> = apply 'decr_list_size'/2 (Sz0,E2) in apply 'same_keys_cache'/9 (E1,K1,L1,C1,L2,C2,[E2|E2s],Sz,M)
<> when call 'erlang':'<' (K1,K2) -> let <Cont> = fun (_19) -> apply 'merge_join1'/7 (E2,K2,_19,C1,L2,C2,M) in apply 'loop_same_keys'/7 (E1,K1,L1,C1,E2s,Cont,M)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<E1,K1,L1,C1,F2,C2,E2s,Sz,M> when 'true' -> case apply F2 () of <L2> when call 'erlang':'is_list' (L2) -> apply 'same_keys_cache'/9 (E1,K1,L1,C1,L2,C2,E2s,Sz,M)
<T2> when 'true' -> let <Cont> = fun (_22) -> T2 in apply 'loop_same_keys'/7 (E1,K1,L1,C1,E2s,Cont,M) end end
'loop_same_keys'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <E1,_X_K1,[],_X_C1,E2s,_X_Cont,M> when 'true' -> let <_7> = apply 'loop_same'/3 (E1,E2s,[]) in apply 'end_merge_join'/2 (_7,M)
<E1,K1,L1,C1,E2s,Cont,M> when 'true' -> let <_8> = fun () -> apply 'loop_keys'/6 (K1,L1,C1,E2s,Cont,M) in apply 'loop_same'/3 (E1,E2s,_8) end
'loop_same'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_E1,[],L> when 'true' -> L
<E1,[E2|E2s],L> when 'true' -> apply 'loop_same'/3 (E1,E2s,[[E1|E2]|L])
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'loop_same',3}}] )-|['compiler_generated'] ) end
'loop_keys'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <K,L1_0 = [E1|L1],C1,E2s,Cont,M> when 'true' -> let <K1> = call 'erlang':'element' (C1,E1) in case <> of <> when call 'erlang':'==' (K1,K) -> apply 'loop_same_keys'/7 (E1,K1,L1,C1,E2s,Cont,M)
<> when call 'erlang':'>' (K1,K) -> apply Cont (L1_0)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<_X_K,L1 = [],_X_C1,_X_Es2,Cont,_X_M> when 'true' -> apply Cont (L1)
<K,F1,C1,E2s,Cont,M> when 'true' -> case apply F1 () of <L1> when call 'erlang':'is_list' (L1) -> apply 'loop_keys'/6 (K,L1,C1,E2s,Cont,M)
<T1> when 'true' -> T1 end end
'same_keys_file'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> case <_0,_1,_2,_3,_4,_5,_6,_7,_8> of <E1,K1,L1,C1,[],_X_C2,E2s,_X_Sz,M> when 'true' -> let <Cont> = fun (_9) -> apply 'end_merge_join'/2 ([],M) in apply 'same_keys_file_write'/7 (E1,K1,L1,C1,E2s,M,Cont)
<E1,K1,L1,C1,L2,C2,E2s,Sz0,M> when call 'erlang':'<' (Sz0,0) -> (case M of (<({'m',_34,_35,_rec95,_36}-|['compiler_generated'] )> when 'true' -> let <C> = fun () -> apply 'same_keys_file'/9 (E1,K1,L1,C1,L2,C2,[],_rec95,M) in apply 'write_same_keys'/4 (E1,E2s,M,C)-|['compiler_generated'] )
(<_37> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','m'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<E1,K1,L1,C1,[E2|L2],C2,E2s,Sz0,M> when 'true' -> let <K2> = call 'erlang':'element' (C2,E2) in case <> of <> when call 'erlang':'==' (K1,K2) -> let <Sz> = apply 'decr_list_size'/2 (Sz0,E2) in apply 'same_keys_file'/9 (E1,K1,L1,C1,L2,C2,[E2|E2s],Sz,M)
<> when call 'erlang':'<' (K1,K2) -> let <Cont> = fun (_18) -> apply 'merge_join1'/7 (E2,K2,_18,C1,L2,C2,M) in apply 'same_keys_file_write'/7 (E1,K1,L1,C1,E2s,M,Cont)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<E1,K1,L1,C1,F2,C2,E2s,Sz,M> when 'true' -> case apply F2 () of <L2> when call 'erlang':'is_list' (L2) -> apply 'same_keys_file'/9 (E1,K1,L1,C1,L2,C2,E2s,Sz,M)
<T2> when 'true' -> let <Cont> = fun (_21) -> T2 in apply 'same_keys_file_write'/7 (E1,K1,L1,C1,E2s,M,Cont) end end
'same_keys_file_write'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <C> = fun () -> apply 'loop_keys_file'/5 (_1,_2,_3,_6,_5) in apply 'write_same_keys'/4 (_0,_4,_5,C)
'write_same_keys'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_E1,[],_X_M,Cont> when 'true' -> apply Cont ()
<E1,Es2,M,Cont> when 'true' -> apply 'write_same_keys'/5 (E1,Es2,M,[],Cont) end
'write_same_keys'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_X_E1,[],M,E2s,Objs> when 'true' -> case apply 'write_merge_join'/2 (M,E2s) of <'ok'> when 'true' -> Objs
<Error> when 'true' -> Error end
<E1,[E2|E2s0],M,E2s,Objs> when 'true' -> let <BE2> = call 'erlang':'term_to_binary' (E2) in apply 'write_same_keys'/5 (E1,E2s0,M,[BE2|E2s],[[E1|E2]|Objs])
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'write_same_keys',5}}] )-|['compiler_generated'] ) end
'loop_keys_file'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <K,L1_0 = [E1|L1],C1,Cont,M> when 'true' -> let <K1> = call 'erlang':'element' (C1,E1) in case <> of <> when call 'erlang':'==' (K1,K) -> let <C> = fun () -> apply 'loop_keys_file'/5 (K1,L1,C1,Cont,M) in apply 'read_merge_join'/3 (M,E1,C)
<> when call 'erlang':'>' (K1,K) -> apply Cont (L1_0)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<_X_K,L1 = [],_X_C1,Cont,_X_M> when 'true' -> apply Cont (L1)
<K,F1,C1,Cont,M> when 'true' -> case apply F1 () of <L1> when call 'erlang':'is_list' (L1) -> apply 'loop_keys_file'/5 (K,L1,C1,Cont,M)
<T1> when 'true' -> T1 end end
'end_merge_join'/2 = fun (_0,_1) -> do apply 'end_merge_join'/1 (_1) _0
'init_merge_join'/1 = fun (_0) -> case _0 of <{'m',MergeId,TmpDir,_8,TmpUsage}> when 'true' -> case apply 'tmp_merge_file'/1 (MergeId) of <{Fd,FileName}> when 'true' -> case call 'file':'position' (Fd,'bof') of <{'ok',0}> when 'true' -> case call 'file':'truncate' (Fd) of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end
<'none'> when call 'erlang':'=:=' (TmpUsage,'not_allowed') -> apply 'error'/1 ({'tmpdir_usage','joining'})
<'none'> when 'true' -> do apply 'maybe_error_logger'/2 (TmpUsage,'joining') let <FName> = apply 'tmp_filename'/1 (TmpDir) in case call 'file':'open' (FName,['raw'|['binary'|['read'|['write']]]]) of <{'ok',Fd}> when 'true' -> let <TmpFiles> = call 'erlang':'get' ('$_qlc_merge_join_tmpfiles_') in do call 'erlang':'put' ('$_qlc_merge_join_tmpfiles_',[{MergeId,Fd,FName}|TmpFiles]) 'ok'
<Error> when 'true' -> apply 'file_error'/2 (FName,Error) end
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'init_merge_join',1}}] )-|['compiler_generated'] ) end
'write_merge_join'/2 = fun (_0,_1) -> case <_0,_1> of <{'m',MergeId,_5,_6,_7},BTerms> when 'true' -> case apply 'tmp_merge_file'/1 (MergeId) of <{Fd,FileName}> when 'true' -> apply 'write_binary_terms'/3 (BTerms,Fd,FileName)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'write_merge_join',2}}] )-|['compiler_generated'] ) end
'read_merge_join'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'m',MergeId,_14,_15,_16},E1,Cont> when 'true' -> case apply 'tmp_merge_file'/1 (MergeId) of <_@r0 = {Fd,FileName}> when 'true' -> case call 'file':'position' (Fd,'bof') of <{'ok',0}> when 'true' -> let <Fun> = fun (_5,_4) -> case <_5,_4> of <[],_17> when 'true' -> apply Cont ()
<Ts,C> when call 'erlang':'is_list' (Ts) -> apply 'join_read_terms'/3 (E1,Ts,C)
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'-read_merge_join/3-fun-0-',2}}] )-|['compiler_generated'] ) end in apply 'file_loop_read'/4 (#{}#,65536,_@r0,Fun)
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11})-|[{'function_name',{'read_merge_join',3}}] )-|['compiler_generated'] ) end
'join_read_terms'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_E1,[],Objs> when 'true' -> Objs
<E1,[E2|E2s],Objs> when 'true' -> apply 'join_read_terms'/3 (E1,E2s,[[E1|E2]|Objs])
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'join_read_terms',3}}] )-|['compiler_generated'] ) end
'end_merge_join'/1 = fun (_0) -> case _0 of <{'m',MergeId,_7,_8,_9}> when 'true' -> case apply 'tmp_merge_file'/1 (MergeId) of <'none'> when 'true' -> 'ok'
<{Fd,FileName}> when 'true' -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (Fd)-|['result_not_wanted'] ) do (call ('file'-|['result_not_wanted'] ):('delete'-|['result_not_wanted'] ) (FileName)-|['result_not_wanted'] ) let <_3> = call 'erlang':'get' ('$_qlc_merge_join_tmpfiles_') in let <_4> = call 'lists':'keydelete' (MergeId,1,_3) in call 'erlang':'put' ('$_qlc_merge_join_tmpfiles_',_4)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'end_merge_join',1}}] )-|['compiler_generated'] ) end
'end_all_merge_joins'/0 = fun () -> let <_9> = fun (_7) -> apply 'end_merge_join'/1 ({'m',_7,'undefined','undefined','undefined'}) in let <_6> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{Id,_X_Fd,_X_FileName}|_1]> when 'true' -> let <_5> = apply 'lc$^0'/1 (_1) in ([Id|_5]-|['compiler_generated'] )
(<[_0|_1]> when 'true' -> apply 'lc$^0'/1 (_1)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_2> = call 'erlang':'get' ('$_qlc_merge_join_tmpfiles_') in let <_3> = call 'lists':'flatten' ([_2|[]]) in apply 'lc$^0'/1 (_3) in do call 'lists':'foreach' (_9,_6) call 'erlang':'erase' ('$_qlc_merge_join_tmpfiles_')
'merge_join_id'/0 = fun () -> do case call 'erlang':'get' ('$_qlc_merge_join_tmpfiles_') of <'undefined'> when 'true' -> call 'erlang':'put' ('$_qlc_merge_join_tmpfiles_',[])
<_1> when 'true' -> 'ok' end call 'erlang':'make_ref' ()
'tmp_merge_file'/1 = fun (_0) -> let <TmpFiles> = call 'erlang':'get' ('$_qlc_merge_join_tmpfiles_') in case call 'lists':'keyfind' (_0,1,TmpFiles) of <{_4,Fd,FileName}> when call 'erlang':'=:=' (_4,_0) -> {Fd,FileName}
<'false'> when 'true' -> 'none'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'decr_list_size'/2 = fun (_0,_1) -> case <_0,_1> of <Sz0,E> when call 'erlang':'is_integer' (Sz0) -> let <_2> = call 'erlang':'external_size' (E) in call 'erlang':'-' (Sz0,_2)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'decr_list_size',2}}] )-|['compiler_generated'] ) end
'lookup_join'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[E1|L1],C1,LuF,C2,Rev> when 'true' -> let <K1> = call 'erlang':'element' (C1,E1) in case apply LuF (C2,[K1|[]]) of <[]> when 'true' -> apply 'lookup_join'/5 (L1,C1,LuF,C2,Rev)
<[E2|[]]> when (call 'erlang':'=:=' (Rev,'true')-|['compiler_generated'] ) -> let <_6> = fun () -> apply 'lookup_join'/5 (L1,C1,LuF,C2,Rev) in [[E2|E1]|_6]
<[E2|[]]> when 'true' -> let <_7> = fun () -> apply 'lookup_join'/5 (L1,C1,LuF,C2,Rev) in [[E1|E2]|_7]
<E2s> when let <_8> = call 'erlang':'is_list' (E2s) in let <_9> = call 'erlang':'=:=' (Rev,'true') in call 'erlang':'and' (_8,_9) -> let <_10> = fun () -> apply 'lookup_join'/5 (L1,C1,LuF,C2,Rev) in (letrec 'lc$^3'/1 = fun (_13) -> case _13 of <[E2|_12]> when 'true' -> let <_14> = apply 'lc$^3'/1 (_12) in ([[E2|E1]|_14]-|['compiler_generated'] )
<[]> when 'true' -> _10
(<_27> when 'true' -> (primop 'match_fail' ({'function_clause',_27})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (E2s)-|['list_comprehension'] )
<E2s> when call 'erlang':'is_list' (E2s) -> let <_15> = fun () -> apply 'lookup_join'/5 (L1,C1,LuF,C2,Rev) in (letrec 'lc$^5'/1 = fun (_18) -> case _18 of <[E2|_17]> when 'true' -> let <_19> = apply 'lc$^5'/1 (_17) in ([[E1|E2]|_19]-|['compiler_generated'] )
<[]> when 'true' -> _15
(<_28> when 'true' -> (primop 'match_fail' ({'function_clause',_28})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in apply 'lc$^5'/1 (E2s)-|['list_comprehension'] )
<Term> when 'true' -> Term end
<Cont = [],_X_C1,_X_LuF,_X_C2,_X_Rev> when 'true' -> Cont
<F1,C1,LuF,C2,Rev> when 'true' -> case apply F1 () of <L1> when call 'erlang':'is_list' (L1) -> apply 'lookup_join'/5 (L1,C1,LuF,C2,Rev)
<T1> when 'true' -> T1 end end
'maybe_error_logger'/2 = fun (_0,_1) -> case <_0,_1> of <'allowed',_20> when 'true' -> 'ok'
<Name,Why> when 'true' -> case apply 'expand_stacktrace'/0 () of <[_21|[_22|[{'qlc','maybe_error_logger',_23,_24}|Stacktrace]]]> when 'true' -> let <Trimmer> = fun (_5,_4,_3) -> call 'erlang':'=:=' (_5,'erl_eval') in let <Formater> = fun (_12,_11) -> call 'io_lib':'print' (_12,_11,80,-1) in let <X> = call 'erl_error':'format_stacktrace' (1,Stacktrace,Trimmer,Formater) in let <_17> = call 'lists':'flatten' (X) in call 'error_logger':Name ([113|[108|[99|[58|[32|[116|[101|[109|[112|[111|[114|[97|[114|[121|[32|[102|[105|[108|[101|[32|[119|[97|[115|[32|[110|[101|[101|[100|[101|[100|[32|[102|[111|[114|[32|[126|[119|[10|[126|[116|[115|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Why|[_17|[]]])
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end end
'expand_stacktrace'/0 = fun () -> let <D> = call 'erlang':'system_flag' ('backtrace_depth',8) in letrec 'after$^0'/0 = fun () -> call 'erlang':'system_flag' ('backtrace_depth',D) in try let <_1> = call 'erlang':'max' (1,D) in apply 'expand_stacktrace'/1 (_1) of <_2> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) _2 catch <_5,_4,_3> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) primop 'raise' (_3,_4)
'expand_stacktrace'/1 = fun (_0) -> do (call ('erlang'-|['result_not_wanted'] ):('system_flag'-|['result_not_wanted'] ) (('backtrace_depth'-|['result_not_wanted'] ),_0)-|['result_not_wanted'] ) let <_2> = catch call 'erlang':'error' ('foo') in case _2 of <{'EXIT',{'foo',Stacktrace}}> when 'true' -> let <_7> = fun (_5) -> case _5 of <{M,_16,_17,_18}> when 'true' -> call 'erlang':'=/=' (M,'qlc')
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'-expand_stacktrace/1-fun-0-',1}}] )-|['compiler_generated'] ) end in let <_4> = call 'lists':'reverse' (Stacktrace) in let <L> = call 'lists':'takewhile' (_7,_4) in case <> of <> when try let <_10> = call 'erlang':'length' (L) in (let <_13> = case call 'erlang':'<' (_10,3) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_11> = call 'erlang':'length' (Stacktrace) in call 'erlang':'=:=' (_11,_0)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_9> when 'true' -> _9-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_13-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_14> = call 'erlang':'+' (_0,5) in apply 'expand_stacktrace'/1 (_14)
<> when 'true' -> Stacktrace end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'write_binary_terms'/3 = fun (_0,_1,_2) -> let <_3> = apply 'size_bin'/2 (_0,[]) in case call 'file':'write' (_1,_3) of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> apply 'file_error'/2 (_2,Error) end
'post_funs'/1 = fun (_0) -> do apply 'end_all_merge_joins'/0 () apply 'local_post'/1 (_0)
'local_post'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <'undefined'> when 'true' -> 'ok'
<F> when 'true' -> catch apply F () end in call 'lists':'foreach' (_3,_0)
'call'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <'undefined',_X_Arg,Default,_X_Post> when 'true' -> Default
<Fun,Arg,_X_Default,Post> when 'true' -> try apply Fun (Arg) of <_4> -> _4 catch <_7,_6,_5> -> do apply 'post_funs'/1 (Post) primop 'raw_raise' (_7,_6,_5) end
'grd'/2 = fun (_0,_1) -> case <_0,_1> of <'undefined',_X_Arg> when 'true' -> 'false'
<Fun,Arg> when 'true' -> case apply Fun (Arg) of <'true'> when 'true' -> 'true'
<_5> when 'true' -> 'false' end end
'anno0'/0 = fun () -> apply 'anno'/1 (0)
'anno1'/0 = fun () -> apply 'anno'/1 (1)
'anno'/1 = fun (_0) -> call 'erl_anno':'new' (_0)
'family'/1 = fun (_0) -> let <_1> = call 'sofs':'relation' (_0) in let <_2> = call 'sofs':'relation_to_family' (_1) in call 'sofs':'to_external' (_2)
'family_union'/1 = fun (_0) -> let <R> = call 'sofs':'relation' (_0,[{'atom',['atom']}]) in let <_2> = call 'sofs':'relation_to_family' (R) in let <_3> = call 'sofs':'family_union' (_2) in call 'sofs':'to_external' (_3)
'file_error'/2 = fun (_0,_1) -> case <_0,_1> of <File,{'error',Reason}> when 'true' -> apply 'error'/1 ({'file_error',File,Reason})
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'file_error',2}}] )-|['compiler_generated'] ) end
'throw_file_error'/2 = fun (_0,_1) -> case <_0,_1> of <File,{'error',Reason}> when 'true' -> apply 'throw_reason'/1 ({'file_error',File,Reason})
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'throw_file_error',2}}] )-|['compiler_generated'] ) end
'throw_reason'/1 = fun (_0) -> let <_1> = apply 'error'/1 (_0) in apply 'throw_error'/1 (_1)
'throw_error'/1 = fun (_0) -> call 'erlang':'throw' (_0)
'error'/1 = fun (_0) -> {'error','qlc',_0}
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('qlc')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('qlc',_0) end