module 'maps' ['filter'/2,'find'/2,'fold'/3,'from_list'/1,'get'/2,'get'/3,'is_key'/2,'iterator'/1,'keys'/1,'map'/2,'merge'/2,'module_info'/0,'module_info'/1,'new'/0,'next'/1,'put'/3,'remove'/2,'size'/1,'take'/2,'to_list'/1,'update'/3,'update_with'/3,'update_with'/4,'values'/1,'with'/2,'without'/2] attributes [ 'file' = [{[115|[114|[99|[47|[109|[97|[112|[115|[46|[101|[114|[108]]]]]]]]]]]],1}]
, 'opaque' = [{'iterator',{'type',35,'union',[{'type',35,'tuple',[{'var',35,'Key'}|[{'var',35,'Value'}|[{'user_type',35,'iterator',[{'var',35,'Key'}|[{'var',35,'Value'}]]}]]]}|[{'atom',35,'none'}|[{'type',36,'nonempty_improper_list',[{'type',36,'integer',[]}|[{'type',36,'map',[{'type',36,'map_field_assoc',[{'var',36,'Key'}|[{'var',36,'Value'}]]}]}]]}]]]},[{'var',35,'Key'}|[{'var',35,'Value'}]]}]
, 'type' = [{'iterator',{'user_type',38,'iterator',[{'type',38,'term',[]}|[{'type',38,'term',[]}]]},[]}]
, 'export_type' = [{'iterator',2}|[{'iterator',0}]]
, 'dialyzer' = [{'no_improper_lists',{'iterator',1}}]
, 'spec' = [{{'get',2},[{'type',47,'bounded_fun',[{'type',47,'fun',[{'type',47,'product',[{'var',47,'Key'}|[{'var',47,'Map'}]]}|[{'var',47,'Value'}]]}|[[{'type',48,'constraint',[{'atom',48,'is_subtype'}|[[{'var',48,'Key'}|[{'type',48,'term',[]}]]]]}|[{'type',49,'constraint',[{'atom',49,'is_subtype'}|[[{'var',49,'Map'}|[{'type',49,'map','any'}]]]]}|[{'type',50,'constraint',[{'atom',50,'is_subtype'}|[[{'var',50,'Value'}|[{'type',50,'term',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'find',2},[{'type',54,'bounded_fun',[{'type',54,'fun',[{'type',54,'product',[{'var',54,'Key'}|[{'var',54,'Map'}]]}|[{'type',54,'union',[{'type',54,'tuple',[{'atom',54,'ok'}|[{'var',54,'Value'}]]}|[{'atom',54,'error'}]]}]]}|[[{'type',55,'constraint',[{'atom',55,'is_subtype'}|[[{'var',55,'Map'}|[{'type',55,'map',[{'type',55,'map_field_assoc',[{'var',55,'Key'}|[{'var',55,'Value'}]]}|[{'type',55,'map_field_assoc',[{'var',55,'_'}|[{'var',55,'_'}]]}]]}]]]]}]]]}]}]
, 'spec' = [{{'from_list',1},[{'type',60,'bounded_fun',[{'type',60,'fun',[{'type',60,'product',[{'var',60,'List'}]}|[{'var',60,'Map'}]]}|[[{'type',61,'constraint',[{'atom',61,'is_subtype'}|[[{'var',61,'List'}|[{'type',61,'list',[{'type',61,'tuple',[{'var',61,'Key'}|[{'var',61,'Value'}]]}]}]]]]}|[{'type',62,'constraint',[{'atom',62,'is_subtype'}|[[{'var',62,'Key'}|[{'type',62,'term',[]}]]]]}|[{'type',63,'constraint',[{'atom',63,'is_subtype'}|[[{'var',63,'Value'}|[{'type',63,'term',[]}]]]]}|[{'type',64,'constraint',[{'atom',64,'is_subtype'}|[[{'var',64,'Map'}|[{'type',64,'map','any'}]]]]}]]]]]]}]}]
, 'spec' = [{{'is_key',2},[{'type',70,'bounded_fun',[{'type',70,'fun',[{'type',70,'product',[{'var',70,'Key'}|[{'var',70,'Map'}]]}|[{'type',70,'boolean',[]}]]}|[[{'type',71,'constraint',[{'atom',71,'is_subtype'}|[[{'var',71,'Key'}|[{'type',71,'term',[]}]]]]}|[{'type',72,'constraint',[{'atom',72,'is_subtype'}|[[{'var',72,'Map'}|[{'type',72,'map','any'}]]]]}]]]]}]}]
, 'spec' = [{{'keys',1},[{'type',77,'bounded_fun',[{'type',77,'fun',[{'type',77,'product',[{'var',77,'Map'}]}|[{'var',77,'Keys'}]]}|[[{'type',78,'constraint',[{'atom',78,'is_subtype'}|[[{'var',78,'Map'}|[{'type',78,'map',[{'type',78,'map_field_assoc',[{'var',78,'Key'}|[{'var',78,'_'}]]}]}]]]]}|[{'type',79,'constraint',[{'atom',79,'is_subtype'}|[[{'var',79,'Keys'}|[{'type',79,'list',[{'var',79,'Key'}]}]]]]}]]]]}]}]
, 'spec' = [{{'merge',2},[{'type',85,'bounded_fun',[{'type',85,'fun',[{'type',85,'product',[{'var',85,'Map1'}|[{'var',85,'Map2'}]]}|[{'var',85,'Map3'}]]}|[[{'type',86,'constraint',[{'atom',86,'is_subtype'}|[[{'var',86,'Map1'}|[{'type',86,'map','any'}]]]]}|[{'type',87,'constraint',[{'atom',87,'is_subtype'}|[[{'var',87,'Map2'}|[{'type',87,'map','any'}]]]]}|[{'type',88,'constraint',[{'atom',88,'is_subtype'}|[[{'var',88,'Map3'}|[{'type',88,'map','any'}]]]]}]]]]]}]}]
, 'spec' = [{{'put',3},[{'type',94,'bounded_fun',[{'type',94,'fun',[{'type',94,'product',[{'var',94,'Key'}|[{'var',94,'Value'}|[{'var',94,'Map1'}]]]}|[{'var',94,'Map2'}]]}|[[{'type',95,'constraint',[{'atom',95,'is_subtype'}|[[{'var',95,'Key'}|[{'type',95,'term',[]}]]]]}|[{'type',96,'constraint',[{'atom',96,'is_subtype'}|[[{'var',96,'Value'}|[{'type',96,'term',[]}]]]]}|[{'type',97,'constraint',[{'atom',97,'is_subtype'}|[[{'var',97,'Map1'}|[{'type',97,'map','any'}]]]]}|[{'type',98,'constraint',[{'atom',98,'is_subtype'}|[[{'var',98,'Map2'}|[{'type',98,'map','any'}]]]]}]]]]]]}]}]
, 'spec' = [{{'remove',2},[{'type',104,'bounded_fun',[{'type',104,'fun',[{'type',104,'product',[{'var',104,'Key'}|[{'var',104,'Map1'}]]}|[{'var',104,'Map2'}]]}|[[{'type',105,'constraint',[{'atom',105,'is_subtype'}|[[{'var',105,'Key'}|[{'type',105,'term',[]}]]]]}|[{'type',106,'constraint',[{'atom',106,'is_subtype'}|[[{'var',106,'Map1'}|[{'type',106,'map','any'}]]]]}|[{'type',107,'constraint',[{'atom',107,'is_subtype'}|[[{'var',107,'Map2'}|[{'type',107,'map','any'}]]]]}]]]]]}]}]
, 'spec' = [{{'take',2},[{'type',111,'bounded_fun',[{'type',111,'fun',[{'type',111,'product',[{'var',111,'Key'}|[{'var',111,'Map1'}]]}|[{'type',111,'union',[{'type',111,'tuple',[{'var',111,'Value'}|[{'var',111,'Map2'}]]}|[{'atom',111,'error'}]]}]]}|[[{'type',112,'constraint',[{'atom',112,'is_subtype'}|[[{'var',112,'Map1'}|[{'type',112,'map',[{'type',112,'map_field_assoc',[{'var',112,'Key'}|[{'var',112,'Value'}]]}|[{'type',112,'map_field_assoc',[{'var',112,'_'}|[{'var',112,'_'}]]}]]}]]]]}|[{'type',113,'constraint',[{'atom',113,'is_subtype'}|[[{'var',113,'Map2'}|[{'type',113,'map',[{'type',113,'map_field_assoc',[{'var',113,'_'}|[{'var',113,'_'}]]}]}]]]]}]]]]}]}]
, 'spec' = [{{'to_list',1},[{'type',117,'bounded_fun',[{'type',117,'fun',[{'type',117,'product',[{'var',117,'Map'}]}|[{'type',117,'list',[{'type',117,'tuple',[{'var',117,'Key'}|[{'var',117,'Value'}]]}]}]]}|[[{'type',118,'constraint',[{'atom',118,'is_subtype'}|[[{'var',118,'Map'}|[{'type',118,'map',[{'type',118,'map_field_assoc',[{'var',118,'Key'}|[{'var',118,'Value'}]]}]}]]]]}]]]}]}]
, 'spec' = [{{'update',3},[{'type',131,'bounded_fun',[{'type',131,'fun',[{'type',131,'product',[{'var',131,'Key'}|[{'var',131,'Value'}|[{'var',131,'Map1'}]]]}|[{'var',131,'Map2'}]]}|[[{'type',132,'constraint',[{'atom',132,'is_subtype'}|[[{'var',132,'Map1'}|[{'type',132,'map',[{'type',132,'map_field_exact',[{'var',132,'Key'}|[{'var',132,'_'}]]}|[{'type',132,'map_field_assoc',[{'var',132,'_'}|[{'var',132,'_'}]]}]]}]]]]}|[{'type',133,'constraint',[{'atom',133,'is_subtype'}|[[{'var',133,'Map2'}|[{'type',133,'map',[{'type',133,'map_field_exact',[{'var',133,'Key'}|[{'var',133,'Value'}]]}|[{'type',133,'map_field_assoc',[{'var',133,'_'}|[{'var',133,'_'}]]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'values',1},[{'type',138,'bounded_fun',[{'type',138,'fun',[{'type',138,'product',[{'var',138,'Map'}]}|[{'var',138,'Values'}]]}|[[{'type',139,'constraint',[{'atom',139,'is_subtype'}|[[{'var',139,'Map'}|[{'type',139,'map',[{'type',139,'map_field_assoc',[{'var',139,'_'}|[{'var',139,'Value'}]]}]}]]]]}|[{'type',140,'constraint',[{'atom',140,'is_subtype'}|[[{'var',140,'Values'}|[{'type',140,'list',[{'var',140,'Value'}]}]]]]}]]]]}]}]
, 'spec' = [{{'new',0},[{'type',146,'bounded_fun',[{'type',146,'fun',[{'type',146,'product',[]}|[{'var',146,'Map'}]]}|[[{'type',147,'constraint',[{'atom',147,'is_subtype'}|[[{'var',147,'Map'}|[{'type',147,'map',[]}]]]]}]]]}]}]
, 'spec' = [{{'update_with',3},[{'type',151,'bounded_fun',[{'type',151,'fun',[{'type',151,'product',[{'var',151,'Key'}|[{'var',151,'Fun'}|[{'var',151,'Map1'}]]]}|[{'var',151,'Map2'}]]}|[[{'type',152,'constraint',[{'atom',152,'is_subtype'}|[[{'var',152,'Map1'}|[{'type',152,'map',[{'type',152,'map_field_exact',[{'var',152,'Key'}|[{'var',152,'Value1'}]]}|[{'type',152,'map_field_assoc',[{'var',152,'_'}|[{'var',152,'_'}]]}]]}]]]]}|[{'type',153,'constraint',[{'atom',153,'is_subtype'}|[[{'var',153,'Map2'}|[{'type',153,'map',[{'type',153,'map_field_exact',[{'var',153,'Key'}|[{'var',153,'Value2'}]]}|[{'type',153,'map_field_assoc',[{'var',153,'_'}|[{'var',153,'_'}]]}]]}]]]]}|[{'type',154,'constraint',[{'atom',154,'is_subtype'}|[[{'var',154,'Fun'}|[{'type',154,'fun',[{'type',154,'product',[{'var',154,'Value1'}]}|[{'var',154,'Value2'}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'update_with',4},[{'type',165,'bounded_fun',[{'type',165,'fun',[{'type',165,'product',[{'var',165,'Key'}|[{'var',165,'Fun'}|[{'var',165,'Init'}|[{'var',165,'Map1'}]]]]}|[{'var',165,'Map2'}]]}|[[{'type',166,'constraint',[{'atom',166,'is_subtype'}|[[{'var',166,'Map1'}|[{'type',166,'map',[{'type',166,'map_field_assoc',[{'var',166,'Key'}|[{'var',166,'Value1'}]]}|[{'type',166,'map_field_assoc',[{'var',166,'_'}|[{'var',166,'_'}]]}]]}]]]]}|[{'type',167,'constraint',[{'atom',167,'is_subtype'}|[[{'var',167,'Map2'}|[{'type',167,'map',[{'type',167,'map_field_exact',[{'var',167,'Key'}|[{'type',167,'union',[{'var',167,'Value2'}|[{'var',167,'Init'}]]}]]}|[{'type',167,'map_field_assoc',[{'var',167,'_'}|[{'var',167,'_'}]]}]]}]]]]}|[{'type',168,'constraint',[{'atom',168,'is_subtype'}|[[{'var',168,'Fun'}|[{'type',168,'fun',[{'type',168,'product',[{'var',168,'Value1'}]}|[{'var',168,'Value2'}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'get',3},[{'type',179,'bounded_fun',[{'type',179,'fun',[{'type',179,'product',[{'var',179,'Key'}|[{'var',179,'Map'}|[{'var',179,'Default'}]]]}|[{'type',179,'union',[{'var',179,'Value'}|[{'var',179,'Default'}]]}]]}|[[{'type',180,'constraint',[{'atom',180,'is_subtype'}|[[{'var',180,'Map'}|[{'type',180,'map',[{'type',180,'map_field_assoc',[{'var',180,'Key'}|[{'var',180,'Value'}]]}|[{'type',180,'map_field_assoc',[{'var',180,'_'}|[{'var',180,'_'}]]}]]}]]]]}]]]}]}]
, 'spec' = [{{'filter',2},[{'type',191,'bounded_fun',[{'type',191,'fun',[{'type',191,'product',[{'var',191,'Pred'}|[{'var',191,'MapOrIter'}]]}|[{'var',191,'Map'}]]}|[[{'type',192,'constraint',[{'atom',192,'is_subtype'}|[[{'var',192,'Pred'}|[{'type',192,'fun',[{'type',192,'product',[{'var',192,'Key'}|[{'var',192,'Value'}]]}|[{'type',192,'boolean',[]}]]}]]]]}|[{'type',193,'constraint',[{'atom',193,'is_subtype'}|[[{'var',193,'MapOrIter'}|[{'type',193,'union',[{'type',193,'map',[{'type',193,'map_field_assoc',[{'var',193,'Key'}|[{'var',193,'Value'}]]}]}|[{'user_type',193,'iterator',[{'var',193,'Key'}|[{'var',193,'Value'}]]}]]}]]]]}|[{'type',194,'constraint',[{'atom',194,'is_subtype'}|[[{'var',194,'Map'}|[{'type',194,'map',[{'type',194,'map_field_assoc',[{'var',194,'Key'}|[{'var',194,'Value'}]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'fold',3},[{'type',216,'bounded_fun',[{'type',216,'fun',[{'type',216,'product',[{'var',216,'Fun'}|[{'var',216,'Init'}|[{'var',216,'MapOrIter'}]]]}|[{'var',216,'Acc'}]]}|[[{'type',217,'constraint',[{'atom',217,'is_subtype'}|[[{'var',217,'Fun'}|[{'type',217,'fun',[{'type',217,'product',[{'var',217,'Key'}|[{'var',217,'Value'}|[{'var',217,'AccIn'}]]]}|[{'var',217,'AccOut'}]]}]]]]}|[{'type',218,'constraint',[{'atom',218,'is_subtype'}|[[{'var',218,'Init'}|[{'type',218,'term',[]}]]]]}|[{'type',219,'constraint',[{'atom',219,'is_subtype'}|[[{'var',219,'Acc'}|[{'var',219,'AccOut'}]]]]}|[{'type',220,'constraint',[{'atom',220,'is_subtype'}|[[{'var',220,'AccIn'}|[{'type',220,'union',[{'var',220,'Init'}|[{'var',220,'AccOut'}]]}]]]]}|[{'type',221,'constraint',[{'atom',221,'is_subtype'}|[[{'var',221,'MapOrIter'}|[{'type',221,'union',[{'type',221,'map',[{'type',221,'map_field_assoc',[{'var',221,'Key'}|[{'var',221,'Value'}]]}]}|[{'user_type',221,'iterator',[{'var',221,'Key'}|[{'var',221,'Value'}]]}]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'map',2},[{'type',238,'bounded_fun',[{'type',238,'fun',[{'type',238,'product',[{'var',238,'Fun'}|[{'var',238,'MapOrIter'}]]}|[{'var',238,'Map'}]]}|[[{'type',239,'constraint',[{'atom',239,'is_subtype'}|[[{'var',239,'Fun'}|[{'type',239,'fun',[{'type',239,'product',[{'var',239,'Key'}|[{'var',239,'Value1'}]]}|[{'var',239,'Value2'}]]}]]]]}|[{'type',240,'constraint',[{'atom',240,'is_subtype'}|[[{'var',240,'MapOrIter'}|[{'type',240,'union',[{'type',240,'map',[{'type',240,'map_field_assoc',[{'var',240,'Key'}|[{'var',240,'Value1'}]]}]}|[{'user_type',240,'iterator',[{'var',240,'Key'}|[{'var',240,'Value1'}]]}]]}]]]]}|[{'type',241,'constraint',[{'atom',241,'is_subtype'}|[[{'var',241,'Map'}|[{'type',241,'map',[{'type',241,'map_field_assoc',[{'var',241,'Key'}|[{'var',241,'Value2'}]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'size',1},[{'type',258,'bounded_fun',[{'type',258,'fun',[{'type',258,'product',[{'var',258,'Map'}]}|[{'type',258,'non_neg_integer',[]}]]}|[[{'type',259,'constraint',[{'atom',259,'is_subtype'}|[[{'var',259,'Map'}|[{'type',259,'map','any'}]]]]}]]]}]}]
, 'spec' = [{{'iterator',1},[{'type',266,'bounded_fun',[{'type',266,'fun',[{'type',266,'product',[{'var',266,'Map'}]}|[{'var',266,'Iterator'}]]}|[[{'type',267,'constraint',[{'atom',267,'is_subtype'}|[[{'var',267,'Map'}|[{'type',267,'map',[{'type',267,'map_field_assoc',[{'var',267,'Key'}|[{'var',267,'Value'}]]}]}]]]]}|[{'type',268,'constraint',[{'atom',268,'is_subtype'}|[[{'var',268,'Iterator'}|[{'user_type',268,'iterator',[{'var',268,'Key'}|[{'var',268,'Value'}]]}]]]]}]]]]}]}]
, 'spec' = [{{'next',1},[{'type',273,'bounded_fun',[{'type',273,'fun',[{'type',273,'product',[{'var',273,'Iterator'}]}|[{'type',273,'union',[{'type',273,'tuple',[{'var',273,'Key'}|[{'var',273,'Value'}|[{'var',273,'NextIterator'}]]]}|[{'atom',273,'none'}]]}]]}|[[{'type',274,'constraint',[{'atom',274,'is_subtype'}|[[{'var',274,'Iterator'}|[{'user_type',274,'iterator',[{'var',274,'Key'}|[{'var',274,'Value'}]]}]]]]}|[{'type',275,'constraint',[{'atom',275,'is_subtype'}|[[{'var',275,'NextIterator'}|[{'user_type',275,'iterator',[{'var',275,'Key'}|[{'var',275,'Value'}]]}]]]]}]]]]}]}]
, 'spec' = [{{'without',2},[{'type',285,'bounded_fun',[{'type',285,'fun',[{'type',285,'product',[{'var',285,'Ks'}|[{'var',285,'Map1'}]]}|[{'var',285,'Map2'}]]}|[[{'type',286,'constraint',[{'atom',286,'is_subtype'}|[[{'var',286,'Ks'}|[{'type',286,'list',[{'var',286,'K'}]}]]]]}|[{'type',287,'constraint',[{'atom',287,'is_subtype'}|[[{'var',287,'Map1'}|[{'type',287,'map','any'}]]]]}|[{'type',288,'constraint',[{'atom',288,'is_subtype'}|[[{'var',288,'Map2'}|[{'type',288,'map','any'}]]]]}|[{'type',289,'constraint',[{'atom',289,'is_subtype'}|[[{'var',289,'K'}|[{'type',289,'term',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'with',2},[{'type',296,'bounded_fun',[{'type',296,'fun',[{'type',296,'product',[{'var',296,'Ks'}|[{'var',296,'Map1'}]]}|[{'var',296,'Map2'}]]}|[[{'type',297,'constraint',[{'atom',297,'is_subtype'}|[[{'var',297,'Ks'}|[{'type',297,'list',[{'var',297,'K'}]}]]]]}|[{'type',298,'constraint',[{'atom',298,'is_subtype'}|[[{'var',298,'Map1'}|[{'type',298,'map',[{'type',298,'map_field_assoc',[{'var',298,'K'}|[{'var',298,'V'}]]}|[{'type',298,'map_field_assoc',[{'var',298,'_'}|[{'var',298,'_'}]]}]]}]]]]}|[{'type',299,'constraint',[{'atom',299,'is_subtype'}|[[{'var',299,'Map2'}|[{'type',299,'map',[{'type',299,'map_field_assoc',[{'var',299,'K'}|[{'var',299,'V'}]]}]}]]]]}]]]]]}]}] ] 'get'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'find'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'from_list'/1 = fun (_0) -> call 'erlang':'nif_error' ('undef')
'is_key'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'keys'/1 = fun (_0) -> call 'erlang':'nif_error' ('undef')
'merge'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'put'/3 = fun (_0,_1,_2) -> call 'erlang':'nif_error' ('undef')
'remove'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'take'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'to_list'/1 = fun (_0) -> case _0 of <Map> when call 'erlang':'is_map' (_0) -> let <_1> = call 'erts_internal':'map_next' (0,Map,[]) in apply 'to_list_internal'/1 (_1)
<Map> when 'true' -> call 'erlang':'error' ({'badmap',Map},[Map|[]]) end
'to_list_internal'/1 = fun (_0) -> case _0 of <[Iter|[Map|Acc]]> when call 'erlang':'is_integer' (Iter) -> let <_1> = call 'erts_internal':'map_next' (Iter,Map,Acc) in apply 'to_list_internal'/1 (_1)
<Acc> when 'true' -> Acc end
'update'/3 = fun (_0,_1,_2) -> call 'erlang':'nif_error' ('undef')
'values'/1 = fun (_0) -> call 'erlang':'nif_error' ('undef')
'new'/0 = fun () -> ~{}~
'update_with'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Key,Fun,Map> when try let <_3> = call 'erlang':'is_function' (Fun,1) in let <_4> = call 'erlang':'is_map' (Map) in call 'erlang':'and' (_3,_4) of <Try> -> Try catch <T,R> -> 'false' -> case Map of <~{Key:=Value}~> when 'true' -> let <_5> = apply Fun (Value) in case <> of (<> when call 'erlang':'is_map' (Map) -> ~{Key:=_5|Map}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Map})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<~{}~> when 'true' -> call 'erlang':'error' ({'badkey',Key},[Key|[Fun|[Map|[]]]])
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<Key,Fun,Map> when 'true' -> let <_7> = apply 'error_type'/1 (Map) in call 'erlang':'error' (_7,[Key|[Fun|[Map|[]]]]) end
'update_with'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Key,Fun,Init,Map> when try let <_4> = call 'erlang':'is_function' (Fun,1) in let <_5> = call 'erlang':'is_map' (Map) in call 'erlang':'and' (_4,_5) of <Try> -> Try catch <T,R> -> 'false' -> case Map of <~{Key:=Value}~> when 'true' -> let <_6> = apply Fun (Value) in case <> of (<> when call 'erlang':'is_map' (Map) -> ~{Key:=_6|Map}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Map})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<~{}~> when 'true' -> case <> of (<> when call 'erlang':'is_map' (Map) -> ~{Key=>Init|Map}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Map})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<Key,Fun,Init,Map> when 'true' -> let <_8> = apply 'error_type'/1 (Map) in call 'erlang':'error' (_8,[Key|[Fun|[Init|[Map|[]]]]]) end
'get'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Key,Map,Default> when call 'erlang':'is_map' (Map) -> case Map of <~{Key:=Value}~> when 'true' -> Value
<~{}~> when 'true' -> Default
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<Key,Map,Default> when 'true' -> call 'erlang':'error' ({'badmap',Map},[Key|[Map|[Default|[]]]]) end
'filter'/2 = fun (_0,_1) -> case <_0,_1> of <Pred,Map> when try let <_2> = call 'erlang':'is_function' (Pred,2) in let <_3> = call 'erlang':'is_map' (Map) in call 'erlang':'and' (_2,_3) of <Try> -> Try catch <T,R> -> 'false' -> let <_4> = apply 'iterator'/1 (Map) in let <_5> = apply 'filter_1'/2 (Pred,_4) in call 'maps':'from_list' (_5)
<Pred,Iterator> when let <_12> = try let <_6> = call 'erlang':'is_function' (Pred,2) in (let <_10> = case call 'erlang':'is_tuple' (Iterator) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_8> = call 'erlang':'tuple_size' (Iterator) in call 'erlang':'=:=' (_8,3)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_7> when 'true' -> _7-|['compiler_generated'] ) end in let <_11> = call 'erlang':'=:=' ((_10-|['compiler_generated'] ),'true') in call 'erlang':'and' (_6,_11)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_13> = call 'erlang':'=:=' (Iterator,'none') in let <_19> = try let <_15> = call 'erlang':'hd' (Iterator) in (let <_18> = case call 'erlang':'is_integer' (_15) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_16> = call 'erlang':'tl' (Iterator) in call 'erlang':'is_map' (_16)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_14> when 'true' -> _14-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_18-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_20> = call 'erlang':'or' (_13,_19) in call 'erlang':'or' (_12,_20) -> let <_21> = apply 'filter_1'/2 (Pred,Iterator) in call 'maps':'from_list' (_21)
<Pred,Map> when 'true' -> let <_22> = apply 'error_type'/1 (Map) in call 'erlang':'error' (_22,[Pred|[Map|[]]]) end
'filter_1'/2 = fun (_0,_1) -> case apply 'next'/1 (_1) of <{K,V,NextIter}> when 'true' -> case apply _0 (K,V) of <'true'> when 'true' -> let <_2> = apply 'filter_1'/2 (_0,NextIter) in [{K,V}|_2]
<'false'> when 'true' -> apply 'filter_1'/2 (_0,NextIter)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<'none'> when 'true' -> []
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'fold'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Fun,Init,Map> when try let <_3> = call 'erlang':'is_function' (Fun,3) in let <_4> = call 'erlang':'is_map' (Map) in call 'erlang':'and' (_3,_4) of <Try> -> Try catch <T,R> -> 'false' -> let <_5> = apply 'iterator'/1 (Map) in apply 'fold_1'/3 (Fun,Init,_5)
<Fun,Init,Iterator> when let <_12> = try let <_6> = call 'erlang':'is_function' (Fun,3) in (let <_10> = case call 'erlang':'is_tuple' (Iterator) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_8> = call 'erlang':'tuple_size' (Iterator) in call 'erlang':'=:=' (_8,3)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_7> when 'true' -> _7-|['compiler_generated'] ) end in let <_11> = call 'erlang':'=:=' ((_10-|['compiler_generated'] ),'true') in call 'erlang':'and' (_6,_11)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_13> = call 'erlang':'=:=' (Iterator,'none') in let <_19> = try let <_15> = call 'erlang':'hd' (Iterator) in (let <_18> = case call 'erlang':'is_integer' (_15) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_16> = call 'erlang':'tl' (Iterator) in call 'erlang':'is_map' (_16)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_14> when 'true' -> _14-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_18-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_20> = call 'erlang':'or' (_13,_19) in call 'erlang':'or' (_12,_20) -> apply 'fold_1'/3 (Fun,Init,Iterator)
<Fun,Init,Map> when 'true' -> let <_21> = apply 'error_type_iter'/1 (Map) in call 'erlang':'error' (_21,[Fun|[Init|[Map|[]]]]) end
'fold_1'/3 = fun (_0,_1,_2) -> case apply 'next'/1 (_2) of <{K,V,NextIter}> when 'true' -> let <_3> = apply _0 (K,V,_1) in apply 'fold_1'/3 (_0,_3,NextIter)
<'none'> when 'true' -> _1
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'map'/2 = fun (_0,_1) -> case <_0,_1> of <Fun,Map> when try let <_2> = call 'erlang':'is_function' (Fun,2) in let <_3> = call 'erlang':'is_map' (Map) in call 'erlang':'and' (_2,_3) of <Try> -> Try catch <T,R> -> 'false' -> let <_4> = apply 'iterator'/1 (Map) in let <_5> = apply 'map_1'/2 (Fun,_4) in call 'maps':'from_list' (_5)
<Fun,Iterator> when let <_12> = try let <_6> = call 'erlang':'is_function' (Fun,2) in (let <_10> = case call 'erlang':'is_tuple' (Iterator) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_8> = call 'erlang':'tuple_size' (Iterator) in call 'erlang':'=:=' (_8,3)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_7> when 'true' -> _7-|['compiler_generated'] ) end in let <_11> = call 'erlang':'=:=' ((_10-|['compiler_generated'] ),'true') in call 'erlang':'and' (_6,_11)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_13> = call 'erlang':'=:=' (Iterator,'none') in let <_19> = try let <_15> = call 'erlang':'hd' (Iterator) in (let <_18> = case call 'erlang':'is_integer' (_15) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_16> = call 'erlang':'tl' (Iterator) in call 'erlang':'is_map' (_16)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_14> when 'true' -> _14-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_18-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_20> = call 'erlang':'or' (_13,_19) in call 'erlang':'or' (_12,_20) -> let <_21> = apply 'map_1'/2 (Fun,Iterator) in call 'maps':'from_list' (_21)
<Fun,Map> when 'true' -> let <_22> = apply 'error_type_iter'/1 (Map) in call 'erlang':'error' (_22,[Fun|[Map|[]]]) end
'map_1'/2 = fun (_0,_1) -> case apply 'next'/1 (_1) of <{K,V,NextIter}> when 'true' -> let <_2> = apply _0 (K,V) in let <_3> = apply 'map_1'/2 (_0,NextIter) in [{K,_2}|_3]
<'none'> when 'true' -> []
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'size'/1 = fun (_0) -> case _0 of <Map> when call 'erlang':'is_map' (_0) -> call 'erlang':'map_size' (Map)
<Val> when 'true' -> call 'erlang':'error' ({'badmap',Val},[Val|[]]) end
'iterator'/1 = fun (_0) -> case _0 of <M> when call 'erlang':'is_map' (_0) -> [0|M]
<M> when 'true' -> call 'erlang':'error' ({'badmap',M},[M|[]]) end
'next'/1 = fun (_0) -> case _0 of <_@r0 = {K,V,I}> when 'true' -> _@r0
<[Path|Map]> when let <_1> = call 'erlang':'is_integer' (Path) in let <_2> = call 'erlang':'is_map' (Map) in call 'erlang':'and' (_1,_2) -> call 'erts_internal':'map_next' (Path,Map,'iterator')
<'none'> when 'true' -> 'none'
<Iter> when 'true' -> call 'erlang':'error' ('badarg',[Iter|[]]) end
'without'/2 = fun (_0,_1) -> case <_0,_1> of <Ks,M> when let <_2> = call 'erlang':'is_list' (Ks) in let <_3> = call 'erlang':'is_map' (M) in call 'erlang':'and' (_2,_3) -> call 'lists':'foldl' (fun 'maps':'remove'/2,M,Ks)
<Ks,M> when 'true' -> let <_5> = apply 'error_type'/1 (M) in call 'erlang':'error' (_5,[Ks|[M|[]]]) end
'with'/2 = fun (_0,_1) -> case <_0,_1> of <Ks,Map1> when let <_2> = call 'erlang':'is_list' (Ks) in let <_3> = call 'erlang':'is_map' (Map1) in call 'erlang':'and' (_2,_3) -> let <_4> = apply 'with_1'/2 (Ks,Map1) in call 'maps':'from_list' (_4)
<Ks,M> when 'true' -> let <_5> = apply 'error_type'/1 (M) in call 'erlang':'error' (_5,[Ks|[M|[]]]) end
'with_1'/2 = fun (_0,_1) -> case <_0,_1> of <[K|Ks],Map> when 'true' -> case Map of <~{K:=V}~> when 'true' -> let <_2> = apply 'with_1'/2 (Ks,Map) in [{K,V}|_2]
<~{}~> when 'true' -> apply 'with_1'/2 (Ks,Map)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<[],_X_Map> when 'true' -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'with_1',2}}] )-|['compiler_generated'] ) end
'error_type'/1 = fun (_0) -> case _0 of <M> when call 'erlang':'is_map' (_0) -> 'badarg'
<V> when 'true' -> {'badmap',V} end
'error_type_iter'/1 = fun (_0) -> case _0 of <M> when let <_1> = call 'erlang':'is_map' (_0) in let <_6> = try (let <_5> = case call 'erlang':'is_tuple' (_0) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_3> = call 'erlang':'tuple_size' (_0) in call 'erlang':'=:=' (_3,3)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_2> when 'true' -> _2-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_5-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_7> = call 'erlang':'=:=' (_0,'none') in let <_13> = try let <_9> = call 'erlang':'hd' (_0) in (let <_12> = case call 'erlang':'is_integer' (_9) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_10> = call 'erlang':'tl' (_0) in call 'erlang':'is_map' (_10)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_8> when 'true' -> _8-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_12-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' in let <_14> = call 'erlang':'or' (_7,_13) in let <_15> = call 'erlang':'or' (_6,_14) in call 'erlang':'or' (_1,_15) -> 'badarg'
<V> when 'true' -> {'badmap',V} end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('maps')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('maps',_0) end