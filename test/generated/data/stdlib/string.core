module 'string' ['casefold'/1,'centre'/2,'centre'/3,'chars'/2,'chars'/3,'chomp'/1,'chr'/2,'concat'/2,'copies'/2,'cspan'/2,'equal'/2,'equal'/3,'equal'/4,'find'/2,'find'/3,'is_empty'/1,'join'/2,'left'/2,'left'/3,'len'/1,'length'/1,'lexemes'/2,'list_to_float'/1,'list_to_integer'/1,'lowercase'/1,'module_info'/0,'module_info'/1,'next_codepoint'/1,'next_grapheme'/1,'nth_lexeme'/3,'pad'/2,'pad'/3,'pad'/4,'prefix'/2,'rchr'/2,'replace'/3,'replace'/4,'reverse'/1,'right'/2,'right'/3,'rstr'/2,'slice'/2,'slice'/3,'span'/2,'split'/2,'split'/3,'str'/2,'strip'/1,'strip'/2,'strip'/3,'sub_string'/2,'sub_string'/3,'sub_word'/2,'sub_word'/3,'substr'/2,'substr'/3,'take'/2,'take'/3,'take'/4,'titlecase'/1,'to_float'/1,'to_graphemes'/1,'to_integer'/1,'to_lower'/1,'to_upper'/1,'tokens'/2,'trim'/1,'trim'/2,'trim'/3,'uppercase'/1,'words'/1,'words'/2] attributes [ 'file' = [{[115|[114|[99|[47|[115|[116|[114|[105|[110|[103|[46|[101|[114|[108]]]]]]]]]]]]]],1}]
, 'compile' = [{'no_auto_import',[{'length',1}]}]
, 'compile' = [{'inline',[{'btoken',2}|[{'rev',1}|[{'append',2}|[{'stack',2}|[{'search_compile',1}]]]]]}]
, 'export_type' = [{'grapheme_cluster',0}]
, 'type' = [{'grapheme_cluster',{'type',83,'union',[{'type',83,'char',[]}|[{'type',83,'list',[{'type',83,'char',[]}]}]]},[]}]
, 'type' = [{'direction',{'type',84,'union',[{'atom',84,'leading'}|[{'atom',84,'trailing'}]]},[]}]
, 'dialyzer' = [{'no_improper_lists',[{'stack',2}|[{'length_b',3}]]}]
, 'spec' = [{{'list_to_float',1},[{'type',92,'bounded_fun',[{'type',92,'fun',[{'type',92,'product',[{'var',92,'String'}]}|[{'type',92,'union',[{'type',92,'tuple',[{'var',92,'Float'}|[{'var',92,'Rest'}]]}|[{'type',92,'tuple',[{'atom',92,'error'}|[{'var',92,'Reason'}]]}]]}]]}|[[{'type',93,'constraint',[{'atom',93,'is_subtype'}|[[{'var',93,'String'}|[{'type',93,'string',[]}]]]]}|[{'type',94,'constraint',[{'atom',94,'is_subtype'}|[[{'var',94,'Float'}|[{'type',94,'float',[]}]]]]}|[{'type',95,'constraint',[{'atom',95,'is_subtype'}|[[{'var',95,'Rest'}|[{'type',95,'string',[]}]]]]}|[{'type',96,'constraint',[{'atom',96,'is_subtype'}|[[{'var',96,'Reason'}|[{'type',96,'union',[{'atom',96,'no_float'}|[{'atom',96,'not_a_list'}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'list_to_integer',1},[{'type',101,'bounded_fun',[{'type',101,'fun',[{'type',101,'product',[{'var',101,'String'}]}|[{'type',101,'union',[{'type',101,'tuple',[{'var',101,'Int'}|[{'var',101,'Rest'}]]}|[{'type',101,'tuple',[{'atom',101,'error'}|[{'var',101,'Reason'}]]}]]}]]}|[[{'type',102,'constraint',[{'atom',102,'is_subtype'}|[[{'var',102,'String'}|[{'type',102,'string',[]}]]]]}|[{'type',103,'constraint',[{'atom',103,'is_subtype'}|[[{'var',103,'Int'}|[{'type',103,'integer',[]}]]]]}|[{'type',104,'constraint',[{'atom',104,'is_subtype'}|[[{'var',104,'Rest'}|[{'type',104,'string',[]}]]]]}|[{'type',105,'constraint',[{'atom',105,'is_subtype'}|[[{'var',105,'Reason'}|[{'type',105,'union',[{'atom',105,'no_integer'}|[{'atom',105,'not_a_list'}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'is_empty',1},[{'type',113,'fun',[{'type',113,'product',[{'ann_type',113,[{'var',113,'String'}|[{'remote_type',113,[{'atom',113,'unicode'}|[{'atom',113,'chardata'}|[[]]]]}]]}]}|[{'type',113,'boolean',[]}]]}]}]
, 'spec' = [{{'length',1},[{'type',120,'fun',[{'type',120,'product',[{'ann_type',120,[{'var',120,'String'}|[{'remote_type',120,[{'atom',120,'unicode'}|[{'atom',120,'chardata'}|[[]]]]}]]}]}|[{'type',120,'non_neg_integer',[]}]]}]}]
, 'spec' = [{{'to_graphemes',1},[{'type',127,'fun',[{'type',127,'product',[{'ann_type',127,[{'var',127,'String'}|[{'remote_type',127,[{'atom',127,'unicode'}|[{'atom',127,'chardata'}|[[]]]]}]]}]}|[{'type',127,'list',[{'user_type',127,'grapheme_cluster',[]}]}]]}]}]
, 'spec' = [{{'equal',2},[{'type',137,'bounded_fun',[{'type',137,'fun',[{'type',137,'product',[{'var',137,'A'}|[{'var',137,'B'}]]}|[{'type',137,'boolean',[]}]]}|[[{'type',138,'constraint',[{'atom',138,'is_subtype'}|[[{'var',138,'A'}|[{'remote_type',138,[{'atom',138,'unicode'}|[{'atom',138,'chardata'}|[[]]]]}]]]]}|[{'type',139,'constraint',[{'atom',139,'is_subtype'}|[[{'var',139,'B'}|[{'remote_type',139,[{'atom',139,'unicode'}|[{'atom',139,'chardata'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'equal',3},[{'type',148,'bounded_fun',[{'type',148,'fun',[{'type',148,'product',[{'var',148,'A'}|[{'var',148,'B'}|[{'var',148,'IgnoreCase'}]]]}|[{'type',148,'boolean',[]}]]}|[[{'type',149,'constraint',[{'atom',149,'is_subtype'}|[[{'var',149,'A'}|[{'remote_type',149,[{'atom',149,'unicode'}|[{'atom',149,'chardata'}|[[]]]]}]]]]}|[{'type',150,'constraint',[{'atom',150,'is_subtype'}|[[{'var',150,'B'}|[{'remote_type',150,[{'atom',150,'unicode'}|[{'atom',150,'chardata'}|[[]]]]}]]]]}|[{'type',151,'constraint',[{'atom',151,'is_subtype'}|[[{'var',151,'IgnoreCase'}|[{'type',151,'boolean',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'equal',4},[{'type',159,'bounded_fun',[{'type',159,'fun',[{'type',159,'product',[{'var',159,'A'}|[{'var',159,'B'}|[{'var',159,'IgnoreCase'}|[{'var',159,'Norm'}]]]]}|[{'type',159,'boolean',[]}]]}|[[{'type',160,'constraint',[{'atom',160,'is_subtype'}|[[{'var',160,'A'}|[{'remote_type',160,[{'atom',160,'unicode'}|[{'atom',160,'chardata'}|[[]]]]}]]]]}|[{'type',161,'constraint',[{'atom',161,'is_subtype'}|[[{'var',161,'B'}|[{'remote_type',161,[{'atom',161,'unicode'}|[{'atom',161,'chardata'}|[[]]]]}]]]]}|[{'type',162,'constraint',[{'atom',162,'is_subtype'}|[[{'var',162,'IgnoreCase'}|[{'type',162,'boolean',[]}]]]]}|[{'type',163,'constraint',[{'atom',163,'is_subtype'}|[[{'var',163,'Norm'}|[{'type',163,'union',[{'atom',163,'none'}|[{'atom',163,'nfc'}|[{'atom',163,'nfd'}|[{'atom',163,'nfkc'}|[{'atom',163,'nfkd'}]]]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'reverse',1},[{'type',172,'fun',[{'type',172,'product',[{'ann_type',172,[{'var',172,'String'}|[{'remote_type',172,[{'atom',172,'unicode'}|[{'atom',172,'chardata'}|[[]]]]}]]}]}|[{'type',172,'list',[{'user_type',172,'grapheme_cluster',[]}]}]]}]}]
, 'spec' = [{{'slice',2},[{'type',180,'bounded_fun',[{'type',180,'fun',[{'type',180,'product',[{'var',180,'String'}|[{'var',180,'Start'}]]}|[{'var',180,'Slice'}]]}|[[{'type',181,'constraint',[{'atom',181,'is_subtype'}|[[{'var',181,'String'}|[{'remote_type',181,[{'atom',181,'unicode'}|[{'atom',181,'chardata'}|[[]]]]}]]]]}|[{'type',182,'constraint',[{'atom',182,'is_subtype'}|[[{'var',182,'Start'}|[{'type',182,'non_neg_integer',[]}]]]]}|[{'type',183,'constraint',[{'atom',183,'is_subtype'}|[[{'var',183,'Slice'}|[{'remote_type',183,[{'atom',183,'unicode'}|[{'atom',183,'chardata'}|[[]]]]}]]]]}]]]]]}]}]
, 'spec' = [{{'slice',3},[{'type',190,'bounded_fun',[{'type',190,'fun',[{'type',190,'product',[{'var',190,'String'}|[{'var',190,'Start'}|[{'var',190,'Length'}]]]}|[{'var',190,'Slice'}]]}|[[{'type',191,'constraint',[{'atom',191,'is_subtype'}|[[{'var',191,'String'}|[{'remote_type',191,[{'atom',191,'unicode'}|[{'atom',191,'chardata'}|[[]]]]}]]]]}|[{'type',192,'constraint',[{'atom',192,'is_subtype'}|[[{'var',192,'Start'}|[{'type',192,'non_neg_integer',[]}]]]]}|[{'type',193,'constraint',[{'atom',193,'is_subtype'}|[[{'var',193,'Length'}|[{'type',193,'union',[{'atom',193,'infinity'}|[{'type',193,'non_neg_integer',[]}]]}]]]]}|[{'type',194,'constraint',[{'atom',194,'is_subtype'}|[[{'var',194,'Slice'}|[{'remote_type',194,[{'atom',194,'unicode'}|[{'atom',194,'chardata'}|[[]]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'pad',2},[{'type',213,'bounded_fun',[{'type',213,'fun',[{'type',213,'product',[{'var',213,'String'}|[{'var',213,'Length'}]]}|[{'remote_type',213,[{'atom',213,'unicode'}|[{'atom',213,'charlist'}|[[]]]]}]]}|[[{'type',214,'constraint',[{'atom',214,'is_subtype'}|[[{'var',214,'String'}|[{'remote_type',214,[{'atom',214,'unicode'}|[{'atom',214,'chardata'}|[[]]]]}]]]]}|[{'type',215,'constraint',[{'atom',215,'is_subtype'}|[[{'var',215,'Length'}|[{'type',215,'integer',[]}]]]]}]]]]}]}]
, 'spec' = [{{'pad',3},[{'type',219,'bounded_fun',[{'type',219,'fun',[{'type',219,'product',[{'var',219,'String'}|[{'var',219,'Length'}|[{'var',219,'Dir'}]]]}|[{'remote_type',219,[{'atom',219,'unicode'}|[{'atom',219,'charlist'}|[[]]]]}]]}|[[{'type',220,'constraint',[{'atom',220,'is_subtype'}|[[{'var',220,'String'}|[{'remote_type',220,[{'atom',220,'unicode'}|[{'atom',220,'chardata'}|[[]]]]}]]]]}|[{'type',221,'constraint',[{'atom',221,'is_subtype'}|[[{'var',221,'Length'}|[{'type',221,'integer',[]}]]]]}|[{'type',222,'constraint',[{'atom',222,'is_subtype'}|[[{'var',222,'Dir'}|[{'type',222,'union',[{'user_type',222,'direction',[]}|[{'atom',222,'both'}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'pad',4},[{'type',226,'bounded_fun',[{'type',226,'fun',[{'type',226,'product',[{'var',226,'String'}|[{'var',226,'Length'}|[{'var',226,'Dir'}|[{'var',226,'Char'}]]]]}|[{'remote_type',226,[{'atom',226,'unicode'}|[{'atom',226,'charlist'}|[[]]]]}]]}|[[{'type',227,'constraint',[{'atom',227,'is_subtype'}|[[{'var',227,'String'}|[{'remote_type',227,[{'atom',227,'unicode'}|[{'atom',227,'chardata'}|[[]]]]}]]]]}|[{'type',228,'constraint',[{'atom',228,'is_subtype'}|[[{'var',228,'Length'}|[{'type',228,'integer',[]}]]]]}|[{'type',229,'constraint',[{'atom',229,'is_subtype'}|[[{'var',229,'Dir'}|[{'type',229,'union',[{'user_type',229,'direction',[]}|[{'atom',229,'both'}]]}]]]]}|[{'type',230,'constraint',[{'atom',230,'is_subtype'}|[[{'var',230,'Char'}|[{'user_type',230,'grapheme_cluster',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'trim',1},[{'type',248,'bounded_fun',[{'type',248,'fun',[{'type',248,'product',[{'var',248,'String'}]}|[{'remote_type',248,[{'atom',248,'unicode'}|[{'atom',248,'chardata'}|[[]]]]}]]}|[[{'type',249,'constraint',[{'atom',249,'is_subtype'}|[[{'var',249,'String'}|[{'remote_type',249,[{'atom',249,'unicode'}|[{'atom',249,'chardata'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'trim',2},[{'type',253,'bounded_fun',[{'type',253,'fun',[{'type',253,'product',[{'var',253,'String'}|[{'var',253,'Dir'}]]}|[{'remote_type',253,[{'atom',253,'unicode'}|[{'atom',253,'chardata'}|[[]]]]}]]}|[[{'type',254,'constraint',[{'atom',254,'is_subtype'}|[[{'var',254,'String'}|[{'remote_type',254,[{'atom',254,'unicode'}|[{'atom',254,'chardata'}|[[]]]]}]]]]}|[{'type',255,'constraint',[{'atom',255,'is_subtype'}|[[{'var',255,'Dir'}|[{'type',255,'union',[{'user_type',255,'direction',[]}|[{'atom',255,'both'}]]}]]]]}]]]]}]}]
, 'spec' = [{{'trim',3},[{'type',259,'bounded_fun',[{'type',259,'fun',[{'type',259,'product',[{'var',259,'String'}|[{'var',259,'Dir'}|[{'var',259,'Characters'}]]]}|[{'remote_type',259,[{'atom',259,'unicode'}|[{'atom',259,'chardata'}|[[]]]]}]]}|[[{'type',260,'constraint',[{'atom',260,'is_subtype'}|[[{'var',260,'String'}|[{'remote_type',260,[{'atom',260,'unicode'}|[{'atom',260,'chardata'}|[[]]]]}]]]]}|[{'type',261,'constraint',[{'atom',261,'is_subtype'}|[[{'var',261,'Dir'}|[{'type',261,'union',[{'user_type',261,'direction',[]}|[{'atom',261,'both'}]]}]]]]}|[{'type',262,'constraint',[{'atom',262,'is_subtype'}|[[{'var',262,'Characters'}|[{'type',262,'list',[{'user_type',262,'grapheme_cluster',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'chomp',1},[{'type',277,'fun',[{'type',277,'product',[{'ann_type',277,[{'var',277,'String'}|[{'remote_type',277,[{'atom',277,'unicode'}|[{'atom',277,'chardata'}|[[]]]]}]]}]}|[{'remote_type',277,[{'atom',277,'unicode'}|[{'atom',277,'chardata'}|[[]]]]}]]}]}]
, 'spec' = [{{'take',2},[{'type',282,'bounded_fun',[{'type',282,'fun',[{'type',282,'product',[{'var',282,'String'}|[{'var',282,'Characters'}]]}|[{'type',282,'tuple',[{'var',282,'Leading'}|[{'var',282,'Trailing'}]]}]]}|[[{'type',283,'constraint',[{'atom',283,'is_subtype'}|[[{'var',283,'String'}|[{'remote_type',283,[{'atom',283,'unicode'}|[{'atom',283,'chardata'}|[[]]]]}]]]]}|[{'type',284,'constraint',[{'atom',284,'is_subtype'}|[[{'var',284,'Characters'}|[{'type',284,'list',[{'user_type',284,'grapheme_cluster',[]}]}]]]]}|[{'type',285,'constraint',[{'atom',285,'is_subtype'}|[[{'var',285,'Leading'}|[{'remote_type',285,[{'atom',285,'unicode'}|[{'atom',285,'chardata'}|[[]]]]}]]]]}|[{'type',286,'constraint',[{'atom',286,'is_subtype'}|[[{'var',286,'Trailing'}|[{'remote_type',286,[{'atom',286,'unicode'}|[{'atom',286,'chardata'}|[[]]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'take',3},[{'type',289,'bounded_fun',[{'type',289,'fun',[{'type',289,'product',[{'var',289,'String'}|[{'var',289,'Characters'}|[{'var',289,'Complement'}]]]}|[{'type',289,'tuple',[{'var',289,'Leading'}|[{'var',289,'Trailing'}]]}]]}|[[{'type',290,'constraint',[{'atom',290,'is_subtype'}|[[{'var',290,'String'}|[{'remote_type',290,[{'atom',290,'unicode'}|[{'atom',290,'chardata'}|[[]]]]}]]]]}|[{'type',291,'constraint',[{'atom',291,'is_subtype'}|[[{'var',291,'Characters'}|[{'type',291,'list',[{'user_type',291,'grapheme_cluster',[]}]}]]]]}|[{'type',292,'constraint',[{'atom',292,'is_subtype'}|[[{'var',292,'Complement'}|[{'type',292,'boolean',[]}]]]]}|[{'type',293,'constraint',[{'atom',293,'is_subtype'}|[[{'var',293,'Leading'}|[{'remote_type',293,[{'atom',293,'unicode'}|[{'atom',293,'chardata'}|[[]]]]}]]]]}|[{'type',294,'constraint',[{'atom',294,'is_subtype'}|[[{'var',294,'Trailing'}|[{'remote_type',294,[{'atom',294,'unicode'}|[{'atom',294,'chardata'}|[[]]]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'take',4},[{'type',297,'bounded_fun',[{'type',297,'fun',[{'type',297,'product',[{'var',297,'String'}|[{'var',297,'Characters'}|[{'var',297,'Complement'}|[{'var',297,'Dir'}]]]]}|[{'type',297,'tuple',[{'var',297,'Leading'}|[{'var',297,'Trailing'}]]}]]}|[[{'type',298,'constraint',[{'atom',298,'is_subtype'}|[[{'var',298,'String'}|[{'remote_type',298,[{'atom',298,'unicode'}|[{'atom',298,'chardata'}|[[]]]]}]]]]}|[{'type',299,'constraint',[{'atom',299,'is_subtype'}|[[{'var',299,'Characters'}|[{'type',299,'list',[{'user_type',299,'grapheme_cluster',[]}]}]]]]}|[{'type',300,'constraint',[{'atom',300,'is_subtype'}|[[{'var',300,'Complement'}|[{'type',300,'boolean',[]}]]]]}|[{'type',301,'constraint',[{'atom',301,'is_subtype'}|[[{'var',301,'Dir'}|[{'user_type',301,'direction',[]}]]]]}|[{'type',302,'constraint',[{'atom',302,'is_subtype'}|[[{'var',302,'Leading'}|[{'remote_type',302,[{'atom',302,'unicode'}|[{'atom',302,'chardata'}|[[]]]]}]]]]}|[{'type',303,'constraint',[{'atom',303,'is_subtype'}|[[{'var',303,'Trailing'}|[{'remote_type',303,[{'atom',303,'unicode'}|[{'atom',303,'chardata'}|[[]]]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'uppercase',1},[{'type',325,'fun',[{'type',325,'product',[{'ann_type',325,[{'var',325,'String'}|[{'remote_type',325,[{'atom',325,'unicode'}|[{'atom',325,'chardata'}|[[]]]]}]]}]}|[{'remote_type',325,[{'atom',325,'unicode'}|[{'atom',325,'chardata'}|[[]]]]}]]}]}]
, 'spec' = [{{'lowercase',1},[{'type',342,'fun',[{'type',342,'product',[{'ann_type',342,[{'var',342,'String'}|[{'remote_type',342,[{'atom',342,'unicode'}|[{'atom',342,'chardata'}|[[]]]]}]]}]}|[{'remote_type',342,[{'atom',342,'unicode'}|[{'atom',342,'chardata'}|[[]]]]}]]}]}]
, 'spec' = [{{'titlecase',1},[{'type',359,'fun',[{'type',359,'product',[{'ann_type',359,[{'var',359,'String'}|[{'remote_type',359,[{'atom',359,'unicode'}|[{'atom',359,'chardata'}|[[]]]]}]]}]}|[{'remote_type',359,[{'atom',359,'unicode'}|[{'atom',359,'chardata'}|[[]]]]}]]}]}]
, 'spec' = [{{'casefold',1},[{'type',374,'fun',[{'type',374,'product',[{'ann_type',374,[{'var',374,'String'}|[{'remote_type',374,[{'atom',374,'unicode'}|[{'atom',374,'chardata'}|[[]]]]}]]}]}|[{'remote_type',374,[{'atom',374,'unicode'}|[{'atom',374,'chardata'}|[[]]]]}]]}]}]
, 'spec' = [{{'to_integer',1},[{'type',389,'bounded_fun',[{'type',389,'fun',[{'type',389,'product',[{'var',389,'String'}]}|[{'type',389,'union',[{'type',389,'tuple',[{'var',389,'Int'}|[{'var',389,'Rest'}]]}|[{'type',389,'tuple',[{'atom',389,'error'}|[{'var',389,'Reason'}]]}]]}]]}|[[{'type',390,'constraint',[{'atom',390,'is_subtype'}|[[{'var',390,'String'}|[{'remote_type',390,[{'atom',390,'unicode'}|[{'atom',390,'chardata'}|[[]]]]}]]]]}|[{'type',391,'constraint',[{'atom',391,'is_subtype'}|[[{'var',391,'Int'}|[{'type',391,'integer',[]}]]]]}|[{'type',392,'constraint',[{'atom',392,'is_subtype'}|[[{'var',392,'Rest'}|[{'remote_type',392,[{'atom',392,'unicode'}|[{'atom',392,'chardata'}|[[]]]]}]]]]}|[{'type',393,'constraint',[{'atom',393,'is_subtype'}|[[{'var',393,'Reason'}|[{'type',393,'union',[{'atom',393,'no_integer'}|[{'atom',393,'badarg'}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'to_float',1},[{'type',411,'bounded_fun',[{'type',411,'fun',[{'type',411,'product',[{'var',411,'String'}]}|[{'type',411,'union',[{'type',411,'tuple',[{'var',411,'Float'}|[{'var',411,'Rest'}]]}|[{'type',411,'tuple',[{'atom',411,'error'}|[{'var',411,'Reason'}]]}]]}]]}|[[{'type',412,'constraint',[{'atom',412,'is_subtype'}|[[{'var',412,'String'}|[{'remote_type',412,[{'atom',412,'unicode'}|[{'atom',412,'chardata'}|[[]]]]}]]]]}|[{'type',413,'constraint',[{'atom',413,'is_subtype'}|[[{'var',413,'Float'}|[{'type',413,'float',[]}]]]]}|[{'type',414,'constraint',[{'atom',414,'is_subtype'}|[[{'var',414,'Rest'}|[{'remote_type',414,[{'atom',414,'unicode'}|[{'atom',414,'chardata'}|[[]]]]}]]]]}|[{'type',415,'constraint',[{'atom',415,'is_subtype'}|[[{'var',415,'Reason'}|[{'type',415,'union',[{'atom',415,'no_float'}|[{'atom',415,'badarg'}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'prefix',2},[{'type',441,'fun',[{'type',441,'product',[{'ann_type',441,[{'var',441,'String'}|[{'remote_type',441,[{'atom',441,'unicode'}|[{'atom',441,'chardata'}|[[]]]]}]]}|[{'ann_type',441,[{'var',441,'Prefix'}|[{'remote_type',441,[{'atom',441,'unicode'}|[{'atom',441,'chardata'}|[[]]]]}]]}]]}|[{'type',442,'union',[{'atom',442,'nomatch'}|[{'remote_type',442,[{'atom',442,'unicode'}|[{'atom',442,'chardata'}|[[]]]]}]]}]]}]}]
, 'spec' = [{{'split',2},[{'type',454,'bounded_fun',[{'type',454,'fun',[{'type',454,'product',[{'var',454,'String'}|[{'var',454,'SearchPattern'}]]}|[{'type',454,'list',[{'remote_type',454,[{'atom',454,'unicode'}|[{'atom',454,'chardata'}|[[]]]]}]}]]}|[[{'type',455,'constraint',[{'atom',455,'is_subtype'}|[[{'var',455,'String'}|[{'remote_type',455,[{'atom',455,'unicode'}|[{'atom',455,'chardata'}|[[]]]]}]]]]}|[{'type',456,'constraint',[{'atom',456,'is_subtype'}|[[{'var',456,'SearchPattern'}|[{'remote_type',456,[{'atom',456,'unicode'}|[{'atom',456,'chardata'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'split',3},[{'type',461,'bounded_fun',[{'type',461,'fun',[{'type',461,'product',[{'var',461,'String'}|[{'var',461,'SearchPattern'}|[{'var',461,'Where'}]]]}|[{'type',461,'list',[{'remote_type',461,[{'atom',461,'unicode'}|[{'atom',461,'chardata'}|[[]]]]}]}]]}|[[{'type',462,'constraint',[{'atom',462,'is_subtype'}|[[{'var',462,'String'}|[{'remote_type',462,[{'atom',462,'unicode'}|[{'atom',462,'chardata'}|[[]]]]}]]]]}|[{'type',463,'constraint',[{'atom',463,'is_subtype'}|[[{'var',463,'SearchPattern'}|[{'remote_type',463,[{'atom',463,'unicode'}|[{'atom',463,'chardata'}|[[]]]]}]]]]}|[{'type',464,'constraint',[{'atom',464,'is_subtype'}|[[{'var',464,'Where'}|[{'type',464,'union',[{'user_type',464,'direction',[]}|[{'atom',464,'all'}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'replace',3},[{'type',479,'bounded_fun',[{'type',479,'fun',[{'type',479,'product',[{'var',479,'String'}|[{'var',479,'SearchPattern'}|[{'var',479,'Replacement'}]]]}|[{'type',480,'list',[{'remote_type',480,[{'atom',480,'unicode'}|[{'atom',480,'chardata'}|[[]]]]}]}]]}|[[{'type',481,'constraint',[{'atom',481,'is_subtype'}|[[{'var',481,'String'}|[{'remote_type',481,[{'atom',481,'unicode'}|[{'atom',481,'chardata'}|[[]]]]}]]]]}|[{'type',482,'constraint',[{'atom',482,'is_subtype'}|[[{'var',482,'SearchPattern'}|[{'remote_type',482,[{'atom',482,'unicode'}|[{'atom',482,'chardata'}|[[]]]]}]]]]}|[{'type',483,'constraint',[{'atom',483,'is_subtype'}|[[{'var',483,'Replacement'}|[{'remote_type',483,[{'atom',483,'unicode'}|[{'atom',483,'chardata'}|[[]]]]}]]]]}]]]]]}]}]
, 'spec' = [{{'replace',4},[{'type',488,'bounded_fun',[{'type',488,'fun',[{'type',488,'product',[{'var',488,'String'}|[{'var',488,'SearchPattern'}|[{'var',488,'Replacement'}|[{'var',488,'Where'}]]]]}|[{'type',489,'list',[{'remote_type',489,[{'atom',489,'unicode'}|[{'atom',489,'chardata'}|[[]]]]}]}]]}|[[{'type',490,'constraint',[{'atom',490,'is_subtype'}|[[{'var',490,'String'}|[{'remote_type',490,[{'atom',490,'unicode'}|[{'atom',490,'chardata'}|[[]]]]}]]]]}|[{'type',491,'constraint',[{'atom',491,'is_subtype'}|[[{'var',491,'SearchPattern'}|[{'remote_type',491,[{'atom',491,'unicode'}|[{'atom',491,'chardata'}|[[]]]]}]]]]}|[{'type',492,'constraint',[{'atom',492,'is_subtype'}|[[{'var',492,'Replacement'}|[{'remote_type',492,[{'atom',492,'unicode'}|[{'atom',492,'chardata'}|[[]]]]}]]]]}|[{'type',493,'constraint',[{'atom',493,'is_subtype'}|[[{'var',493,'Where'}|[{'type',493,'union',[{'user_type',493,'direction',[]}|[{'atom',493,'all'}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'lexemes',2},[{'type',499,'fun',[{'type',499,'product',[{'ann_type',499,[{'var',499,'String'}|[{'remote_type',499,[{'atom',499,'unicode'}|[{'atom',499,'chardata'}|[[]]]]}]]}|[{'ann_type',500,[{'var',500,'SeparatorList'}|[{'type',500,'list',[{'user_type',500,'grapheme_cluster',[]}]}]]}]]}|[{'type',501,'list',[{'remote_type',501,[{'atom',501,'unicode'}|[{'atom',501,'chardata'}|[[]]]]}]}]]}]}]
, 'spec' = [{{'nth_lexeme',3},[{'type',508,'bounded_fun',[{'type',508,'fun',[{'type',508,'product',[{'var',508,'String'}|[{'var',508,'N'}|[{'var',508,'SeparatorList'}]]]}|[{'remote_type',508,[{'atom',508,'unicode'}|[{'atom',508,'chardata'}|[[]]]]}]]}|[[{'type',509,'constraint',[{'atom',509,'is_subtype'}|[[{'var',509,'String'}|[{'remote_type',509,[{'atom',509,'unicode'}|[{'atom',509,'chardata'}|[[]]]]}]]]]}|[{'type',510,'constraint',[{'atom',510,'is_subtype'}|[[{'var',510,'N'}|[{'type',510,'non_neg_integer',[]}]]]]}|[{'type',511,'constraint',[{'atom',511,'is_subtype'}|[[{'var',511,'SeparatorList'}|[{'type',511,'list',[{'user_type',511,'grapheme_cluster',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'find',2},[{'type',519,'bounded_fun',[{'type',519,'fun',[{'type',519,'product',[{'var',519,'String'}|[{'var',519,'SearchPattern'}]]}|[{'type',519,'union',[{'remote_type',519,[{'atom',519,'unicode'}|[{'atom',519,'chardata'}|[[]]]]}|[{'atom',519,'nomatch'}]]}]]}|[[{'type',520,'constraint',[{'atom',520,'is_subtype'}|[[{'var',520,'String'}|[{'remote_type',520,[{'atom',520,'unicode'}|[{'atom',520,'chardata'}|[[]]]]}]]]]}|[{'type',521,'constraint',[{'atom',521,'is_subtype'}|[[{'var',521,'SearchPattern'}|[{'remote_type',521,[{'atom',521,'unicode'}|[{'atom',521,'chardata'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'find',3},[{'type',526,'bounded_fun',[{'type',526,'fun',[{'type',526,'product',[{'var',526,'String'}|[{'var',526,'SearchPattern'}|[{'var',526,'Dir'}]]]}|[{'type',526,'union',[{'remote_type',526,[{'atom',526,'unicode'}|[{'atom',526,'chardata'}|[[]]]]}|[{'atom',526,'nomatch'}]]}]]}|[[{'type',527,'constraint',[{'atom',527,'is_subtype'}|[[{'var',527,'String'}|[{'remote_type',527,[{'atom',527,'unicode'}|[{'atom',527,'chardata'}|[[]]]]}]]]]}|[{'type',528,'constraint',[{'atom',528,'is_subtype'}|[[{'var',528,'SearchPattern'}|[{'remote_type',528,[{'atom',528,'unicode'}|[{'atom',528,'chardata'}|[[]]]]}]]]]}|[{'type',529,'constraint',[{'atom',529,'is_subtype'}|[[{'var',529,'Dir'}|[{'user_type',529,'direction',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'next_grapheme',1},[{'type',538,'fun',[{'type',538,'product',[{'ann_type',538,[{'var',538,'String'}|[{'remote_type',538,[{'atom',538,'unicode'}|[{'atom',538,'chardata'}|[[]]]]}]]}]}|[{'type',539,'union',[{'type',539,'maybe_improper_list',[{'user_type',539,'grapheme_cluster',[]}|[{'remote_type',539,[{'atom',539,'unicode'}|[{'atom',539,'chardata'}|[[]]]]}]]}|[{'type',540,'tuple',[{'atom',540,'error'}|[{'remote_type',540,[{'atom',540,'unicode'}|[{'atom',540,'chardata'}|[[]]]]}]]}]]}]]}]}]
, 'spec' = [{{'next_codepoint',1},[{'type',544,'fun',[{'type',544,'product',[{'ann_type',544,[{'var',544,'String'}|[{'remote_type',544,[{'atom',544,'unicode'}|[{'atom',544,'chardata'}|[[]]]]}]]}]}|[{'type',545,'union',[{'type',545,'maybe_improper_list',[{'type',545,'char',[]}|[{'remote_type',545,[{'atom',545,'unicode'}|[{'atom',545,'chardata'}|[[]]]]}]]}|[{'type',546,'tuple',[{'atom',546,'error'}|[{'remote_type',546,[{'atom',546,'unicode'}|[{'atom',546,'chardata'}|[[]]]]}]]}]]}]]}]}]
, 'spec' = [{{'len',1},[{'type',1764,'bounded_fun',[{'type',1764,'fun',[{'type',1764,'product',[{'var',1764,'String'}]}|[{'var',1764,'Length'}]]}|[[{'type',1765,'constraint',[{'atom',1765,'is_subtype'}|[[{'var',1765,'String'}|[{'type',1765,'string',[]}]]]]}|[{'type',1766,'constraint',[{'atom',1766,'is_subtype'}|[[{'var',1766,'Length'}|[{'type',1766,'non_neg_integer',[]}]]]]}]]]]}]}]
, 'spec' = [{{'concat',2},[{'type',1783,'bounded_fun',[{'type',1783,'fun',[{'type',1783,'product',[{'var',1783,'String1'}|[{'var',1783,'String2'}]]}|[{'var',1783,'String3'}]]}|[[{'type',1784,'constraint',[{'atom',1784,'is_subtype'}|[[{'var',1784,'String1'}|[{'type',1784,'string',[]}]]]]}|[{'type',1785,'constraint',[{'atom',1785,'is_subtype'}|[[{'var',1785,'String2'}|[{'type',1785,'string',[]}]]]]}|[{'type',1786,'constraint',[{'atom',1786,'is_subtype'}|[[{'var',1786,'String3'}|[{'type',1786,'string',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'chr',2},[{'type',1794,'bounded_fun',[{'type',1794,'fun',[{'type',1794,'product',[{'var',1794,'String'}|[{'var',1794,'Character'}]]}|[{'var',1794,'Index'}]]}|[[{'type',1795,'constraint',[{'atom',1795,'is_subtype'}|[[{'var',1795,'String'}|[{'type',1795,'string',[]}]]]]}|[{'type',1796,'constraint',[{'atom',1796,'is_subtype'}|[[{'var',1796,'Character'}|[{'type',1796,'char',[]}]]]]}|[{'type',1797,'constraint',[{'atom',1797,'is_subtype'}|[[{'var',1797,'Index'}|[{'type',1797,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'rchr',2},[{'type',1805,'bounded_fun',[{'type',1805,'fun',[{'type',1805,'product',[{'var',1805,'String'}|[{'var',1805,'Character'}]]}|[{'var',1805,'Index'}]]}|[[{'type',1806,'constraint',[{'atom',1806,'is_subtype'}|[[{'var',1806,'String'}|[{'type',1806,'string',[]}]]]]}|[{'type',1807,'constraint',[{'atom',1807,'is_subtype'}|[[{'var',1807,'Character'}|[{'type',1807,'char',[]}]]]]}|[{'type',1808,'constraint',[{'atom',1808,'is_subtype'}|[[{'var',1808,'Index'}|[{'type',1808,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'str',2},[{'type',1824,'bounded_fun',[{'type',1824,'fun',[{'type',1824,'product',[{'var',1824,'String'}|[{'var',1824,'SubString'}]]}|[{'var',1824,'Index'}]]}|[[{'type',1825,'constraint',[{'atom',1825,'is_subtype'}|[[{'var',1825,'String'}|[{'type',1825,'string',[]}]]]]}|[{'type',1826,'constraint',[{'atom',1826,'is_subtype'}|[[{'var',1826,'SubString'}|[{'type',1826,'string',[]}]]]]}|[{'type',1827,'constraint',[{'atom',1827,'is_subtype'}|[[{'var',1827,'Index'}|[{'type',1827,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'rstr',2},[{'type',1839,'bounded_fun',[{'type',1839,'fun',[{'type',1839,'product',[{'var',1839,'String'}|[{'var',1839,'SubString'}]]}|[{'var',1839,'Index'}]]}|[[{'type',1840,'constraint',[{'atom',1840,'is_subtype'}|[[{'var',1840,'String'}|[{'type',1840,'string',[]}]]]]}|[{'type',1841,'constraint',[{'atom',1841,'is_subtype'}|[[{'var',1841,'SubString'}|[{'type',1841,'string',[]}]]]]}|[{'type',1842,'constraint',[{'atom',1842,'is_subtype'}|[[{'var',1842,'Index'}|[{'type',1842,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'span',2},[{'type',1861,'bounded_fun',[{'type',1861,'fun',[{'type',1861,'product',[{'var',1861,'String'}|[{'var',1861,'Chars'}]]}|[{'var',1861,'Length'}]]}|[[{'type',1862,'constraint',[{'atom',1862,'is_subtype'}|[[{'var',1862,'String'}|[{'type',1862,'string',[]}]]]]}|[{'type',1863,'constraint',[{'atom',1863,'is_subtype'}|[[{'var',1863,'Chars'}|[{'type',1863,'string',[]}]]]]}|[{'type',1864,'constraint',[{'atom',1864,'is_subtype'}|[[{'var',1864,'Length'}|[{'type',1864,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'cspan',2},[{'type',1875,'bounded_fun',[{'type',1875,'fun',[{'type',1875,'product',[{'var',1875,'String'}|[{'var',1875,'Chars'}]]}|[{'var',1875,'Length'}]]}|[[{'type',1876,'constraint',[{'atom',1876,'is_subtype'}|[[{'var',1876,'String'}|[{'type',1876,'string',[]}]]]]}|[{'type',1877,'constraint',[{'atom',1877,'is_subtype'}|[[{'var',1877,'Chars'}|[{'type',1877,'string',[]}]]]]}|[{'type',1878,'constraint',[{'atom',1878,'is_subtype'}|[[{'var',1878,'Length'}|[{'type',1878,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'substr',2},[{'type',1893,'bounded_fun',[{'type',1893,'fun',[{'type',1893,'product',[{'var',1893,'String'}|[{'var',1893,'Start'}]]}|[{'var',1893,'SubString'}]]}|[[{'type',1894,'constraint',[{'atom',1894,'is_subtype'}|[[{'var',1894,'String'}|[{'type',1894,'string',[]}]]]]}|[{'type',1895,'constraint',[{'atom',1895,'is_subtype'}|[[{'var',1895,'SubString'}|[{'type',1895,'string',[]}]]]]}|[{'type',1896,'constraint',[{'atom',1896,'is_subtype'}|[[{'var',1896,'Start'}|[{'type',1896,'pos_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'substr',3},[{'type',1903,'bounded_fun',[{'type',1903,'fun',[{'type',1903,'product',[{'var',1903,'String'}|[{'var',1903,'Start'}|[{'var',1903,'Length'}]]]}|[{'var',1903,'SubString'}]]}|[[{'type',1904,'constraint',[{'atom',1904,'is_subtype'}|[[{'var',1904,'String'}|[{'type',1904,'string',[]}]]]]}|[{'type',1905,'constraint',[{'atom',1905,'is_subtype'}|[[{'var',1905,'SubString'}|[{'type',1905,'string',[]}]]]]}|[{'type',1906,'constraint',[{'atom',1906,'is_subtype'}|[[{'var',1906,'Start'}|[{'type',1906,'pos_integer',[]}]]]]}|[{'type',1907,'constraint',[{'atom',1907,'is_subtype'}|[[{'var',1907,'Length'}|[{'type',1907,'non_neg_integer',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'tokens',2},[{'type',1921,'bounded_fun',[{'type',1921,'fun',[{'type',1921,'product',[{'var',1921,'String'}|[{'var',1921,'SeparatorList'}]]}|[{'var',1921,'Tokens'}]]}|[[{'type',1922,'constraint',[{'atom',1922,'is_subtype'}|[[{'var',1922,'String'}|[{'type',1922,'string',[]}]]]]}|[{'type',1923,'constraint',[{'atom',1923,'is_subtype'}|[[{'var',1923,'SeparatorList'}|[{'type',1923,'string',[]}]]]]}|[{'type',1924,'constraint',[{'atom',1924,'is_subtype'}|[[{'var',1924,'Tokens'}|[{'type',1924,'list',[{'ann_type',1924,[{'var',1924,'Token'}|[{'type',1924,'nonempty_string',[]}]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'chars',2},[{'type',1969,'bounded_fun',[{'type',1969,'fun',[{'type',1969,'product',[{'var',1969,'Character'}|[{'var',1969,'Number'}]]}|[{'var',1969,'String'}]]}|[[{'type',1970,'constraint',[{'atom',1970,'is_subtype'}|[[{'var',1970,'Character'}|[{'type',1970,'char',[]}]]]]}|[{'type',1971,'constraint',[{'atom',1971,'is_subtype'}|[[{'var',1971,'Number'}|[{'type',1971,'non_neg_integer',[]}]]]]}|[{'type',1972,'constraint',[{'atom',1972,'is_subtype'}|[[{'var',1972,'String'}|[{'type',1972,'string',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'chars',3},[{'type',1976,'bounded_fun',[{'type',1976,'fun',[{'type',1976,'product',[{'var',1976,'Character'}|[{'var',1976,'Number'}|[{'var',1976,'Tail'}]]]}|[{'var',1976,'String'}]]}|[[{'type',1977,'constraint',[{'atom',1977,'is_subtype'}|[[{'var',1977,'Character'}|[{'type',1977,'char',[]}]]]]}|[{'type',1978,'constraint',[{'atom',1978,'is_subtype'}|[[{'var',1978,'Number'}|[{'type',1978,'non_neg_integer',[]}]]]]}|[{'type',1979,'constraint',[{'atom',1979,'is_subtype'}|[[{'var',1979,'Tail'}|[{'type',1979,'string',[]}]]]]}|[{'type',1980,'constraint',[{'atom',1980,'is_subtype'}|[[{'var',1980,'String'}|[{'type',1980,'string',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'copies',2},[{'type',1991,'bounded_fun',[{'type',1991,'fun',[{'type',1991,'product',[{'var',1991,'String'}|[{'var',1991,'Number'}]]}|[{'var',1991,'Copies'}]]}|[[{'type',1992,'constraint',[{'atom',1992,'is_subtype'}|[[{'var',1992,'String'}|[{'type',1992,'string',[]}]]]]}|[{'type',1993,'constraint',[{'atom',1993,'is_subtype'}|[[{'var',1993,'Copies'}|[{'type',1993,'string',[]}]]]]}|[{'type',1994,'constraint',[{'atom',1994,'is_subtype'}|[[{'var',1994,'Number'}|[{'type',1994,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'words',1},[{'type',2006,'bounded_fun',[{'type',2006,'fun',[{'type',2006,'product',[{'var',2006,'String'}]}|[{'var',2006,'Count'}]]}|[[{'type',2007,'constraint',[{'atom',2007,'is_subtype'}|[[{'var',2007,'String'}|[{'type',2007,'string',[]}]]]]}|[{'type',2008,'constraint',[{'atom',2008,'is_subtype'}|[[{'var',2008,'Count'}|[{'type',2008,'pos_integer',[]}]]]]}]]]]}]}]
, 'spec' = [{{'words',2},[{'type',2012,'bounded_fun',[{'type',2012,'fun',[{'type',2012,'product',[{'var',2012,'String'}|[{'var',2012,'Character'}]]}|[{'var',2012,'Count'}]]}|[[{'type',2013,'constraint',[{'atom',2013,'is_subtype'}|[[{'var',2013,'String'}|[{'type',2013,'string',[]}]]]]}|[{'type',2014,'constraint',[{'atom',2014,'is_subtype'}|[[{'var',2014,'Character'}|[{'type',2014,'char',[]}]]]]}|[{'type',2015,'constraint',[{'atom',2015,'is_subtype'}|[[{'var',2015,'Count'}|[{'type',2015,'pos_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'sub_word',2},[{'type',2026,'bounded_fun',[{'type',2026,'fun',[{'type',2026,'product',[{'var',2026,'String'}|[{'var',2026,'Number'}]]}|[{'var',2026,'Word'}]]}|[[{'type',2027,'constraint',[{'atom',2027,'is_subtype'}|[[{'var',2027,'String'}|[{'type',2027,'string',[]}]]]]}|[{'type',2028,'constraint',[{'atom',2028,'is_subtype'}|[[{'var',2028,'Word'}|[{'type',2028,'string',[]}]]]]}|[{'type',2029,'constraint',[{'atom',2029,'is_subtype'}|[[{'var',2029,'Number'}|[{'type',2029,'integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'sub_word',3},[{'type',2033,'bounded_fun',[{'type',2033,'fun',[{'type',2033,'product',[{'var',2033,'String'}|[{'var',2033,'Number'}|[{'var',2033,'Character'}]]]}|[{'var',2033,'Word'}]]}|[[{'type',2034,'constraint',[{'atom',2034,'is_subtype'}|[[{'var',2034,'String'}|[{'type',2034,'string',[]}]]]]}|[{'type',2035,'constraint',[{'atom',2035,'is_subtype'}|[[{'var',2035,'Word'}|[{'type',2035,'string',[]}]]]]}|[{'type',2036,'constraint',[{'atom',2036,'is_subtype'}|[[{'var',2036,'Number'}|[{'type',2036,'integer',[]}]]]]}|[{'type',2037,'constraint',[{'atom',2037,'is_subtype'}|[[{'var',2037,'Character'}|[{'type',2037,'char',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'strip',1},[{'type',2057,'fun',[{'type',2057,'product',[{'type',2057,'string',[]}]}|[{'type',2057,'string',[]}]]}]}]
, 'spec' = [{{'strip',2},[{'type',2061,'bounded_fun',[{'type',2061,'fun',[{'type',2061,'product',[{'var',2061,'String'}|[{'var',2061,'Direction'}]]}|[{'var',2061,'Stripped'}]]}|[[{'type',2062,'constraint',[{'atom',2062,'is_subtype'}|[[{'var',2062,'String'}|[{'type',2062,'string',[]}]]]]}|[{'type',2063,'constraint',[{'atom',2063,'is_subtype'}|[[{'var',2063,'Stripped'}|[{'type',2063,'string',[]}]]]]}|[{'type',2064,'constraint',[{'atom',2064,'is_subtype'}|[[{'var',2064,'Direction'}|[{'type',2064,'union',[{'atom',2064,'left'}|[{'atom',2064,'right'}|[{'atom',2064,'both'}]]]}]]]]}]]]]]}]}]
, 'spec' = [{{'strip',3},[{'type',2071,'bounded_fun',[{'type',2071,'fun',[{'type',2071,'product',[{'var',2071,'String'}|[{'var',2071,'Direction'}|[{'var',2071,'Character'}]]]}|[{'var',2071,'Stripped'}]]}|[[{'type',2072,'constraint',[{'atom',2072,'is_subtype'}|[[{'var',2072,'String'}|[{'type',2072,'string',[]}]]]]}|[{'type',2073,'constraint',[{'atom',2073,'is_subtype'}|[[{'var',2073,'Stripped'}|[{'type',2073,'string',[]}]]]]}|[{'type',2074,'constraint',[{'atom',2074,'is_subtype'}|[[{'var',2074,'Direction'}|[{'type',2074,'union',[{'atom',2074,'left'}|[{'atom',2074,'right'}|[{'atom',2074,'both'}]]]}]]]]}|[{'type',2075,'constraint',[{'atom',2075,'is_subtype'}|[[{'var',2075,'Character'}|[{'type',2075,'char',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'left',2},[{'type',2099,'bounded_fun',[{'type',2099,'fun',[{'type',2099,'product',[{'var',2099,'String'}|[{'var',2099,'Number'}]]}|[{'var',2099,'Left'}]]}|[[{'type',2100,'constraint',[{'atom',2100,'is_subtype'}|[[{'var',2100,'String'}|[{'type',2100,'string',[]}]]]]}|[{'type',2101,'constraint',[{'atom',2101,'is_subtype'}|[[{'var',2101,'Left'}|[{'type',2101,'string',[]}]]]]}|[{'type',2102,'constraint',[{'atom',2102,'is_subtype'}|[[{'var',2102,'Number'}|[{'type',2102,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'left',3},[{'type',2106,'bounded_fun',[{'type',2106,'fun',[{'type',2106,'product',[{'var',2106,'String'}|[{'var',2106,'Number'}|[{'var',2106,'Character'}]]]}|[{'var',2106,'Left'}]]}|[[{'type',2107,'constraint',[{'atom',2107,'is_subtype'}|[[{'var',2107,'String'}|[{'type',2107,'string',[]}]]]]}|[{'type',2108,'constraint',[{'atom',2108,'is_subtype'}|[[{'var',2108,'Left'}|[{'type',2108,'string',[]}]]]]}|[{'type',2109,'constraint',[{'atom',2109,'is_subtype'}|[[{'var',2109,'Number'}|[{'type',2109,'non_neg_integer',[]}]]]]}|[{'type',2110,'constraint',[{'atom',2110,'is_subtype'}|[[{'var',2110,'Character'}|[{'type',2110,'char',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'right',2},[{'type',2124,'bounded_fun',[{'type',2124,'fun',[{'type',2124,'product',[{'var',2124,'String'}|[{'var',2124,'Number'}]]}|[{'var',2124,'Right'}]]}|[[{'type',2125,'constraint',[{'atom',2125,'is_subtype'}|[[{'var',2125,'String'}|[{'type',2125,'string',[]}]]]]}|[{'type',2126,'constraint',[{'atom',2126,'is_subtype'}|[[{'var',2126,'Right'}|[{'type',2126,'string',[]}]]]]}|[{'type',2127,'constraint',[{'atom',2127,'is_subtype'}|[[{'var',2127,'Number'}|[{'type',2127,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'right',3},[{'type',2131,'bounded_fun',[{'type',2131,'fun',[{'type',2131,'product',[{'var',2131,'String'}|[{'var',2131,'Number'}|[{'var',2131,'Character'}]]]}|[{'var',2131,'Right'}]]}|[[{'type',2132,'constraint',[{'atom',2132,'is_subtype'}|[[{'var',2132,'String'}|[{'type',2132,'string',[]}]]]]}|[{'type',2133,'constraint',[{'atom',2133,'is_subtype'}|[[{'var',2133,'Right'}|[{'type',2133,'string',[]}]]]]}|[{'type',2134,'constraint',[{'atom',2134,'is_subtype'}|[[{'var',2134,'Number'}|[{'type',2134,'non_neg_integer',[]}]]]]}|[{'type',2135,'constraint',[{'atom',2135,'is_subtype'}|[[{'var',2135,'Character'}|[{'type',2135,'char',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'centre',2},[{'type',2149,'bounded_fun',[{'type',2149,'fun',[{'type',2149,'product',[{'var',2149,'String'}|[{'var',2149,'Number'}]]}|[{'var',2149,'Centered'}]]}|[[{'type',2150,'constraint',[{'atom',2150,'is_subtype'}|[[{'var',2150,'String'}|[{'type',2150,'string',[]}]]]]}|[{'type',2151,'constraint',[{'atom',2151,'is_subtype'}|[[{'var',2151,'Centered'}|[{'type',2151,'string',[]}]]]]}|[{'type',2152,'constraint',[{'atom',2152,'is_subtype'}|[[{'var',2152,'Number'}|[{'type',2152,'non_neg_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'centre',3},[{'type',2156,'bounded_fun',[{'type',2156,'fun',[{'type',2156,'product',[{'var',2156,'String'}|[{'var',2156,'Number'}|[{'var',2156,'Character'}]]]}|[{'var',2156,'Centered'}]]}|[[{'type',2157,'constraint',[{'atom',2157,'is_subtype'}|[[{'var',2157,'String'}|[{'type',2157,'string',[]}]]]]}|[{'type',2158,'constraint',[{'atom',2158,'is_subtype'}|[[{'var',2158,'Centered'}|[{'type',2158,'string',[]}]]]]}|[{'type',2159,'constraint',[{'atom',2159,'is_subtype'}|[[{'var',2159,'Number'}|[{'type',2159,'non_neg_integer',[]}]]]]}|[{'type',2160,'constraint',[{'atom',2160,'is_subtype'}|[[{'var',2160,'Character'}|[{'type',2160,'char',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'sub_string',2},[{'type',2176,'bounded_fun',[{'type',2176,'fun',[{'type',2176,'product',[{'var',2176,'String'}|[{'var',2176,'Start'}]]}|[{'var',2176,'SubString'}]]}|[[{'type',2177,'constraint',[{'atom',2177,'is_subtype'}|[[{'var',2177,'String'}|[{'type',2177,'string',[]}]]]]}|[{'type',2178,'constraint',[{'atom',2178,'is_subtype'}|[[{'var',2178,'SubString'}|[{'type',2178,'string',[]}]]]]}|[{'type',2179,'constraint',[{'atom',2179,'is_subtype'}|[[{'var',2179,'Start'}|[{'type',2179,'pos_integer',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'sub_string',3},[{'type',2183,'bounded_fun',[{'type',2183,'fun',[{'type',2183,'product',[{'var',2183,'String'}|[{'var',2183,'Start'}|[{'var',2183,'Stop'}]]]}|[{'var',2183,'SubString'}]]}|[[{'type',2184,'constraint',[{'atom',2184,'is_subtype'}|[[{'var',2184,'String'}|[{'type',2184,'string',[]}]]]]}|[{'type',2185,'constraint',[{'atom',2185,'is_subtype'}|[[{'var',2185,'SubString'}|[{'type',2185,'string',[]}]]]]}|[{'type',2186,'constraint',[{'atom',2186,'is_subtype'}|[[{'var',2186,'Start'}|[{'type',2186,'pos_integer',[]}]]]]}|[{'type',2187,'constraint',[{'atom',2187,'is_subtype'}|[[{'var',2187,'Stop'}|[{'type',2187,'pos_integer',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'to_lower',1},[{'type',2212,'bounded_fun',[{'type',2212,'fun',[{'type',2212,'product',[{'var',2212,'String'}]}|[{'var',2212,'Result'}]]}|[[{'type',2213,'constraint',[{'atom',2213,'is_subtype'}|[[{'var',2213,'String'}|[{'remote_type',2213,[{'atom',2213,'io_lib'}|[{'atom',2213,'latin1_string'}|[[]]]]}]]]]}|[{'type',2214,'constraint',[{'atom',2214,'is_subtype'}|[[{'var',2214,'Result'}|[{'remote_type',2214,[{'atom',2214,'io_lib'}|[{'atom',2214,'latin1_string'}|[[]]]]}]]]]}]]]]}|[{'type',2215,'bounded_fun',[{'type',2215,'fun',[{'type',2215,'product',[{'var',2215,'Char'}]}|[{'var',2215,'CharResult'}]]}|[[{'type',2216,'constraint',[{'atom',2216,'is_subtype'}|[[{'var',2216,'Char'}|[{'type',2216,'char',[]}]]]]}|[{'type',2217,'constraint',[{'atom',2217,'is_subtype'}|[[{'var',2217,'CharResult'}|[{'type',2217,'char',[]}]]]]}]]]]}]]}]
, 'spec' = [{{'to_upper',1},[{'type',2224,'bounded_fun',[{'type',2224,'fun',[{'type',2224,'product',[{'var',2224,'String'}]}|[{'var',2224,'Result'}]]}|[[{'type',2225,'constraint',[{'atom',2225,'is_subtype'}|[[{'var',2225,'String'}|[{'remote_type',2225,[{'atom',2225,'io_lib'}|[{'atom',2225,'latin1_string'}|[[]]]]}]]]]}|[{'type',2226,'constraint',[{'atom',2226,'is_subtype'}|[[{'var',2226,'Result'}|[{'remote_type',2226,[{'atom',2226,'io_lib'}|[{'atom',2226,'latin1_string'}|[[]]]]}]]]]}]]]]}|[{'type',2227,'bounded_fun',[{'type',2227,'fun',[{'type',2227,'product',[{'var',2227,'Char'}]}|[{'var',2227,'CharResult'}]]}|[[{'type',2228,'constraint',[{'atom',2228,'is_subtype'}|[[{'var',2228,'Char'}|[{'type',2228,'char',[]}]]]]}|[{'type',2229,'constraint',[{'atom',2229,'is_subtype'}|[[{'var',2229,'CharResult'}|[{'type',2229,'char',[]}]]]]}]]]]}]]}]
, 'spec' = [{{'join',2},[{'type',2236,'bounded_fun',[{'type',2236,'fun',[{'type',2236,'product',[{'var',2236,'StringList'}|[{'var',2236,'Separator'}]]}|[{'var',2236,'String'}]]}|[[{'type',2237,'constraint',[{'atom',2237,'is_subtype'}|[[{'var',2237,'StringList'}|[{'type',2237,'list',[{'type',2237,'string',[]}]}]]]]}|[{'type',2238,'constraint',[{'atom',2238,'is_subtype'}|[[{'var',2238,'Separator'}|[{'type',2238,'string',[]}]]]]}|[{'type',2239,'constraint',[{'atom',2239,'is_subtype'}|[[{'var',2239,'String'}|[{'type',2239,'string',[]}]]]]}]]]]]}]}] ] 'list_to_float'/1 = fun (_0) -> call 'erlang':'nif_error' ('undef')
'list_to_integer'/1 = fun (_0) -> call 'erlang':'nif_error' ('undef')
'is_empty'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'true'
<#{}#> when 'true' -> 'true'
<[L|R]> when 'true' -> (case apply 'is_empty'/1 (L) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_empty'/1 (R)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_4> when 'true' -> 'false' end
'length'/1 = fun (_0) -> case _0 of <#{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> apply 'length_b'/3 (Bin,CP1,0)
<CD> when 'true' -> apply 'length_1'/2 (CD,0) end
'to_graphemes'/1 = fun (_0) -> case call 'unicode_util':'gc' (_0) of <[GC|CD]> when 'true' -> let <_1> = apply 'to_graphemes'/1 (CD) in [GC|_1]
<[]> when 'true' -> []
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'equal'/2 = fun (_0,_1) -> case <_0,_1> of <A,B> when let <_2> = call 'erlang':'is_binary' (A) in let <_3> = call 'erlang':'is_binary' (B) in call 'erlang':'and' (_2,_3) -> call 'erlang':'=:=' (A,B)
<A,B> when 'true' -> apply 'equal_1'/2 (A,B) end
'equal'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <A,B,'false'> when 'true' -> apply 'equal'/2 (A,B)
<A,B,'true'> when 'true' -> apply 'equal_nocase'/2 (A,B)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'equal',3}}] )-|['compiler_generated'] ) end
'equal'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <A,B,Case,'none'> when 'true' -> apply 'equal'/3 (A,B,Case)
<A,B,'false',Norm> when 'true' -> apply 'equal_norm'/3 (A,B,Norm)
<A,B,'true',Norm> when 'true' -> apply 'equal_norm_nocase'/3 (A,B,Norm)
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'equal',4}}] )-|['compiler_generated'] ) end
'reverse'/1 = fun (_0) -> case _0 of <#{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> apply 'reverse_b'/3 (Rest,CP1,[])
<CD> when 'true' -> apply 'reverse_1'/2 (CD,[]) end
'slice'/2 = fun (_0,_1) -> case <_0,_1> of <CD,N> when let <_2> = call 'erlang':'is_integer' (N) in let <_3> = call 'erlang':'>=' (N,0) in call 'erlang':'and' (_2,_3) -> case apply 'slice_l0'/2 (CD,N) of <[]> when call 'erlang':'is_binary' (CD) -> #{}#
<Res> when 'true' -> Res end
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'slice',2}}] )-|['compiler_generated'] ) end
'slice'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <CD,N,Length> when try let <_3> = call 'erlang':'is_integer' (N) in let <_4> = call 'erlang':'>=' (N,0) in let <_5> = call 'erlang':'is_integer' (Length) in let <_6> = call 'erlang':'>' (Length,0) in let <_7> = call 'erlang':'and' (_5,_6) in let <_8> = call 'erlang':'and' (_4,_7) in call 'erlang':'and' (_3,_8) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'slice_l0'/2 (CD,N) of <[]> when call 'erlang':'is_binary' (CD) -> #{}#
<L> when 'true' -> apply 'slice_trail'/2 (L,Length) end
<CD,N,'infinity'> when 'true' -> case apply 'slice_l0'/2 (CD,N) of <[]> when call 'erlang':'is_binary' (CD) -> #{}#
<Res> when 'true' -> Res end
<CD,_15,0> when 'true' -> case <> of <> when call 'erlang':'is_binary' (CD) -> #{}#
<> when 'true' -> [] end
(<_14,_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12})-|[{'function_name',{'slice',3}}] )-|['compiler_generated'] ) end
'pad'/2 = fun (_0,_1) -> apply 'pad'/4 (_0,_1,'trailing',32)
'pad'/3 = fun (_0,_1,_2) -> apply 'pad'/4 (_0,_1,_2,32)
'pad'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <CD,Length,'leading',Char> when call 'erlang':'is_integer' (Length) -> let <Len> = apply 'length'/1 (CD) in let <_5> = call 'erlang':'-' (Length,Len) in let <_6> = call 'erlang':'max' (0,_5) in let <_7> = call 'lists':'duplicate' (_6,Char) in [_7|[CD|[]]]
<CD,Length,'trailing',Char> when call 'erlang':'is_integer' (Length) -> let <Len> = apply 'length'/1 (CD) in let <_9> = call 'erlang':'-' (Length,Len) in let <_10> = call 'erlang':'max' (0,_9) in let <_11> = call 'lists':'duplicate' (_10,Char) in [CD|_11]
<CD,Length,'both',Char> when call 'erlang':'is_integer' (Length) -> let <Len> = apply 'length'/1 (CD) in let <_13> = call 'erlang':'-' (Length,Len) in let <Size> = call 'erlang':'max' (0,_13) in let <_15> = call 'erlang':'div' (Size,2) in let <Pre> = call 'lists':'duplicate' (_15,Char) in let <_18> = case call 'erlang':'rem' (Size,2) of <1> when 'true' -> [Char|[]]
<_24> when 'true' -> [] end in [Pre|[CD|[Pre|_18]]]
(<_23,_22,_21,_20> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21,_20})-|[{'function_name',{'pad',4}}] )-|['compiler_generated'] ) end
'trim'/1 = fun (_0) -> let <_1> = call 'unicode_util':'whitespace' () in apply 'trim'/3 (_0,'both',_1)
'trim'/2 = fun (_0,_1) -> let <_2> = call 'unicode_util':'whitespace' () in apply 'trim'/3 (_0,_1,_2)
'trim'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Str,_12,[]> when 'true' -> Str
<Str,'leading',[Sep|[]]> when let <_3> = call 'erlang':'is_list' (Str) in let <_4> = call 'erlang':'<' (Sep,256) in call 'erlang':'and' (_3,_4) -> apply 'trim_ls'/2 (Str,Sep)
<Str,'leading',Sep> when call 'erlang':'is_list' (Sep) -> apply 'trim_l'/2 (Str,Sep)
<Str,'trailing',[Sep|[]]> when let <_5> = call 'erlang':'is_list' (Str) in let <_6> = call 'erlang':'<' (Sep,256) in call 'erlang':'and' (_5,_6) -> apply 'trim_ts'/2 (Str,Sep)
<Str,'trailing',Seps0> when call 'erlang':'is_list' (Seps0) -> let <Seps> = apply 'search_pattern'/1 (Seps0) in apply 'trim_t'/3 (Str,0,Seps)
<Str,'both',Sep> when call 'erlang':'is_list' (Sep) -> let <_8> = apply 'trim'/3 (Str,'leading',Sep) in apply 'trim'/3 (_8,'trailing',Sep)
(<_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9})-|[{'function_name',{'trim',3}}] )-|['compiler_generated'] ) end
'chomp'/1 = fun (_0) -> apply 'trim'/3 (_0,'trailing',[[13|[10]]|[10]])
'take'/2 = fun (_0,_1) -> apply 'take'/4 (_0,_1,'false','leading')
'take'/3 = fun (_0,_1,_2) -> apply 'take'/4 (_0,_1,_2,'leading')
'take'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Str,[],Complement,Dir> when 'true' -> let <_5> = case <> of <> when call 'erlang':'is_binary' (Str) -> #{}#
<> when 'true' -> [] end in case <Complement,Dir> of <'false','leading'> when 'true' -> {_5,Str}
<'false','trailing'> when 'true' -> {Str,_5}
<'true','leading'> when 'true' -> {Str,_5}
<'true','trailing'> when 'true' -> {_5,Str}
(<(_15-|['compiler_generated'] ),(_16-|['compiler_generated'] )> when 'true' -> let <_7> = {(_15-|['compiler_generated'] ),(_16-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<Str,Sep,'false','leading'> when 'true' -> apply 'take_l'/3 (Str,Sep,[])
<Str,Sep0,'true','leading'> when 'true' -> let <Sep> = apply 'search_pattern'/1 (Sep0) in apply 'take_lc'/3 (Str,Sep,[])
<Str,Sep0,'false','trailing'> when 'true' -> let <Sep> = apply 'search_pattern'/1 (Sep0) in apply 'take_t'/3 (Str,0,Sep)
<Str,Sep0,'true','trailing'> when 'true' -> let <Sep> = apply 'search_pattern'/1 (Sep0) in apply 'take_tc'/3 (Str,0,Sep)
(<_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11})-|[{'function_name',{'take',4}}] )-|['compiler_generated'] ) end
'uppercase'/1 = fun (_0) -> case _0 of <CD> when call 'erlang':'is_list' (_0) -> try apply 'uppercase_list'/2 (CD,'false') of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('throw'-|['compiler_generated'] ),('unchanged'-|['compiler_generated'] ),_11> when 'true' -> CD
(<_13,_14,_15> when 'true' -> primop 'raise' (_15,_14)-|['compiler_generated'] ) end
<Orig = #{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> try apply 'uppercase_bin'/3 (CP1,Rest,'false') of <_5> -> call 'unicode':'characters_to_binary' (_5) catch <_9,_8,_7> -> case <_9,_8,_7> of <('throw'-|['compiler_generated'] ),('unchanged'-|['compiler_generated'] ),_12> when 'true' -> Orig
(<_17,_18,_19> when 'true' -> primop 'raise' (_19,_18)-|['compiler_generated'] ) end
<#{}#> when 'true' -> #{}#
<Bin> when 'true' -> call 'erlang':'error' ({'badarg',Bin}) end
'lowercase'/1 = fun (_0) -> case _0 of <CD> when call 'erlang':'is_list' (_0) -> try apply 'lowercase_list'/2 (CD,'false') of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('throw'-|['compiler_generated'] ),('unchanged'-|['compiler_generated'] ),_11> when 'true' -> CD
(<_13,_14,_15> when 'true' -> primop 'raise' (_15,_14)-|['compiler_generated'] ) end
<Orig = #{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> try apply 'lowercase_bin'/3 (CP1,Rest,'false') of <_5> -> call 'unicode':'characters_to_binary' (_5) catch <_9,_8,_7> -> case <_9,_8,_7> of <('throw'-|['compiler_generated'] ),('unchanged'-|['compiler_generated'] ),_12> when 'true' -> Orig
(<_17,_18,_19> when 'true' -> primop 'raise' (_19,_18)-|['compiler_generated'] ) end
<#{}#> when 'true' -> #{}#
<Bin> when 'true' -> call 'erlang':'error' ({'badarg',Bin}) end
'titlecase'/1 = fun (_0) -> case _0 of <CD> when call 'erlang':'is_list' (_0) -> case call 'unicode_util':'titlecase' (CD) of <[GC|Tail]> when 'true' -> (case <GC,Tail> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<_11,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_11)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_11,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_2> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_2}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Empty> when 'true' -> Empty end
<CD> when call 'erlang':'is_binary' (_0) -> case call 'unicode_util':'titlecase' (CD) of <[CP|Chars]> when call 'erlang':'is_integer' (CP) -> #{#<CP>('undefined','undefined','utf8',['unsigned'|['big']]),#<Chars>('all',8,'binary',['unsigned'|['big']])}#
<[CPs|Chars]> when 'true' -> let <_2> = primop 'bs_init_writable' (256) in let <_7> = letrec 'lbc$^0'/2 = fun (_6,_5) -> case <_6,_5> of <[CP|_4],_12> when 'true' -> let <_13> = #{#<_12>('all',1,'binary',['unsigned'|['big']]),#<CP>('undefined','undefined','utf8',['unsigned'|['big']])}# in apply 'lbc$^0'/2 (_4,_13)
<[],_14> when 'true' -> _14
(<_15,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_16})-|[{'function_name',{'lbc$^0',2}}] )-|['compiler_generated'] ) end in apply 'lbc$^0'/2 (CPs,_2) in #{#<_7>('all',8,'binary',['unsigned'|['big']]),#<Chars>('all',8,'binary',['unsigned'|['big']])}#
<[]> when 'true' -> #{}#
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'titlecase',1}}] )-|['compiler_generated'] ) end
'casefold'/1 = fun (_0) -> case _0 of <CD> when call 'erlang':'is_list' (_0) -> try apply 'casefold_list'/2 (CD,'false') of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('throw'-|['compiler_generated'] ),('unchanged'-|['compiler_generated'] ),_11> when 'true' -> CD
(<_13,_14,_15> when 'true' -> primop 'raise' (_15,_14)-|['compiler_generated'] ) end
<Orig = #{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> try apply 'casefold_bin'/3 (CP1,Rest,'false') of <_5> -> call 'unicode':'characters_to_binary' (_5) catch <_9,_8,_7> -> case <_9,_8,_7> of <('throw'-|['compiler_generated'] ),('unchanged'-|['compiler_generated'] ),_12> when 'true' -> Orig
(<_17,_18,_19> when 'true' -> primop 'raise' (_19,_18)-|['compiler_generated'] ) end
<#{}#> when 'true' -> #{}#
<Bin> when 'true' -> call 'erlang':'error' ({'badarg',Bin}) end
'to_integer'/1 = fun (_0) -> try apply 'take'/2 (_0,[43|[45|[48|[49|[50|[51|[52|[53|[54|[55|[56|[57]]]]]]]]]]]]) of <_1> -> case _1 of <{Head,Tail}> when 'true' -> case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> {'error','no_integer'}
<'false'> when 'true' -> let <List> = call 'unicode':'characters_to_list' (Head) in case call 'string':'list_to_integer' (List) of <Err = {'error',_10}> when 'true' -> Err
<{Int,Rest}> when 'true' -> apply 'to_number'/5 (_0,Int,Rest,List,Tail)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'try_clause',_5})-|['compiler_generated'] ) end catch <_8,_7,_6> -> {'error','badarg'}
'to_float'/1 = fun (_0) -> try apply 'take'/2 (_0,[43|[45|[48|[49|[50|[51|[52|[53|[54|[55|[56|[57|[101|[69|[46|[44]]]]]]]]]]]]]]]]) of <_1> -> case _1 of <{Head,Tail}> when 'true' -> case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> {'error','no_float'}
<'false'> when 'true' -> let <List> = call 'unicode':'characters_to_list' (Head) in case call 'string':'list_to_float' (List) of <Err = {'error',_10}> when 'true' -> Err
<{Float,Rest}> when 'true' -> apply 'to_number'/5 (_0,Float,Rest,List,Tail)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'try_clause',_5})-|['compiler_generated'] ) end catch <_8,_7,_6> -> {'error','badarg'}
'to_number'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <String,Number,Rest,List,_X_Tail> when call 'erlang':'is_binary' (String) -> let <_6> = call 'erlang':'length' (List) in let <_5> = call 'erlang':'length' (Rest) in let <BSz> = call 'erlang':'-' (_6,_5) in case String of <#{#<_15>(BSz,8,'binary',['unsigned'|['big']]),#<Cont>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> {Number,Cont}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<_16,Number,Rest,_17,Tail> when 'true' -> let <_9> = apply 'concat'/2 (Rest,Tail) in {Number,_9} end
'prefix'/2 = fun (_0,_1) -> let <_3> = case call 'unicode':'characters_to_list' (_1) of <[]> when 'true' -> _0
<Prefix> when 'true' -> apply 'prefix_1'/2 (_0,Prefix) end in case _3 of <[]> when call 'erlang':'is_binary' (_0) -> #{}#
<Res> when 'true' -> Res end
'split'/2 = fun (_0,_1) -> apply 'split'/3 (_0,_1,'leading')
'split'/3 = fun (_0,_1,_2) -> case apply 'is_empty'/1 (_1) of <'true'> when 'true' -> [_0|[]]
<'false'> when 'true' -> let <SearchPatternCPs> = call 'unicode':'characters_to_list' (_1) in case apply 'split_1'/6 (_0,SearchPatternCPs,0,_2,[],[]) of <{_X_Curr,[]}> when 'true' -> [_0|[]]
<{_X_Curr,Acc}> when call 'erlang':'=:=' (_2,'trailing') -> Acc
<{Curr,Acc}> when call 'erlang':'=:=' (_2,'all') -> call 'lists':'reverse' ([Curr|Acc])
<Acc> when call 'erlang':'is_list' (Acc) -> Acc
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'replace'/3 = fun (_0,_1,_2) -> let <_3> = apply 'split'/2 (_0,_1) in call 'lists':'join' (_2,_3)
'replace'/4 = fun (_0,_1,_2,_3) -> let <_4> = apply 'split'/3 (_0,_1,_3) in call 'lists':'join' (_2,_4)
'lexemes'/2 = fun (_0,_1) -> case <_0,_1> of <[],_5> when 'true' -> []
<Str,[]> when 'true' -> [Str|[]]
<Str,Seps0> when call 'erlang':'is_list' (Seps0) -> let <Seps> = apply 'search_pattern'/1 (Seps0) in apply 'lexemes_m'/3 (Str,Seps,[])
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'lexemes',2}}] )-|['compiler_generated'] ) end
'nth_lexeme'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Str,1,[]> when 'true' -> Str
<Str,N,Seps0> when try let <_3> = call 'erlang':'is_list' (Seps0) in let <_4> = call 'erlang':'is_integer' (N) in let <_5> = call 'erlang':'>' (N,0) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <Seps> = apply 'search_pattern'/1 (Seps0) in apply 'nth_lexeme_m'/3 (Str,Seps,N)
(<_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8})-|[{'function_name',{'nth_lexeme',3}}] )-|['compiler_generated'] ) end
'find'/2 = fun (_0,_1) -> apply 'find'/3 (_0,_1,'leading')
'find'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <String,[],_8> when 'true' -> String
<String,#{}#,_9> when 'true' -> String
<String,SearchPattern,'leading'> when 'true' -> let <_3> = call 'unicode':'characters_to_list' (SearchPattern) in apply 'find_l'/2 (String,_3)
<String,SearchPattern,'trailing'> when 'true' -> let <_4> = call 'unicode':'characters_to_list' (SearchPattern) in apply 'find_r'/3 (String,_4,'nomatch')
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'find',3}}] )-|['compiler_generated'] ) end
'next_grapheme'/1 = fun (_0) -> call 'unicode_util':'gc' (_0)
'next_codepoint'/1 = fun (_0) -> call 'unicode_util':'cp' (_0)
'length_1'/2 = fun (_0,_1) -> case <_0,_1> of <[CP1|Cont = [CP2|_11]],N> when try let <_2> = call 'erlang':'<' (CP1,256) in let <_3> = call 'erlang':'<' (CP2,256) in let <_4> = call 'erlang':'=/=' (CP1,13) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <_6> = call 'erlang':'+' (N,1) in apply 'length_1'/2 (Cont,_6)
<Str,N> when 'true' -> case call 'unicode_util':'gc' (Str) of <[]> when 'true' -> N
<[_12|Rest]> when 'true' -> let <_7> = call 'erlang':'+' (N,1) in apply 'length_1'/2 (Rest,_7)
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end end
'length_b'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,CP1,N> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = call 'erlang':'+' (N,1) in apply 'length_b'/3 (Rest,CP2,_7)
<Bin0,CP1,N> when 'true' -> case call 'unicode_util':'gc' ([CP1|Bin0]) of <[_14|Bin1]> when 'true' -> case call 'unicode_util':'cp' (Bin1) of <[]> when 'true' -> call 'erlang':'+' (N,1)
<[CP3|Bin]> when 'true' -> let <_9> = call 'erlang':'+' (N,1) in apply 'length_b'/3 (Bin,CP3,_9)
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end
'equal_1'/2 = fun (_0,_1) -> case <_0,_1> of <[A|AR],[B|BR]> when let <_2> = call 'erlang':'is_integer' (A) in let <_3> = call 'erlang':'is_integer' (B) in call 'erlang':'and' (_2,_3) -> (case <> of (<> when call 'erlang':'=:=' (A,B) -> apply 'equal_1'/2 (AR,BR)-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end-|['compiler_generated'] )
<[],BR> when 'true' -> apply 'is_empty'/1 (BR)
<A0,B0> when 'true' -> let <_7> = call 'unicode_util':'cp' (A0) in let <_6> = call 'unicode_util':'cp' (B0) in case <_7,_6> of <([CP|A]-|['compiler_generated'] ),([_13|B]-|['compiler_generated'] )> when call 'erlang':'=:=' (_13,CP) -> apply 'equal_1'/2 (A,B)
<[],[]> when 'true' -> 'true'
<L1,L2> when let <_8> = call 'erlang':'is_list' (L1) in let <_9> = call 'erlang':'is_list' (L2) in call 'erlang':'and' (_8,_9) -> 'false'
(<(_14-|['compiler_generated'] ),(_15-|['compiler_generated'] )> when 'true' -> let <_10> = {(_14-|['compiler_generated'] ),(_15-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end end
'equal_nocase'/2 = fun (_0,_1) -> case <_0,_1> of <A,_11> when call 'erlang':'=:=' (_11,A) -> 'true'
<A0,B0> when 'true' -> let <_4> = call 'unicode_util':'casefold' (A0) in let <_5> = call 'unicode_util':'cp' (_4) in let <_2> = call 'unicode_util':'casefold' (B0) in let <_3> = call 'unicode_util':'cp' (_2) in case <_5,_3> of <([CP|A]-|['compiler_generated'] ),([_12|B]-|['compiler_generated'] )> when call 'erlang':'=:=' (_12,CP) -> apply 'equal_nocase'/2 (A,B)
<[],[]> when 'true' -> 'true'
<L1,L2> when let <_6> = call 'erlang':'is_list' (L1) in let <_7> = call 'erlang':'is_list' (L2) in call 'erlang':'and' (_6,_7) -> 'false'
(<(_13-|['compiler_generated'] ),(_14-|['compiler_generated'] )> when 'true' -> let <_8> = {(_13-|['compiler_generated'] ),(_14-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end end
'equal_norm'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <A,_13,_X_Norm> when call 'erlang':'=:=' (_13,A) -> 'true'
<A0,B0,Norm> when 'true' -> let <_5> = call 'unicode_util':Norm (A0) in let <_6> = call 'unicode_util':'cp' (_5) in let <_3> = call 'unicode_util':Norm (B0) in let <_4> = call 'unicode_util':'cp' (_3) in case <_6,_4> of <([CP|A]-|['compiler_generated'] ),([_14|B]-|['compiler_generated'] )> when call 'erlang':'=:=' (_14,CP) -> apply 'equal_norm'/3 (A,B,Norm)
<[],[]> when 'true' -> 'true'
<L1,L2> when let <_7> = call 'erlang':'is_list' (L1) in let <_8> = call 'erlang':'is_list' (L2) in call 'erlang':'and' (_7,_8) -> 'false'
(<(_15-|['compiler_generated'] ),(_16-|['compiler_generated'] )> when 'true' -> let <_9> = {(_15-|['compiler_generated'] ),(_16-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end end
'equal_norm_nocase'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <A,_15,_X_Norm> when call 'erlang':'=:=' (_15,A) -> 'true'
<A0,B0,Norm> when 'true' -> let <_6> = call 'unicode_util':Norm (A0) in let <_7> = call 'unicode_util':'casefold' (_6) in let <_8> = call 'unicode_util':'cp' (_7) in let <_3> = call 'unicode_util':Norm (B0) in let <_4> = call 'unicode_util':'casefold' (_3) in let <_5> = call 'unicode_util':'cp' (_4) in case <_8,_5> of <([CP|A]-|['compiler_generated'] ),([_16|B]-|['compiler_generated'] )> when call 'erlang':'=:=' (_16,CP) -> apply 'equal_norm_nocase'/3 (A,B,Norm)
<[],[]> when 'true' -> 'true'
<L1,L2> when let <_9> = call 'erlang':'is_list' (L1) in let <_10> = call 'erlang':'is_list' (L2) in call 'erlang':'and' (_9,_10) -> 'false'
(<(_17-|['compiler_generated'] ),(_18-|['compiler_generated'] )> when 'true' -> let <_11> = {(_17-|['compiler_generated'] ),(_18-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end end
'reverse_1'/2 = fun (_0,_1) -> case <_0,_1> of <[CP1|Cont = [CP2|_9]],Acc> when try let <_2> = call 'erlang':'<' (CP1,256) in let <_3> = call 'erlang':'<' (CP2,256) in let <_4> = call 'erlang':'=/=' (CP1,13) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> apply 'reverse_1'/2 (Cont,[CP1|Acc])
<CD,Acc> when 'true' -> case call 'unicode_util':'gc' (CD) of <[GC|Rest]> when 'true' -> apply 'reverse_1'/2 (Rest,[GC|Acc])
<[]> when 'true' -> Acc
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end end
'reverse_b'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,CP1,Acc> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> apply 'reverse_b'/3 (Rest,CP2,[CP1|Acc])
<Bin0,CP1,Acc> when 'true' -> case call 'unicode_util':'gc' ([CP1|Bin0]) of <[GC|Bin1]> when 'true' -> case call 'unicode_util':'cp' (Bin1) of <[]> when 'true' -> [GC|Acc]
<[CP3|Bin]> when 'true' -> apply 'reverse_b'/3 (Bin,CP3,[GC|Acc])
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end end
'slice_l0'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,N> when call 'erlang':'>' (N,0) -> apply 'slice_lb'/3 (Bin,CP1,N)
<L,N> when 'true' -> apply 'slice_l'/2 (L,N) end
'slice_l'/2 = fun (_0,_1) -> case <_0,_1> of <[CP1|Cont = [CP2|_13]],N> when try let <_2> = call 'erlang':'<' (CP1,256) in let <_3> = call 'erlang':'<' (CP2,256) in let <_4> = call 'erlang':'=/=' (CP1,13) in let <_5> = call 'erlang':'>' (N,0) in let <_6> = call 'erlang':'and' (_4,_5) in let <_7> = call 'erlang':'and' (_3,_6) in call 'erlang':'and' (_2,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <_8> = call 'erlang':'-' (N,1) in apply 'slice_l'/2 (Cont,_8)
<CD,N> when call 'erlang':'>' (N,0) -> case call 'unicode_util':'gc' (CD) of <[_14|Cont]> when 'true' -> let <_9> = call 'erlang':'-' (N,1) in apply 'slice_l'/2 (Cont,_9)
<[]> when 'true' -> []
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<Cont,0> when 'true' -> Cont
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'slice_l',2}}] )-|['compiler_generated'] ) end
'slice_lb'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,CP1,N> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'>' (N,1) in let <_7> = call 'erlang':'and' (_5,_6) in let <_8> = call 'erlang':'and' (_4,_7) in call 'erlang':'and' (_3,_8) of <Try> -> Try catch <T,R> -> 'false' -> let <_9> = call 'erlang':'-' (N,1) in apply 'slice_lb'/3 (Bin,CP2,_9)
<Bin,CP1,N> when 'true' -> case call 'unicode_util':'gc' ([CP1|Bin]) of <[_16|Rest]> when 'true' -> case <> of <> when call 'erlang':'>' (N,1) -> case call 'unicode_util':'cp' (Rest) of <[CP2|Cont]> when 'true' -> let <_11> = call 'erlang':'-' (N,1) in apply 'slice_lb'/3 (Cont,CP2,_11)
<[]> when 'true' -> #{}#
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
<> when call 'erlang':'=:=' (N,1) -> Rest
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end end
'slice_trail'/2 = fun (_0,_1) -> case <_0,_1> of <Orig,N> when call 'erlang':'is_binary' (Orig) -> case Orig of <#{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#> when call 'erlang':'>' (N,0) -> let <Length> = apply 'slice_bin'/3 (Bin,CP1,N) in let <_3> = call 'erlang':'byte_size' (Orig) in let <Sz> = call 'erlang':'-' (_3,Length) in case Orig of <#{#<Keep>(Sz,8,'binary',['unsigned'|['big']]),#<_9>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> Keep
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<#{#<_10>(8,1,'integer',['unsigned'|['big']]),#<_11>('all',8,'binary',['unsigned'|['big']])}#> when call 'erlang':'>' (N,0) -> call 'erlang':'error' ({'badarg',Orig})
<_12> when 'true' -> #{}# end
<CD,N> when call 'erlang':'is_list' (CD) -> apply 'slice_list'/2 (CD,N)
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'slice_trail',2}}] )-|['compiler_generated'] ) end
'slice_list'/2 = fun (_0,_1) -> case <_0,_1> of <[CP1|Cont = [CP2|_15]],N> when try let <_2> = call 'erlang':'<' (CP1,256) in let <_3> = call 'erlang':'<' (CP2,256) in let <_4> = call 'erlang':'=/=' (CP1,13) in let <_5> = call 'erlang':'>' (N,0) in let <_6> = call 'erlang':'and' (_4,_5) in let <_7> = call 'erlang':'and' (_3,_6) in call 'erlang':'and' (_2,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <_8> = call 'erlang':'-' (N,1) in let <_9> = apply 'slice_list'/2 (Cont,_8) in [CP1|_9]
<CD,N> when call 'erlang':'>' (N,0) -> case call 'unicode_util':'gc' (CD) of <[GC|Cont]> when 'true' -> let <_10> = call 'erlang':'-' (N,1) in let <_11> = apply 'slice_list'/2 (Cont,_10) in (case <GC,_11> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<_19,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_19)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_19,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_2> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_2}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[]> when 'true' -> []
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
<_16,0> when 'true' -> []
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'slice_list',2}}] )-|['compiler_generated'] ) end
'slice_bin'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,CP1,N> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'>' (N,0) in let <_7> = call 'erlang':'and' (_5,_6) in let <_8> = call 'erlang':'and' (_4,_7) in call 'erlang':'and' (_3,_8) of <Try> -> Try catch <T,R> -> 'false' -> let <_9> = call 'erlang':'-' (N,1) in apply 'slice_bin'/3 (Bin,CP2,_9)
<CD,CP1,N> when call 'erlang':'>' (N,0) -> case call 'unicode_util':'gc' ([CP1|CD]) of <[_19|Bin]> when 'true' -> case call 'unicode_util':'cp' (Bin) of <[CP2|Cont]> when 'true' -> let <_11> = call 'erlang':'-' (N,1) in apply 'slice_bin'/3 (Cont,CP2,_11)
<[]> when 'true' -> 0
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<CD,CP1,0> when 'true' -> let <_15> = call 'erlang':'byte_size' (CD) in let <_13> = #{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']])}# in let <_14> = call 'erlang':'byte_size' (_13) in call 'erlang':'+' (_15,_14)
(<_18,_17,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17,_16})-|[{'function_name',{'slice_bin',3}}] )-|['compiler_generated'] ) end
'uppercase_list'/2 = fun (_0,_1) -> case <_0,_1> of <[CP1|Cont = [CP2|_17]],_X_Changed> when try let <_2> = call 'erlang':'=<' (97,CP1) in let <_3> = call 'erlang':'=<' (CP1,122) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <_6> = call 'erlang':'-' (CP1,32) in let <_7> = apply 'uppercase_list'/2 (Cont,'true') in [_6|_7]
<[CP1|Cont = [CP2|_18]],Changed> when let <_8> = call 'erlang':'<' (CP1,128) in let <_9> = call 'erlang':'<' (CP2,256) in call 'erlang':'and' (_8,_9) -> let <_10> = apply 'uppercase_list'/2 (Cont,Changed) in [CP1|_10]
<[],'true'> when 'true' -> []
<[],'false'> when 'true' -> call 'erlang':'throw' ('unchanged')
<CPs0,Changed> when 'true' -> case call 'unicode_util':'uppercase' (CPs0) of <[Char|CPs]> when try let <_11> = call 'erlang':'hd' (CPs0) in call 'erlang':'=:=' (Char,_11) of <Try> -> Try catch <T,R> -> 'false' -> let <_12> = apply 'uppercase_list'/2 (CPs,Changed) in [Char|_12]
<[Char|CPs]> when 'true' -> let <_13> = apply 'uppercase_list'/2 (CPs,'true') in (case <Char,_13> of (<_21,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_21)-|['compiler_generated'] ) -> ([_21|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<_22,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_22)-|['compiler_generated'] ) -> _22-|['compiler_generated'] )
(<_23,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([_23|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<_24,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_24)-|['compiler_generated'] ) -> ([_24|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_2> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_2}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[]> when 'true' -> apply 'uppercase_list'/2 ([],Changed)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end end
'uppercase_bin'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <CP1,#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,_X_Changed> when try let <_3> = call 'erlang':'=<' (97,CP1) in let <_4> = call 'erlang':'=<' (CP1,122) in let <_5> = call 'erlang':'<' (CP2,256) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = call 'erlang':'-' (CP1,32) in let <_8> = apply 'uppercase_bin'/3 (CP2,Bin,'true') in [_7|_8]
<CP1,#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,Changed> when let <_9> = call 'erlang':'<' (CP1,128) in let <_10> = call 'erlang':'<' (CP2,256) in call 'erlang':'and' (_9,_10) -> let <_11> = apply 'uppercase_bin'/3 (CP2,Bin,Changed) in [CP1|_11]
<CP1,Bin,Changed> when 'true' -> case call 'unicode_util':'uppercase' ([CP1|Bin]) of <[_20|CPs]> when call 'erlang':'=:=' (_20,CP1) -> case call 'unicode_util':'cp' (CPs) of <[Next|Rest]> when 'true' -> let <_12> = apply 'uppercase_bin'/3 (Next,Rest,Changed) in [CP1|_12]
<[]> when (call 'erlang':'=:=' (Changed,'true')-|['compiler_generated'] ) -> [CP1|[]]
<[]> when 'true' -> call 'erlang':'throw' ('unchanged')
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<[Char|CPs]> when 'true' -> case call 'unicode_util':'cp' (CPs) of <[Next|Rest]> when 'true' -> let <_14> = apply 'uppercase_bin'/3 (Next,Rest,'true') in [Char|_14]
<[]> when 'true' -> [Char|[]]
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end end
'lowercase_list'/2 = fun (_0,_1) -> case <_0,_1> of <[CP1|Cont = [CP2|_17]],_X_Changed> when try let <_2> = call 'erlang':'=<' (65,CP1) in let <_3> = call 'erlang':'=<' (CP1,90) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <_6> = call 'erlang':'+' (CP1,32) in let <_7> = apply 'lowercase_list'/2 (Cont,'true') in [_6|_7]
<[CP1|Cont = [CP2|_18]],Changed> when let <_8> = call 'erlang':'<' (CP1,128) in let <_9> = call 'erlang':'<' (CP2,256) in call 'erlang':'and' (_8,_9) -> let <_10> = apply 'lowercase_list'/2 (Cont,Changed) in [CP1|_10]
<[],'true'> when 'true' -> []
<[],'false'> when 'true' -> call 'erlang':'throw' ('unchanged')
<CPs0,Changed> when 'true' -> case call 'unicode_util':'lowercase' (CPs0) of <[Char|CPs]> when try let <_11> = call 'erlang':'hd' (CPs0) in call 'erlang':'=:=' (Char,_11) of <Try> -> Try catch <T,R> -> 'false' -> let <_12> = apply 'lowercase_list'/2 (CPs,Changed) in [Char|_12]
<[Char|CPs]> when 'true' -> let <_13> = apply 'lowercase_list'/2 (CPs,'true') in (case <Char,_13> of (<_21,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_21)-|['compiler_generated'] ) -> ([_21|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<_22,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_22)-|['compiler_generated'] ) -> _22-|['compiler_generated'] )
(<_23,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([_23|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<_24,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_24)-|['compiler_generated'] ) -> ([_24|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_2> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_2}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[]> when 'true' -> apply 'lowercase_list'/2 ([],Changed)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end end
'lowercase_bin'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <CP1,#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,_X_Changed> when try let <_3> = call 'erlang':'=<' (65,CP1) in let <_4> = call 'erlang':'=<' (CP1,90) in let <_5> = call 'erlang':'<' (CP2,256) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = call 'erlang':'+' (CP1,32) in let <_8> = apply 'lowercase_bin'/3 (CP2,Bin,'true') in [_7|_8]
<CP1,#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,Changed> when let <_9> = call 'erlang':'<' (CP1,128) in let <_10> = call 'erlang':'<' (CP2,256) in call 'erlang':'and' (_9,_10) -> let <_11> = apply 'lowercase_bin'/3 (CP2,Bin,Changed) in [CP1|_11]
<CP1,Bin,Changed> when 'true' -> case call 'unicode_util':'lowercase' ([CP1|Bin]) of <[_20|CPs]> when call 'erlang':'=:=' (_20,CP1) -> case call 'unicode_util':'cp' (CPs) of <[Next|Rest]> when 'true' -> let <_12> = apply 'lowercase_bin'/3 (Next,Rest,Changed) in [CP1|_12]
<[]> when (call 'erlang':'=:=' (Changed,'true')-|['compiler_generated'] ) -> [CP1|[]]
<[]> when 'true' -> call 'erlang':'throw' ('unchanged')
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<[Char|CPs]> when 'true' -> case call 'unicode_util':'cp' (CPs) of <[Next|Rest]> when 'true' -> let <_14> = apply 'lowercase_bin'/3 (Next,Rest,'true') in [Char|_14]
<[]> when 'true' -> [Char|[]]
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end end
'casefold_list'/2 = fun (_0,_1) -> case <_0,_1> of <[CP1|Cont = [CP2|_17]],_X_Changed> when try let <_2> = call 'erlang':'=<' (65,CP1) in let <_3> = call 'erlang':'=<' (CP1,90) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <_6> = call 'erlang':'+' (CP1,32) in let <_7> = apply 'casefold_list'/2 (Cont,'true') in [_6|_7]
<[CP1|Cont = [CP2|_18]],Changed> when let <_8> = call 'erlang':'<' (CP1,128) in let <_9> = call 'erlang':'<' (CP2,256) in call 'erlang':'and' (_8,_9) -> let <_10> = apply 'casefold_list'/2 (Cont,Changed) in [CP1|_10]
<[],'true'> when 'true' -> []
<[],'false'> when 'true' -> call 'erlang':'throw' ('unchanged')
<CPs0,Changed> when 'true' -> case call 'unicode_util':'casefold' (CPs0) of <[Char|CPs]> when try let <_11> = call 'erlang':'hd' (CPs0) in call 'erlang':'=:=' (Char,_11) of <Try> -> Try catch <T,R> -> 'false' -> let <_12> = apply 'casefold_list'/2 (CPs,Changed) in [Char|_12]
<[Char|CPs]> when 'true' -> let <_13> = apply 'casefold_list'/2 (CPs,'true') in (case <Char,_13> of (<_21,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_21)-|['compiler_generated'] ) -> ([_21|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<_22,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_22)-|['compiler_generated'] ) -> _22-|['compiler_generated'] )
(<_23,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([_23|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<_24,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_24)-|['compiler_generated'] ) -> ([_24|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_2> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_2}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[]> when 'true' -> apply 'casefold_list'/2 ([],Changed)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end end
'casefold_bin'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <CP1,#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,_X_Changed> when try let <_3> = call 'erlang':'=<' (65,CP1) in let <_4> = call 'erlang':'=<' (CP1,90) in let <_5> = call 'erlang':'<' (CP2,256) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = call 'erlang':'+' (CP1,32) in let <_8> = apply 'casefold_bin'/3 (CP2,Bin,'true') in [_7|_8]
<CP1,#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#,Changed> when let <_9> = call 'erlang':'<' (CP1,128) in let <_10> = call 'erlang':'<' (CP2,256) in call 'erlang':'and' (_9,_10) -> let <_11> = apply 'casefold_bin'/3 (CP2,Bin,Changed) in [CP1|_11]
<CP1,Bin,Changed> when 'true' -> case call 'unicode_util':'casefold' ([CP1|Bin]) of <[_20|CPs]> when call 'erlang':'=:=' (_20,CP1) -> case call 'unicode_util':'cp' (CPs) of <[Next|Rest]> when 'true' -> let <_12> = apply 'casefold_bin'/3 (Next,Rest,Changed) in [CP1|_12]
<[]> when (call 'erlang':'=:=' (Changed,'true')-|['compiler_generated'] ) -> [CP1|[]]
<[]> when 'true' -> call 'erlang':'throw' ('unchanged')
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<[Char|CPs]> when 'true' -> case call 'unicode_util':'cp' (CPs) of <[Next|Rest]> when 'true' -> let <_14> = apply 'casefold_bin'/3 (Next,Rest,'true') in [Char|_14]
<[]> when 'true' -> [Char|[]]
<{'error',Err}> when 'true' -> call 'erlang':'error' ({'badarg',Err})
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end end
'trim_ls'/2 = fun (_0,_1) -> case <_0,_1> of <Str = [CP1|Cont = [CP2|_9]],Sep> when try let <_2> = call 'erlang':'<' (CP1,256) in let <_3> = call 'erlang':'<' (CP2,256) in let <_4> = call 'erlang':'=/=' (CP1,13) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> case Sep of <_10> when call 'erlang':'=:=' (Sep,CP1) -> apply 'trim_ls'/2 (Cont,Sep)
<_11> when 'true' -> Str end
<Str,Sep> when 'true' -> apply 'trim_l'/2 (Str,[Sep|[]]) end
'trim_l'/2 = fun (_0,_1) -> case <_0,_1> of <Str = [CP1|Cont = [CP2|_13]],Sep> when try let <_2> = call 'erlang':'<' (CP1,256) in let <_3> = call 'erlang':'<' (CP2,256) in let <_4> = call 'erlang':'=/=' (CP1,13) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> case call 'lists':'member' (CP1,Sep) of <'true'> when 'true' -> apply 'trim_l'/2 (Cont,Sep)
<'false'> when 'true' -> Str
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<[Bin|Cont0],Sep> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_inv'/3 (Bin,Cont0,Sep) of <{'nomatch',Cont}> when 'true' -> apply 'trim_l'/2 (Cont,Sep)
<Keep> when 'true' -> Keep end
<Str,Sep> when call 'erlang':'is_list' (Str) -> case call 'unicode_util':'gc' (Str) of <[C|Cs]> when 'true' -> case call 'lists':'member' (C,Sep) of <'true'> when 'true' -> apply 'trim_l'/2 (Cs,Sep)
<'false'> when 'true' -> Str
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<Bin,Sep> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_inv'/3 (Bin,[],Sep) of <{'nomatch',_14}> when 'true' -> #{}#
<[Keep|[]]> when 'true' -> Keep
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'trim_l',2}}] )-|['compiler_generated'] ) end
'trim_ts'/2 = fun (_0,_1) -> case <_0,_1> of <Str = [Sep|Cs1],_14> when call 'erlang':'=:=' (_14,Sep) -> case Cs1 of <[]> when 'true' -> []
<[CP2|_15]> when try let <_2> = call 'erlang':'<' (Sep,256) in let <_3> = call 'erlang':'<' (CP2,256) in let <_4> = call 'erlang':'=/=' (Sep,13) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <Tail> = apply 'trim_ts'/2 (Cs1,Sep) in case apply 'is_empty'/1 (Tail) of <'true'> when 'true' -> []
<'false'> when 'true' -> [Sep|Tail]
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<_16> when 'true' -> let <_8> = apply 'search_pattern'/1 ([Sep|[]]) in apply 'trim_t'/3 (Str,0,_8) end
<[CP|Cont],Sep> when call 'erlang':'is_integer' (CP) -> let <_10> = apply 'trim_ts'/2 (Cont,Sep) in [CP|_10]
<Str,Sep> when 'true' -> let <_11> = apply 'search_pattern'/1 ([Sep|[]]) in apply 'trim_t'/3 (Str,0,_11) end
'trim_t'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Cs0 = [CP1|Cont],_45,Seps = {GCs,CPs,_46}> when call 'erlang':'is_integer' (CP1) -> case call 'lists':'member' (CP1,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[GC|Cs1]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> let <Tail> = apply 'trim_t'/3 (Cs1,0,Seps) in case apply 'is_empty'/1 (Tail) of <'true'> when 'true' -> []
<'false'> when 'true' -> (case <GC,Tail> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<_62,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_62)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_62,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_63> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_63}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_6> = apply 'trim_t'/3 (Cs1,0,Seps) in (case <GC,_6> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<_66,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_66)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_66,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_67> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_67}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_8> = apply 'trim_t'/3 (Cont,0,Seps) in [CP1|_8]
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<[Bin|Cont0],N,Seps0 = {GCs,_47,_48}> when call 'erlang':'is_binary' (Bin) -> case Bin of <#{#<_49>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_69> = apply 'bin_pattern'/1 (CPs) in (let <_70> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_69) in ({Sep,CPs,_70}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Rest,Cont0,Seps) of <{'nomatch',_50}> when 'true' -> let <_12> = apply 'trim_t'/3 (Cont0,0,Seps) in (case <Bin,_12> of (<_73,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _73-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_74,St> when ('true'-|['compiler_generated'] ) -> ([_74|St]-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[SepStart|Cont1]> when 'true' -> case apply 'bin_search_inv'/3 (SepStart,Cont1,GCs) of <{'nomatch',Cont}> when 'true' -> let <Tail> = apply 'trim_t'/3 (Cont,0,Seps) in case apply 'is_empty'/1 (Tail) of <'true'> when 'true' -> let <_15> = call 'erlang':'byte_size' (Bin) in let <_14> = call 'erlang':'byte_size' (SepStart) in let <KeepSz> = call 'erlang':'-' (_15,_14) in case Bin of <#{#<Keep>(KeepSz,8,'binary',['unsigned'|['big']]),#<_51>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> Keep
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <Used> = apply 'cp_prefix'/2 (Cont0,Cont) in let <_19> = case <Used,Tail> of (<_77,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _77-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_78,St> when ('true'-|['compiler_generated'] ) -> ([_78|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in (case <Bin,_19> of (<_81,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _81-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_82,St> when ('true'-|['compiler_generated'] ) -> ([_82|St]-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_20> when 'true' -> primop 'match_fail' ({'case_clause',_20})-|['compiler_generated'] ) end
<[NonSep|Cont]> when call 'erlang':'is_binary' (NonSep) -> let <_22> = call 'erlang':'byte_size' (Bin) in let <_21> = call 'erlang':'byte_size' (NonSep) in let <KeepSz> = call 'erlang':'-' (_22,_21) in apply 'trim_t'/3 ([Bin|Cont],KeepSz,Seps)
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end
(<_25> when 'true' -> primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<Str,0,Seps = {GCs,_52,_53}> when call 'erlang':'is_list' (Str) -> case call 'unicode_util':'gc' (Str) of <[GC|Cs1]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> let <Tail> = apply 'trim_t'/3 (Cs1,0,Seps) in case apply 'is_empty'/1 (Tail) of <'true'> when 'true' -> []
<'false'> when 'true' -> (case <GC,Tail> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_85> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_85]-|['compiler_generated'] )-|['compiler_generated'] )
(<_86,_87> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_86)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_86,_87)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_88> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_88}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_27> when 'true' -> primop 'match_fail' ({'case_clause',_27})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_28> = apply 'trim_t'/3 (Cs1,0,Seps) in (case <GC,_28> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_91> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_91]-|['compiler_generated'] )-|['compiler_generated'] )
(<_92,_93> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_92)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_92,_93)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_94> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_94}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_29> when 'true' -> primop 'match_fail' ({'case_clause',_29})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_30> when 'true' -> primop 'match_fail' ({'case_clause',_30})-|['compiler_generated'] ) end
<Bin,N,Seps0 = {GCs,_54,_55}> when call 'erlang':'is_binary' (Bin) -> case Bin of <#{#<_56>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_96> = apply 'bin_pattern'/1 (CPs) in (let <_97> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_96) in ({Sep,CPs,_97}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Rest,[],Seps) of <{'nomatch',_57}> when 'true' -> Bin
<[SepStart|[]]> when 'true' -> case apply 'bin_search_inv'/3 (SepStart,[],GCs) of <{'nomatch',_58}> when 'true' -> let <_34> = call 'erlang':'byte_size' (Bin) in let <_33> = call 'erlang':'byte_size' (SepStart) in let <KeepSz> = call 'erlang':'-' (_34,_33) in case Bin of <#{#<Keep>(KeepSz,8,'binary',['unsigned'|['big']]),#<_59>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> Keep
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end
<[NonSep|[]]> when 'true' -> let <_38> = call 'erlang':'byte_size' (Bin) in let <_37> = call 'erlang':'byte_size' (NonSep) in let <KeepSz> = call 'erlang':'-' (_38,_37) in apply 'trim_t'/3 (Bin,KeepSz,Seps)
(<_40> when 'true' -> primop 'match_fail' ({'case_clause',_40})-|['compiler_generated'] ) end
(<_41> when 'true' -> primop 'match_fail' ({'case_clause',_41})-|['compiler_generated'] ) end
(<_31> when 'true' -> primop 'match_fail' ({'badmatch',_31})-|['compiler_generated'] ) end
(<_44,_43,_42> when 'true' -> (primop 'match_fail' ({'function_clause',_44,_43,_42})-|[{'function_name',{'trim_t',3}}] )-|['compiler_generated'] ) end
'take_l'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Str = [CP1|Cont = [CP2|_33]],Seps,Acc> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> case call 'lists':'member' (CP1,Seps) of <'true'> when 'true' -> apply 'take_l'/3 (Cont,Seps,[CP1|Acc])
<'false'> when 'true' -> let <_7> = case Acc of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_39> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_39}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_7,Str}
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<[Bin|Cont0],Seps,Acc> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_inv'/3 (Bin,Cont0,Seps) of <{'nomatch',Cont}> when 'true' -> let <Used> = apply 'cp_prefix'/2 (Cont0,Cont) in let <_10> = call 'unicode':'characters_to_binary' ([Bin|Used]) in apply 'take_l'/3 (Cont,Seps,[_10|Acc])
<After = [Bin1|_34]> when call 'erlang':'is_binary' (Bin1) -> let <_12> = call 'erlang':'byte_size' (Bin) in let <_11> = call 'erlang':'byte_size' (Bin1) in let <First> = call 'erlang':'-' (_12,_11) in case Bin of <#{#<Keep>(First,8,'binary',['unsigned'|['big']]),#<_35>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_15> = case <Keep,Acc> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),Tkn> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_42> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_42|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_15,After}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end
<Str,Seps,Acc> when call 'erlang':'is_list' (Str) -> case call 'unicode_util':'gc' (Str) of <[C|Cs]> when 'true' -> case call 'lists':'member' (C,Seps) of <'true'> when 'true' -> let <_17> = case C of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_44> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> _44-|['compiler_generated'] )
(<_45> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_45}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_18> = case <_17,Acc> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_48> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_48]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,_49> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,_49)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_50> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_50}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'take_l'/3 (Cs,Seps,_18)
<'false'> when 'true' -> let <_19> = case Acc of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_52> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> _52-|['compiler_generated'] )
(<_53> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_53}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_19,Str}
(<_20> when 'true' -> primop 'match_fail' ({'case_clause',_20})-|['compiler_generated'] ) end
<[]> when 'true' -> let <_21> = case Acc of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_55> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_55}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_21,[]}
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end
<Bin,Seps,Acc> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_inv'/3 (Bin,[],Seps) of <{'nomatch',_36}> when 'true' -> let <_23> = case <Bin,Acc> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),Tkn> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_58> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_58|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_23,#{}#}
<[After|[]]> when 'true' -> let <_25> = call 'erlang':'byte_size' (Bin) in let <_24> = call 'erlang':'byte_size' (After) in let <First> = call 'erlang':'-' (_25,_24) in case Bin of <#{#<Keep>(First,8,'binary',['unsigned'|['big']]),#<_37>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_28> = case <Keep,Acc> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),Tkn> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_61> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_61|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_28,After}
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end
(<_29> when 'true' -> primop 'match_fail' ({'case_clause',_29})-|['compiler_generated'] ) end
(<_32,_31,_30> when 'true' -> (primop 'match_fail' ({'function_clause',_32,_31,_30})-|[{'function_name',{'take_l',3}}] )-|['compiler_generated'] ) end
'take_lc'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Str0 = [CP1|Cont],Seps = {GCs,CPs,_36},Acc> when call 'erlang':'is_integer' (CP1) -> case call 'lists':'member' (CP1,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Str0) of <[GC|Str]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'false'> when 'true' -> let <_4> = case GC of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_44> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_44}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_5> = case <_4,Acc> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_47> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_47]-|['compiler_generated'] )-|['compiler_generated'] )
(<_48,_49> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_48)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_48,_49)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_50> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_50}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'take_lc'/3 (Str,Seps,_5)
<'true'> when 'true' -> let <_6> = case Acc of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_52> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_52}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_6,Str0}
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_8> = case <CP1,Acc> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_55> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_55}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'take_lc'/3 (Cont,Seps,_8)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<[Bin|Cont0],Seps0,Acc> when call 'erlang':'is_binary' (Bin) -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_57> = apply 'bin_pattern'/1 (CPs) in (let <_58> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_57) in ({Sep,CPs,_58}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Bin,Cont0,Seps) of <{'nomatch',Cont}> when 'true' -> let <Used> = apply 'cp_prefix'/2 (Cont0,Cont) in let <_12> = call 'unicode':'characters_to_binary' ([Bin|Used]) in apply 'take_lc'/3 (Cont,Seps,[_12|Acc])
<After = [Bin1|_37]> when call 'erlang':'is_binary' (Bin1) -> let <_14> = call 'erlang':'byte_size' (Bin) in let <_13> = call 'erlang':'byte_size' (Bin1) in let <First> = call 'erlang':'-' (_14,_13) in case Bin of <#{#<Keep>(First,8,'binary',['unsigned'|['big']]),#<_38>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_17> = case <Keep,Acc> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),Tkn> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_61> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_61|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_17,After}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end
<Str,Seps = {GCs,_39,_40},Acc> when call 'erlang':'is_list' (Str) -> case call 'unicode_util':'gc' (Str) of <[C|Cs]> when 'true' -> case call 'lists':'member' (C,GCs) of <'false'> when 'true' -> let <_19> = case C of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_63> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> _63-|['compiler_generated'] )
(<_64> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_64}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_20> = case <_19,Acc> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_67> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_67]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,_68> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,_68)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_69> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_69}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'take_lc'/3 (Cs,Seps,_20)
<'true'> when 'true' -> let <_21> = case Acc of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_71> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> _71-|['compiler_generated'] )
(<_72> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_72}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_21,Str}
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end
<[]> when 'true' -> let <_23> = case Acc of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Acc)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_74> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_74}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_23,[]}
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end
<Bin,Seps0,Acc> when call 'erlang':'is_binary' (Bin) -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_76> = apply 'bin_pattern'/1 (CPs) in (let <_77> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_76) in ({Sep,CPs,_77}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Bin,[],Seps) of <{'nomatch',_41}> when 'true' -> let <_26> = case <Bin,Acc> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),Tkn> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_80> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_80|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_26,#{}#}
<[After|[]]> when 'true' -> let <_28> = call 'erlang':'byte_size' (Bin) in let <_27> = call 'erlang':'byte_size' (After) in let <First> = call 'erlang':'-' (_28,_27) in case Bin of <#{#<Keep>(First,8,'binary',['unsigned'|['big']]),#<_42>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_31> = case <Keep,Acc> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),Tkn> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_83> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_83|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_31,After}
(<_30> when 'true' -> primop 'match_fail' ({'badmatch',_30})-|['compiler_generated'] ) end
(<_32> when 'true' -> primop 'match_fail' ({'case_clause',_32})-|['compiler_generated'] ) end
(<_35,_34,_33> when 'true' -> (primop 'match_fail' ({'function_clause',_35,_34,_33})-|[{'function_name',{'take_lc',3}}] )-|['compiler_generated'] ) end
'take_t'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Str0 = [CP1|Cont],_57,Seps = {GCs,CPs,_58}> when call 'erlang':'is_integer' (CP1) -> case call 'lists':'member' (CP1,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Str0) of <[GC|Str]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> case apply 'take_t'/3 (Str,0,Seps) of <{Head,Tail}> when 'true' -> case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> let <_5> = case <GC,Tail> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_71> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_71]-|['compiler_generated'] )-|['compiler_generated'] )
(<_72,_73> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_72)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_72,_73)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_74> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_74}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {Head,_5}
<'false'> when 'true' -> let <_6> = case <GC,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_77> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_77]-|['compiler_generated'] )-|['compiler_generated'] )
(<_78,_79> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_78)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_78,_79)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_80> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_80}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_6,Tail}
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<'false'> when 'true' -> case apply 'take_t'/3 (Str,0,Seps) of <{Head,Tail}> when 'true' -> let <_9> = case <GC,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_83> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_83]-|['compiler_generated'] )-|['compiler_generated'] )
(<_84,_85> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_84)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_84,_85)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_86> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_86}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_9,Tail}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'false'> when 'true' -> case apply 'take_t'/3 (Cont,0,Seps) of <{Head,Tail}> when 'true' -> {[CP1|Head],Tail}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
<[Bin|Cont0],N,Seps0 = {GCs,_59,_60}> when call 'erlang':'is_binary' (Bin) -> case Bin of <#{#<_61>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_88> = apply 'bin_pattern'/1 (CPs) in (let <_89> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_88) in ({Sep,CPs,_89}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Rest,Cont0,Seps) of <{'nomatch',Cont}> when 'true' -> let <Used> = apply 'cp_prefix'/2 (Cont0,Cont) in case apply 'take_t'/3 (Cont,0,Seps) of <{Head,Tail}> when 'true' -> let <_17> = call 'unicode':'characters_to_binary' ([Bin|Used]) in let <_18> = case <_17,Head> of (<_92,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _92-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_93,St> when ('true'-|['compiler_generated'] ) -> ([_93|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in {_18,Tail}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
<[SepStart|Cont1]> when 'true' -> case apply 'bin_search_inv'/3 (SepStart,Cont1,GCs) of <{'nomatch',Cont}> when 'true' -> case apply 'take_t'/3 (Cont,0,Seps) of <{Head,Tail}> when 'true' -> let <Used> = apply 'cp_prefix'/2 (Cont0,Cont) in case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> let <_22> = call 'erlang':'byte_size' (Bin) in let <_21> = call 'erlang':'byte_size' (SepStart) in let <KeepSz> = call 'erlang':'-' (_22,_21) in case Bin of <#{#<Keep>(KeepSz,8,'binary',['unsigned'|['big']]),#<End>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_25> = case <End,Used> of (<_96,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _96-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_97,St> when ('true'-|['compiler_generated'] ) -> ([_97|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_26> = case <_25,Tail> of (<_100,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _100-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_101,St> when ('true'-|['compiler_generated'] ) -> ([_101|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in {Keep,_26}
(<_24> when 'true' -> primop 'match_fail' ({'badmatch',_24})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_27> = call 'unicode':'characters_to_binary' ([Bin|Used]) in let <_28> = case <_27,Head> of (<_104,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _104-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_105,St> when ('true'-|['compiler_generated'] ) -> ([_105|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in {_28,Tail}
(<_29> when 'true' -> primop 'match_fail' ({'case_clause',_29})-|['compiler_generated'] ) end
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<[NonSep|Cont]> when call 'erlang':'is_binary' (NonSep) -> let <_31> = call 'erlang':'byte_size' (Bin) in let <_30> = call 'erlang':'byte_size' (NonSep) in let <KeepSz> = call 'erlang':'-' (_31,_30) in apply 'take_t'/3 ([Bin|Cont],KeepSz,Seps)
(<_33> when 'true' -> primop 'match_fail' ({'case_clause',_33})-|['compiler_generated'] ) end
(<_34> when 'true' -> primop 'match_fail' ({'case_clause',_34})-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<Str,0,Seps = {GCs,_62,_63}> when call 'erlang':'is_list' (Str) -> case call 'unicode_util':'gc' (Str) of <[GC|Cs1]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> case apply 'take_t'/3 (Cs1,0,Seps) of <{Head,Tail}> when 'true' -> case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> let <_36> = case <GC,Tail> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_108> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_108]-|['compiler_generated'] )-|['compiler_generated'] )
(<_109,_110> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_109)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_109,_110)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_111> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_111}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {Head,_36}
<'false'> when 'true' -> let <_37> = case <GC,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_114> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_114]-|['compiler_generated'] )-|['compiler_generated'] )
(<_115,_116> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_115)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_115,_116)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_117> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_117}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_37,Tail}
(<_38> when 'true' -> primop 'match_fail' ({'case_clause',_38})-|['compiler_generated'] ) end
(<_35> when 'true' -> primop 'match_fail' ({'badmatch',_35})-|['compiler_generated'] ) end
<'false'> when 'true' -> case apply 'take_t'/3 (Cs1,0,Seps) of <{Head,Tail}> when 'true' -> let <_40> = case <GC,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_120> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_120]-|['compiler_generated'] )-|['compiler_generated'] )
(<_121,_122> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_121)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_121,_122)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_123> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_123}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_40,Tail}
(<_39> when 'true' -> primop 'match_fail' ({'badmatch',_39})-|['compiler_generated'] ) end
(<_41> when 'true' -> primop 'match_fail' ({'case_clause',_41})-|['compiler_generated'] ) end
<[]> when 'true' -> {[],[]}
(<_42> when 'true' -> primop 'match_fail' ({'case_clause',_42})-|['compiler_generated'] ) end
<Bin,N,Seps0 = {GCs,_64,_65}> when call 'erlang':'is_binary' (Bin) -> case Bin of <#{#<_66>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_125> = apply 'bin_pattern'/1 (CPs) in (let <_126> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_125) in ({Sep,CPs,_126}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Rest,[],Seps) of <{'nomatch',_67}> when 'true' -> {Bin,#{}#}
<[SepStart|[]]> when 'true' -> case apply 'bin_search_inv'/3 (SepStart,[],GCs) of <{'nomatch',_68}> when 'true' -> let <_46> = call 'erlang':'byte_size' (Bin) in let <_45> = call 'erlang':'byte_size' (SepStart) in let <KeepSz> = call 'erlang':'-' (_46,_45) in case Bin of <#{#<Before>(KeepSz,8,'binary',['unsigned'|['big']]),#<End>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> {Before,End}
(<_48> when 'true' -> primop 'match_fail' ({'badmatch',_48})-|['compiler_generated'] ) end
<[NonSep|[]]> when 'true' -> let <_50> = call 'erlang':'byte_size' (Bin) in let <_49> = call 'erlang':'byte_size' (NonSep) in let <KeepSz> = call 'erlang':'-' (_50,_49) in apply 'take_t'/3 (Bin,KeepSz,Seps)
(<_52> when 'true' -> primop 'match_fail' ({'case_clause',_52})-|['compiler_generated'] ) end
(<_53> when 'true' -> primop 'match_fail' ({'case_clause',_53})-|['compiler_generated'] ) end
(<_43> when 'true' -> primop 'match_fail' ({'badmatch',_43})-|['compiler_generated'] ) end
(<_56,_55,_54> when 'true' -> (primop 'match_fail' ({'function_clause',_56,_55,_54})-|[{'function_name',{'take_t',3}}] )-|['compiler_generated'] ) end
'take_tc'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[CP1|Cont = [CP2|_58]],_59,Seps = {GCs,_60,_61}> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> case call 'lists':'member' (CP1,GCs) of <'false'> when 'true' -> case apply 'take_tc'/3 (Cont,0,Seps) of <{Head,Tail}> when 'true' -> case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> let <_8> = case <CP1,Tail> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_74> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_74}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {Head,_8}
<'false'> when 'true' -> let <_9> = case <CP1,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_77> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_77}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_9,Tail}
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<'true'> when 'true' -> case apply 'take_tc'/3 (Cont,0,Seps) of <{Head,Tail}> when 'true' -> let <_12> = case <CP1,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_80> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_80}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_12,Tail}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<[Bin|Cont0],N,Seps0 = {GCs,_62,_63}> when call 'erlang':'is_binary' (Bin) -> case Bin of <#{#<_64>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case apply 'bin_search_inv'/3 (Rest,Cont0,GCs) of <{'nomatch',Cont}> when 'true' -> let <Used> = apply 'cp_prefix'/2 (Cont0,Cont) in case apply 'take_tc'/3 (Cont,0,Seps0) of <{Head,Tail}> when 'true' -> let <_17> = call 'unicode':'characters_to_binary' ([Bin|Used]) in let <_18> = case <_17,Head> of (<_83,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _83-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_84,St> when ('true'-|['compiler_generated'] ) -> ([_84|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in {_18,Tail}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
<[SepStart|Cont1]> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_86> = apply 'bin_pattern'/1 (CPs) in (let <_87> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_86) in ({Sep,CPs,_87}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (SepStart,Cont1,Seps) of <{'nomatch',Cont}> when 'true' -> case apply 'take_tc'/3 (Cont,0,Seps) of <{Head,Tail}> when 'true' -> let <Used> = apply 'cp_prefix'/2 (Cont0,Cont) in case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> let <_23> = call 'erlang':'byte_size' (Bin) in let <_22> = call 'erlang':'byte_size' (SepStart) in let <KeepSz> = call 'erlang':'-' (_23,_22) in case Bin of <#{#<Keep>(KeepSz,8,'binary',['unsigned'|['big']]),#<End>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_26> = case <End,Used> of (<_90,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _90-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_91,St> when ('true'-|['compiler_generated'] ) -> ([_91|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_27> = case <_26,Tail> of (<_94,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _94-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_95,St> when ('true'-|['compiler_generated'] ) -> ([_95|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in {Keep,_27}
(<_25> when 'true' -> primop 'match_fail' ({'badmatch',_25})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_28> = call 'unicode':'characters_to_binary' ([Bin|Used]) in let <_29> = case <_28,Head> of (<_98,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _98-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_99,St> when ('true'-|['compiler_generated'] ) -> ([_99|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in {_29,Tail}
(<_30> when 'true' -> primop 'match_fail' ({'case_clause',_30})-|['compiler_generated'] ) end
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
<[NonSep|Cont]> when call 'erlang':'is_binary' (NonSep) -> let <_32> = call 'erlang':'byte_size' (Bin) in let <_31> = call 'erlang':'byte_size' (NonSep) in let <KeepSz> = call 'erlang':'-' (_32,_31) in apply 'take_tc'/3 ([Bin|Cont],KeepSz,Seps)
(<_34> when 'true' -> primop 'match_fail' ({'case_clause',_34})-|['compiler_generated'] ) end
(<_35> when 'true' -> primop 'match_fail' ({'case_clause',_35})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<Str,0,Seps = {GCs,_65,_66}> when call 'erlang':'is_list' (Str) -> case call 'unicode_util':'gc' (Str) of <[GC|Cs1]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'false'> when 'true' -> case apply 'take_tc'/3 (Cs1,0,Seps) of <{Head,Tail}> when 'true' -> case apply 'is_empty'/1 (Head) of <'true'> when 'true' -> let <_37> = case <GC,Tail> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_102> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_102]-|['compiler_generated'] )-|['compiler_generated'] )
(<_103,_104> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_103)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_103,_104)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_105> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_105}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {Head,_37}
<'false'> when 'true' -> let <_38> = case <GC,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_108> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_108]-|['compiler_generated'] )-|['compiler_generated'] )
(<_109,_110> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_109)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_109,_110)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_111> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_111}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_38,Tail}
(<_39> when 'true' -> primop 'match_fail' ({'case_clause',_39})-|['compiler_generated'] ) end
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end
<'true'> when 'true' -> case apply 'take_tc'/3 (Cs1,0,Seps) of <{Head,Tail}> when 'true' -> let <_41> = case <GC,Head> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,_114> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|_114]-|['compiler_generated'] )-|['compiler_generated'] )
(<_115,_116> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_115)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_115,_116)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_117> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_117}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_41,Tail}
(<_40> when 'true' -> primop 'match_fail' ({'badmatch',_40})-|['compiler_generated'] ) end
(<_42> when 'true' -> primop 'match_fail' ({'case_clause',_42})-|['compiler_generated'] ) end
<[]> when 'true' -> {[],[]}
(<_43> when 'true' -> primop 'match_fail' ({'case_clause',_43})-|['compiler_generated'] ) end
<Bin,N,Seps0 = {GCs,_67,_68}> when call 'erlang':'is_binary' (Bin) -> case Bin of <#{#<_69>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case apply 'bin_search_inv'/3 (Rest,[],GCs) of <{'nomatch',_70}> when 'true' -> {Bin,#{}#}
<[SepStart|[]]> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_119> = apply 'bin_pattern'/1 (CPs) in (let <_120> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_119) in ({Sep,CPs,_120}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (SepStart,[],Seps) of <{'nomatch',_71}> when 'true' -> let <_47> = call 'erlang':'byte_size' (Bin) in let <_46> = call 'erlang':'byte_size' (SepStart) in let <KeepSz> = call 'erlang':'-' (_47,_46) in case Bin of <#{#<Before>(KeepSz,8,'binary',['unsigned'|['big']]),#<End>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> {Before,End}
(<_49> when 'true' -> primop 'match_fail' ({'badmatch',_49})-|['compiler_generated'] ) end
<[NonSep|[]]> when 'true' -> let <_51> = call 'erlang':'byte_size' (Bin) in let <_50> = call 'erlang':'byte_size' (NonSep) in let <KeepSz> = call 'erlang':'-' (_51,_50) in apply 'take_tc'/3 (Bin,KeepSz,Seps)
(<_53> when 'true' -> primop 'match_fail' ({'case_clause',_53})-|['compiler_generated'] ) end
(<_54> when 'true' -> primop 'match_fail' ({'case_clause',_54})-|['compiler_generated'] ) end
(<_44> when 'true' -> primop 'match_fail' ({'badmatch',_44})-|['compiler_generated'] ) end
(<_57,_56,_55> when 'true' -> (primop 'match_fail' ({'function_clause',_57,_56,_55})-|[{'function_name',{'take_tc',3}}] )-|['compiler_generated'] ) end
'prefix_1'/2 = fun (_0,_1) -> case <_0,_1> of <Cs0,[GC|[]]> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[_8|Cs]> when call 'erlang':'=:=' (_8,GC) -> Cs
<_9> when 'true' -> 'nomatch' end
<[CP|Cs],[Pre|PreR]> when call 'erlang':'is_integer' (CP) -> case <> of <> when call 'erlang':'=:=' (CP,Pre) -> apply 'prefix_1'/2 (Cs,PreR)
<> when 'true' -> 'nomatch' end
<#{#<CP>('undefined','undefined','utf8',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#,[Pre|PreR]> when 'true' -> case <> of <> when call 'erlang':'=:=' (CP,Pre) -> apply 'prefix_1'/2 (Cs,PreR)
<> when 'true' -> 'nomatch' end
<Cs0,[Pre|PreR]> when 'true' -> case call 'unicode_util':'cp' (Cs0) of <[_10|Cs]> when call 'erlang':'=:=' (_10,Pre) -> apply 'prefix_1'/2 (Cs,PreR)
<_11> when 'true' -> 'nomatch' end
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'prefix_1',2}}] )-|['compiler_generated'] ) end
'split_1'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Cs0 = [CP1|Cs],Needle = [C|_54],_55,Where,Curr,Acc> when call 'erlang':'is_integer' (CP1) -> case <> of <> when call 'erlang':'=:=' (CP1,C) -> case apply 'prefix_1'/2 (Cs0,Needle) of <'nomatch'> when 'true' -> let <_6> = case <C,Curr> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_69,_70> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_69,_70}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Cs,Needle,0,Where,_6,Acc)
<Rest> when call 'erlang':'=:=' (Where,'leading') -> let <_7> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_72> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> _72-|['compiler_generated'] )
(<_73> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_73}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in [_7|[Rest|[]]]
<Rest> when call 'erlang':'=:=' (Where,'trailing') -> let <_8> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_75> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> _75-|['compiler_generated'] )
(<_76> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_76}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Cs,Needle,0,Where,[C|Curr],[_8|[Rest|[]]])
<Rest> when call 'erlang':'=:=' (Where,'all') -> let <_9> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_78> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> _78-|['compiler_generated'] )
(<_79> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_79}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Rest,Needle,0,Where,[],[_9|Acc])
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<> when 'true' -> let <_11> = case <CP1,Curr> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_82,_83> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_82,_83}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Cs,Needle,0,Where,_11,Acc) end
<[Bin|Cont0],Needle,Start,Where,Curr0,Acc> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_str'/4 (Bin,Start,Cont0,Needle) of <{'nomatch',Sz,Cont}> when 'true' -> case Bin of <#{#<Keep>(Sz,8,'binary',['unsigned'|['big']]),#<_56>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> apply 'split_1'/6 (Cont,Needle,0,Where,[Keep|Curr0],Acc)
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<{Before,[Cs0|Cont],After}> when 'true' -> let <Curr> = apply 'add_non_empty'/2 (Before,Curr0) in case Where of <'leading'> when 'true' -> let <_15> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_85> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_85}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in [_15|[After|[]]]
<'trailing'> when 'true' -> case Cs0 of <#{#<_57>('undefined','undefined','utf8',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_18> = call 'erlang':'byte_size' (Bin) in let <_17> = call 'erlang':'byte_size' (Cs) in let <Next> = call 'erlang':'-' (_18,_17) in let <_20> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_87> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_87}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 ([Bin|Cont],Needle,Next,Where,Curr0,[_20|[After|[]]])
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
<'all'> when 'true' -> let <_21> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_89> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_89}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (After,Needle,0,Where,[],[_21|Acc])
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end
<Cs0,Needle = [C|_58],_59,Where,Curr,Acc> when call 'erlang':'is_list' (Cs0) -> case call 'unicode_util':'cp' (Cs0) of <[_60|Cs]> when call 'erlang':'=:=' (_60,C) -> case apply 'prefix_1'/2 (Cs0,Needle) of <'nomatch'> when 'true' -> let <_24> = case <C,Curr> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_92,_93> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_92,_93}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Cs,Needle,0,Where,_24,Acc)
<Rest> when call 'erlang':'=:=' (Where,'leading') -> let <_25> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_95> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> _95-|['compiler_generated'] )
(<_96> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_96}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in [_25|[Rest|[]]]
<Rest> when call 'erlang':'=:=' (Where,'trailing') -> let <_26> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_98> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> _98-|['compiler_generated'] )
(<_99> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_99}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Cs,Needle,0,Where,[C|Curr],[_26|[Rest|[]]])
<Rest> when call 'erlang':'=:=' (Where,'all') -> let <_27> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_101> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> _101-|['compiler_generated'] )
(<_102> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_102}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Rest,Needle,0,Where,[],[_27|Acc])
(<_28> when 'true' -> primop 'match_fail' ({'case_clause',_28})-|['compiler_generated'] ) end
<[Other|Cs]> when 'true' -> let <_29> = case <Other,Curr> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_105,_106> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_105,_106}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Cs,Needle,0,Where,_29,Acc)
<[]> when 'true' -> let <_30> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<_108> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> _108-|['compiler_generated'] )
(<_109> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_109}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_30,Acc}
(<_31> when 'true' -> primop 'match_fail' ({'case_clause',_31})-|['compiler_generated'] ) end
<Bin,Needle = [_X_C|_61],Start,Where,Curr0,Acc> when 'true' -> case apply 'bin_search_str'/4 (Bin,Start,[],Needle) of <{'nomatch',_62,_63}> when 'true' -> case Bin of <#{#<_64>(Start,8,'binary',['unsigned'|['big']]),#<Keep>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_110> = [Keep|Curr0] in let <_33> = case _110 of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_110)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_110)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_111> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_111}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_33,Acc}
(<_32> when 'true' -> primop 'match_fail' ({'badmatch',_32})-|['compiler_generated'] ) end
<{Before,[Cs0|[]],After}> when 'true' -> case Where of <'leading'> when 'true' -> let <_112> = [Before|Curr0] in let <_34> = case _112 of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_112)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (_112)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_113> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_113}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in [_34|[After|[]]]
<'trailing'> when 'true' -> case Cs0 of <#{#<_65>('undefined','undefined','utf8',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_37> = call 'erlang':'byte_size' (Bin) in let <_36> = call 'erlang':'byte_size' (Cs) in let <Next> = call 'erlang':'-' (_37,_36) in let <_39> = case <Before,Curr0> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),Tkn> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,_116> when ('true'-|['compiler_generated'] ) -> (let <_117> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (_116) in ([_117|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Bin,Needle,Next,Where,Curr0,[_39|[After|[]]])
(<_35> when 'true' -> primop 'match_fail' ({'badmatch',_35})-|['compiler_generated'] ) end
<'all'> when 'true' -> let <_41> = call 'erlang':'byte_size' (Bin) in let <_40> = call 'erlang':'byte_size' (After) in let <Next> = call 'erlang':'-' (_41,_40) in case Before of <#{#<_66>(Start,8,'binary',['unsigned'|['big']]),#<Keep>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Curr> = [Keep|Curr0] in let <_45> = case Curr of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Curr)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_119> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_119}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'split_1'/6 (Bin,Needle,Next,Where,[],[_45|Acc])
(<_43> when 'true' -> primop 'match_fail' ({'badmatch',_43})-|['compiler_generated'] ) end
(<_46> when 'true' -> primop 'match_fail' ({'case_clause',_46})-|['compiler_generated'] ) end
(<_47> when 'true' -> primop 'match_fail' ({'case_clause',_47})-|['compiler_generated'] ) end
(<_53,_52,_51,_50,_49,_48> when 'true' -> (primop 'match_fail' ({'function_clause',_53,_52,_51,_50,_49,_48})-|[{'function_name',{'split_1',6}}] )-|['compiler_generated'] ) end
'lexemes_m'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Cs0 = [CP|_24],Seps0 = {GCs,CPs,_25},Ts> when call 'erlang':'is_integer' (CP) -> case call 'lists':'member' (CP,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[GC|Cs2]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> apply 'lexemes_m'/3 (Cs2,Seps0,Ts)
<'false'> when 'true' -> let <Seps> = case Seps0 of (<({Sep,_34,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_35> = apply 'bin_pattern'/1 (_34) in (let <_36> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_35) in ({Sep,_34,_36}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'lexeme_pick'/3 (Cs0,Seps,[]) of <{Lexeme,Rest}> when 'true' -> apply 'lexemes_m'/3 (Rest,Seps,[Lexeme|Ts])
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <Seps> = case Seps0 of (<({Sep,_38,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_39> = apply 'bin_pattern'/1 (_38) in (let <_40> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_39) in ({Sep,_38,_40}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'lexeme_pick'/3 (Cs0,Seps,[]) of <{Lexeme,Rest}> when 'true' -> apply 'lexemes_m'/3 (Rest,Seps,[Lexeme|Ts])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<[Bin|Cont0],Seps0 = {GCs,_26,_27},Ts> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_inv'/3 (Bin,Cont0,GCs) of <{'nomatch',Cont}> when 'true' -> apply 'lexemes_m'/3 (Cont,Seps0,Ts)
<Cs> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_42> = apply 'bin_pattern'/1 (CPs) in (let <_43> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_42) in ({Sep,CPs,_43}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'lexeme_pick'/3 (Cs,Seps,[]) of <{Lexeme,Rest}> when 'true' -> apply 'lexemes_m'/3 (Rest,Seps,[Lexeme|Ts])
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end end
<Cs0,Seps0 = {GCs,_28,_29},Ts> when call 'erlang':'is_list' (Cs0) -> case call 'unicode_util':'gc' (Cs0) of <[C|Cs]> when 'true' -> case call 'lists':'member' (C,GCs) of <'true'> when 'true' -> apply 'lexemes_m'/3 (Cs,Seps0,Ts)
<'false'> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_45> = apply 'bin_pattern'/1 (CPs) in (let <_46> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_45) in ({Sep,CPs,_46}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'lexeme_pick'/3 (Cs0,Seps,[]) of <{Lexeme,Rest}> when 'true' -> apply 'lexemes_m'/3 (Rest,Seps,[Lexeme|Ts])
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
<[]> when 'true' -> call 'lists':'reverse' (Ts)
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end
<Bin,Seps0 = {GCs,_30,_31},Ts> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_inv'/3 (Bin,[],GCs) of <{'nomatch',_32}> when 'true' -> call 'lists':'reverse' (Ts)
<[Cs|[]]> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_48> = apply 'bin_pattern'/1 (CPs) in (let <_49> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_48) in ({Sep,CPs,_49}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'lexeme_pick'/3 (Cs,Seps,[]) of <{Lexeme,Rest}> when 'true' -> let <_19> = apply 'add_non_empty'/2 (Lexeme,Ts) in apply 'lexemes_m'/3 (Rest,Seps,_19)
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
(<_20> when 'true' -> primop 'match_fail' ({'case_clause',_20})-|['compiler_generated'] ) end
(<_23,_22,_21> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21})-|[{'function_name',{'lexemes_m',3}}] )-|['compiler_generated'] ) end
'lexeme_pick'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Cs0 = [CP|Cs1],Seps = {GCs,CPs,_34},Tkn> when call 'erlang':'is_integer' (CP) -> case call 'lists':'member' (CP,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[GC|Cs2]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> let <_4> = case Tkn of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_41> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_41}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_4,Cs2}
<'false'> when 'true' -> let <_5> = case GC of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_43> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_43}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_6> = case <_5,Tkn> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<_46,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_46)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_46,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_47> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_47}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'lexeme_pick'/3 (Cs2,Seps,_6)
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'false'> when 'true' -> apply 'lexeme_pick'/3 (Cs1,Seps,[CP|Tkn])
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<[Bin|Cont0],Seps,Tkn> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search'/3 (Bin,Cont0,Seps) of <{'nomatch',_35}> when 'true' -> apply 'lexeme_pick'/3 (Cont0,Seps,[Bin|Tkn])
<Cs = [Left|_X_Cont]> when 'true' -> let <_10> = call 'erlang':'byte_size' (Bin) in let <_9> = call 'erlang':'byte_size' (Left) in let <Bytes> = call 'erlang':'-' (_10,_9) in case Bin of <#{#<Lexeme>(Bytes,8,'binary',['unsigned'|['big']]),#<_36>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_13> = case <Lexeme,Tkn> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),_50> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (_50)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,_51> when ('true'-|['compiler_generated'] ) -> (let <_52> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (_51) in ([_52|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_13,Cs}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
<Cs0,Seps = {GCs,CPs,_37},Tkn> when call 'erlang':'is_list' (Cs0) -> case call 'unicode_util':'cp' (Cs0) of <[CP|Cs]> when 'true' -> case call 'lists':'member' (CP,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[GC|Cs2]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> let <_16> = case Tkn of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_54> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_54}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_16,Cs2}
<'false'> when 'true' -> let <_17> = case GC of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_56> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_56}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_18> = case <_17,Tkn> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<_59,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_59)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (_59,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_60> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_60}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'lexeme_pick'/3 (Cs2,Seps,_18)
(<_19> when 'true' -> primop 'match_fail' ({'case_clause',_19})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_20> = case <CP,Tkn> of (<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|([]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,(#{}#-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> Char-|['compiler_generated'] )
(<Char,Bin> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (Bin)-|['compiler_generated'] ) -> ([Char|([Bin|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )
(<Char,Str> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Char)-|['compiler_generated'] ) -> ([Char|Str]-|['compiler_generated'] )-|['compiler_generated'] )
(<GC,Str> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (GC)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('++'-|['compiler_generated'] ) (GC,Str)-|['compiler_generated'] )-|['compiler_generated'] )
(<_3,_63> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3,_63}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'lexeme_pick'/3 (Cs,Seps,_20)
(<_21> when 'true' -> primop 'match_fail' ({'case_clause',_21})-|['compiler_generated'] ) end
<[]> when 'true' -> let <_22> = case Tkn of (<([B|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_binary'-|['compiler_generated'] ) (B)-|['compiler_generated'] ) -> B-|['compiler_generated'] )
(<L> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (L)-|['compiler_generated'] )-|['compiler_generated'] )
(<C> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (Tkn)-|['compiler_generated'] ) -> C-|['compiler_generated'] )
(<_65> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_65}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in {_22,[]}
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end
<Bin,Seps,Tkn> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search'/3 (Bin,[],Seps) of <{'nomatch',_38}> when 'true' -> let <_24> = case <Bin,Tkn> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),_68> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (_68)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_69> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_69|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_24,[]}
<[Left|[]]> when 'true' -> let <_26> = call 'erlang':'byte_size' (Bin) in let <_25> = call 'erlang':'byte_size' (Left) in let <Bytes> = call 'erlang':'-' (_26,_25) in case Bin of <#{#<Lexeme>(Bytes,8,'binary',['unsigned'|['big']]),#<_39>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_29> = case <Lexeme,Tkn> of (<Token,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Token-|['compiler_generated'] )
(<BinPart,([C|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_integer'-|['compiler_generated'] ) (C)-|['compiler_generated'] ) -> (#{(#<C>(('undefined'-|['compiler_generated'] ),('undefined'-|['compiler_generated'] ),('utf8'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] ),(#<BinPart>(('all'-|['compiler_generated'] ),(8-|['compiler_generated'] ),('binary'-|['compiler_generated'] ),(['unsigned'|['big']]-|['compiler_generated'] ))-|['compiler_generated'] )}#-|['compiler_generated'] )-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),_72> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (_72)-|['compiler_generated'] )-|['compiler_generated'] )
(<BinPart,Cs> when ('true'-|['compiler_generated'] ) -> (let <_73> = call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (Cs) in ([_73|([BinPart|([]-|['compiler_generated'] )]-|['compiler_generated'] )]-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end in {_29,Left}
(<_28> when 'true' -> primop 'match_fail' ({'badmatch',_28})-|['compiler_generated'] ) end
(<_30> when 'true' -> primop 'match_fail' ({'case_clause',_30})-|['compiler_generated'] ) end
(<_33,_32,_31> when 'true' -> (primop 'match_fail' ({'function_clause',_33,_32,_31})-|[{'function_name',{'lexeme_pick',3}}] )-|['compiler_generated'] ) end
'nth_lexeme_m'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[Bin|Cont0],Seps0 = {GCs,_22,_23},N> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_inv'/3 (Bin,Cont0,GCs) of <{'nomatch',Cont}> when 'true' -> apply 'nth_lexeme_m'/3 (Cont,Seps0,N)
<Cs> when call 'erlang':'>' (N,1) -> let <Rest> = apply 'lexeme_skip'/2 (Cs,Seps0) in let <_4> = call 'erlang':'-' (N,1) in apply 'nth_lexeme_m'/3 (Rest,Seps0,_4)
<Cs> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_33> = apply 'bin_pattern'/1 (CPs) in (let <_34> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_33) in ({Sep,CPs,_34}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'lexeme_pick'/3 (Cs,Seps,[]) of <{Lexeme,_24}> when 'true' -> Lexeme
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end end
<Cs0,Seps0 = {GCs,_25,_26},N> when call 'erlang':'is_list' (Cs0) -> case call 'unicode_util':'gc' (Cs0) of <[C|Cs]> when 'true' -> case call 'lists':'member' (C,GCs) of <'true'> when 'true' -> apply 'nth_lexeme_m'/3 (Cs,Seps0,N)
<'false'> when call 'erlang':'>' (N,1) -> let <Cs1> = apply 'lexeme_skip'/2 (Cs,Seps0) in let <_9> = call 'erlang':'-' (N,1) in apply 'nth_lexeme_m'/3 (Cs1,Seps0,_9)
<'false'> when 'true' -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_36> = apply 'bin_pattern'/1 (CPs) in (let <_37> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_36) in ({Sep,CPs,_37}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'lexeme_pick'/3 (Cs0,Seps,[]) of <{Lexeme,_27}> when 'true' -> Lexeme
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<Bin,Seps0 = {GCs,_28,_29},N> when call 'erlang':'is_binary' (Bin) -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_39> = apply 'bin_pattern'/1 (CPs) in (let <_40> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_39) in ({Sep,CPs,_40}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search_inv'/3 (Bin,[],GCs) of <[Cs|[]]> when call 'erlang':'>' (N,1) -> let <Cs1> = apply 'lexeme_skip'/2 (Cs,Seps) in let <_16> = call 'erlang':'-' (N,1) in apply 'nth_lexeme_m'/3 (Cs1,Seps,_16)
<[Cs|[]]> when 'true' -> case apply 'lexeme_pick'/3 (Cs,Seps,[]) of <{Lexeme,_30}> when 'true' -> Lexeme
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<{'nomatch',_31}> when 'true' -> #{}#
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end
(<_21,_20,_19> when 'true' -> (primop 'match_fail' ({'function_clause',_21,_20,_19})-|[{'function_name',{'nth_lexeme_m',3}}] )-|['compiler_generated'] ) end
'lexeme_skip'/2 = fun (_0,_1) -> case <_0,_1> of <Cs0 = [CP|Cs1],Seps = {GCs,CPs,_17}> when call 'erlang':'is_integer' (CP) -> case call 'lists':'member' (CP,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[GC|Cs2]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> Cs2
<'false'> when 'true' -> apply 'lexeme_skip'/2 (Cs2,Seps)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<'false'> when 'true' -> apply 'lexeme_skip'/2 (Cs1,Seps)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[Bin|Cont0],Seps0> when call 'erlang':'is_binary' (Bin) -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_22> = apply 'bin_pattern'/1 (CPs) in (let <_2> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_22) in ({Sep,CPs,_2}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Bin,Cont0,Seps) of <{'nomatch',_18}> when 'true' -> apply 'lexeme_skip'/2 (Cont0,Seps)
<Cs> when 'true' -> let <_6> = call 'unicode_util':'gc' (Cs) in call 'erlang':'tl' (_6) end
<Cs0,Seps = {GCs,CPs,_19}> when call 'erlang':'is_list' (Cs0) -> case call 'unicode_util':'cp' (Cs0) of <[CP|Cs]> when 'true' -> case call 'lists':'member' (CP,CPs) of <'true'> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[GC|Cs2]> when 'true' -> case call 'lists':'member' (GC,GCs) of <'true'> when 'true' -> Cs2
<'false'> when 'true' -> apply 'lexeme_skip'/2 (Cs2,Seps)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<'false'> when 'true' -> apply 'lexeme_skip'/2 (Cs,Seps)
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
<Bin,Seps0> when call 'erlang':'is_binary' (Bin) -> let <Seps> = case Seps0 of (<({Sep,CPs,('undefined'-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_24> = apply 'bin_pattern'/1 (CPs) in (let <_2> = call ('binary'-|['compiler_generated'] ):('compile_pattern'-|['compiler_generated'] ) (_24) in ({Sep,CPs,_2}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(Compiled = ({_4,_5,_6}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Compiled-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'bin_search'/3 (Bin,[],Seps) of <{'nomatch',_20}> when 'true' -> #{}#
<[Left|[]]> when 'true' -> let <_13> = call 'unicode_util':'gc' (Left) in call 'erlang':'tl' (_13)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
(<_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15})-|[{'function_name',{'lexeme_skip',2}}] )-|['compiler_generated'] ) end
'find_l'/2 = fun (_0,_1) -> case <_0,_1> of <Cs0 = [C1|Cs],Needle = [C|_10]> when call 'erlang':'is_integer' (C1) -> case C1 of <_11> when call 'erlang':'=:=' (C1,C) -> case apply 'prefix_1'/2 (Cs0,Needle) of <'nomatch'> when 'true' -> apply 'find_l'/2 (Cs,Needle)
<_12> when 'true' -> Cs0 end
<_13> when 'true' -> apply 'find_l'/2 (Cs,Needle) end
<[Bin|Cont0],Needle> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_str'/4 (Bin,0,Cont0,Needle) of <{'nomatch',_14,Cont}> when 'true' -> apply 'find_l'/2 (Cont,Needle)
<{_X_Before,Cs,_X_After}> when 'true' -> Cs
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<Cs0,Needle = [C|_15]> when call 'erlang':'is_list' (Cs0) -> case call 'unicode_util':'cp' (Cs0) of <[_16|Cs]> when call 'erlang':'=:=' (_16,C) -> case apply 'prefix_1'/2 (Cs0,Needle) of <'nomatch'> when 'true' -> apply 'find_l'/2 (Cs,Needle)
<_17> when 'true' -> Cs0 end
<[_X_C|Cs]> when 'true' -> apply 'find_l'/2 (Cs,Needle)
<[]> when 'true' -> 'nomatch'
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<Bin,Needle> when 'true' -> case apply 'bin_search_str'/4 (Bin,0,[],Needle) of <{'nomatch',_18,_19}> when 'true' -> 'nomatch'
<{_X_Before,[Cs|[]],_X_After}> when 'true' -> Cs
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end end
'find_r'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Cs0 = [Cp|Cs],Needle = [C|_14],Res> when call 'erlang':'is_integer' (Cp) -> case Cp of <_15> when call 'erlang':'=:=' (Cp,C) -> case apply 'prefix_1'/2 (Cs0,Needle) of <'nomatch'> when 'true' -> apply 'find_r'/3 (Cs,Needle,Res)
<_16> when 'true' -> apply 'find_r'/3 (Cs,Needle,Cs0) end
<_17> when 'true' -> apply 'find_r'/3 (Cs,Needle,Res) end
<[Bin|Cont0],Needle,Res> when call 'erlang':'is_binary' (Bin) -> case apply 'bin_search_str'/4 (Bin,0,Cont0,Needle) of <{'nomatch',_18,Cont}> when 'true' -> apply 'find_r'/3 (Cont,Needle,Res)
<{_19,Cs0,_20}> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <[_21|Cs]> when 'true' -> apply 'find_r'/3 (Cs,Needle,Cs0)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<Cs0,Needle = [C|_22],Res> when call 'erlang':'is_list' (Cs0) -> case call 'unicode_util':'cp' (Cs0) of <[_23|Cs]> when call 'erlang':'=:=' (_23,C) -> case apply 'prefix_1'/2 (Cs0,Needle) of <'nomatch'> when 'true' -> apply 'find_r'/3 (Cs,Needle,Res)
<_24> when 'true' -> apply 'find_r'/3 (Cs,Needle,Cs0) end
<[_X_C|Cs]> when 'true' -> apply 'find_r'/3 (Cs,Needle,Res)
<[]> when 'true' -> Res
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<Bin,Needle,Res> when 'true' -> case apply 'bin_search_str'/4 (Bin,0,[],Needle) of <{'nomatch',_25,_26}> when 'true' -> Res
<{_X_Before,[Cs0|[]],_X_After}> when 'true' -> case Cs0 of <#{#<_27>('undefined','undefined','utf8',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> apply 'find_r'/3 (Cs,Needle,Cs0)
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end end
'btoken'/2 = fun (_0,_1) -> case <_0,_1> of <Token,[]> when 'true' -> Token
<BinPart,[C|[]]> when call 'erlang':'is_integer' (C) -> #{#<C>('undefined','undefined','utf8',['unsigned'|['big']]),#<BinPart>('all',8,'binary',['unsigned'|['big']])}#
<#{}#,Tkn> when 'true' -> call 'lists':'reverse' (Tkn)
<BinPart,Cs> when 'true' -> let <_2> = call 'lists':'reverse' (Cs) in [_2|[BinPart|[]]] end
'rev'/1 = fun (_0) -> case _0 of <[B|[]]> when call 'erlang':'is_binary' (B) -> B
<L> when call 'erlang':'is_list' (_0) -> call 'lists':'reverse' (L)
<C> when call 'erlang':'is_integer' (_0) -> C
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'rev',1}}] )-|['compiler_generated'] ) end
'append'/2 = fun (_0,_1) -> case <_0,_1> of <Char,#{}#> when call 'erlang':'is_integer' (Char) -> [Char|[]]
<Char,#{}#> when call 'erlang':'is_list' (Char) -> Char
<Char,Bin> when call 'erlang':'is_binary' (Bin) -> [Char|[Bin|[]]]
<Char,Str> when call 'erlang':'is_integer' (Char) -> [Char|Str]
<GC,Str> when call 'erlang':'is_list' (GC) -> call 'erlang':'++' (GC,Str)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'append',2}}] )-|['compiler_generated'] ) end
'stack'/2 = fun (_0,_1) -> case <_0,_1> of <Bin,[]> when 'true' -> Bin
<#{}#,St> when 'true' -> St
<[],St> when 'true' -> St
<Bin,St> when 'true' -> [Bin|St] end
'add_non_empty'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,L> when 'true' -> L
<Token,L> when 'true' -> [Token|L] end
'cp_prefix'/2 = fun (_0,_1) -> case call 'unicode_util':'cp' (_1) of <[]> when 'true' -> _0
<[Cp|Rest]> when 'true' -> apply 'cp_prefix_1'/3 (_0,Cp,Rest)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'cp_prefix_1'/3 = fun (_0,_1,_2) -> case call 'unicode_util':'cp' (_0) of <[_10|Rest]> when call 'erlang':'=:=' (_10,_1) -> case apply 'equal'/2 (Rest,_2) of <'true'> when 'true' -> []
<'false'> when 'true' -> let <_3> = apply 'cp_prefix_1'/3 (Rest,_1,_2) in [_1|_3]
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[CP|Rest]> when 'true' -> let <_5> = apply 'cp_prefix_1'/3 (Rest,_1,_2) in [CP|_5]
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
'bin_search'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Bin,Cont,{Seps,_6,BP}> when 'true' -> apply 'bin_search_loop'/5 (Bin,0,BP,Cont,Seps)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'bin_search',3}}] )-|['compiler_generated'] ) end
'search_pattern'/1 = fun (_0) -> case _0 of <P = {_3,_4,_5}> when 'true' -> P
<Seps> when 'true' -> let <CPs> = apply 'search_cp'/1 (Seps) in {Seps,CPs,'undefined'} end
'search_compile'/1 = fun (_0) -> case _0 of <{Sep,CPs,'undefined'}> when 'true' -> let <_1> = apply 'bin_pattern'/1 (CPs) in let <_2> = call 'binary':'compile_pattern' (_1) in {Sep,CPs,_2}
<Compiled = {_4,_5,_6}> when 'true' -> Compiled
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'search_compile',1}}] )-|['compiler_generated'] ) end
'search_cp'/1 = fun (_0) -> case _0 of <[CP|Seps]> when call 'erlang':'is_integer' (CP) -> let <_1> = apply 'search_cp'/1 (Seps) in [CP|_1]
<[Pattern|Seps]> when 'true' -> case call 'unicode_util':'cp' (Pattern) of <[CP|_5]> when 'true' -> let <_3> = apply 'search_cp'/1 (Seps) in [CP|_3]
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'search_cp',1}}] )-|['compiler_generated'] ) end
'bin_pattern'/1 = fun (_0) -> case _0 of <[CP|Seps]> when 'true' -> let <_1> = #{#<CP>('undefined','undefined','utf8',['unsigned'|['big']])}# in let <_2> = apply 'bin_pattern'/1 (Seps) in [_1|_2]
<[]> when 'true' -> []
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'bin_pattern',1}}] )-|['compiler_generated'] ) end
'bin_search_loop'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Bin0,Start,_29,Cont,_X_Seps> when let <_6> = try let <_5> = call 'erlang':'byte_size' (Bin0) in call 'erlang':'=<' (_5,Start) of <Try> -> Try catch <T,R> -> 'false' in let <_7> = call 'erlang':'<' (Start,0) in call 'erlang':'or' (_6,_7) -> {'nomatch',Cont}
<Bin0,Start,BinSeps,Cont,Seps> when 'true' -> case Bin0 of <#{#<_30>(Start,8,'binary',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case call 'binary':'match' (Bin,BinSeps) of <'nomatch'> when 'true' -> {'nomatch',Cont}
<{Where,_X_CL}> when call 'erlang':'=:=' (Cont,[]) -> case Bin of <#{#<_31>(Where,8,'binary',['unsigned'|['big']]),#<Cont1>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case call 'unicode_util':'gc' (Cont1) of <[GC|Cont2]> when 'true' -> case call 'lists':'member' (GC,Seps) of <'false'> when call 'erlang':'=:=' (Cont2,[]) -> {'nomatch',[]}
<'false'> when 'true' -> let <_12> = call 'erlang':'byte_size' (Bin0) in let <_11> = call 'erlang':'byte_size' (Cont2) in let <Next> = call 'erlang':'-' (_12,_11) in apply 'bin_search_loop'/5 (Bin0,Next,BinSeps,Cont,Seps)
<'true'> when 'true' -> [Cont1|[]]
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<{Where,_X_CL}> when 'true' -> case Bin of <#{#<_32>(Where,8,'binary',['unsigned'|['big']]),#<Cont0>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Cont1> = [Cont0|Cont] in case call 'unicode_util':'gc' (Cont1) of <[GC|Cont2]> when 'true' -> case call 'lists':'member' (GC,Seps) of <'false'> when 'true' -> case Cont2 of <[BinR|_33]> when let <_34> = call 'erlang':'=:=' (_33,Cont) in let <_35> = call 'erlang':'is_binary' (BinR) in call 'erlang':'and' (_34,_35) -> let <_19> = call 'erlang':'byte_size' (Bin0) in let <_18> = call 'erlang':'byte_size' (BinR) in let <Next> = call 'erlang':'-' (_19,_18) in apply 'bin_search_loop'/5 (Bin0,Next,BinSeps,Cont,Seps)
<_36> when 'true' -> {'nomatch',Cont2} end
<'true'> when 'true' -> Cont1
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end
'bin_search_inv'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{}#,Cont,_6> when 'true' -> {'nomatch',Cont}
<Bin,Cont,[Sep|[]]> when 'true' -> apply 'bin_search_inv_1'/3 (Bin,Cont,Sep)
<Bin,Cont,Seps> when 'true' -> apply 'bin_search_inv_n'/3 (Bin,Cont,Seps) end
'bin_search_inv_1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Bin0 = #{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<BinRest>('all',8,'binary',['unsigned'|['big']])}#,Cont,Sep> when 'true' -> case BinRest of <#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<_14>('all',8,'binary',['unsigned'|['big']])}#> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> case CP1 of <_15> when call 'erlang':'=:=' (CP1,Sep) -> apply 'bin_search_inv_1'/3 (BinRest,Cont,Sep)
<_16> when 'true' -> [Bin0|Cont] end
<_17> when call 'erlang':'=:=' (Cont,[]) -> case call 'unicode_util':'gc' (Bin0) of <[_18|Bin]> when call 'erlang':'=:=' (_18,Sep) -> apply 'bin_search_inv_1'/3 (Bin,Cont,Sep)
<_19> when 'true' -> [Bin0|Cont] end
<_20> when 'true' -> case call 'unicode_util':'gc' ([Bin0|Cont]) of <[_21|[Bin|_22]]> when let <_25> = call 'erlang':'=:=' (_21,Sep) in let <_23> = call 'erlang':'=:=' (_22,Cont) in let <_24> = call 'erlang':'is_binary' (Bin) in let <_26> = call 'erlang':'and' (_23,_24) in call 'erlang':'and' (_25,_26) -> apply 'bin_search_inv_1'/3 (Bin,Cont,Sep)
<[_27|Cs]> when call 'erlang':'=:=' (_27,Sep) -> {'nomatch',Cs}
<_28> when 'true' -> [Bin0|Cont] end end
<#{}#,Cont,_X_Sep> when 'true' -> {'nomatch',Cont}
<[],Cont,_X_Sep> when 'true' -> {'nomatch',Cont}
<Bin,_29,_30> when 'true' -> call 'erlang':'error' ({'badarg',Bin}) end
'bin_search_inv_n'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Bin0 = #{#<CP1>('undefined','undefined','utf8',['unsigned'|['big']]),#<BinRest>('all',8,'binary',['unsigned'|['big']])}#,Cont,Seps> when 'true' -> case BinRest of <#{#<CP2>('undefined','undefined','utf8',['unsigned'|['big']]),#<_17>('all',8,'binary',['unsigned'|['big']])}#> when try let <_3> = call 'erlang':'<' (CP1,256) in let <_4> = call 'erlang':'<' (CP2,256) in let <_5> = call 'erlang':'=/=' (CP1,13) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> case call 'lists':'member' (CP1,Seps) of <'true'> when 'true' -> apply 'bin_search_inv_n'/3 (BinRest,Cont,Seps)
<'false'> when 'true' -> [Bin0|Cont]
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<_18> when call 'erlang':'=:=' (Cont,[]) -> case call 'unicode_util':'gc' (Bin0) of <[GC|Bin]> when 'true' -> case call 'lists':'member' (GC,Seps) of <'true'> when 'true' -> apply 'bin_search_inv_n'/3 (Bin,Cont,Seps)
<'false'> when 'true' -> [Bin0|Cont]
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<_19> when 'true' -> case call 'unicode_util':'gc' ([Bin0|Cont]) of <[GC|Cs0]> when 'true' -> case call 'lists':'member' (GC,Seps) of <'false'> when 'true' -> [Bin0|Cont]
<'true'> when 'true' -> case Cs0 of <[Bin|_20]> when let <_21> = call 'erlang':'=:=' (_20,Cont) in let <_22> = call 'erlang':'is_binary' (Bin) in call 'erlang':'and' (_21,_22) -> apply 'bin_search_inv_n'/3 (Bin,Cont,Seps)
<_23> when 'true' -> {'nomatch',Cs0} end
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end end
<#{}#,Cont,_X_Sep> when 'true' -> {'nomatch',Cont}
<[],Cont,_X_Sep> when 'true' -> {'nomatch',Cont}
<Bin,_24,_25> when 'true' -> call 'erlang':'error' ({'badarg',Bin}) end
'bin_search_str'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Bin0,Start,[],SearchCPs> when 'true' -> let <_4> = call 'unicode':'characters_to_binary' (SearchCPs) in let <Compiled> = call 'binary':'compile_pattern' (_4) in apply 'bin_search_str_1'/4 (Bin0,Start,Compiled,SearchCPs)
<Bin0,Start,Cont,SearchCPs = [CP|_12]> when 'true' -> let <_6> = #{#<CP>('undefined','undefined','utf8',['unsigned'|['big']])}# in let <First> = call 'binary':'compile_pattern' (_6) in apply 'bin_search_str_2'/5 (Bin0,Start,Cont,First,SearchCPs)
(<_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8})-|[{'function_name',{'bin_search_str',4}}] )-|['compiler_generated'] ) end
'bin_search_str_1'/4 = fun (_0,_1,_2,_3) -> case _0 of <#{#<_18>(_1,8,'binary',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case call 'binary':'match' (Bin,_2) of <'nomatch'> when 'true' -> let <_5> = call 'erlang':'byte_size' (_0) in {'nomatch',_5,[]}
<{Where0,_19}> when 'true' -> let <Where> = call 'erlang':'+' (_1,Where0) in case _0 of <#{#<Keep>(Where,8,'binary',['unsigned'|['big']]),#<Cs0>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case apply 'prefix_1'/2 (Cs0,_3) of <'nomatch'> when 'true' -> case Cs0 of <#{#<_20>('undefined','undefined','utf8',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_10> = call 'erlang':'byte_size' (_0) in let <_9> = call 'erlang':'byte_size' (Cs) in let <KeepSz> = call 'erlang':'-' (_10,_9) in apply 'bin_search_str_1'/4 (_0,KeepSz,_2,_3)
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<[]> when 'true' -> {Keep,[Cs0|[]],#{}#}
<Rest> when 'true' -> {Keep,[Cs0|[]],Rest} end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'bin_search_str_2'/5 = fun (_0,_1,_2,_3,_4) -> case _0 of <#{#<_22>(_1,8,'binary',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case call 'binary':'match' (Bin,_3) of <'nomatch'> when 'true' -> let <_6> = call 'erlang':'byte_size' (_0) in {'nomatch',_6,_2}
<{Where0,_23}> when 'true' -> let <Where> = call 'erlang':'+' (_1,Where0) in case _0 of <#{#<Keep>(Where,8,'binary',['unsigned'|['big']]),#<Cs0>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case call 'unicode_util':'gc' (Cs0) of <_@r0 = [GC|Cs]> when 'true' -> let <_10> = case <Cs0,_2> of (<_26,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _26-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_27,St> when ('true'-|['compiler_generated'] ) -> ([_27|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply 'prefix_1'/2 (_10,_4) of <'nomatch'> when call 'erlang':'is_binary' (Cs) -> let <_12> = call 'erlang':'byte_size' (_0) in let <_11> = call 'erlang':'byte_size' (Cs) in let <KeepSz> = call 'erlang':'-' (_12,_11) in apply 'bin_search_str_2'/5 (_0,KeepSz,_2,_3,_4)
<'nomatch'> when 'true' -> let <_28> = _@r0 in let <_14> = case <_28,_2> of (<_30,([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _30-|['compiler_generated'] )
(<(#{}#-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<([]-|['compiler_generated'] ),St> when ('true'-|['compiler_generated'] ) -> St-|['compiler_generated'] )
(<_31,St> when ('true'-|['compiler_generated'] ) -> ([_31|St]-|['compiler_generated'] )-|['compiler_generated'] ) end in {'nomatch',Where,_14}
<[]> when 'true' -> {Keep,[Cs0|_2],#{}#}
<Rest> when 'true' -> {Keep,[Cs0|_2],Rest} end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'len'/1 = fun (_0) -> call 'erlang':'length' (_0)
'concat'/2 = fun (_0,_1) -> call 'erlang':'++' (_0,_1)
'chr'/2 = fun (_0,_1) -> case <_0,_1> of <S,C> when call 'erlang':'is_integer' (C) -> apply 'chr'/3 (S,C,1)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'chr',2}}] )-|['compiler_generated'] ) end
'chr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[C|_X_Cs],_7,I> when call 'erlang':'=:=' (_7,C) -> I
<[_8|Cs],C,I> when 'true' -> let <_3> = call 'erlang':'+' (I,1) in apply 'chr'/3 (Cs,C,_3)
<[],_X_C,_X_I> when 'true' -> 0
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'chr',3}}] )-|['compiler_generated'] ) end
'rchr'/2 = fun (_0,_1) -> case <_0,_1> of <S,C> when call 'erlang':'is_integer' (C) -> apply 'rchr'/4 (S,C,1,0)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'rchr',2}}] )-|['compiler_generated'] ) end
'rchr'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[C|Cs],_10,I,_X_L> when call 'erlang':'=:=' (_10,C) -> let <_4> = call 'erlang':'+' (I,1) in apply 'rchr'/4 (Cs,C,_4,I)
<[_11|Cs],C,I,L> when 'true' -> let <_5> = call 'erlang':'+' (I,1) in apply 'rchr'/4 (Cs,C,_5,L)
<[],_X_C,_X_I,L> when 'true' -> L
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'rchr',4}}] )-|['compiler_generated'] ) end
'str'/2 = fun (_0,_1) -> case <_0,_1> of <S,Sub> when call 'erlang':'is_list' (Sub) -> apply 'str'/3 (S,Sub,1)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'str',2}}] )-|['compiler_generated'] ) end
'str'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[C|S],[_9|Sub],I> when call 'erlang':'=:=' (_9,C) -> case apply 'l_prefix'/2 (Sub,S) of <'true'> when 'true' -> I
<'false'> when 'true' -> let <_3> = call 'erlang':'+' (I,1) in apply 'str'/3 (S,[C|Sub],_3)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[_10|S],Sub,I> when 'true' -> let <_5> = call 'erlang':'+' (I,1) in apply 'str'/3 (S,Sub,_5)
<[],_X_Sub,_X_I> when 'true' -> 0
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'str',3}}] )-|['compiler_generated'] ) end
'rstr'/2 = fun (_0,_1) -> case <_0,_1> of <S,Sub> when call 'erlang':'is_list' (Sub) -> apply 'rstr'/4 (S,Sub,1,0)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'rstr',2}}] )-|['compiler_generated'] ) end
'rstr'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[C|S],[_12|Sub],I,L> when call 'erlang':'=:=' (_12,C) -> case apply 'l_prefix'/2 (Sub,S) of <'true'> when 'true' -> let <_4> = call 'erlang':'+' (I,1) in apply 'rstr'/4 (S,[C|Sub],_4,I)
<'false'> when 'true' -> let <_5> = call 'erlang':'+' (I,1) in apply 'rstr'/4 (S,[C|Sub],_5,L)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<[_13|S],Sub,I,L> when 'true' -> let <_7> = call 'erlang':'+' (I,1) in apply 'rstr'/4 (S,Sub,_7,L)
<[],_X_Sub,_X_I,L> when 'true' -> L
(<_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8})-|[{'function_name',{'rstr',4}}] )-|['compiler_generated'] ) end
'l_prefix'/2 = fun (_0,_1) -> case <_0,_1> of <[C|Pre],[_6|String]> when call 'erlang':'=:=' (_6,C) -> apply 'l_prefix'/2 (Pre,String)
<[],String> when call 'erlang':'is_list' (String) -> 'true'
<Pre,String> when let <_2> = call 'erlang':'is_list' (Pre) in let <_3> = call 'erlang':'is_list' (String) in call 'erlang':'and' (_2,_3) -> 'false'
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'l_prefix',2}}] )-|['compiler_generated'] ) end
'span'/2 = fun (_0,_1) -> case <_0,_1> of <S,Cs> when call 'erlang':'is_list' (Cs) -> apply 'span'/3 (S,Cs,0)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'span',2}}] )-|['compiler_generated'] ) end
'span'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[C|S],Cs,I> when 'true' -> case call 'lists':'member' (C,Cs) of <'true'> when 'true' -> let <_3> = call 'erlang':'+' (I,1) in apply 'span'/3 (S,Cs,_3)
<'false'> when 'true' -> I
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[],_X_Cs,I> when 'true' -> I
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'span',3}}] )-|['compiler_generated'] ) end
'cspan'/2 = fun (_0,_1) -> case <_0,_1> of <S,Cs> when call 'erlang':'is_list' (Cs) -> apply 'cspan'/3 (S,Cs,0)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'cspan',2}}] )-|['compiler_generated'] ) end
'cspan'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[C|S],Cs,I> when 'true' -> case call 'lists':'member' (C,Cs) of <'true'> when 'true' -> I
<'false'> when 'true' -> let <_3> = call 'erlang':'+' (I,1) in apply 'cspan'/3 (S,Cs,_3)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[],_X_Cs,I> when 'true' -> I
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'cspan',3}}] )-|['compiler_generated'] ) end
'substr'/2 = fun (_0,_1) -> case <_0,_1> of <String,1> when call 'erlang':'is_list' (String) -> String
<String,S> when let <_2> = call 'erlang':'is_integer' (S) in let <_3> = call 'erlang':'>' (S,1) in call 'erlang':'and' (_2,_3) -> apply 'substr2'/2 (String,S)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'substr',2}}] )-|['compiler_generated'] ) end
'substr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <String,S,L> when try let <_3> = call 'erlang':'is_integer' (S) in let <_4> = call 'erlang':'>=' (S,1) in let <_5> = call 'erlang':'is_integer' (L) in let <_6> = call 'erlang':'>=' (L,0) in let <_7> = call 'erlang':'and' (_5,_6) in let <_8> = call 'erlang':'and' (_4,_7) in call 'erlang':'and' (_3,_8) of <Try> -> Try catch <T,R> -> 'false' -> let <_9> = apply 'substr2'/2 (String,S) in apply 'substr1'/2 (_9,L)
(<_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10})-|[{'function_name',{'substr',3}}] )-|['compiler_generated'] ) end
'substr1'/2 = fun (_0,_1) -> case <_0,_1> of <[C|String],L> when call 'erlang':'>' (L,0) -> let <_2> = call 'erlang':'-' (L,1) in let <_3> = apply 'substr1'/2 (String,_2) in [C|_3]
<String,_X_L> when call 'erlang':'is_list' (String) -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'substr1',2}}] )-|['compiler_generated'] ) end
'substr2'/2 = fun (_0,_1) -> case <_0,_1> of <String,1> when call 'erlang':'is_list' (String) -> String
<[_5|String],S> when 'true' -> let <_2> = call 'erlang':'-' (S,1) in apply 'substr2'/2 (String,_2)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'substr2',2}}] )-|['compiler_generated'] ) end
'tokens'/2 = fun (_0,_1) -> case _1 of <[]> when 'true' -> case _0 of <[]> when 'true' -> []
<[_8|_9]> when 'true' -> [_0|[]]
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<[C|[]]> when 'true' -> let <_3> = call 'lists':'reverse' (_0) in apply 'tokens_single_1'/3 (_3,C,[])
<[_10|_11]> when 'true' -> let <_4> = call 'lists':'reverse' (_0) in apply 'tokens_multiple_1'/3 (_4,_1,[])
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'tokens_single_1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[Sep|S],_6,Toks> when call 'erlang':'=:=' (_6,Sep) -> apply 'tokens_single_1'/3 (S,Sep,Toks)
<[C|S],Sep,Toks> when 'true' -> apply 'tokens_single_2'/4 (S,Sep,Toks,[C|[]])
<[],_7,Toks> when 'true' -> Toks
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'tokens_single_1',3}}] )-|['compiler_generated'] ) end
'tokens_single_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[Sep|S],_8,Toks,Tok> when call 'erlang':'=:=' (_8,Sep) -> apply 'tokens_single_1'/3 (S,Sep,[Tok|Toks])
<[C|S],Sep,Toks,Tok> when 'true' -> apply 'tokens_single_2'/4 (S,Sep,Toks,[C|Tok])
<[],_X_Sep,Toks,Tok> when 'true' -> [Tok|Toks]
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'tokens_single_2',4}}] )-|['compiler_generated'] ) end
'tokens_multiple_1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[C|S],Seps,Toks> when 'true' -> case call 'lists':'member' (C,Seps) of <'true'> when 'true' -> apply 'tokens_multiple_1'/3 (S,Seps,Toks)
<'false'> when 'true' -> apply 'tokens_multiple_2'/4 (S,Seps,Toks,[C|[]])
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<[],_X_Seps,Toks> when 'true' -> Toks
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'tokens_multiple_1',3}}] )-|['compiler_generated'] ) end
'tokens_multiple_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[C|S],Seps,Toks,Tok> when 'true' -> case call 'lists':'member' (C,Seps) of <'true'> when 'true' -> apply 'tokens_multiple_1'/3 (S,Seps,[Tok|Toks])
<'false'> when 'true' -> apply 'tokens_multiple_2'/4 (S,Seps,Toks,[C|Tok])
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[],_X_Seps,Toks,Tok> when 'true' -> [Tok|Toks]
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'tokens_multiple_2',4}}] )-|['compiler_generated'] ) end
'chars'/2 = fun (_0,_1) -> apply 'chars'/3 (_0,_1,[])
'chars'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <C,N,Tail> when call 'erlang':'>' (N,0) -> let <_3> = call 'erlang':'-' (N,1) in apply 'chars'/3 (C,_3,[C|Tail])
<C,0,Tail> when call 'erlang':'is_integer' (C) -> Tail
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'chars',3}}] )-|['compiler_generated'] ) end
'copies'/2 = fun (_0,_1) -> case <_0,_1> of <CharList,Num> when try let <_2> = call 'erlang':'is_list' (CharList) in let <_3> = call 'erlang':'is_integer' (Num) in let <_4> = call 'erlang':'>=' (Num,0) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> apply 'copies'/3 (CharList,Num,[])
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'copies',2}}] )-|['compiler_generated'] ) end
'copies'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_CharList,0,R> when 'true' -> R
<CharList,Num,R> when 'true' -> let <_4> = call 'erlang':'-' (Num,1) in let <_3> = call 'erlang':'++' (CharList,R) in apply 'copies'/3 (CharList,_4,_3) end
'words'/1 = fun (_0) -> apply 'words'/2 (_0,32)
'words'/2 = fun (_0,_1) -> case <_0,_1> of <String,Char> when call 'erlang':'is_integer' (Char) -> let <_2> = apply 'strip'/3 (String,'both',Char) in apply 'w_count'/3 (_2,Char,0)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'words',2}}] )-|['compiler_generated'] ) end
'w_count'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],_8,Num> when 'true' -> call 'erlang':'+' (Num,1)
<[H|T],_9,Num> when call 'erlang':'=:=' (_9,H) -> let <_4> = apply 'strip'/3 (T,'left',H) in let <_3> = call 'erlang':'+' (Num,1) in apply 'w_count'/3 (_4,H,_3)
<[_X_H|T],Char,Num> when 'true' -> apply 'w_count'/3 (T,Char,Num)
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'w_count',3}}] )-|['compiler_generated'] ) end
'sub_word'/2 = fun (_0,_1) -> apply 'sub_word'/3 (_0,_1,32)
'sub_word'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <String,Index,Char> when let <_3> = call 'erlang':'is_integer' (Index) in let <_4> = call 'erlang':'is_integer' (Char) in call 'erlang':'and' (_3,_4) -> case apply 'words'/2 (String,Char) of <Num> when call 'erlang':'<' (Num,Index) -> []
<_X_Num> when 'true' -> let <_5> = apply 'strip'/3 (String,'left',Char) in apply 's_word'/5 (_5,Index,Char,1,[]) end
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'sub_word',3}}] )-|['compiler_generated'] ) end
's_word'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[],_12,_13,_14,Res> when 'true' -> call 'lists':'reverse' (Res)
<[Char|_15],Index,_16,_17,Res> when let <_18> = call 'erlang':'=:=' (_16,Char) in let <_19> = call 'erlang':'=:=' (_17,Index) in call 'erlang':'and' (_18,_19) -> call 'lists':'reverse' (Res)
<[H|T],Index,Char,_20,Res> when call 'erlang':'=:=' (_20,Index) -> apply 's_word'/5 (T,Index,Char,Index,[H|Res])
<[Char|T],Stop,_21,Index,Res> when let <_22> = call 'erlang':'=:=' (_21,Char) in let <_23> = call 'erlang':'<' (Index,Stop) in call 'erlang':'and' (_22,_23) -> let <_6> = apply 'strip'/3 (T,'left',Char) in let <_5> = call 'erlang':'+' (Index,1) in apply 's_word'/5 (_6,Stop,Char,_5,Res)
<[_24|T],Stop,Char,Index,Res> when call 'erlang':'<' (Index,Stop) -> apply 's_word'/5 (T,Stop,Char,Index,Res)
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'s_word',5}}] )-|['compiler_generated'] ) end
'strip'/1 = fun (_0) -> apply 'strip'/2 (_0,'both')
'strip'/2 = fun (_0,_1) -> case <_0,_1> of <String,'left'> when 'true' -> apply 'strip_left'/2 (String,32)
<String,'right'> when 'true' -> apply 'strip_right'/2 (String,32)
<String,'both'> when 'true' -> let <_2> = apply 'strip_left'/2 (String,32) in apply 'strip_right'/2 (_2,32)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'strip',2}}] )-|['compiler_generated'] ) end
'strip'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <String,'right',Char> when 'true' -> apply 'strip_right'/2 (String,Char)
<String,'left',Char> when 'true' -> apply 'strip_left'/2 (String,Char)
<String,'both',Char> when 'true' -> let <_3> = apply 'strip_left'/2 (String,Char) in apply 'strip_right'/2 (_3,Char)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'strip',3}}] )-|['compiler_generated'] ) end
'strip_left'/2 = fun (_0,_1) -> case <_0,_1> of <[Sc|S],_4> when call 'erlang':'=:=' (_4,Sc) -> apply 'strip_left'/2 (S,Sc)
<S = [_5|_6],Sc> when call 'erlang':'is_integer' (Sc) -> S
<[],Sc> when call 'erlang':'is_integer' (Sc) -> []
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'strip_left',2}}] )-|['compiler_generated'] ) end
'strip_right'/2 = fun (_0,_1) -> case <_0,_1> of <[Sc|S],_6> when call 'erlang':'=:=' (_6,Sc) -> case apply 'strip_right'/2 (S,Sc) of <[]> when 'true' -> []
<T> when 'true' -> [Sc|T] end
<[C|S],Sc> when 'true' -> let <_3> = apply 'strip_right'/2 (S,Sc) in [C|_3]
<[],Sc> when call 'erlang':'is_integer' (Sc) -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'strip_right',2}}] )-|['compiler_generated'] ) end
'left'/2 = fun (_0,_1) -> case <_0,_1> of <String,Len> when call 'erlang':'is_integer' (Len) -> apply 'left'/3 (String,Len,32)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'left',2}}] )-|['compiler_generated'] ) end
'left'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <String,Len,Char> when call 'erlang':'is_integer' (Char) -> let <Slen> = call 'erlang':'length' (String) in case <> of <> when call 'erlang':'>' (Slen,Len) -> apply 'substr'/3 (String,1,Len)
<> when call 'erlang':'<' (Slen,Len) -> let <_4> = call 'erlang':'-' (Len,Slen) in apply 'l_pad'/3 (String,_4,Char)
<> when call 'erlang':'=:=' (Slen,Len) -> String
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'left',3}}] )-|['compiler_generated'] ) end
'l_pad'/3 = fun (_0,_1,_2) -> let <_3> = apply 'chars'/2 (_2,_1) in call 'erlang':'++' (_0,_3)
'right'/2 = fun (_0,_1) -> case <_0,_1> of <String,Len> when call 'erlang':'is_integer' (Len) -> apply 'right'/3 (String,Len,32)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'right',2}}] )-|['compiler_generated'] ) end
'right'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <String,Len,Char> when call 'erlang':'is_integer' (Char) -> let <Slen> = call 'erlang':'length' (String) in case <> of <> when call 'erlang':'>' (Slen,Len) -> let <_4> = call 'erlang':'-' (Slen,Len) in let <_5> = call 'erlang':'+' (_4,1) in apply 'substr'/2 (String,_5)
<> when call 'erlang':'<' (Slen,Len) -> let <_6> = call 'erlang':'-' (Len,Slen) in apply 'r_pad'/3 (String,_6,Char)
<> when call 'erlang':'=:=' (Slen,Len) -> String
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'right',3}}] )-|['compiler_generated'] ) end
'r_pad'/3 = fun (_0,_1,_2) -> apply 'chars'/3 (_2,_1,_0)
'centre'/2 = fun (_0,_1) -> case <_0,_1> of <String,Len> when call 'erlang':'is_integer' (Len) -> apply 'centre'/3 (String,Len,32)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'centre',2}}] )-|['compiler_generated'] ) end
'centre'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <String,0,Char> when let <_3> = call 'erlang':'is_list' (String) in let <_4> = call 'erlang':'is_integer' (Char) in call 'erlang':'and' (_3,_4) -> []
<String,Len,Char> when call 'erlang':'is_integer' (Char) -> let <Slen> = call 'erlang':'length' (String) in case <> of <> when call 'erlang':'>' (Slen,Len) -> let <_6> = call 'erlang':'-' (Slen,Len) in let <_7> = call 'erlang':'div' (_6,2) in let <_8> = call 'erlang':'+' (_7,1) in apply 'substr'/3 (String,_8,Len)
<> when call 'erlang':'<' (Slen,Len) -> let <_9> = call 'erlang':'-' (Len,Slen) in let <N> = call 'erlang':'div' (_9,2) in let <_11> = call 'erlang':'+' (Slen,N) in let <_12> = call 'erlang':'-' (Len,_11) in let <_13> = apply 'l_pad'/3 (String,_12,Char) in apply 'r_pad'/3 (_13,N,Char)
<> when call 'erlang':'=:=' (Slen,Len) -> String
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
(<_16,_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14})-|[{'function_name',{'centre',3}}] )-|['compiler_generated'] ) end
'sub_string'/2 = fun (_0,_1) -> apply 'substr'/2 (_0,_1)
'sub_string'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'-' (_2,_1) in let <_4> = call 'erlang':'+' (_3,1) in apply 'substr'/3 (_0,_1,_4)
'to_lower_char'/1 = fun (_0) -> case _0 of <C> when try let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'=<' (65,_0) in let <_3> = call 'erlang':'=<' (_0,90) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (C,32)
<C> when try let <_5> = call 'erlang':'is_integer' (_0) in let <_6> = call 'erlang':'=<' (192,_0) in let <_7> = call 'erlang':'=<' (_0,214) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (C,32)
<C> when try let <_9> = call 'erlang':'is_integer' (_0) in let <_10> = call 'erlang':'=<' (216,_0) in let <_11> = call 'erlang':'=<' (_0,222) in let <_12> = call 'erlang':'and' (_10,_11) in call 'erlang':'and' (_9,_12) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (C,32)
<C> when 'true' -> C end
'to_upper_char'/1 = fun (_0) -> case _0 of <C> when try let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'=<' (97,_0) in let <_3> = call 'erlang':'=<' (_0,122) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C,32)
<C> when try let <_5> = call 'erlang':'is_integer' (_0) in let <_6> = call 'erlang':'=<' (224,_0) in let <_7> = call 'erlang':'=<' (_0,246) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C,32)
<C> when try let <_9> = call 'erlang':'is_integer' (_0) in let <_10> = call 'erlang':'=<' (248,_0) in let <_11> = call 'erlang':'=<' (_0,254) in let <_12> = call 'erlang':'and' (_10,_11) in call 'erlang':'and' (_9,_12) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C,32)
<C> when 'true' -> C end
'to_lower'/1 = fun (_0) -> case _0 of <S> when call 'erlang':'is_list' (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[C|_2]> when 'true' -> let <_4> = apply 'to_lower_char'/1 (C) in let <_5> = apply 'lc$^0'/1 (_2) in ([_4|_5]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (S)-|['list_comprehension'] )
<C> when call 'erlang':'is_integer' (_0) -> apply 'to_lower_char'/1 (C)
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'to_lower',1}}] )-|['compiler_generated'] ) end
'to_upper'/1 = fun (_0) -> case _0 of <S> when call 'erlang':'is_list' (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[C|_2]> when 'true' -> let <_4> = apply 'to_upper_char'/1 (C) in let <_5> = apply 'lc$^0'/1 (_2) in ([_4|_5]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (S)-|['list_comprehension'] )
<C> when call 'erlang':'is_integer' (_0) -> apply 'to_upper_char'/1 (C)
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'to_upper',1}}] )-|['compiler_generated'] ) end
'join'/2 = fun (_0,_1) -> case <_0,_1> of <[],Sep> when call 'erlang':'is_list' (Sep) -> []
<[H|T],Sep> when 'true' -> let <_7> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[X|_3]> when 'true' -> let <_5> = call 'erlang':'++' (Sep,X) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (T) in let <_8> = call 'lists':'append' (_7) in call 'erlang':'++' (H,_8)
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'join',2}}] )-|['compiler_generated'] ) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('string')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('string',_0) end