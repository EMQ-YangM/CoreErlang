module 'erl_expand_records' ['module'/2,'module_info'/0,'module_info'/1] attributes [ 'file' = [{[115|[114|[99|[47|[101|[114|[108|[95|[101|[120|[112|[97|[110|[100|[95|[114|[101|[99|[111|[114|[100|[115|[46|[101|[114|[108]]]]]]]]]]]]]]]]]]]]]]]]]],1}]
, 'record' = [{'exprec',[{'record_field',33,{'atom',33,'compile'},{'nil',33}}|[{'record_field',34,{'atom',34,'vcount'},{'integer',34,0}}|[{'record_field',35,{'atom',35,'calltype'},{'map',35,[]}}|[{'record_field',36,{'atom',36,'records'},{'map',36,[]}}|[{'record_field',37,{'atom',37,'strict_ra'},{'nil',37}}|[{'record_field',38,{'atom',38,'checked_ra'},{'nil',38}}]]]]]]}]
, 'spec' = [{{'module',2},[{'type',41,'bounded_fun',[{'type',41,'fun',[{'type',41,'product',[{'var',41,'AbsForms'}|[{'var',41,'CompileOptions'}]]}|[{'var',41,'AbsForms2'}]]}|[[{'type',42,'constraint',[{'atom',42,'is_subtype'}|[[{'var',42,'AbsForms'}|[{'type',42,'list',[{'remote_type',42,[{'atom',42,'erl_parse'}|[{'atom',42,'abstract_form'}|[[]]]]}]}]]]]}|[{'type',43,'constraint',[{'atom',43,'is_subtype'}|[[{'var',43,'AbsForms2'}|[{'type',43,'list',[{'remote_type',43,[{'atom',43,'erl_parse'}|[{'atom',43,'abstract_form'}|[[]]]]}]}]]]]}|[{'type',44,'constraint',[{'atom',44,'is_subtype'}|[[{'var',44,'CompileOptions'}|[{'type',44,'list',[{'remote_type',44,[{'atom',44,'compile'}|[{'atom',44,'option'}|[[]]]]}]}]]]]}]]]]]}]}] ] 'module'/2 = fun (_0,_1) -> let <_2> = apply 'compiler_options'/1 (_0) in let <Opts> = call 'erlang':'++' (_2,_1) in let <Calltype> = apply 'init_calltype'/1 (_0) in let <St0> = {'exprec',Opts,0,Calltype,~{}~,[],[]} in case apply 'forms'/2 (_0,St0) of <{Fs,_X_St}> when 'true' -> Fs
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'compiler_options'/1 = fun (_0) -> let <_5> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{'attribute',_7,'compile',C}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([C|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in call 'lists':'flatten' (_5)
'init_calltype'/1 = fun (_0) -> let <_5> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{'function',_9,Name,Arity,_10}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([{{Name,Arity},'local'}|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <Ctype> = call 'maps':'from_list' (_5) in apply 'init_calltype_imports'/2 (_0,Ctype)
'init_calltype_imports'/2 = fun (_0,_1) -> case <_0,_1> of <[{'attribute',_11,'import',{Mod,Fs}}|T],Ctype0> when 'true' -> case call 'erlang':'is_atom' (Mod) of <'true'> when 'true' -> let <_7> = fun (_4,_3) -> case <> of (<> when call 'erlang':'is_map' (_3) -> ~{_4=>{'imported',Mod}|_3}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',_3})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end in let <Ctype> = call 'lists':'foldl' (_7,Ctype0,Fs) in apply 'init_calltype_imports'/2 (T,Ctype)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[_12|T],Ctype> when 'true' -> apply 'init_calltype_imports'/2 (T,Ctype)
<[],Ctype> when 'true' -> Ctype
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'init_calltype_imports',2}}] )-|['compiler_generated'] ) end
'forms'/2 = fun (_0,_1) -> case <_0,_1> of <[Attr = {'attribute',_16,'record',{Name,Defs}}|Fs],St0> when 'true' -> let <NDefs> = apply 'normalise_fields'/1 (Defs) in (case St0 of (<({'exprec',_17,_18,_19,_rec2,_20,_21}-|['compiler_generated'] )> when 'true' -> let <_rec0> = call 'maps':'put' (Name,NDefs,_rec2) in case St0 of <{'exprec',_23,_24,_25,_26,_27,_28}> when 'true' -> let <_8> = call 'erlang':'setelement' (5,St0,_rec0) in case apply 'forms'/2 (Fs,_8) of <{Fs1,St1}> when 'true' -> {[Attr|Fs1],St1}
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[{'function',L,N,A,Cs0}|Fs0],St0> when 'true' -> case apply 'clauses'/2 (Cs0,St0) of <{Cs,St1}> when 'true' -> case apply 'forms'/2 (Fs0,St1) of <{Fs,St2}> when 'true' -> {[{'function',L,N,A,Cs}|Fs],St2}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
<[F|Fs0],St0> when 'true' -> case apply 'forms'/2 (Fs0,St0) of <{Fs,St}> when 'true' -> {[F|Fs],St}
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<[],St> when 'true' -> {[],St}
(<_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14})-|[{'function_name',{'forms',2}}] )-|['compiler_generated'] ) end
'clauses'/2 = fun (_0,_1) -> case <_0,_1> of <[{'clause',Line,H0,G0,B0}|Cs0],St0> when 'true' -> case apply 'head'/2 (H0,St0) of <{H1,St1}> when 'true' -> case apply 'guard'/2 (G0,St1) of <{G1,St2}> when 'true' -> case apply 'optimize_is_record'/3 (H1,G1,St2) of <{H,G}> when 'true' -> case apply 'exprs'/2 (B0,St2) of <{B,St3}> when 'true' -> case apply 'clauses'/2 (Cs0,St3) of <{Cs,St4}> when 'true' -> {[{'clause',Line,H,G,B}|Cs],St4}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[],St> when 'true' -> {[],St}
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'clauses',2}}] )-|['compiler_generated'] ) end
'head'/2 = fun (_0,_1) -> apply 'pattern_list'/2 (_0,_1)
'pattern'/2 = fun (_0,_1) -> case <_0,_1> of <Var = {'var',_22,'_'},St> when 'true' -> {Var,St}
<Var = {'var',_23,_24},St> when 'true' -> {Var,St}
<Char = {'char',_25,_26},St> when 'true' -> {Char,St}
<Int = {'integer',_27,_28},St> when 'true' -> {Int,St}
<Float = {'float',_29,_30},St> when 'true' -> {Float,St}
<Atom = {'atom',_31,_32},St> when 'true' -> {Atom,St}
<String = {'string',_33,_34},St> when 'true' -> {String,St}
<Nil = {'nil',_35},St> when 'true' -> {Nil,St}
<{'cons',Line,H,T},St0> when 'true' -> case apply 'pattern'/2 (H,St0) of <{TH,St1}> when 'true' -> case apply 'pattern'/2 (T,St1) of <{TT,St2}> when 'true' -> {{'cons',Line,TH,TT},St2}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{'tuple',Line,Ps},St0> when 'true' -> case apply 'pattern_list'/2 (Ps,St0) of <{TPs,St1}> when 'true' -> {{'tuple',Line,TPs},St1}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<{'map',Line,Ps},St0> when 'true' -> case apply 'pattern_list'/2 (Ps,St0) of <{TPs,St1}> when 'true' -> {{'map',Line,TPs},St1}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{'map_field_exact',Line,K0,V0},St0> when 'true' -> case apply 'expr'/2 (K0,St0) of <{K,St1}> when 'true' -> case apply 'pattern'/2 (V0,St1) of <{V,St2}> when 'true' -> {{'map_field_exact',Line,K,V},St2}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<{'record_index',Line,Name,Field},St> when 'true' -> let <_8> = apply 'record_fields'/2 (Name,St) in let <_9> = apply 'index_expr'/4 (Line,Field,Name,_8) in {_9,St}
<{'record',Line0,Name,Pfs},St0> when 'true' -> let <Fs> = apply 'record_fields'/2 (Name,St0) in let <_11> = apply 'pattern_fields'/2 (Fs,Pfs) in case apply 'pattern_list'/2 (_11,St0) of <{TMs,St1}> when 'true' -> let <Line> = apply 'mark_record'/2 (Line0,St1) in {{'tuple',Line,[{'atom',Line0,Name}|TMs]},St1}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<{'bin',Line,Es0},St0> when 'true' -> case apply 'pattern_bin'/2 (Es0,St0) of <{Es1,St1}> when 'true' -> {{'bin',Line,Es1},St1}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<{'match',Line,Pat1,Pat2},St0> when 'true' -> case apply 'pattern'/2 (Pat2,St0) of <{TH,St1}> when 'true' -> case apply 'pattern'/2 (Pat1,St1) of <{TT,St2}> when 'true' -> {{'match',Line,TT,TH},St2}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<{'op',Line,Op,A0},St0> when 'true' -> case apply 'pattern'/2 (A0,St0) of <{A,St1}> when 'true' -> {{'op',Line,Op,A},St1}
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<{'op',Line,Op,L0,R0},St0> when 'true' -> case apply 'pattern'/2 (L0,St0) of <{L,St1}> when 'true' -> case apply 'pattern'/2 (R0,St1) of <{R,St2}> when 'true' -> {{'op',Line,Op,L,R},St2}
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
(<_21,_20> when 'true' -> (primop 'match_fail' ({'function_clause',_21,_20})-|[{'function_name',{'pattern',2}}] )-|['compiler_generated'] ) end
'pattern_list'/2 = fun (_0,_1) -> case <_0,_1> of <[P0|Ps0],St0> when 'true' -> case apply 'pattern'/2 (P0,St0) of <{P,St1}> when 'true' -> case apply 'pattern_list'/2 (Ps0,St1) of <{Ps,St2}> when 'true' -> {[P|Ps],St2}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[],St> when 'true' -> {[],St}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'pattern_list',2}}] )-|['compiler_generated'] ) end
'guard'/2 = fun (_0,_1) -> case <_0,_1> of <[G0|Gs0],St0> when 'true' -> case apply 'guard_tests'/2 (G0,St0) of <{G,St1}> when 'true' -> case apply 'guard'/2 (Gs0,St1) of <{Gs,St2}> when 'true' -> {[G|Gs],St2}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[],St> when 'true' -> {[],St}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'guard',2}}] )-|['compiler_generated'] ) end
'guard_tests'/2 = fun (_0,_1) -> case apply 'guard_tests1'/2 (_0,_1) of <{Gts1,St1}> when 'true' -> case St1 of <{'exprec',_8,_9,_10,_11,_12,_13}> when 'true' -> let <_5> = call 'erlang':'setelement' (7,St1,[]) in {Gts1,_5}
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'guard_tests1'/2 = fun (_0,_1) -> case <_0,_1> of <[Gt0|Gts0],St0> when 'true' -> case apply 'guard_test'/2 (Gt0,St0) of <{Gt1,St1}> when 'true' -> case apply 'guard_tests1'/2 (Gts0,St1) of <{Gts1,St2}> when 'true' -> {[Gt1|Gts1],St2}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[],St> when 'true' -> {[],St}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'guard_tests1',2}}] )-|['compiler_generated'] ) end
'guard_test'/2 = fun (_0,_1) -> let <_3> = fun () -> case apply 'guard_test1'/2 (_0,_1) of <{G1,St1}> when 'true' -> apply 'strict_record_access'/2 (G1,St1)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end in apply 'in_guard'/1 (_3)
'guard_test1'/2 = fun (_0,_1) -> case <_0,_1> of <{'call',Line,{'atom',Lt,Tname},As},St> when 'true' -> let <_2> = call 'erlang':'length' (As) in let <_3> = apply 'normalise_test'/2 (Tname,_2) in let <Test> = {'atom',Lt,_3} in apply 'expr'/2 ({'call',Line,Test,As},St)
<Test,St> when 'true' -> apply 'expr'/2 (Test,St) end
'normalise_test'/2 = fun (_0,_1) -> case <_0,_1> of <'atom',1> when 'true' -> 'is_atom'
<'binary',1> when 'true' -> 'is_binary'
<'float',1> when 'true' -> 'is_float'
<'function',1> when 'true' -> 'is_function'
<'integer',1> when 'true' -> 'is_integer'
<'list',1> when 'true' -> 'is_list'
<'number',1> when 'true' -> 'is_number'
<'pid',1> when 'true' -> 'is_pid'
<'port',1> when 'true' -> 'is_port'
<'record',2> when 'true' -> 'is_record'
<'reference',1> when 'true' -> 'is_reference'
<'tuple',1> when 'true' -> 'is_tuple'
<Name,_4> when 'true' -> Name end
'is_in_guard'/0 = fun () -> let <_0> = call 'erlang':'get' ('erl_expand_records_in_guard') in call 'erlang':'=/=' (_0,'undefined')
'in_guard'/1 = fun (_0) -> case call 'erlang':'put' ('erl_expand_records_in_guard','true') of <'undefined'> when 'true' -> let <Res> = apply _0 () in case call 'erlang':'erase' ('erl_expand_records_in_guard') of <'true'> when 'true' -> Res
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'record_test'/4 = fun (_0,_1,_2,_3) -> case apply 'is_in_guard'/0 () of <'false'> when 'true' -> apply 'record_test_in_body'/4 (_0,_1,_2,_3)
<'true'> when 'true' -> apply 'record_test_in_guard'/4 (_0,_1,_2,_3)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'record_test_in_guard'/4 = fun (_0,_1,_2,_3) -> case apply 'not_a_tuple'/1 (_1) of <'true'> when 'true' -> apply 'expr'/2 ({'atom',_0,'false'},_3)
<'false'> when 'true' -> let <Fs> = apply 'record_fields'/2 (_2,_3) in let <NLine> = apply 'no_compiler_warning'/1 (_0) in let <_6> = call 'erlang':'length' (Fs) in let <_7> = call 'erlang':'+' (_6,1) in apply 'expr'/2 ({'call',NLine,{'remote',NLine,{'atom',NLine,'erlang'},{'atom',NLine,'is_record'}},[_1|[{'atom',_0,_2}|[{'integer',_0,_7}|[]]]]},_3)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
'not_a_tuple'/1 = fun (_0) -> case _0 of <{'atom',_2,_3}> when 'true' -> 'true'
<{'integer',_4,_5}> when 'true' -> 'true'
<{'float',_6,_7}> when 'true' -> 'true'
<{'nil',_8}> when 'true' -> 'true'
<{'cons',_9,_10,_11}> when 'true' -> 'true'
<{'char',_12,_13}> when 'true' -> 'true'
<{'string',_14,_15}> when 'true' -> 'true'
<{'record_index',_16,_17,_18}> when 'true' -> 'true'
<{'bin',_19,_20}> when 'true' -> 'true'
<{'op',_21,_22,_23}> when 'true' -> 'true'
<{'op',_24,_25,_26,_27}> when 'true' -> 'true'
<_28> when 'true' -> 'false' end
'record_test_in_body'/4 = fun (_0,_1,_2,_3) -> let <Fs> = apply 'record_fields'/2 (_2,_3) in case apply 'new_var'/2 (_0,_3) of <{Var,St}> when 'true' -> let <NLine> = apply 'no_compiler_warning'/1 (_0) in let <_7> = call 'erlang':'length' (Fs) in let <_8> = call 'erlang':'+' (_7,1) in apply 'expr'/2 ({'block',_0,[{'match',_0,Var,_1}|[{'call',NLine,{'remote',NLine,{'atom',NLine,'erlang'},{'atom',NLine,'is_record'}},[Var|[{'atom',_0,_2}|[{'integer',_0,_8}|[]]]]}|[]]]},St)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'exprs'/2 = fun (_0,_1) -> case <_0,_1> of <[E0|Es0],St0> when 'true' -> case apply 'expr'/2 (E0,St0) of <{E,St1}> when 'true' -> case apply 'exprs'/2 (Es0,St1) of <{Es,St2}> when 'true' -> {[E|Es],St2}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[],St> when 'true' -> {[],St}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'exprs',2}}] )-|['compiler_generated'] ) end
'expr'/2 = fun (_0,_1) -> case <_0,_1> of <Var = {'var',_77,_78},St> when 'true' -> {Var,St}
<Char = {'char',_79,_80},St> when 'true' -> {Char,St}
<Int = {'integer',_81,_82},St> when 'true' -> {Int,St}
<Float = {'float',_83,_84},St> when 'true' -> {Float,St}
<Atom = {'atom',_85,_86},St> when 'true' -> {Atom,St}
<String = {'string',_87,_88},St> when 'true' -> {String,St}
<Nil = {'nil',_89},St> when 'true' -> {Nil,St}
<{'cons',Line,H0,T0},St0> when 'true' -> case apply 'expr'/2 (H0,St0) of <{H,St1}> when 'true' -> case apply 'expr'/2 (T0,St1) of <{T,St2}> when 'true' -> {{'cons',Line,H,T},St2}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{'lc',Line,E0,Qs0},St0> when 'true' -> case apply 'lc_tq'/3 (Line,Qs0,St0) of <{Qs1,St1}> when 'true' -> case apply 'expr'/2 (E0,St1) of <{E1,St2}> when 'true' -> {{'lc',Line,E1,Qs1},St2}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<{'bc',Line,E0,Qs0},St0> when 'true' -> case apply 'lc_tq'/3 (Line,Qs0,St0) of <{Qs1,St1}> when 'true' -> case apply 'expr'/2 (E0,St1) of <{E1,St2}> when 'true' -> {{'bc',Line,E1,Qs1},St2}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<{'tuple',Line,Es0},St0> when 'true' -> case apply 'expr_list'/2 (Es0,St0) of <{Es1,St1}> when 'true' -> {{'tuple',Line,Es1},St1}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<{'map',Line,Es0},St0> when 'true' -> case apply 'expr_list'/2 (Es0,St0) of <{Es1,St1}> when 'true' -> {{'map',Line,Es1},St1}
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<{'map',Line,Arg0,Es0},St0> when 'true' -> case apply 'expr'/2 (Arg0,St0) of <{Arg1,St1}> when 'true' -> case apply 'expr_list'/2 (Es0,St1) of <{Es1,St2}> when 'true' -> {{'map',Line,Arg1,Es1},St2}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<{'map_field_assoc',Line,K0,V0},St0> when 'true' -> case apply 'expr'/2 (K0,St0) of <{K,St1}> when 'true' -> case apply 'expr'/2 (V0,St1) of <{V,St2}> when 'true' -> {{'map_field_assoc',Line,K,V},St2}
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<{'map_field_exact',Line,K0,V0},St0> when 'true' -> case apply 'expr'/2 (K0,St0) of <{K,St1}> when 'true' -> case apply 'expr'/2 (V0,St1) of <{V,St2}> when 'true' -> {{'map_field_exact',Line,K,V},St2}
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<{'record_index',Line,Name,F},St> when 'true' -> let <_16> = apply 'record_fields'/2 (Name,St) in let <I> = apply 'index_expr'/4 (Line,F,Name,_16) in apply 'expr'/2 (I,St)
<{'record',Line0,Name,Is},St> when 'true' -> let <Line> = apply 'mark_record'/2 (Line0,St) in let <_19> = apply 'record_fields'/2 (Name,St) in let <_20> = apply 'record_inits'/2 (_19,Is) in apply 'expr'/2 ({'tuple',Line,[{'atom',Line0,Name}|_20]},St)
<{'record_field',Line,R,Name,F},St> when 'true' -> apply 'get_record_field'/5 (Line,R,F,Name,St)
<{'record',_90,R,Name,Us},St0> when 'true' -> let <_21> = apply 'record_fields'/2 (Name,St0) in case apply 'record_update'/5 (R,Name,_21,Us,St0) of <{Ue,St1}> when 'true' -> apply 'expr'/2 (Ue,St1)
(<_22> when 'true' -> primop 'match_fail' ({'badmatch',_22})-|['compiler_generated'] ) end
<{'bin',Line,Es0},St0> when 'true' -> case apply 'expr_bin'/2 (Es0,St0) of <{Es1,St1}> when 'true' -> {{'bin',Line,Es1},St1}
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end
<{'block',Line,Es0},St0> when 'true' -> case apply 'exprs'/2 (Es0,St0) of <{Es,St1}> when 'true' -> {{'block',Line,Es},St1}
(<_24> when 'true' -> primop 'match_fail' ({'badmatch',_24})-|['compiler_generated'] ) end
<{'if',Line,Cs0},St0> when 'true' -> case apply 'clauses'/2 (Cs0,St0) of <{Cs,St1}> when 'true' -> {{'if',Line,Cs},St1}
(<_25> when 'true' -> primop 'match_fail' ({'badmatch',_25})-|['compiler_generated'] ) end
<{'case',Line,E0,Cs0},St0> when 'true' -> case apply 'expr'/2 (E0,St0) of <{E,St1}> when 'true' -> case apply 'clauses'/2 (Cs0,St1) of <{Cs,St2}> when 'true' -> {{'case',Line,E,Cs},St2}
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end
(<_26> when 'true' -> primop 'match_fail' ({'badmatch',_26})-|['compiler_generated'] ) end
<{'receive',Line,Cs0},St0> when 'true' -> case apply 'clauses'/2 (Cs0,St0) of <{Cs,St1}> when 'true' -> {{'receive',Line,Cs},St1}
(<_28> when 'true' -> primop 'match_fail' ({'badmatch',_28})-|['compiler_generated'] ) end
<{'receive',Line,Cs0,To0,ToEs0},St0> when 'true' -> case apply 'expr'/2 (To0,St0) of <{To,St1}> when 'true' -> case apply 'exprs'/2 (ToEs0,St1) of <{ToEs,St2}> when 'true' -> case apply 'clauses'/2 (Cs0,St2) of <{Cs,St3}> when 'true' -> {{'receive',Line,Cs,To,ToEs},St3}
(<_31> when 'true' -> primop 'match_fail' ({'badmatch',_31})-|['compiler_generated'] ) end
(<_30> when 'true' -> primop 'match_fail' ({'badmatch',_30})-|['compiler_generated'] ) end
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end
<Fun0 = {'fun',Lf,{'function',F,A}},St0> when 'true' -> case call 'erl_internal':'bif' (F,A) of <'true'> when 'true' -> case apply 'new_vars'/3 (A,Lf,St0) of <{As,St1}> when 'true' -> let <Cs> = [{'clause',Lf,As,[],[{'call',Lf,{'atom',Lf,F},As}|[]]}|[]] in let <Fun> = {'fun',Lf,{'clauses',Cs}} in apply 'expr'/2 (Fun,St1)
(<_32> when 'true' -> primop 'match_fail' ({'badmatch',_32})-|['compiler_generated'] ) end
<'false'> when 'true' -> {Fun0,St0}
(<_35> when 'true' -> primop 'match_fail' ({'case_clause',_35})-|['compiler_generated'] ) end
<Fun = {'fun',_91,{'function',_X_M,_X_F,_X_A}},St> when 'true' -> {Fun,St}
<{'fun',Line,{'clauses',Cs0}},St0> when 'true' -> case apply 'clauses'/2 (Cs0,St0) of <{Cs,St1}> when 'true' -> {{'fun',Line,{'clauses',Cs}},St1}
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end
<{'named_fun',Line,Name,Cs0},St0> when 'true' -> case apply 'clauses'/2 (Cs0,St0) of <{Cs,St1}> when 'true' -> {{'named_fun',Line,Name,Cs},St1}
(<_37> when 'true' -> primop 'match_fail' ({'badmatch',_37})-|['compiler_generated'] ) end
<{'call',Line,{'atom',_92,'is_record'},[A|[{'atom',_93,Name}|[]]]},St> when 'true' -> apply 'record_test'/4 (Line,A,Name,St)
<{'call',Line,{'remote',_94,{'atom',_95,'erlang'},{'atom',_96,'is_record'}},[A|[{'atom',_97,Name}|[]]]},St> when 'true' -> apply 'record_test'/4 (Line,A,Name,St)
<{'call',Line,{'tuple',_98,[{'atom',_99,'erlang'}|[{'atom',_100,'is_record'}|[]]]},[A|[{'atom',_101,Name}|[]]]},St> when 'true' -> apply 'record_test'/4 (Line,A,Name,St)
<{'call',Line,{'atom',_X_La,'record_info'},As0 = [_102|[_103|[]]]},St0> when 'true' -> case apply 'expr_list'/2 (As0,St0) of <{As,St1}> when 'true' -> apply 'record_info_call'/3 (Line,As,St1)
(<_38> when 'true' -> primop 'match_fail' ({'badmatch',_38})-|['compiler_generated'] ) end
<{'call',Line,Atom = {'atom',_X_La,N},As0},St0> when 'true' -> case apply 'expr_list'/2 (As0,St0) of <{As,St1}> when 'true' -> let <Ar> = call 'erlang':'length' (As) in let <NA> = {N,Ar} in (case St0 of (<({'exprec',_104,_105,_rec4,_106,_107,_108}-|['compiler_generated'] )> when 'true' -> case _rec4 of <~{NA:='local'}~> when 'true' -> {{'call',Line,Atom,As},St1}
<~{NA:={'imported',Module}}~> when 'true' -> let <ModAtom> = {'atom',Line,Module} in {{'call',Line,{'remote',Line,ModAtom,Atom},As},St1}
<_110> when 'true' -> case call 'erl_internal':'bif' (N,Ar) of <'true'> when 'true' -> let <ModAtom> = {'atom',Line,'erlang'} in {{'call',Line,{'remote',Line,ModAtom,Atom},As},St1}
<'false'> when 'true' -> {{'call',Line,Atom,As},St1}
(<_46> when 'true' -> primop 'match_fail' ({'case_clause',_46})-|['compiler_generated'] ) end end-|['compiler_generated'] )
(<_109> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_39> when 'true' -> primop 'match_fail' ({'badmatch',_39})-|['compiler_generated'] ) end
<{'call',Line,{'remote',Lr,M,F},As0},St0> when 'true' -> case apply 'expr_list'/2 ([M|[F|As0]],St0) of <{[M1|[F1|As1]],St1}> when 'true' -> {{'call',Line,{'remote',Lr,M1,F1},As1},St1}
(<_48> when 'true' -> primop 'match_fail' ({'badmatch',_48})-|['compiler_generated'] ) end
<{'call',Line,F,As0},St0> when 'true' -> case apply 'expr_list'/2 ([F|As0],St0) of <{[Fun1|As1],St1}> when 'true' -> {{'call',Line,Fun1,As1},St1}
(<_49> when 'true' -> primop 'match_fail' ({'badmatch',_49})-|['compiler_generated'] ) end
<{'try',Line,Es0,Scs0,Ccs0,As0},St0> when 'true' -> case apply 'exprs'/2 (Es0,St0) of <{Es1,St1}> when 'true' -> case apply 'clauses'/2 (Scs0,St1) of <{Scs1,St2}> when 'true' -> case apply 'clauses'/2 (Ccs0,St2) of <{Ccs1,St3}> when 'true' -> case apply 'exprs'/2 (As0,St3) of <{As1,St4}> when 'true' -> {{'try',Line,Es1,Scs1,Ccs1,As1},St4}
(<_53> when 'true' -> primop 'match_fail' ({'badmatch',_53})-|['compiler_generated'] ) end
(<_52> when 'true' -> primop 'match_fail' ({'badmatch',_52})-|['compiler_generated'] ) end
(<_51> when 'true' -> primop 'match_fail' ({'badmatch',_51})-|['compiler_generated'] ) end
(<_50> when 'true' -> primop 'match_fail' ({'badmatch',_50})-|['compiler_generated'] ) end
<{'catch',Line,E0},St0> when 'true' -> case apply 'expr'/2 (E0,St0) of <{E,St1}> when 'true' -> {{'catch',Line,E},St1}
(<_54> when 'true' -> primop 'match_fail' ({'badmatch',_54})-|['compiler_generated'] ) end
<{'match',Line,P0,E0},St0> when 'true' -> case apply 'expr'/2 (E0,St0) of <{E,St1}> when 'true' -> case apply 'pattern'/2 (P0,St1) of <{P,St2}> when 'true' -> {{'match',Line,P,E},St2}
(<_56> when 'true' -> primop 'match_fail' ({'badmatch',_56})-|['compiler_generated'] ) end
(<_55> when 'true' -> primop 'match_fail' ({'badmatch',_55})-|['compiler_generated'] ) end
<{'op',Line,'not',A0},St0> when 'true' -> case apply 'bool_operand'/2 (A0,St0) of <{A,St1}> when 'true' -> {{'op',Line,'not',A},St1}
(<_57> when 'true' -> primop 'match_fail' ({'badmatch',_57})-|['compiler_generated'] ) end
<{'op',Line,Op,A0},St0> when 'true' -> case apply 'expr'/2 (A0,St0) of <{A,St1}> when 'true' -> {{'op',Line,Op,A},St1}
(<_58> when 'true' -> primop 'match_fail' ({'badmatch',_58})-|['compiler_generated'] ) end
<{'op',Line,Op,L0,R0},St0> when let <_59> = call 'erlang':'=:=' (Op,'and') in let <_60> = call 'erlang':'=:=' (Op,'or') in call 'erlang':'or' (_59,_60) -> case apply 'bool_operand'/2 (L0,St0) of <{L,St1}> when 'true' -> case apply 'bool_operand'/2 (R0,St1) of <{R,St2}> when 'true' -> {{'op',Line,Op,L,R},St2}
(<_62> when 'true' -> primop 'match_fail' ({'badmatch',_62})-|['compiler_generated'] ) end
(<_61> when 'true' -> primop 'match_fail' ({'badmatch',_61})-|['compiler_generated'] ) end
<{'op',Line,Op,L0,R0},St0> when let <_63> = call 'erlang':'=:=' (Op,'andalso') in let <_64> = call 'erlang':'=:=' (Op,'orelse') in call 'erlang':'or' (_63,_64) -> case apply 'bool_operand'/2 (L0,St0) of <{L,St1}> when 'true' -> case apply 'bool_operand'/2 (R0,St1) of <{R,St2}> when 'true' -> (case St1 of (<({'exprec',_111,_112,_113,_114,_115,_rec7}-|['compiler_generated'] )> when 'true' -> case St2 of <{'exprec',_117,_118,_119,_120,_121,_122}> when 'true' -> let <_72> = call 'erlang':'setelement' (7,St2,_rec7) in {{'op',Line,Op,L,R},_72}
(<_123> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_116> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_66> when 'true' -> primop 'match_fail' ({'badmatch',_66})-|['compiler_generated'] ) end
(<_65> when 'true' -> primop 'match_fail' ({'badmatch',_65})-|['compiler_generated'] ) end
<{'op',Line,Op,L0,R0},St0> when 'true' -> case apply 'expr'/2 (L0,St0) of <{L,St1}> when 'true' -> case apply 'expr'/2 (R0,St1) of <{R,St2}> when 'true' -> {{'op',Line,Op,L,R},St2}
(<_74> when 'true' -> primop 'match_fail' ({'badmatch',_74})-|['compiler_generated'] ) end
(<_73> when 'true' -> primop 'match_fail' ({'badmatch',_73})-|['compiler_generated'] ) end
(<_76,_75> when 'true' -> (primop 'match_fail' ({'function_clause',_76,_75})-|[{'function_name',{'expr',2}}] )-|['compiler_generated'] ) end
'expr_list'/2 = fun (_0,_1) -> case <_0,_1> of <[E0|Es0],St0> when 'true' -> case apply 'expr'/2 (E0,St0) of <{E,St1}> when 'true' -> case apply 'expr_list'/2 (Es0,St1) of <{Es,St2}> when 'true' -> {[E|Es],St2}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[],St> when 'true' -> {[],St}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'expr_list',2}}] )-|['compiler_generated'] ) end
'bool_operand'/2 = fun (_0,_1) -> case apply 'expr'/2 (_0,_1) of <{E1,St1}> when 'true' -> apply 'strict_record_access'/2 (E1,St1)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'strict_record_access'/2 = fun (_0,_1) -> case <_0,_1> of <E,St = {'exprec',_19,_20,_21,_22,[],_23}> when 'true' -> {E,St}
<E0,St0> when 'true' -> case St0 of <{'exprec',_24,_25,_26,_27,StrictRA,CheckedRA}> when 'true' -> let <_8> = fun (_5,_4) -> case <_5,_4> of <A = {Key,_X_L,_X_R,_X_Sz},_@r0 = {L,C}> when 'true' -> case call 'lists':'keymember' (Key,1,C) of <'true'> when 'true' -> _@r0
<'false'> when 'true' -> {[A|L],[A|C]}
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'-strict_record_access/2-fun-0-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'foldl' (_8,{[],CheckedRA},StrictRA) of <{New,NC}> when 'true' -> let <_10> = case <> of <> when call 'erlang':'=:=' (New,[]) -> E0
<> when 'true' -> apply 'conj'/2 (New,E0) end in case St0 of <{'exprec',_28,_29,_30,_31,_32,_33}> when 'true' -> let <_13> = call 'erlang':'setelement' (7,St0,NC) in let <_15> = call 'erlang':'setelement' (6,_13,[]) in apply 'expr'/2 (_10,_15)
(<_34> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end end
'conj'/2 = fun (_0,_1) -> case <_0,_1> of <[],_X_E> when 'true' -> 'empty'
<[{{Name,_X_Rp},L,R,Sz}|AL],E> when 'true' -> let <NL> = apply 'no_compiler_warning'/1 (L) in let <T1> = {'op',NL,'orelse',{'call',NL,{'remote',NL,{'atom',NL,'erlang'},{'atom',NL,'is_record'}},[R|[{'atom',NL,Name}|[{'integer',NL,Sz}|[]]]]},{'atom',NL,'fail'}} in let <_5> = case apply 'conj'/2 (AL,'none') of <'empty'> when 'true' -> T1
<C> when 'true' -> {'op',NL,'and',C,T1} end in case E of <'none'> when 'true' -> case _5 of <{'op',_11,'and',_12,_13}> when 'true' -> _5
<_14> when 'true' -> {'op',NL,'and',_5,{'atom',NL,'true'}} end
<_15> when 'true' -> {'op',NL,'and',_5,E} end
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'conj',2}}] )-|['compiler_generated'] ) end
'lc_tq'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Line,[{'generate',Lg,P0,G0}|Qs0],St0> when 'true' -> case apply 'expr'/2 (G0,St0) of <{G1,St1}> when 'true' -> case apply 'pattern'/2 (P0,St1) of <{P1,St2}> when 'true' -> case apply 'lc_tq'/3 (Line,Qs0,St2) of <{Qs1,St3}> when 'true' -> {[{'generate',Lg,P1,G1}|Qs1],St3}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<Line,[{'b_generate',Lg,P0,G0}|Qs0],St0> when 'true' -> case apply 'expr'/2 (G0,St0) of <{G1,St1}> when 'true' -> case apply 'pattern'/2 (P0,St1) of <{P1,St2}> when 'true' -> case apply 'lc_tq'/3 (Line,Qs0,St2) of <{Qs1,St3}> when 'true' -> {[{'b_generate',Lg,P1,G1}|Qs1],St3}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<Line,[F0|Qs0],St0 = {'exprec',_24,_25,Calltype,_26,_27,_28}> when 'true' -> let <IsOverriden> = fun (_10) -> case Calltype of <~{_10:='local'}~> when 'true' -> 'true'
<~{_10:={'imported',_29}}~> when 'true' -> 'true'
<_30> when 'true' -> 'false' end in case call 'erl_lint':'is_guard_test' (F0,[],IsOverriden) of <'true'> when 'true' -> case apply 'guard_test'/2 (F0,St0) of <{F1,St1}> when 'true' -> case apply 'lc_tq'/3 (Line,Qs0,St1) of <{Qs1,St2}> when 'true' -> {[F1|Qs1],St2}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<'false'> when 'true' -> case apply 'expr'/2 (F0,St0) of <{F1,St1}> when 'true' -> case apply 'lc_tq'/3 (Line,Qs0,St1) of <{Qs1,St2}> when 'true' -> {[F1|Qs1],St2}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_17> when 'true' -> primop 'match_fail' ({'case_clause',_17})-|['compiler_generated'] ) end
<_X_Line,[],St0> when 'true' -> case St0 of <{'exprec',_31,_32,_33,_34,_35,_36}> when 'true' -> let <_20> = call 'erlang':'setelement' (7,St0,[]) in {[],_20}
(<_37> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_23,_22,_21> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21})-|[{'function_name',{'lc_tq',3}}] )-|['compiler_generated'] ) end
'normalise_fields'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'record_field',Lf,Field}> when 'true' -> {'record_field',Lf,Field,{'atom',Lf,'undefined'}}
<{'typed_record_field',{'record_field',Lf,Field},_X_Type}> when 'true' -> {'record_field',Lf,Field,{'atom',Lf,'undefined'}}
<{'typed_record_field',Field,_X_Type}> when 'true' -> Field
<F> when 'true' -> F end in call 'lists':'map' (_3,_0)
'record_fields'/2 = fun (_0,_1) -> (case _1 of (<({'exprec',_6,_7,_8,_rec10,_9,_10}-|['compiler_generated'] )> when 'true' -> call 'maps':'get' (_0,_rec10)-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'find_field'/2 = fun (_0,_1) -> case <_0,_1> of <F,[{'record_field',_4,{'atom',_5,_6},Val}|_7]> when call 'erlang':'=:=' (_6,F) -> {'ok',Val}
<F,[_8|Fs]> when 'true' -> apply 'find_field'/2 (F,Fs)
<_9,[]> when 'true' -> 'error'
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'find_field',2}}] )-|['compiler_generated'] ) end
'field_names'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'record_field',_5,Field,_X_Val}> when 'true' -> Field
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-field_names/1-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'map' (_3,_0)
'index_expr'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Line,{'atom',_9,F},_X_Name,Fs> when 'true' -> let <_4> = apply 'index_expr'/3 (F,Fs,2) in {'integer',Line,_4}
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'index_expr',4}}] )-|['compiler_generated'] ) end
'index_expr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F,[{'record_field',_7,{'atom',_8,_9},_10}|_11],I> when call 'erlang':'=:=' (_9,F) -> I
<F,[_12|Fs],I> when 'true' -> let <_3> = call 'erlang':'+' (I,1) in apply 'index_expr'/3 (F,Fs,_3)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'index_expr',3}}] )-|['compiler_generated'] ) end
'get_record_field'/5 = fun (_0,_1,_2,_3,_4) -> (case _4 of (<({'exprec',_rec11,_13,_14,_15,_16,_17}-|['compiler_generated'] )> when 'true' -> case apply 'strict_record_tests'/1 (_rec11) of <'false'> when 'true' -> apply 'sloppy_get_record_field'/5 (_0,_1,_2,_3,_4)
<'true'> when 'true' -> apply 'strict_get_record_field'/5 (_0,_1,_2,_3,_4)
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_18> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'strict_get_record_field'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Line,R,Index = {'atom',_38,F},Name,St0> when 'true' -> case apply 'is_in_guard'/0 () of <'false'> when 'true' -> case apply 'new_var'/2 (Line,St0) of <{Var,St}> when 'true' -> let <Fs> = apply 'record_fields'/2 (Name,St) in let <I> = apply 'index_expr'/3 (F,Fs,2) in let <_8> = call 'erlang':'length' (Fs) in let <_9> = call 'erlang':'+' (_8,1) in let <P> = apply 'record_pattern'/6 (2,I,Var,_9,Line,[{'atom',Line,Name}|[]]) in let <NLine> = apply 'no_compiler_warning'/1 (Line) in let <RLine> = apply 'mark_record'/2 (NLine,St) in let <E> = {'case',NLine,R,[{'clause',NLine,[{'tuple',RLine,P}|[]],[],[Var|[]]}|[{'clause',NLine,[{'var',NLine,'_'}|[]],[],[{'call',NLine,{'remote',NLine,{'atom',NLine,'erlang'},{'atom',NLine,'error'}},[{'tuple',NLine,[{'atom',NLine,'badrecord'}|[{'atom',NLine,Name}|[]]]}|[]]}|[]]}|[]]]} in apply 'expr'/2 (E,St)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<'true'> when 'true' -> let <Fs> = apply 'record_fields'/2 (Name,St0) in let <I> = apply 'index_expr'/4 (Line,Index,Name,Fs) in case apply 'expr'/2 (R,St0) of <{ExpR,St1}> when 'true' -> let <A0> = call 'erl_anno':'new' (0) in let <_20> = fun (_18) -> A0 in let <ExpRp> = call 'erl_parse':'map_anno' (_20,ExpR) in let <_22> = call 'erlang':'length' (Fs) in let <_23> = call 'erlang':'+' (_22,1) in let <RA> = {{Name,ExpRp},Line,ExpR,_23} in (case St1 of (<({'exprec',_39,_40,_41,_42,_rec14,_43}-|['compiler_generated'] )> when 'true' -> let <_rec12> = [RA|_rec14] in case St1 of <{'exprec',_45,_46,_47,_48,_49,_50}> when 'true' -> let <_30> = call 'erlang':'setelement' (6,St1,_rec12) in {{'call',Line,{'remote',Line,{'atom',Line,'erlang'},{'atom',Line,'element'}},[I|[ExpR|[]]]},_30}
(<_51> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_44> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_32> when 'true' -> primop 'match_fail' ({'case_clause',_32})-|['compiler_generated'] ) end
(<_37,_36,_35,_34,_33> when 'true' -> (primop 'match_fail' ({'function_clause',_37,_36,_35,_34,_33})-|[{'function_name',{'strict_get_record_field',5}}] )-|['compiler_generated'] ) end
'record_pattern'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <I,_14,Var,Sz,Line,Acc> when call 'erlang':'=:=' (_14,I) -> let <_6> = call 'erlang':'+' (I,1) in apply 'record_pattern'/6 (_6,I,Var,Sz,Line,[Var|Acc])
<Cur,I,Var,Sz,Line,Acc> when call 'erlang':'=<' (Cur,Sz) -> let <_7> = call 'erlang':'+' (Cur,1) in apply 'record_pattern'/6 (_7,I,Var,Sz,Line,[{'var',Line,'_'}|Acc])
<_15,_16,_17,_18,_19,Acc> when 'true' -> call 'lists':'reverse' (Acc) end
'sloppy_get_record_field'/5 = fun (_0,_1,_2,_3,_4) -> let <Fs> = apply 'record_fields'/2 (_3,_4) in let <I> = apply 'index_expr'/4 (_0,_2,_3,Fs) in apply 'expr'/2 ({'call',_0,{'remote',_0,{'atom',_0,'erlang'},{'atom',_0,'element'}},[I|[_1|[]]]},_4)
'strict_record_tests'/1 = fun (_0) -> case _0 of <['strict_record_tests'|_2]> when 'true' -> 'true'
<['no_strict_record_tests'|_3]> when 'true' -> 'false'
<[_4|Os]> when 'true' -> apply 'strict_record_tests'/1 (Os)
<[]> when 'true' -> 'true'
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'strict_record_tests',1}}] )-|['compiler_generated'] ) end
'strict_record_updates'/1 = fun (_0) -> case _0 of <['strict_record_updates'|_2]> when 'true' -> 'true'
<['no_strict_record_updates'|_3]> when 'true' -> 'false'
<[_4|Os]> when 'true' -> apply 'strict_record_updates'/1 (Os)
<[]> when 'true' -> 'false'
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'strict_record_updates',1}}] )-|['compiler_generated'] ) end
'pattern_fields'/2 = fun (_0,_1) -> let <Wildcard> = apply 'record_wildcard_init'/1 (_1) in let <_6> = fun (_4) -> case _4 of <{'record_field',L,{'atom',_9,F},_10}> when 'true' -> case apply 'find_field'/2 (F,_1) of <{'ok',Match}> when 'true' -> Match
<'error'> when call 'erlang':'=:=' (Wildcard,'none') -> {'var',L,'_'}
<'error'> when 'true' -> Wildcard
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_5> when 'true' -> (primop 'match_fail' ({'function_clause',_5})-|[{'function_name',{'-pattern_fields/2-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'map' (_6,_0)
'record_inits'/2 = fun (_0,_1) -> let <WildcardInit> = apply 'record_wildcard_init'/1 (_1) in let <_6> = fun (_4) -> case _4 of <{'record_field',_9,{'atom',_10,F},D}> when 'true' -> case apply 'find_field'/2 (F,_1) of <{'ok',Init}> when 'true' -> Init
<'error'> when call 'erlang':'=:=' (WildcardInit,'none') -> D
<'error'> when 'true' -> WildcardInit
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_5> when 'true' -> (primop 'match_fail' ({'function_clause',_5})-|[{'function_name',{'-record_inits/2-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'map' (_6,_0)
'record_wildcard_init'/1 = fun (_0) -> case _0 of <[{'record_field',_2,{'var',_3,'_'},D}|_4]> when 'true' -> D
<[_5|Is]> when 'true' -> apply 'record_wildcard_init'/1 (Is)
<[]> when 'true' -> 'none'
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'record_wildcard_init',1}}] )-|['compiler_generated'] ) end
'record_update'/5 = fun (_0,_1,_2,_3,_4) -> let <Line> = call 'erlang':'element' (2,_0) in case apply 'record_exprs'/2 (_3,_4) of <{Pre,Us,St1}> when 'true' -> let <Nf> = call 'erlang':'length' (_2) in let <Nu> = call 'erlang':'length' (Us) in let <Nc> = call 'erlang':'-' (Nf,Nu) in case apply 'new_var'/2 (Line,St1) of <{Var,St2}> when 'true' -> (case St2 of (<({'exprec',_rec15,_27,_28,_29,_30,_31}-|['compiler_generated'] )> when 'true' -> let <StrictUpdates> = apply 'strict_record_updates'/1 (_rec15) in let <_19> = case <> of <> when call 'erlang':'=:=' (Nu,0) -> apply 'record_match'/6 (Var,_1,Line,_2,Us,St2)
<> when let <_14> = call 'erlang':'=<' (Nu,Nc) in let <_15> = call 'erlang':'=:=' (StrictUpdates,'false') in call 'erlang':'and' (_14,_15) -> let <_16> = apply 'record_setel'/4 (Var,_1,_2,Us) in {_16,St2}
<> when 'true' -> let <_17> = call 'erlang':'hd' (Us) in let <_18> = call 'erlang':'element' (2,_17) in apply 'record_match'/6 (Var,_1,_18,_2,Us,St2) end in case _19 of <{Update,St}> when 'true' -> let <_21> = call 'erlang':'++' (Pre,[{'match',Line,Var,_0}|[Update|[]]]) in {{'block',Line,_21},St}
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_32> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'record_match'/6 = fun (_0,_1,_2,_3,_4,_5) -> case apply 'record_upd_fs'/3 (_3,_4,_5) of <{Ps,News,St1}> when 'true' -> let <NLr> = apply 'no_compiler_warning'/1 (_2) in let <RLine> = apply 'mark_record'/2 (_2,St1) in let <_9> = apply 'call_error'/2 (NLr,{'tuple',NLr,[{'atom',NLr,'badrecord'}|[{'atom',NLr,_1}|[]]]}) in {{'case',_2,_0,[{'clause',_2,[{'tuple',RLine,[{'atom',_2,_1}|Ps]}|[]],[],[{'tuple',RLine,[{'atom',_2,_1}|News]}|[]]}|[{'clause',NLr,[{'var',NLr,'_'}|[]],[],[_9|[]]}|[]]]},St1}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'record_upd_fs'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{'record_field',Lf,{'atom',_X_La,F},_X_Val}|Fs],Us,St0> when 'true' -> case apply 'new_var'/2 (Lf,St0) of <{P,St1}> when 'true' -> case apply 'record_upd_fs'/3 (Fs,Us,St1) of <{Ps,News,St2}> when 'true' -> case apply 'find_field'/2 (F,Us) of <{'ok',New}> when 'true' -> {[P|Ps],[New|News],St2}
<'error'> when 'true' -> {[P|Ps],[P|News],St2}
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<[],_9,St> when 'true' -> {[],[],St}
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'record_upd_fs',3}}] )-|['compiler_generated'] ) end
'record_setel'/4 = fun (_0,_1,_2,_3) -> let <_9> = fun (_6,_5) -> case <_6,_5> of <{'record_field',Lf,Field,Val},Acc> when 'true' -> case apply 'index_expr'/4 (Lf,Field,_1,_2) of <I = {'integer',_34,FieldIndex}> when 'true' -> [{FieldIndex,{I,Lf,Val}}|Acc]
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'-record_setel/4-fun-0-',2}}] )-|['compiler_generated'] ) end in let <Us1> = call 'lists':'foldl' (_9,[],_3) in let <Us2> = call 'lists':'sort' (Us1) in let <_16> = letrec 'lc$^1'/1 = fun (_14) -> case _14 of <[{_35,T}|_13]> when 'true' -> let <_15> = apply 'lc$^1'/1 (_13) in ([T|_15]-|['compiler_generated'] )
(<[_12|_13]> when 'true' -> apply 'lc$^1'/1 (_13)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_36> when 'true' -> (primop 'match_fail' ({'function_clause',_36})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Us2) in let <_18> = call 'erlang':'hd' (_16) in let <Lr> = call 'erlang':'element' (2,_18) in let <_20> = call 'erlang':'length' (_2) in let <Wildcards> = call 'lists':'duplicate' (_20,{'var',Lr,'_'}) in let <NLr> = apply 'no_compiler_warning'/1 (Lr) in let <_27> = fun (_24,_23) -> case <_24,_23> of <{I,Lf,Val},Acc> when 'true' -> {'call',Lf,{'remote',Lf,{'atom',Lf,'erlang'},{'atom',Lf,'setelement'}},[I|[Acc|[Val|[]]]]}
(<_26,_25> when 'true' -> (primop 'match_fail' ({'function_clause',_26,_25})-|[{'function_name',{'-record_setel/4-fun-2-',2}}] )-|['compiler_generated'] ) end in let <_28> = call 'lists':'foldr' (_27,_0,_16) in let <_29> = apply 'call_error'/2 (NLr,{'tuple',NLr,[{'atom',NLr,'badrecord'}|[{'atom',NLr,_1}|[]]]}) in {'case',Lr,_0,[{'clause',Lr,[{'tuple',Lr,[{'atom',Lr,_1}|Wildcards]}|[]],[],[_28|[]]}|[{'clause',NLr,[{'var',NLr,'_'}|[]],[],[_29|[]]}|[]]]}
'record_info_call'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Line,[{'atom',_X_Li,Info}|[{'atom',_X_Ln,Name}|[]]],St> when 'true' -> case Info of <'size'> when 'true' -> let <_3> = apply 'record_fields'/2 (Name,St) in let <_4> = call 'erlang':'length' (_3) in let <_5> = call 'erlang':'+' (1,_4) in {{'integer',Line,_5},St}
<'fields'> when 'true' -> let <_6> = apply 'record_fields'/2 (Name,St) in let <_7> = apply 'field_names'/1 (_6) in let <_8> = apply 'make_list'/2 (_7,Line) in {_8,St}
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
(<_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10})-|[{'function_name',{'record_info_call',3}}] )-|['compiler_generated'] ) end
'record_exprs'/2 = fun (_0,_1) -> apply 'record_exprs'/4 (_0,_1,[],[])
'record_exprs'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[Field0 = {'record_field',Lf,Name = {'atom',_X_La,_X_F},Val}|Us],St0,Pre,Fs> when 'true' -> case apply 'is_simple_val'/1 (Val) of <'true'> when 'true' -> apply 'record_exprs'/4 (Us,St0,Pre,[Field0|Fs])
<'false'> when 'true' -> case apply 'new_var'/2 (Lf,St0) of <{Var,St}> when 'true' -> let <Bind> = {'match',Lf,Var,Val} in let <Field> = {'record_field',Lf,Name,Var} in apply 'record_exprs'/4 (Us,St,[Bind|Pre],[Field|Fs])
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<[],St,Pre,Fs> when 'true' -> let <_8> = call 'lists':'reverse' (Pre) in {_8,Fs,St}
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'record_exprs',4}}] )-|['compiler_generated'] ) end
'is_simple_val'/1 = fun (_0) -> case _0 of <{'var',_6,_7}> when 'true' -> 'true'
<Val> when 'true' -> try do call 'erl_parse':'normalise' (Val) 'true' of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('error'-|['compiler_generated'] ),_8,_9> when 'true' -> 'false'
(<_10,_11,_12> when 'true' -> primop 'raise' (_12,_11)-|['compiler_generated'] ) end end
'pattern_bin'/2 = fun (_0,_1) -> let <_6> = fun (_3,_2) -> apply 'pattern_element'/2 (_3,_2) in call 'lists':'foldr' (_6,{[],_1},_0)
'pattern_element'/2 = fun (_0,_1) -> case <_0,_1> of <{'bin_element',Line,Expr0,Size0,Type},{Es,St0}> when 'true' -> case apply 'pattern'/2 (Expr0,St0) of <{Expr,St1}> when 'true' -> let <_4> = case Size0 of <'default'> when 'true' -> {Size0,St1}
<_8> when 'true' -> apply 'expr'/2 (Size0,St1) end in case _4 of <{Size,St2}> when 'true' -> {[{'bin_element',Line,Expr,Size,Type}|Es],St2}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'pattern_element',2}}] )-|['compiler_generated'] ) end
'expr_bin'/2 = fun (_0,_1) -> let <_6> = fun (_3,_2) -> apply 'bin_element'/2 (_3,_2) in call 'lists':'foldr' (_6,{[],_1},_0)
'bin_element'/2 = fun (_0,_1) -> case <_0,_1> of <{'bin_element',Line,Expr,Size,Type},{Es,St0}> when 'true' -> case apply 'expr'/2 (Expr,St0) of <{Expr1,St1}> when 'true' -> let <_3> = case <> of <> when call 'erlang':'=:=' (Size,'default') -> {'default',St1}
<> when 'true' -> apply 'expr'/2 (Size,St1) end in case _3 of <{Size1,St2}> when 'true' -> {[{'bin_element',Line,Expr1,Size1,Type}|Es],St2}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'bin_element',2}}] )-|['compiler_generated'] ) end
'new_vars'/3 = fun (_0,_1,_2) -> apply 'new_vars'/4 (_0,_1,_2,[])
'new_vars'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <N,L,St0,Vs> when call 'erlang':'>' (N,0) -> case apply 'new_var'/2 (L,St0) of <{V,St1}> when 'true' -> let <_5> = call 'erlang':'-' (N,1) in apply 'new_vars'/4 (_5,L,St1,[V|Vs])
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<0,_X_L,St,Vs> when 'true' -> {Vs,St}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'new_vars',4}}] )-|['compiler_generated'] ) end
'new_var'/2 = fun (_0,_1) -> case apply 'new_var_name'/1 (_1) of <{New,St1}> when 'true' -> {{'var',_0,New},St1}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'new_var_name'/1 = fun (_0) -> (case _0 of (<({'exprec',_12,_rec16,_13,_14,_15,_16}-|['compiler_generated'] )> when 'true' -> let <_8> = call 'erlang':'integer_to_list' (_rec16) in let <_9> = [114|[101|[99|_8]]] in let <_10> = call 'erlang':'list_to_atom' (_9) in let <_rec17> = call 'erlang':'+' (_rec16,1) in case _0 of <{'exprec',_18,_19,_20,_21,_22,_23}> when 'true' -> let <_7> = call 'erlang':'setelement' (3,_0,_rec17) in {_10,_7}
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_17> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'make_list'/2 = fun (_0,_1) -> let <_6> = fun (_3,_2) -> {'cons',_1,_3,_2} in call 'lists':'foldr' (_6,{'nil',_1},_0)
'call_error'/2 = fun (_0,_1) -> {'call',_0,{'remote',_0,{'atom',_0,'erlang'},{'atom',_0,'error'}},[_1|[]]}
'optimize_is_record'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <H0,G0,{'exprec',Opts,_10,_11,_12,_13,_14}> when 'true' -> case apply 'opt_rec_vars'/1 (G0) of <[]> when 'true' -> {H0,G0}
<Rs0> when 'true' -> case call 'lists':'member' ('dialyzer',Opts) of <'true'> when 'true' -> {H0,G0}
<'false'> when 'true' -> case apply 'opt_pattern_list'/2 (H0,Rs0) of <{H,Rs}> when 'true' -> let <G> = apply 'opt_remove'/2 (G0,Rs) in {H,G}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end end
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'optimize_is_record',3}}] )-|['compiler_generated'] ) end
'opt_rec_vars'/1 = fun (_0) -> case _0 of <[G|Gs]> when 'true' -> let <_1> = call 'orddict':'new' () in let <Rs> = apply 'opt_rec_vars_1'/2 (G,_1) in apply 'opt_rec_vars'/2 (Gs,Rs)
<[]> when 'true' -> call 'orddict':'new' ()
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'opt_rec_vars',1}}] )-|['compiler_generated'] ) end
'opt_rec_vars'/2 = fun (_0,_1) -> case <_0,_1> of <[G|Gs],Rs0> when 'true' -> let <_2> = call 'orddict':'new' () in let <Rs1> = apply 'opt_rec_vars_1'/2 (G,_2) in let <Rs> = call 'ordsets':'intersection' (Rs0,Rs1) in apply 'opt_rec_vars'/2 (Gs,Rs)
<[],Rs> when 'true' -> Rs
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'opt_rec_vars',2}}] )-|['compiler_generated'] ) end
'opt_rec_vars_1'/2 = fun (_0,_1) -> case <_0,_1> of <[T|Ts],Rs0> when 'true' -> let <Rs> = apply 'opt_rec_vars_2'/2 (T,Rs0) in apply 'opt_rec_vars_1'/2 (Ts,Rs)
<[],Rs> when 'true' -> Rs
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'opt_rec_vars_1',2}}] )-|['compiler_generated'] ) end
'opt_rec_vars_2'/2 = fun (_0,_1) -> case <_0,_1> of <{'op',_4,'and',A1,A2},Rs> when 'true' -> apply 'opt_rec_vars_1'/2 ([A1|[A2|[]]],Rs)
<{'op',_5,'andalso',A1,A2},Rs> when 'true' -> apply 'opt_rec_vars_1'/2 ([A1|[A2|[]]],Rs)
<{'op',_6,'orelse',Arg,{'atom',_7,'fail'}},Rs> when 'true' -> apply 'opt_rec_vars_2'/2 (Arg,Rs)
<{'call',_8,{'remote',_9,{'atom',_10,'erlang'},{'atom',_11,'is_record'}},[{'var',_12,V}|[{'atom',_13,Tag}|[{'integer',_14,Sz}|[]]]]},Rs> when 'true' -> call 'orddict':'store' (V,{Tag,Sz},Rs)
<{'call',_15,{'atom',_16,'is_record'},[{'var',_17,V}|[{'atom',_18,Tag}|[{'integer',_19,Sz}|[]]]]},Rs> when 'true' -> call 'orddict':'store' (V,{Tag,Sz},Rs)
<_20,Rs> when 'true' -> Rs end
'opt_pattern_list'/2 = fun (_0,_1) -> apply 'opt_pattern_list'/3 (_0,_1,[])
'opt_pattern_list'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[P0|Ps],Rs0,Acc> when 'true' -> case apply 'opt_pattern'/2 (P0,Rs0) of <{P,Rs}> when 'true' -> apply 'opt_pattern_list'/3 (Ps,Rs,[P|Acc])
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<[],Rs,Acc> when 'true' -> let <_4> = call 'lists':'reverse' (Acc) in {_4,Rs}
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'opt_pattern_list',3}}] )-|['compiler_generated'] ) end
'opt_pattern'/2 = fun (_0,_1) -> case <_0,_1> of <Var = {'var',_12,V},Rs0> when 'true' -> case call 'orddict':'find' (V,Rs0) of <{'ok',{Tag,Sz}}> when 'true' -> let <Rs> = call 'orddict':'store' (V,{'remove',Tag,Sz},Rs0) in let <_3> = apply 'opt_var'/3 (Var,Tag,Sz) in {_3,Rs}
<_13> when 'true' -> {Var,Rs0} end
<{'cons',Line,H0,T0},Rs0> when 'true' -> case apply 'opt_pattern'/2 (H0,Rs0) of <{H,Rs1}> when 'true' -> case apply 'opt_pattern'/2 (T0,Rs1) of <{T,Rs}> when 'true' -> {{'cons',Line,H,T},Rs}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{'tuple',Line,Es0},Rs0> when 'true' -> case apply 'opt_pattern_list'/2 (Es0,Rs0) of <{Es,Rs}> when 'true' -> {{'tuple',Line,Es},Rs}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<{'match',Line,Pa0,Pb0},Rs0> when 'true' -> case apply 'opt_pattern'/2 (Pa0,Rs0) of <{Pa,Rs1}> when 'true' -> case apply 'opt_pattern'/2 (Pb0,Rs1) of <{Pb,Rs}> when 'true' -> {{'match',Line,Pa,Pb},Rs}
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<P,Rs> when 'true' -> {P,Rs} end
'opt_var'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Var = {'var',Line,_8},Tag,Sz> when 'true' -> let <Rp> = apply 'record_pattern'/6 (2,-1,'ignore',Sz,Line,[{'atom',Line,Tag}|[]]) in {'match',Line,{'tuple',Line,Rp},Var}
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'opt_var',3}}] )-|['compiler_generated'] ) end
'opt_remove'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[G|_3]> when 'true' -> let <_5> = apply 'opt_remove_1'/2 (G,_1) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'opt_remove_1'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[T|_3]> when 'true' -> let <_5> = apply 'opt_remove_2'/2 (T,_1) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'opt_remove_2'/2 = fun (_0,_1) -> case <_0,_1> of <{'op',L,Op = 'and',A1,A2},Rs> when 'true' -> let <_3> = apply 'opt_remove_2'/2 (A1,Rs) in let <_2> = apply 'opt_remove_2'/2 (A2,Rs) in {'op',L,Op,_3,_2}
<{'op',L,Op = 'andalso',A1,A2},Rs> when 'true' -> let <_5> = apply 'opt_remove_2'/2 (A1,Rs) in let <_4> = apply 'opt_remove_2'/2 (A2,Rs) in {'op',L,Op,_5,_4}
<{'op',L,'orelse',A1,A2},Rs> when 'true' -> let <_6> = apply 'opt_remove_2'/2 (A1,Rs) in {'op',L,'orelse',_6,A2}
<A = {'call',Line,{'remote',_11,{'atom',_12,'erlang'},{'atom',_13,'is_record'}},[{'var',_14,V}|[{'atom',_15,Tag}|[{'integer',_16,Sz}|[]]]]},Rs> when 'true' -> case call 'orddict':'find' (V,Rs) of <{'ok',{'remove',_17,_18}}> when let <_19> = call 'erlang':'=:=' (_17,Tag) in let <_20> = call 'erlang':'=:=' (_18,Sz) in call 'erlang':'and' (_19,_20) -> {'atom',Line,'true'}
<_21> when 'true' -> A end
<A = {'call',Line,{'atom',_22,'is_record'},[{'var',_23,V}|[{'atom',_24,Tag}|[{'integer',_25,Sz}|[]]]]},Rs> when 'true' -> case call 'orddict':'find' (V,Rs) of <{'ok',{'remove',_26,_27}}> when let <_28> = call 'erlang':'=:=' (_26,Tag) in let <_29> = call 'erlang':'=:=' (_27,Sz) in call 'erlang':'and' (_28,_29) -> {'atom',Line,'true'}
<_30> when 'true' -> A end
<A,_31> when 'true' -> A end
'no_compiler_warning'/1 = fun (_0) -> call 'erl_anno':'set_generated' ('true',_0)
'mark_record'/2 = fun (_0,_1) -> (case _1 of (<({'exprec',_rec19,_7,_8,_9,_10,_11}-|['compiler_generated'] )> when 'true' -> case call 'lists':'member' ('dialyzer',_rec19) of <'true'> when 'true' -> call 'erl_anno':'set_record' ('true',_0)
<'false'> when 'true' -> _0
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_12> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','exprec'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('erl_expand_records')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('erl_expand_records',_0) end