module 'erl_pp' ['attribute'/1,'attribute'/2,'expr'/1,'expr'/2,'expr'/3,'expr'/4,'exprs'/1,'exprs'/2,'exprs'/3,'form'/1,'form'/2,'function'/1,'function'/2,'guard'/1,'guard'/2,'module_info'/0,'module_info'/1] attributes [ 'file' = [{[115|[114|[99|[47|[101|[114|[108|[95|[112|[112|[46|[101|[114|[108]]]]]]]]]]]]]],1}]
, 'type' = [{'hook_function',{'type',37,'union',[{'atom',37,'none'}|[{'type',38,'fun',[{'type',38,'product',[{'ann_type',38,[{'var',38,'Expr'}|[{'remote_type',38,[{'atom',38,'erl_parse'}|[{'atom',38,'abstract_expr'}|[[]]]]}]]}|[{'ann_type',39,[{'var',39,'CurrentIndentation'}|[{'type',39,'integer',[]}]]}|[{'ann_type',40,[{'var',40,'CurrentPrecedence'}|[{'type',40,'non_neg_integer',[]}]]}|[{'ann_type',41,[{'var',41,'Options'}|[{'user_type',41,'options',[]}]]}]]]]}|[{'remote_type',42,[{'atom',42,'io_lib'}|[{'atom',42,'chars'}|[[]]]]}]]}]]},[]}]
, 'type' = [{'option',{'type',44,'union',[{'type',44,'tuple',[{'atom',44,'hook'}|[{'user_type',44,'hook_function',[]}]]}|[{'type',45,'tuple',[{'atom',45,'encoding'}|[{'type',45,'union',[{'atom',45,'latin1'}|[{'atom',45,'unicode'}|[{'atom',45,'utf8'}]]]}]]}|[{'type',46,'tuple',[{'atom',46,'quote_singleton_atom_types'}|[{'type',46,'boolean',[]}]]}|[{'type',47,'tuple',[{'atom',47,'linewidth'}|[{'type',47,'pos_integer',[]}]]}|[{'type',48,'tuple',[{'atom',48,'indent'}|[{'type',48,'pos_integer',[]}]]}]]]]]},[]}]
, 'type' = [{'options',{'type',49,'union',[{'user_type',49,'hook_function',[]}|[{'type',49,'list',[{'user_type',49,'option',[]}]}]]},[]}]
, 'record' = [{'pp',[{'record_field',51,{'atom',51,'value_fun'}}|[{'record_field',51,{'atom',51,'singleton_atom_type_fun'}}|[{'record_field',51,{'atom',51,'string_fun'}}|[{'record_field',51,{'atom',51,'char_fun'}}|[{'record_field',52,{'atom',52,'linewidth'},{'integer',52,72}}|[{'record_field',52,{'atom',52,'indent'},{'integer',52,4}}]]]]]]}]
, 'record' = [{'options',[{'record_field',54,{'atom',54,'hook'}}|[{'record_field',54,{'atom',54,'encoding'}}|[{'record_field',54,{'atom',54,'opts'}}]]]}]
, 'spec' = [{{'form',1},[{'type',88,'bounded_fun',[{'type',88,'fun',[{'type',88,'product',[{'var',88,'Form'}]}|[{'remote_type',88,[{'atom',88,'io_lib'}|[{'atom',88,'chars'}|[[]]]]}]]}|[[{'type',89,'constraint',[{'atom',89,'is_subtype'}|[[{'var',89,'Form'}|[{'type',89,'union',[{'remote_type',89,[{'atom',89,'erl_parse'}|[{'atom',89,'abstract_form'}|[[]]]]}|[{'remote_type',89,[{'atom',89,'erl_parse'}|[{'atom',89,'form_info'}|[[]]]]}]]}]]]]}]]]}]}]
, 'spec' = [{{'form',2},[{'type',94,'bounded_fun',[{'type',94,'fun',[{'type',94,'product',[{'var',94,'Form'}|[{'var',94,'Options'}]]}|[{'remote_type',94,[{'atom',94,'io_lib'}|[{'atom',94,'chars'}|[[]]]]}]]}|[[{'type',95,'constraint',[{'atom',95,'is_subtype'}|[[{'var',95,'Form'}|[{'type',95,'union',[{'remote_type',95,[{'atom',95,'erl_parse'}|[{'atom',95,'abstract_form'}|[[]]]]}|[{'remote_type',95,[{'atom',95,'erl_parse'}|[{'atom',95,'form_info'}|[[]]]]}]]}]]]]}|[{'type',96,'constraint',[{'atom',96,'is_subtype'}|[[{'var',96,'Options'}|[{'user_type',96,'options',[]}]]]]}]]]]}]}]
, 'spec' = [{{'attribute',1},[{'type',103,'bounded_fun',[{'type',103,'fun',[{'type',103,'product',[{'var',103,'Attribute'}]}|[{'remote_type',103,[{'atom',103,'io_lib'}|[{'atom',103,'chars'}|[[]]]]}]]}|[[{'type',104,'constraint',[{'atom',104,'is_subtype'}|[[{'var',104,'Attribute'}|[{'remote_type',104,[{'atom',104,'erl_parse'}|[{'atom',104,'abstract_form'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'attribute',2},[{'type',109,'bounded_fun',[{'type',109,'fun',[{'type',109,'product',[{'var',109,'Attribute'}|[{'var',109,'Options'}]]}|[{'remote_type',109,[{'atom',109,'io_lib'}|[{'atom',109,'chars'}|[[]]]]}]]}|[[{'type',110,'constraint',[{'atom',110,'is_subtype'}|[[{'var',110,'Attribute'}|[{'remote_type',110,[{'atom',110,'erl_parse'}|[{'atom',110,'abstract_form'}|[[]]]]}]]]]}|[{'type',111,'constraint',[{'atom',111,'is_subtype'}|[[{'var',111,'Options'}|[{'user_type',111,'options',[]}]]]]}]]]]}]}]
, 'spec' = [{{'function',1},[{'type',118,'bounded_fun',[{'type',118,'fun',[{'type',118,'product',[{'var',118,'Function'}]}|[{'remote_type',118,[{'atom',118,'io_lib'}|[{'atom',118,'chars'}|[[]]]]}]]}|[[{'type',119,'constraint',[{'atom',119,'is_subtype'}|[[{'var',119,'Function'}|[{'remote_type',119,[{'atom',119,'erl_parse'}|[{'atom',119,'abstract_form'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'function',2},[{'type',124,'bounded_fun',[{'type',124,'fun',[{'type',124,'product',[{'var',124,'Function'}|[{'var',124,'Options'}]]}|[{'remote_type',124,[{'atom',124,'io_lib'}|[{'atom',124,'chars'}|[[]]]]}]]}|[[{'type',125,'constraint',[{'atom',125,'is_subtype'}|[[{'var',125,'Function'}|[{'remote_type',125,[{'atom',125,'erl_parse'}|[{'atom',125,'abstract_form'}|[[]]]]}]]]]}|[{'type',126,'constraint',[{'atom',126,'is_subtype'}|[[{'var',126,'Options'}|[{'user_type',126,'options',[]}]]]]}]]]]}]}]
, 'spec' = [{{'guard',1},[{'type',132,'bounded_fun',[{'type',132,'fun',[{'type',132,'product',[{'var',132,'Guard'}]}|[{'remote_type',132,[{'atom',132,'io_lib'}|[{'atom',132,'chars'}|[[]]]]}]]}|[[{'type',133,'constraint',[{'atom',133,'is_subtype'}|[[{'var',133,'Guard'}|[{'type',133,'list',[{'remote_type',133,[{'atom',133,'erl_parse'}|[{'atom',133,'abstract_expr'}|[[]]]]}]}]]]]}]]]}]}]
, 'spec' = [{{'guard',2},[{'type',138,'bounded_fun',[{'type',138,'fun',[{'type',138,'product',[{'var',138,'Guard'}|[{'var',138,'Options'}]]}|[{'remote_type',138,[{'atom',138,'io_lib'}|[{'atom',138,'chars'}|[[]]]]}]]}|[[{'type',139,'constraint',[{'atom',139,'is_subtype'}|[[{'var',139,'Guard'}|[{'type',139,'list',[{'remote_type',139,[{'atom',139,'erl_parse'}|[{'atom',139,'abstract_expr'}|[[]]]]}]}]]]]}|[{'type',140,'constraint',[{'atom',140,'is_subtype'}|[[{'var',140,'Options'}|[{'user_type',140,'options',[]}]]]]}]]]]}]}]
, 'spec' = [{{'exprs',1},[{'type',146,'bounded_fun',[{'type',146,'fun',[{'type',146,'product',[{'var',146,'Expressions'}]}|[{'remote_type',146,[{'atom',146,'io_lib'}|[{'atom',146,'chars'}|[[]]]]}]]}|[[{'type',147,'constraint',[{'atom',147,'is_subtype'}|[[{'var',147,'Expressions'}|[{'type',147,'list',[{'remote_type',147,[{'atom',147,'erl_parse'}|[{'atom',147,'abstract_expr'}|[[]]]]}]}]]]]}]]]}]}]
, 'spec' = [{{'exprs',2},[{'type',152,'bounded_fun',[{'type',152,'fun',[{'type',152,'product',[{'var',152,'Expressions'}|[{'var',152,'Options'}]]}|[{'remote_type',152,[{'atom',152,'io_lib'}|[{'atom',152,'chars'}|[[]]]]}]]}|[[{'type',153,'constraint',[{'atom',153,'is_subtype'}|[[{'var',153,'Expressions'}|[{'type',153,'list',[{'remote_type',153,[{'atom',153,'erl_parse'}|[{'atom',153,'abstract_expr'}|[[]]]]}]}]]]]}|[{'type',154,'constraint',[{'atom',154,'is_subtype'}|[[{'var',154,'Options'}|[{'user_type',154,'options',[]}]]]]}]]]]}]}]
, 'spec' = [{{'exprs',3},[{'type',159,'bounded_fun',[{'type',159,'fun',[{'type',159,'product',[{'var',159,'Expressions'}|[{'var',159,'Indent'}|[{'var',159,'Options'}]]]}|[{'remote_type',159,[{'atom',159,'io_lib'}|[{'atom',159,'chars'}|[[]]]]}]]}|[[{'type',160,'constraint',[{'atom',160,'is_subtype'}|[[{'var',160,'Expressions'}|[{'type',160,'list',[{'remote_type',160,[{'atom',160,'erl_parse'}|[{'atom',160,'abstract_expr'}|[[]]]]}]}]]]]}|[{'type',161,'constraint',[{'atom',161,'is_subtype'}|[[{'var',161,'Indent'}|[{'type',161,'integer',[]}]]]]}|[{'type',162,'constraint',[{'atom',162,'is_subtype'}|[[{'var',162,'Options'}|[{'user_type',162,'options',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'expr',1},[{'type',168,'bounded_fun',[{'type',168,'fun',[{'type',168,'product',[{'var',168,'Expression'}]}|[{'remote_type',168,[{'atom',168,'io_lib'}|[{'atom',168,'chars'}|[[]]]]}]]}|[[{'type',169,'constraint',[{'atom',169,'is_subtype'}|[[{'var',169,'Expression'}|[{'remote_type',169,[{'atom',169,'erl_parse'}|[{'atom',169,'abstract_expr'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'expr',2},[{'type',175,'bounded_fun',[{'type',175,'fun',[{'type',175,'product',[{'var',175,'Expression'}|[{'var',175,'Options'}]]}|[{'remote_type',175,[{'atom',175,'io_lib'}|[{'atom',175,'chars'}|[[]]]]}]]}|[[{'type',176,'constraint',[{'atom',176,'is_subtype'}|[[{'var',176,'Expression'}|[{'remote_type',176,[{'atom',176,'erl_parse'}|[{'atom',176,'abstract_expr'}|[[]]]]}]]]]}|[{'type',177,'constraint',[{'atom',177,'is_subtype'}|[[{'var',177,'Options'}|[{'user_type',177,'options',[]}]]]]}]]]]}]}]
, 'spec' = [{{'expr',3},[{'type',183,'bounded_fun',[{'type',183,'fun',[{'type',183,'product',[{'var',183,'Expression'}|[{'var',183,'Indent'}|[{'var',183,'Options'}]]]}|[{'remote_type',183,[{'atom',183,'io_lib'}|[{'atom',183,'chars'}|[[]]]]}]]}|[[{'type',184,'constraint',[{'atom',184,'is_subtype'}|[[{'var',184,'Expression'}|[{'remote_type',184,[{'atom',184,'erl_parse'}|[{'atom',184,'abstract_expr'}|[[]]]]}]]]]}|[{'type',185,'constraint',[{'atom',185,'is_subtype'}|[[{'var',185,'Indent'}|[{'type',185,'integer',[]}]]]]}|[{'type',186,'constraint',[{'atom',186,'is_subtype'}|[[{'var',186,'Options'}|[{'user_type',186,'options',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'expr',4},[{'type',192,'bounded_fun',[{'type',192,'fun',[{'type',192,'product',[{'var',192,'Expression'}|[{'var',192,'Indent'}|[{'var',192,'Precedence'}|[{'var',192,'Options'}]]]]}|[{'remote_type',192,[{'atom',192,'io_lib'}|[{'atom',192,'chars'}|[[]]]]}]]}|[[{'type',193,'constraint',[{'atom',193,'is_subtype'}|[[{'var',193,'Expression'}|[{'remote_type',193,[{'atom',193,'erl_parse'}|[{'atom',193,'abstract_expr'}|[[]]]]}]]]]}|[{'type',194,'constraint',[{'atom',194,'is_subtype'}|[[{'var',194,'Indent'}|[{'type',194,'integer',[]}]]]]}|[{'type',195,'constraint',[{'atom',195,'is_subtype'}|[[{'var',195,'Precedence'}|[{'type',195,'non_neg_integer',[]}]]]]}|[{'type',196,'constraint',[{'atom',196,'is_subtype'}|[[{'var',196,'Options'}|[{'user_type',196,'options',[]}]]]]}]]]]]]}]}] ] 'form'/1 = fun (_0) -> apply 'form'/2 (_0,'none')
'form'/2 = fun (_0,_1) -> let <State> = apply 'state'/1 (_1) in let <_3> = apply 'options'/1 (_1) in let <_4> = apply 'lform'/2 (_0,_3) in apply 'frmt'/2 (_4,State)
'attribute'/1 = fun (_0) -> apply 'attribute'/2 (_0,'none')
'attribute'/2 = fun (_0,_1) -> let <State> = apply 'state'/1 (_1) in let <_3> = apply 'options'/1 (_1) in let <_4> = apply 'lattribute'/2 (_0,_3) in apply 'frmt'/2 (_4,State)
'function'/1 = fun (_0) -> apply 'function'/2 (_0,'none')
'function'/2 = fun (_0,_1) -> let <_3> = apply 'options'/1 (_1) in let <_4> = apply 'lfunction'/2 (_0,_3) in let <_2> = apply 'state'/1 (_1) in apply 'frmt'/2 (_4,_2)
'guard'/1 = fun (_0) -> apply 'guard'/2 (_0,'none')
'guard'/2 = fun (_0,_1) -> let <_3> = apply 'options'/1 (_1) in let <_4> = apply 'lguard'/2 (_0,_3) in let <_2> = apply 'state'/1 (_1) in apply 'frmt'/2 (_4,_2)
'exprs'/1 = fun (_0) -> apply 'exprs'/3 (_0,0,'none')
'exprs'/2 = fun (_0,_1) -> apply 'exprs'/3 (_0,0,_1)
'exprs'/3 = fun (_0,_1,_2) -> let <_4> = apply 'options'/1 (_2) in let <_5> = apply 'lexprs'/2 (_0,_4) in let <_3> = apply 'state'/1 (_2) in apply 'frmt'/3 ({'seq',[],[],[44],_5},_1,_3)
'expr'/1 = fun (_0) -> let <_2> = apply 'options'/1 ('none') in let <_3> = apply 'lexpr'/3 (_0,0,_2) in let <_1> = apply 'state'/1 ('none') in apply 'frmt'/2 (_3,_1)
'expr'/2 = fun (_0,_1) -> let <_3> = apply 'options'/1 (_1) in let <_4> = apply 'lexpr'/3 (_0,0,_3) in let <_2> = apply 'state'/1 (_1) in apply 'frmt'/2 (_4,_2)
'expr'/3 = fun (_0,_1,_2) -> let <_4> = apply 'options'/1 (_2) in let <_5> = apply 'lexpr'/3 (_0,0,_4) in let <_3> = apply 'state'/1 (_2) in apply 'frmt'/3 (_5,_1,_3)
'expr'/4 = fun (_0,_1,_2,_3) -> let <_5> = apply 'options'/1 (_3) in let <_6> = apply 'lexpr'/3 (_0,_2,_5) in let <_4> = apply 'state'/1 (_3) in apply 'frmt'/3 (_6,_1,_4)
'options'/1 = fun (_0) -> case _0 of <Options> when call 'erlang':'is_list' (_0) -> let <Hook> = call 'proplists':'get_value' ('hook',Options,'none') in let <Encoding> = apply 'encoding'/1 (Options) in {'options',Hook,Encoding,Options}
<Hook> when 'true' -> let <_3> = apply 'encoding'/1 ([]) in {'options',Hook,_3,Hook} end
'state'/1 = fun (_0) -> case _0 of <Options> when call 'erlang':'is_list' (_0) -> let <Quote> = call 'proplists':'get_bool' ('quote_singleton_atom_types',Options) in let <_3> = case apply 'encoding'/1 (Options) of <'latin1'> when 'true' -> apply 'latin1_state'/1 (Quote)
<'unicode'> when 'true' -> apply 'unicode_state'/1 (Quote)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end in let <Indent> = call 'proplists':'get_value' ('indent',Options,4) in let <LineWidth> = call 'proplists':'get_value' ('linewidth',Options,72) in case _3 of <{'pp',_11,_12,_13,_14,_15,_16}> when 'true' -> let <_8> = call 'erlang':'setelement' (7,_3,Indent) in call 'erlang':'setelement' (6,_8,LineWidth)
(<_17> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<_X_Hook> when 'true' -> apply 'latin1_state'/1 ('false') end
'latin1_state'/1 = fun (_0) -> let <ValueFun> = fun (_2) -> call 'io_lib_pretty':'print' (_2,[{'encoding','latin1'}]) in let <_9> = case _0 of <'true'> when 'true' -> (fun (_6) -> let <_5> = call 'erlang':'atom_to_list' (_6) in call 'io_lib':'write_string_as_latin1' (_5,39)-|[{'id',{0,0,'-latin1_state/1-fun-1-'}}] )
<'false'> when 'true' -> ValueFun
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end in {'pp',ValueFun,_9,fun 'io_lib':'write_string_as_latin1'/1,fun 'io_lib':'write_char_as_latin1'/1,72,4}
'unicode_state'/1 = fun (_0) -> let <ValueFun> = fun (_2) -> call 'io_lib_pretty':'print' (_2,[{'encoding','unicode'}]) in let <_9> = case _0 of <'true'> when 'true' -> (fun (_6) -> let <_5> = call 'erlang':'atom_to_list' (_6) in call 'io_lib':'write_string' (_5,39)-|[{'id',{0,0,'-unicode_state/1-fun-1-'}}] )
<'false'> when 'true' -> ValueFun
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end in {'pp',ValueFun,_9,fun 'io_lib':'write_string'/1,fun 'io_lib':'write_char'/1,72,4}
'encoding'/1 = fun (_0) -> let <_1> = call 'epp':'default_encoding' () in case call 'proplists':'get_value' ('encoding',_0,_1) of <'latin1'> when 'true' -> 'latin1'
<'utf8'> when 'true' -> 'unicode'
<'unicode'> when 'true' -> 'unicode'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'lform'/2 = fun (_0,_1) -> case <_0,_1> of <_@r0 = {'attribute',Line,Name,Arg},Opts> when 'true' -> apply 'lattribute'/2 (_@r0,Opts)
<_@r1 = {'function',Line,Name,Arity,Clauses},Opts> when 'true' -> apply 'lfunction'/2 (_@r1,Opts)
<E = {'error',_4},Opts> when 'true' -> apply 'message'/2 (E,Opts)
<W = {'warning',_5},Opts> when 'true' -> apply 'message'/2 (W,Opts)
<{'eof',_X_Line},_X_Opts> when 'true' -> 10
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'lform',2}}] )-|['compiler_generated'] ) end
'message'/2 = fun (_0,_1) -> case <_0,_1> of <M,{'options',_8,Encoding,_9}> when 'true' -> let <_3> = case Encoding of <'latin1'> when 'true' -> [126|[112|[10]]]
<'unicode'> when 'true' -> [126|[116|[112|[10]]]]
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end in let <_5> = call 'io_lib':'format' (_3,[M|[]]) in apply 'leaf'/1 (_5)
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'message',2}}] )-|['compiler_generated'] ) end
'lattribute'/2 = fun (_0,_1) -> case <_0,_1> of <{'attribute',_X_Line,'type',Type},Opts> when 'true' -> let <_2> = apply 'typeattr'/3 ('type',Type,Opts) in let <_3> = apply 'leaf'/1 ([46|[10]]) in [_2|[_3|[]]]
<{'attribute',_X_Line,'opaque',Type},Opts> when 'true' -> let <_4> = apply 'typeattr'/3 ('opaque',Type,Opts) in let <_5> = apply 'leaf'/1 ([46|[10]]) in [_4|[_5|[]]]
<{'attribute',_X_Line,'spec',Arg},_X_Opts> when 'true' -> let <_6> = apply 'specattr'/2 ('spec',Arg) in let <_7> = apply 'leaf'/1 ([46|[10]]) in [_6|[_7|[]]]
<{'attribute',_X_Line,'callback',Arg},_X_Opts> when 'true' -> let <_8> = apply 'specattr'/2 ('callback',Arg) in let <_9> = apply 'leaf'/1 ([46|[10]]) in [_8|[_9|[]]]
<{'attribute',_X_Line,Name,Arg},Opts> when 'true' -> let <_10> = apply 'lattribute'/3 (Name,Arg,Opts) in let <_11> = apply 'leaf'/1 ([46|[10]]) in [_10|[_11|[]]]
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'lattribute',2}}] )-|['compiler_generated'] ) end
'lattribute'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'module',{M,Vs},_X_Opts> when 'true' -> let <A> = apply 'a0'/0 () in let <_4> = apply 'pname'/1 (M) in let <_9> = fun (_6,_5) -> {'cons',A,{'var',A,_6},_5} in let <_10> = call 'lists':'foldr' (_9,{'nil',A},Vs) in apply 'attr'/2 ('module',[{'var',A,_4}|[_10|[]]])
<'module',M,_X_Opts> when 'true' -> let <_12> = apply 'a0'/0 () in let <_11> = apply 'pname'/1 (M) in apply 'attr'/2 ('module',[{'var',_12,_11}|[]])
<'export',Falist,_X_Opts> when 'true' -> let <_13> = apply 'falist'/1 (Falist) in apply 'attrib'/2 ('export',_13)
<'import',Name,_X_Opts> when call 'erlang':'is_list' (Name) -> let <_15> = apply 'a0'/0 () in let <_14> = apply 'pname'/1 (Name) in apply 'attr'/2 ('import',[{'var',_15,_14}|[]])
<'import',{From,Falist},_X_Opts> when 'true' -> let <_16> = apply 'pname'/1 (From) in let <_17> = apply 'leaf'/1 (_16) in let <_18> = apply 'falist'/1 (Falist) in apply 'attrib'/2 ('import',[_17|[_18|[]]])
<'export_type',Talist,_X_Opts> when 'true' -> let <_19> = apply 'falist'/1 (Talist) in apply 'attrib'/2 ('export_type',_19)
<'optional_callbacks',Falist,Opts> when 'true' -> try let <_20> = apply 'falist'/1 (Falist) in apply 'attrib'/2 ('optional_callbacks',_20) of <_21> -> _21 catch <_24,_23,_22> -> let <_25> = apply 'abstract'/2 (Falist,Opts) in apply 'attr'/2 ('optional_callbacks',[_25|[]])
<'file',{Name,Line},_X_Opts> when 'true' -> let <_26> = apply 'a0'/0 () in let <_27> = apply 'a0'/0 () in apply 'attr'/2 ('file',[{'string',_26,Name}|[{'integer',_27,Line}|[]]])
<'record',{Name,Is},Opts> when 'true' -> let <_28> = apply 'leaf'/1 ([45|[114|[101|[99|[111|[114|[100|[40]]]]]]]]) in let <Nl> = [_28|[{'atom',Name}|[44]]] in let <_30> = apply 'record_fields'/2 (Is,Opts) in [{'first',Nl,_30}|[41]]
<Name,Arg,Options> when 'true' -> let <_31> = apply 'abstract'/2 (Arg,Options) in apply 'attr'/2 (Name,[_31|[]]) end
'abstract'/2 = fun (_0,_1) -> case <_0,_1> of <Arg,{'options',_4,Encoding,_5}> when 'true' -> call 'erl_parse':'abstract' (Arg,[{'encoding',Encoding}|[]])
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'abstract',2}}] )-|['compiler_generated'] ) end
'typeattr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Tag,{TypeName,Type,Args},_X_Opts> when 'true' -> let <_7> = call 'erlang':'atom_to_list' (Tag) in let <_8> = call 'erlang':'++' (_7,[32]) in let <_9> = [45|_8] in let <_10> = apply 'leaf'/1 (_9) in let <_4> = apply 'a0'/0 () in let <_3> = apply 'options'/1 ('none') in let <_5> = apply 'call'/4 ({'atom',_4,TypeName},Args,0,_3) in let <_6> = apply 'typed'/2 (_5,Type) in {'first',_10,_6}
(<_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11})-|[{'function_name',{'typeattr',3}}] )-|['compiler_generated'] ) end
'ltype'/1 = fun (_0) -> apply 'ltype'/2 (_0,0)
'ltype'/2 = fun (_0,_1) -> case <_0,_1> of <{'ann_type',_X_Line,[V|[T|[]]]},Prec> when 'true' -> case call 'erl_parse':'type_inop_prec' ('::') of <{L,P,R}> when 'true' -> let <Vl> = apply 'ltype'/2 (V,L) in let <Tr> = apply 'ltype'/2 (T,R) in let <El> = {'list',[{'cstep',[Vl|[' ::']],Tr}|[]]} in apply 'maybe_paren'/3 (P,Prec,El)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{'paren_type',_X_Line,[T|[]]},P> when 'true' -> apply 'ltype'/2 (T,P)
<{'type',_X_Line,'union',Ts},Prec> when 'true' -> case call 'erl_parse':'type_inop_prec' ('|') of <{_X_L,P,R}> when 'true' -> let <_7> = apply 'ltypes'/2 (Ts,R) in let <E> = {'seq',[],[],[' |'],_7} in apply 'maybe_paren'/3 (P,Prec,E)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<{'type',_X_Line,'list',[T|[]]},_31> when 'true' -> let <_9> = apply 'ltype'/1 (T) in {'seq',91,93,44,[_9|[]]}
<{'type',_X_Line,'nonempty_list',[T|[]]},_32> when 'true' -> let <_10> = apply 'ltype'/1 (T) in let <_11> = apply 'leaf'/1 ([46|[46|[46]]]) in {'seq',91,93,[44],[_10|[_11|[]]]}
<{'type',Line,'nil',[]},_33> when 'true' -> let <_12> = apply 'options'/1 ('none') in apply 'lexpr'/2 ({'nil',Line},_12)
<{'type',Line,'map','any'},_34> when 'true' -> apply 'simple_type'/2 ({'atom',Line,'map'},[])
<{'type',_X_Line,'map',Pairs},Prec> when 'true' -> case call 'erl_parse':'type_preop_prec' ('#') of <{P,_X_R}> when 'true' -> let <E> = apply 'map_type'/1 (Pairs) in apply 'maybe_paren'/3 (P,Prec,E)
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<{'type',Line,'tuple','any'},_35> when 'true' -> apply 'simple_type'/2 ({'atom',Line,'tuple'},[])
<{'type',_X_Line,'tuple',Ts},_36> when 'true' -> let <_15> = 'ltype'/2 in apply 'tuple_type'/2 (Ts,_15)
<{'type',_X_Line,'record',[{'atom',_37,N}|Fs]},Prec> when 'true' -> case call 'erl_parse':'type_preop_prec' ('#') of <{P,_X_R}> when 'true' -> let <E> = apply 'record_type'/2 (N,Fs) in apply 'maybe_paren'/3 (P,Prec,E)
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
<{'type',_X_Line,'range',Es = [_X_I1|[_X_I2|[]]]},Prec> when 'true' -> case call 'erl_parse':'type_inop_prec' ('..') of <{_X_L,P,R}> when 'true' -> let <F> = fun (_20,_19) -> apply 'lexpr'/3 (_20,R,_19) in let <_24> = apply 'options'/1 ('none') in let <E> = apply 'expr_list'/4 (Es,'..',F,_24) in apply 'maybe_paren'/3 (P,Prec,E)
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
<{'type',_X_Line,'binary',[I1|[I2|[]]]},_38> when 'true' -> apply 'binary_type'/2 (I1,I2)
<{'type',_X_Line,'fun',[]},_39> when 'true' -> apply 'leaf'/1 ([102|[117|[110|[40|[41]]]]])
<FunType = {'type',_40,'fun',[{'type',_41,'any'}|[_42|[]]]},_43> when 'true' -> let <_26> = apply 'fun_type'/2 (['fun'|[40]],FunType) in [_26|[41]]
<FunType = {'type',_X_Line,'fun',[{'type',_44,'product',_45}|[_46|[]]]},_47> when 'true' -> let <_27> = apply 'fun_type'/2 (['fun'|[40]],FunType) in [_27|[41]]
<{'type',Line,T,Ts},_48> when 'true' -> apply 'simple_type'/2 ({'atom',Line,T},Ts)
<{'user_type',Line,T,Ts},_49> when 'true' -> apply 'simple_type'/2 ({'atom',Line,T},Ts)
<{'remote_type',Line,[M|[F|[Ts|[]]]]},_50> when 'true' -> apply 'simple_type'/2 ({'remote',Line,M,F},Ts)
<{'atom',_51,T},_52> when 'true' -> {'singleton_atom_type',T}
<E,P> when 'true' -> let <_28> = apply 'options'/1 ('none') in apply 'lexpr'/3 (E,P,_28) end
'binary_type'/2 = fun (_0,_1) -> let <_6> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{'integer',_28,0}|_3]> when 'true' -> let <_5> = apply 'lc$^0'/1 (_3) in ([[]|_5]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_30> when 'true' -> (primop 'match_fail' ({'function_clause',_30})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([_0|[]]) in let <B> = call 'erlang':'=:=' (_6,[]) in let <_12> = letrec 'lc$^1'/1 = fun (_10) -> case _10 of <[{'integer',_29,0}|_9]> when 'true' -> let <_11> = apply 'lc$^1'/1 (_9) in ([[]|_11]-|['compiler_generated'] )
(<[_8|_9]> when 'true' -> apply 'lc$^1'/1 (_9)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_31> when 'true' -> (primop 'match_fail' ({'function_clause',_31})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 ([_1|[]]) in let <U> = call 'erlang':'=:=' (_12,[]) in let <P> = call 'erl_parse':'max_prec' () in let <_18> = case <> of <> when B -> let <_15> = apply 'leaf'/1 ([95|[58]]) in let <_16> = apply 'options'/1 ('none') in let <_17> = apply 'lexpr'/3 (_0,P,_16) in ([[_15|[_17|[]]]|[]]-|['compiler_generated'] )
(<> when 'true' -> []-|['compiler_generated'] ) end in let <_23> = case <> of <> when U -> let <_20> = apply 'leaf'/1 ([95|[58|[95|[42]]]]) in let <_21> = apply 'options'/1 ('none') in let <_22> = apply 'lexpr'/3 (_1,P,_21) in ([[_20|[_22|[]]]|[]]-|['compiler_generated'] )
(<> when 'true' -> []-|['compiler_generated'] ) end in case call 'erlang':'++' (_18,_23) of <[]> when 'true' -> apply 'leaf'/1 ([60|[60|[62|[62]]]])
<Es> when 'true' -> {'seq','<<','>>',[44],Es} end
'map_type'/1 = fun (_0) -> let <_1> = apply 'map_pair_types'/1 (_0) in {'first',[35],_1}
'map_pair_types'/1 = fun (_0) -> let <_1> = 'map_pair_type'/2 in apply 'tuple_type'/2 (_0,_1)
'map_pair_type'/2 = fun (_0,_1) -> case <_0,_1> of <{'type',_X_Line,'map_field_assoc',[KType|[VType|[]]]},Prec> when 'true' -> let <_3> = apply 'ltype'/2 (KType,Prec) in let <_4> = apply 'leaf'/1 ([32|[61|[62]]]) in let <_2> = apply 'ltype'/2 (VType,Prec) in {'list',[{'cstep',[_3|[_4|[]]],_2}|[]]}
<{'type',_X_Line,'map_field_exact',[KType|[VType|[]]]},Prec> when 'true' -> let <_6> = apply 'ltype'/2 (KType,Prec) in let <_7> = apply 'leaf'/1 ([32|[58|[61]]]) in let <_5> = apply 'ltype'/2 (VType,Prec) in {'list',[{'cstep',[_6|[_7|[]]],_5}|[]]}
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'map_pair_type',2}}] )-|['compiler_generated'] ) end
'record_type'/2 = fun (_0,_1) -> let <_3> = apply 'record_name'/1 (_0) in let <_2> = apply 'field_types'/1 (_1) in {'first',[_3|[]],_2}
'field_types'/1 = fun (_0) -> let <_1> = 'field_type'/2 in apply 'tuple_type'/2 (_0,_1)
'field_type'/2 = fun (_0,_1) -> case <_0,_1> of <{'type',_X_Line,'field_type',[Name|[Type|[]]]},_X_Prec> when 'true' -> let <_2> = apply 'options'/1 ('none') in let <_3> = apply 'lexpr'/2 (Name,_2) in apply 'typed'/2 (_3,Type)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'field_type',2}}] )-|['compiler_generated'] ) end
'typed'/2 = fun (_0,_1) -> let <_2> = apply 'ltype'/1 (_1) in {'list',[{'cstep',[_0|[' ::']],_2}|[]]}
'tuple_type'/2 = fun (_0,_1) -> case <_0,_1> of <[],_5> when 'true' -> apply 'leaf'/1 ([123|[125]])
<Ts,F> when 'true' -> let <_2> = apply 'ltypes'/3 (Ts,F,0) in {'seq',123,125,[44],_2} end
'specattr'/2 = fun (_0,_1) -> case <_0,_1> of <SpecKind,{FuncSpec,TypeSpecs}> when 'true' -> let <_3> = case FuncSpec of <{F,_X_A}> when 'true' -> {'atom',F}
<{M,F,_X_A}> when 'true' -> [{'atom',M}|[58|[{'atom',F}|[]]]]
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end in let <_6> = call 'lists':'concat' ([[45]|[SpecKind|[[32]]]]) in let <_7> = apply 'leaf'/1 (_6) in let <_5> = apply 'spec_clauses'/1 (TypeSpecs) in {'first',_7,{'list',[{'first',_3,_5}|[]]}}
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'specattr',2}}] )-|['compiler_generated'] ) end
'spec_clauses'/1 = fun (_0) -> let <_6> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[T|_2]> when 'true' -> let <_4> = apply 'sig_type'/1 (T) in let <_5> = apply 'lc$^0'/1 (_2) in ([_4|_5]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in {'prefer_nl',[59],_6}
'sig_type'/1 = fun (_0) -> case _0 of <{'type',_X_Line,'bounded_fun',[T|[Gs|[]]]}> when 'true' -> let <_1> = apply 'fun_type'/2 ([],T) in apply 'guard_type'/2 (_1,Gs)
<FunType> when 'true' -> apply 'fun_type'/2 ([],FunType) end
'guard_type'/2 = fun (_0,_1) -> let <Opts> = apply 'options'/1 ('none') in let <_3> = 'constraint'/2 in let <_4> = apply 'expr_list'/4 (_1,[44],_3,Opts) in let <Gl> = {'list',[{'step','when',_4}|[]]} in {'list',[{'step',_0,Gl}|[]]}
'constraint'/2 = fun (_0,_1) -> case <_0,_1> of <{'type',_X_Line,'constraint',[{'atom',_6,'is_subtype'}|[[V = {'var',_7,_8}|[Type|[]]]|[]]]},_X_Opts> when 'true' -> let <_2> = apply 'options'/1 ('none') in let <_3> = apply 'lexpr'/2 (V,_2) in apply 'typed'/2 (_3,Type)
<{'type',_X_Line,'constraint',[Tag|[As|[]]]},_X_Opts> when 'true' -> apply 'simple_type'/2 (Tag,As)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'constraint',2}}] )-|['compiler_generated'] ) end
'fun_type'/2 = fun (_0,_1) -> case <_0,_1> of <Before,{'type',_6,'fun',[FType|[Ret|[]]]}> when 'true' -> let <_3> = apply 'type_args'/1 (FType) in let <_2> = apply 'ltype'/1 (Ret) in {'first',Before,{'step',[_3|[' ->']],_2}}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'fun_type',2}}] )-|['compiler_generated'] ) end
'type_args'/1 = fun (_0) -> case _0 of <{'type',_X_Line,'any'}> when 'true' -> apply 'leaf'/1 ([40|[46|[46|[46|[41]]]]])
<{'type',_X_line,'product',Ts}> when 'true' -> apply 'targs'/1 (Ts)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'type_args',1}}] )-|['compiler_generated'] ) end
'simple_type'/2 = fun (_0,_1) -> let <_3> = apply 'options'/1 ('none') in let <_4> = apply 'lexpr'/2 (_0,_3) in let <_2> = apply 'targs'/1 (_1) in {'first',_4,_2}
'targs'/1 = fun (_0) -> let <_1> = apply 'ltypes'/2 (_0,0) in {'seq',40,41,[44],_1}
'ltypes'/2 = fun (_0,_1) -> let <_2> = 'ltype'/2 in apply 'ltypes'/3 (_0,_2,_1)
'ltypes'/3 = fun (_0,_1,_2) -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[T|_4]> when 'true' -> let <_6> = apply _1 (T,_2) in let <_7> = apply 'lc$^0'/1 (_4) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'attr'/2 = fun (_0,_1) -> let <_2> = apply 'options'/1 ('none') in let <_3> = apply 'args'/2 (_1,_2) in {'first',[45|[{'atom',_0}|[]]],_3}
'attrib'/2 = fun (_0,_1) -> {'first',[45|[{'atom',_0}|[]]],[{'seq',40,41,[44],_1}|[]]}
'pname'/1 = fun (_0) -> case _0 of <[''|As]> when 'true' -> let <_1> = apply 'pname'/1 (As) in [46|_1]
<[A|[]]> when 'true' -> call 'io_lib':'write' (A)
<[A|As]> when 'true' -> let <_2> = call 'io_lib':'write' (A) in let <_3> = apply 'pname'/1 (As) in [_2|[46|_3]]
<A> when call 'erlang':'is_atom' (_0) -> call 'io_lib':'write' (A)
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'pname',1}}] )-|['compiler_generated'] ) end
'falist'/1 = fun (_0) -> case _0 of <[]> when 'true' -> ['[]']
<Falist> when 'true' -> let <_8> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[Fa|_2]> when 'true' -> case Fa of <{Name,Arity}> when 'true' -> let <_5> = call 'io_lib':'format' ([47|[126|[119]]],[Arity|[]]) in let <_6> = apply 'leaf'/1 (_5) in let <_7> = apply 'lc$^0'/1 (_2) in ([[{'atom',Name}|[_6|[]]]|_7]-|['compiler_generated'] )
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Falist) in [{'seq',91,93,44,_8}|[]] end
'lfunction'/2 = fun (_0,_1) -> case <_0,_1> of <{'function',_X_Line,Name,_X_Arity,Cs},Opts> when 'true' -> let <_6> = fun (_3,_2) -> apply 'func_clause'/3 (Name,_3,_2) in let <Cll> = apply 'nl_clauses'/4 (_6,59,Opts,Cs) in let <_8> = apply 'leaf'/1 ([46|[10]]) in [Cll|[_8|[]]]
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'lfunction',2}}] )-|['compiler_generated'] ) end
'func_clause'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Name,{'clause',Line,Head,Guard,Body},Opts> when 'true' -> let <Hl> = apply 'call'/4 ({'atom',Line,Name},Head,0,Opts) in let <Gl> = apply 'guard_when'/3 (Hl,Guard,Opts) in let <Bl> = apply 'body'/2 (Body,Opts) in {'step',Gl,Bl}
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'func_clause',3}}] )-|['compiler_generated'] ) end
'guard_when'/3 = fun (_0,_1,_2) -> apply 'guard_when'/4 (_0,_1,_2,' ->')
'guard_when'/4 = fun (_0,_1,_2,_3) -> let <Gl> = apply 'lguard'/2 (_1,_2) in [{'list',[{'step',_0,Gl}|[]]}|[_3|[]]]
'lguard'/2 = fun (_0,_1) -> case <_0,_1> of <_@r0 = [E|Es],Opts> when call 'erlang':'is_list' (E) -> let <_2> = 'guard0'/2 in let <_3> = apply 'expr_list'/4 (_@r0,[59],_2,Opts) in {'list',[{'step','when',_3}|[]]}
<_@r1 = [E|Es],Opts> when 'true' -> apply 'lguard'/2 ([_@r1|[]],Opts)
<[],_6> when 'true' -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'lguard',2}}] )-|['compiler_generated'] ) end
'guard0'/2 = fun (_0,_1) -> let <_2> = 'lexpr'/2 in apply 'expr_list'/4 (_0,[44],_2,_1)
'body'/2 = fun (_0,_1) -> case <_0,_1> of <[E|[]],Opts> when 'true' -> apply 'lexpr'/2 (E,Opts)
<Es,Opts> when 'true' -> let <_2> = apply 'lexprs'/2 (Es,Opts) in {'prefer_nl',[44],_2} end
'lexpr'/2 = fun (_0,_1) -> apply 'lexpr'/3 (_0,0,_1)
'lexpr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'var',_135,V},_136,_137> when call 'erlang':'is_integer' (V) -> let <_3> = call 'io_lib':'format' ([95|[126|[119]]],[V|[]]) in apply 'leaf'/1 (_3)
<{'var',_138,V},_139,_140> when 'true' -> let <_4> = call 'io_lib':'format' ([126|[116|[115]]],[V|[]]) in apply 'leaf'/1 (_4)
<{'char',_141,C},_142,_143> when 'true' -> {'char',C}
<{'integer',_144,N},_145,_146> when 'true' -> let <_5> = call 'io_lib':'write' (N) in apply 'leaf'/1 (_5)
<{'float',_147,F},_148,_149> when 'true' -> let <_6> = call 'io_lib':'write' (F) in apply 'leaf'/1 (_6)
<{'atom',_150,A},_151,_152> when 'true' -> {'atom',A}
<{'string',_153,S},_154,_155> when 'true' -> {'string',S}
<{'nil',_156},_157,_158> when 'true' -> '[]'
<{'cons',_159,H,T},_160,Opts> when 'true' -> apply 'list'/3 (T,[H|[]],Opts)
<{'lc',_161,E,Qs},_X_Prec,Opts> when 'true' -> let <P> = call 'erl_parse':'max_prec' () in let <_9> = apply 'lexpr'/3 (E,P,Opts) in let <_10> = apply 'leaf'/1 ([32|[124|[124]]]) in let <_8> = apply 'lc_quals'/2 (Qs,Opts) in let <Lcl> = {'list',[{'step',[_9|[_10|[]]],_8}|[]]} in let <_12> = apply 'leaf'/1 ([32]) in {'list',[{'seq',91,[],[[]],[{'force_nl',_12,[Lcl|[]]}|[]]}|[93]]}
<{'bc',_162,E,Qs},_X_Prec,Opts> when 'true' -> let <P> = call 'erl_parse':'max_prec' () in let <_15> = apply 'lexpr'/3 (E,P,Opts) in let <_16> = apply 'leaf'/1 ([32|[124|[124]]]) in let <_14> = apply 'lc_quals'/2 (Qs,Opts) in let <Lcl> = {'list',[{'step',[_15|[_16|[]]],_14}|[]]} in let <_18> = apply 'leaf'/1 ([32]) in {'list',[{'seq','<<',[],[[]],[{'force_nl',_18,[Lcl|[]]}|[]]}|['>>']]}
<{'tuple',_163,Elts},_164,Opts> when 'true' -> apply 'tuple'/2 (Elts,Opts)
<{'record_index',_165,Name,F},Prec,Opts> when 'true' -> case call 'erl_parse':'preop_prec' ('#') of <{P,R}> when 'true' -> let <Nl> = apply 'record_name'/1 (Name) in let <_21> = apply 'lexpr'/3 (F,R,Opts) in let <El> = [Nl|[46|[_21|[]]]] in apply 'maybe_paren'/3 (P,Prec,El)
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<{'record',_166,Name,Fs},Prec,Opts> when 'true' -> case call 'erl_parse':'preop_prec' ('#') of <{P,_X_R}> when 'true' -> let <Nl> = apply 'record_name'/1 (Name) in let <_25> = apply 'record_fields'/2 (Fs,Opts) in let <El> = {'first',Nl,_25} in apply 'maybe_paren'/3 (P,Prec,El)
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end
<{'record_field',_167,Rec,Name,F},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('#') of <{L,P,R}> when 'true' -> let <Rl> = apply 'lexpr'/3 (Rec,L,Opts) in let <Sep> = apply 'hash_after_integer'/2 (Rec,[35]) in let <Nl> = [Sep|[{'atom',Name}|[46]]] in let <_31> = apply 'lexpr'/3 (F,R,Opts) in let <El> = [Rl|[Nl|[_31|[]]]] in apply 'maybe_paren'/3 (P,Prec,El)
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end
<{'record',_168,Rec,Name,Fs},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('#') of <{L,P,_X_R}> when 'true' -> let <Rl> = apply 'lexpr'/3 (Rec,L,Opts) in let <Sep> = apply 'hash_after_integer'/2 (Rec,[]) in let <Nl> = apply 'record_name'/1 (Name) in let <_37> = apply 'record_fields'/2 (Fs,Opts) in let <El> = {'first',[Rl|[Sep|[Nl|[]]]],_37} in apply 'maybe_paren'/3 (P,Prec,El)
(<_33> when 'true' -> primop 'match_fail' ({'badmatch',_33})-|['compiler_generated'] ) end
<{'record_field',_169,{'atom',_170,''},F},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('.') of <{_X_L,P,R}> when 'true' -> let <_40> = apply 'lexpr'/3 (F,R,Opts) in let <El> = [46|[_40|[]]] in apply 'maybe_paren'/3 (P,Prec,El)
(<_39> when 'true' -> primop 'match_fail' ({'badmatch',_39})-|['compiler_generated'] ) end
<{'record_field',_171,Rec,F},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('.') of <{L,P,R}> when 'true' -> let <_43> = apply 'lexpr'/3 (Rec,L,Opts) in let <_44> = apply 'lexpr'/3 (F,R,Opts) in let <El> = [_43|[46|[_44|[]]]] in apply 'maybe_paren'/3 (P,Prec,El)
(<_42> when 'true' -> primop 'match_fail' ({'badmatch',_42})-|['compiler_generated'] ) end
<{'map',_172,Fs},Prec,Opts> when 'true' -> case call 'erl_parse':'preop_prec' ('#') of <{P,_X_R}> when 'true' -> let <_47> = apply 'map_fields'/2 (Fs,Opts) in let <El> = {'first',35,_47} in apply 'maybe_paren'/3 (P,Prec,El)
(<_46> when 'true' -> primop 'match_fail' ({'badmatch',_46})-|['compiler_generated'] ) end
<{'map',_173,Map,Fs},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('#') of <{L,P,_X_R}> when 'true' -> let <Rl> = apply 'lexpr'/3 (Map,L,Opts) in let <Sep> = apply 'hash_after_integer'/2 (Map,[35]) in let <_52> = apply 'map_fields'/2 (Fs,Opts) in let <El> = {'first',[Rl|Sep],_52} in apply 'maybe_paren'/3 (P,Prec,El)
(<_49> when 'true' -> primop 'match_fail' ({'badmatch',_49})-|['compiler_generated'] ) end
<{'block',_174,Es},_175,Opts> when 'true' -> let <_54> = apply 'body'/2 (Es,Opts) in {'list',[{'step','begin',_54}|[{'reserved','end'}]]}
<{'if',_176,Cs},_177,Opts> when 'true' -> let <_55> = apply 'if_clauses'/2 (Cs,Opts) in {'list',[{'step','if',_55}|[{'reserved','end'}]]}
<{'case',_178,Expr,Cs},_179,Opts> when 'true' -> let <_57> = apply 'lexpr'/2 (Expr,Opts) in let <_56> = apply 'cr_clauses'/2 (Cs,Opts) in {'list',[{'step',{'list',[{'step','case',_57}|[{'reserved','of'}]]},_56}|[{'reserved','end'}]]}
<{'cond',_180,Cs},_181,Opts> when 'true' -> let <_59> = apply 'leaf'/1 ([99|[111|[110|[100]]]]) in let <_58> = apply 'cond_clauses'/2 (Cs,Opts) in {'list',[{'step',_59,_58}|[{'reserved','end'}]]}
<{'receive',_182,Cs},_183,Opts> when 'true' -> let <_60> = apply 'cr_clauses'/2 (Cs,Opts) in {'list',[{'step','receive',_60}|[{'reserved','end'}]]}
<{'receive',_184,Cs,To,ToOpt},_185,Opts> when 'true' -> let <_62> = apply 'lexpr'/2 (To,Opts) in let <_61> = apply 'body'/2 (ToOpt,Opts) in let <Al> = {'list',[{'step',[_62|[' ->']],_61}|[]]} in let <_64> = apply 'cr_clauses'/2 (Cs,Opts) in {'list',[{'step','receive',_64}|[{'step','after',Al}|[{'reserved','end'}]]]}
<{'fun',_186,{'function',F,A}},_X_Prec,_X_Opts> when 'true' -> let <_65> = apply 'leaf'/1 ([102|[117|[110|[32]]]]) in let <_66> = call 'io_lib':'format' ([47|[126|[119]]],[A|[]]) in let <_67> = apply 'leaf'/1 (_66) in [_65|[{'atom',F}|[_67|[]]]]
<{'fun',L,Func = {'function',_187,_188},Extra},Prec,Opts> when 'true' -> let <_69> = apply 'fun_info'/1 (Extra) in let <_68> = apply 'lexpr'/3 ({'fun',L,Func},Prec,Opts) in {'force_nl',_69,_68}
<{'fun',L,{'function',M,F,A}},Prec,Opts> when try let <_70> = call 'erlang':'is_atom' (M) in let <_71> = call 'erlang':'is_atom' (F) in let <_72> = call 'erlang':'is_integer' (A) in let <_73> = call 'erlang':'and' (_71,_72) in call 'erlang':'and' (_70,_73) of <Try> -> Try catch <T,R> -> 'false' -> let <Mod> = call 'erl_parse':'abstract' (M) in let <Fun> = call 'erl_parse':'abstract' (F) in let <Arity> = call 'erl_parse':'abstract' (A) in apply 'lexpr'/3 ({'fun',L,{'function',Mod,Fun,Arity}},Prec,Opts)
<{'fun',_189,{'function',M,F,A}},_X_Prec,Opts> when 'true' -> let <NameItem> = apply 'lexpr'/2 (M,Opts) in let <CallItem> = apply 'lexpr'/2 (F,Opts) in let <ArityItem> = apply 'lexpr'/2 (A,Opts) in [[102|[117|[110|[32]]]]|[NameItem|[58|[CallItem|[47|[ArityItem|[]]]]]]]
<{'fun',_190,{'clauses',Cs}},_X_Prec,Opts> when 'true' -> let <_80> = apply 'fun_clauses'/3 (Cs,Opts,'unnamed') in {'list',[{'first','fun',_80}|[{'reserved','end'}]]}
<{'named_fun',_191,Name,Cs},_X_Prec,Opts> when 'true' -> let <_81> = apply 'fun_clauses'/3 (Cs,Opts,{'named',Name}) in {'list',[{'first',['fun'|[[32]]],_81}|[{'reserved','end'}]]}
<{'fun',_192,{'clauses',Cs},Extra},_X_Prec,Opts> when 'true' -> let <_83> = apply 'fun_info'/1 (Extra) in let <_82> = apply 'fun_clauses'/3 (Cs,Opts,'unnamed') in {'force_nl',_83,{'list',[{'first','fun',_82}|[{'reserved','end'}]]}}
<{'named_fun',_193,Name,Cs,Extra},_X_Prec,Opts> when 'true' -> let <_85> = apply 'fun_info'/1 (Extra) in let <_84> = apply 'fun_clauses'/3 (Cs,Opts,{'named',Name}) in {'force_nl',_85,{'list',[{'first',['fun'|[[32]]],_84}|[{'reserved','end'}]]}}
<{'call',_194,Name = {'remote',_195,{'atom',_196,M},N = {'atom',_197,F}},Args},Prec,Opts> when 'true' -> let <_86> = call 'erlang':'length' (Args) in case call 'erl_internal':'bif' (M,F,_86) of <'true'> when 'true' -> apply 'call'/4 (N,Args,Prec,Opts)
<'false'> when 'true' -> apply 'call'/4 (Name,Args,Prec,Opts)
(<_87> when 'true' -> primop 'match_fail' ({'case_clause',_87})-|['compiler_generated'] ) end
<{'call',_198,Name,Args},Prec,Opts> when 'true' -> apply 'call'/4 (Name,Args,Prec,Opts)
<{'try',_199,Es,Scs,Ccs,As},_200,Opts> when 'true' -> let <_97> = case <> of <> when call 'erlang':'=:=' (Scs,[]) -> let <_94> = apply 'body'/2 (Es,Opts) in {'step','try',_94}
<> when 'true' -> let <_96> = apply 'body'/2 (Es,Opts) in let <_95> = apply 'cr_clauses'/2 (Scs,Opts) in {'step',{'list',[{'step','try',_96}|[{'reserved','of'}]]},_95} end in let <_92> = case <> of <> when call 'erlang':'=:=' (Ccs,[]) -> []
<> when 'true' -> let <_91> = apply 'try_clauses'/2 (Ccs,Opts) in [{'step','catch',_91}|[]] end in let <_89> = case <> of <> when call 'erlang':'=:=' (As,[]) -> []
<> when 'true' -> let <_88> = apply 'body'/2 (As,Opts) in [{'step','after',_88}|[]] end in let <_90> = call 'erlang':'++' (_89,[{'reserved','end'}]) in let <_93> = call 'erlang':'++' (_92,_90) in let <_98> = [_97|_93] in {'list',_98}
<{'catch',_201,Expr},Prec,Opts> when 'true' -> case call 'erl_parse':'preop_prec' ('catch') of <{P,R}> when 'true' -> let <_100> = apply 'lexpr'/3 (Expr,R,Opts) in let <El> = {'list',[{'step','catch',_100}|[]]} in apply 'maybe_paren'/3 (P,Prec,El)
(<_99> when 'true' -> primop 'match_fail' ({'badmatch',_99})-|['compiler_generated'] ) end
<{'match',_202,Lhs,Rhs},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('=') of <{L,P,R}> when 'true' -> let <Pl> = apply 'lexpr'/3 (Lhs,L,Opts) in let <Rl> = apply 'lexpr'/3 (Rhs,R,Opts) in let <El> = {'list',[{'cstep',[Pl|[' =']],Rl}|[]]} in apply 'maybe_paren'/3 (P,Prec,El)
(<_102> when 'true' -> primop 'match_fail' ({'badmatch',_102})-|['compiler_generated'] ) end
<{'op',_203,Op,Arg},Prec,Opts> when 'true' -> case call 'erl_parse':'preop_prec' (Op) of <{P,R}> when 'true' -> let <_107> = call 'io_lib':'format' ([126|[115|[32]]],[Op|[]]) in let <_108> = apply 'leaf'/1 (_107) in let <Ol> = {'reserved',_108} in let <_110> = apply 'lexpr'/3 (Arg,R,Opts) in let <El> = [Ol|[_110|[]]] in apply 'maybe_paren'/3 (P,Prec,El)
(<_106> when 'true' -> primop 'match_fail' ({'badmatch',_106})-|['compiler_generated'] ) end
<{'op',_204,Op,Larg,Rarg},Prec,Opts> when let <_112> = call 'erlang':'=:=' (Op,'orelse') in let <_113> = call 'erlang':'=:=' (Op,'andalso') in call 'erlang':'or' (_112,_113) -> case call 'erl_parse':'inop_prec' (Op) of <{L,P,R}> when 'true' -> let <Ll> = apply 'lexpr'/3 (Larg,L,Opts) in let <_116> = call 'io_lib':'format' ([126|[115]],[Op|[]]) in let <_117> = apply 'leaf'/1 (_116) in let <Ol> = {'reserved',_117} in let <Lr> = apply 'lexpr'/3 (Rarg,R,Opts) in let <El> = {'prefer_nl',[[]],[Ll|[Ol|[Lr|[]]]]} in apply 'maybe_paren'/3 (P,Prec,El)
(<_114> when 'true' -> primop 'match_fail' ({'badmatch',_114})-|['compiler_generated'] ) end
<{'op',_205,Op,Larg,Rarg},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' (Op) of <{L,P,R}> when 'true' -> let <Ll> = apply 'lexpr'/3 (Larg,L,Opts) in let <_123> = call 'io_lib':'format' ([126|[115]],[Op|[]]) in let <_124> = apply 'leaf'/1 (_123) in let <Ol> = {'reserved',_124} in let <Lr> = apply 'lexpr'/3 (Rarg,R,Opts) in let <El> = {'list',[Ll|[Ol|[Lr|[]]]]} in apply 'maybe_paren'/3 (P,Prec,El)
(<_121> when 'true' -> primop 'match_fail' ({'badmatch',_121})-|['compiler_generated'] ) end
<{'remote',_206,M,F},Prec,Opts> when 'true' -> case call 'erl_parse':'inop_prec' (':') of <{L,P,R}> when 'true' -> let <NameItem> = apply 'lexpr'/3 (M,L,Opts) in let <CallItem> = apply 'lexpr'/3 (F,R,Opts) in apply 'maybe_paren'/3 (P,Prec,[NameItem|[58|[CallItem|[]]]])
(<_128> when 'true' -> primop 'match_fail' ({'badmatch',_128})-|['compiler_generated'] ) end
<{'bin',_207,Fs},_208,Opts> when 'true' -> apply 'bit_grp'/2 (Fs,Opts)
<{'value',_209,Val},_210,_211> when 'true' -> {'value',Val}
<Other,_X_Precedence,{'options','none',_212,_213}> when 'true' -> let <_131> = call 'io_lib':'format' ([73|[78|[86|[65|[76|[73|[68|[45|[70|[79|[82|[77|[58|[126|[119|[58]]]]]]]]]]]]]]]],[Other|[]]) in apply 'leaf'/1 (_131)
<HookExpr,Precedence,{'options',_@r0 = {Mod,Func,Eas},_214,_215}> when call 'erlang':'=/=' (Mod,'fun') -> {'ehook',HookExpr,Precedence,_@r0}
<HookExpr,Precedence,{'options',Func,_216,Options}> when 'true' -> {'hook',HookExpr,Precedence,Func,Options}
(<_134,_133,_132> when 'true' -> (primop 'match_fail' ({'function_clause',_134,_133,_132})-|[{'function_name',{'lexpr',3}}] )-|['compiler_generated'] ) end
'hash_after_integer'/2 = fun (_0,_1) -> case <_0,_1> of <{'integer',_4,_5},C> when 'true' -> [32|C]
<{'fun',_6,{'function',_7,_8}},C> when 'true' -> [32|C]
<{'fun',_9,{'function',_10,_11,_12}},C> when 'true' -> [32|C]
<_13,C> when 'true' -> C end
'call'/4 = fun (_0,_1,_2,_3) -> case call 'erl_parse':'func_prec' () of <{F,P}> when 'true' -> let <_6> = apply 'lexpr'/3 (_0,F,_3) in let <_5> = apply 'args'/2 (_1,_3) in let <Item> = {'first',_6,_5} in apply 'maybe_paren'/3 (P,_2,Item)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'fun_info'/1 = fun (_0) -> let <_1> = apply 'leaf'/1 ([37|[32|[102|[117|[110|[45|[105|[110|[102|[111|[58|[32]]]]]]]]]]]]) in [_1|[{'value',_0}|[]]]
'bit_grp'/2 = fun (_0,_1) -> case <_0,_1> of <[],_X_Opts> when 'true' -> apply 'leaf'/1 ([60|[60|[62|[62]]]])
<Fs,Opts> when 'true' -> let <_2> = apply 'bit_elems'/2 (Fs,Opts) in call 'lists':'append' ([['<<']|[[_2|[]]|[['>>']]]]) end
'bit_elems'/2 = fun (_0,_1) -> let <_2> = 'bit_elem'/2 in apply 'expr_list'/4 (_0,44,_2,_1)
'bit_elem'/2 = fun (_0,_1) -> case <_0,_1> of <{'bin_element',_10,Expr,Sz,Types},Opts> when 'true' -> let <P> = call 'erl_parse':'max_prec' () in let <VChars> = apply 'lexpr'/3 (Expr,P,Opts) in let <_5> = case <> of <> when call 'erlang':'=/=' (Sz,'default') -> let <_4> = apply 'lexpr'/3 (Sz,P,Opts) in [VChars|[58|[_4|[]]]]
<> when 'true' -> VChars end in case <> of <> when call 'erlang':'=/=' (Types,'default') -> let <_7> = apply 'bit_elem_types'/1 (Types) in [_5|[47|_7]]
<> when 'true' -> _5 end
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'bit_elem',2}}] )-|['compiler_generated'] ) end
'bit_elem_types'/1 = fun (_0) -> case _0 of <[T|[]]> when 'true' -> let <_1> = apply 'bit_elem_type'/1 (T) in [_1|[]]
<[T|Rest]> when 'true' -> let <_2> = apply 'bit_elem_type'/1 (T) in let <_3> = apply 'bit_elem_types'/1 (Rest) in [_2|[45|_3]]
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'bit_elem_types',1}}] )-|['compiler_generated'] ) end
'bit_elem_type'/1 = fun (_0) -> case _0 of <{A,B}> when 'true' -> let <_2> = call 'erl_parse':'abstract' (A) in let <_1> = apply 'options'/1 ('none') in let <_3> = apply 'lexpr'/2 (_2,_1) in let <_5> = call 'erl_parse':'abstract' (B) in let <_4> = apply 'options'/1 ('none') in let <_6> = apply 'lexpr'/2 (_5,_4) in [_3|[58|[_6|[]]]]
<T> when 'true' -> let <_8> = call 'erl_parse':'abstract' (T) in let <_7> = apply 'options'/1 ('none') in apply 'lexpr'/2 (_8,_7) end
'record_name'/1 = fun (_0) -> [35|[{'atom',_0}|[]]]
'record_fields'/2 = fun (_0,_1) -> let <_2> = 'record_field'/2 in apply 'tuple'/3 (_0,_2,_1)
'record_field'/2 = fun (_0,_1) -> case <_0,_1> of <{'record_field',_12,F,Val},Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('=') of <{L,_X_P,R}> when 'true' -> let <Fl> = apply 'lexpr'/3 (F,L,Opts) in let <Vl> = apply 'lexpr'/3 (Val,R,Opts) in {'list',[{'cstep',[Fl|[' =']],Vl}|[]]}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{'typed_record_field',{'record_field',_13,F,Val},Type},Opts> when 'true' -> case call 'erl_parse':'inop_prec' ('=') of <{L,_X_P,R}> when 'true' -> let <Fl> = apply 'lexpr'/3 (F,L,Opts) in let <_7> = apply 'lexpr'/3 (Val,R,Opts) in let <Vl> = apply 'typed'/2 (_7,Type) in {'list',[{'cstep',[Fl|[' =']],Vl}|[]]}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{'typed_record_field',Field,Type},Opts> when 'true' -> let <_9> = apply 'record_field'/2 (Field,Opts) in apply 'typed'/2 (_9,Type)
<{'record_field',_14,F},Opts> when 'true' -> apply 'lexpr'/3 (F,0,Opts)
(<_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10})-|[{'function_name',{'record_field',2}}] )-|['compiler_generated'] ) end
'map_fields'/2 = fun (_0,_1) -> let <_2> = 'map_field'/2 in apply 'tuple'/3 (_0,_2,_1)
'map_field'/2 = fun (_0,_1) -> case <_0,_1> of <{'map_field_assoc',_10,K,V},Opts> when 'true' -> let <Pl> = apply 'lexpr'/3 (K,0,Opts) in let <_4> = apply 'leaf'/1 ([32|[61|[62]]]) in let <_3> = apply 'lexpr'/3 (V,0,Opts) in {'list',[{'step',[Pl|[_4|[]]],_3}|[]]}
<{'map_field_exact',_11,K,V},Opts> when 'true' -> let <Pl> = apply 'lexpr'/3 (K,0,Opts) in let <_7> = apply 'leaf'/1 ([32|[58|[61]]]) in let <_6> = apply 'lexpr'/3 (V,0,Opts) in {'list',[{'step',[Pl|[_7|[]]],_6}|[]]}
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'map_field',2}}] )-|['compiler_generated'] ) end
'list'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'cons',_8,H,T},Es,Opts> when 'true' -> apply 'list'/3 (T,[H|Es],Opts)
<{'nil',_9},Es,Opts> when 'true' -> let <_3> = call 'lists':'reverse' (Es) in apply 'proper_list'/2 (_3,Opts)
<Other,Es,Opts> when 'true' -> let <_4> = call 'lists':'reverse' (Es,[Other|[]]) in apply 'improper_list'/2 (_4,Opts) end
'if_clauses'/2 = fun (_0,_1) -> let <_2> = 'if_clause'/2 in apply 'clauses'/3 (_2,_1,_0)
'if_clause'/2 = fun (_0,_1) -> case <_0,_1> of <{'clause',_7,[],G,B},Opts> when 'true' -> let <_2> = apply 'guard_no_when'/2 (G,Opts) in let <Gl> = [_2|[' ->']] in let <_4> = apply 'body'/2 (B,Opts) in {'step',Gl,_4}
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'if_clause',2}}] )-|['compiler_generated'] ) end
'guard_no_when'/2 = fun (_0,_1) -> case <_0,_1> of <_@r0 = [E|Es],Opts> when call 'erlang':'is_list' (E) -> let <_2> = 'guard0'/2 in apply 'expr_list'/4 (_@r0,59,_2,Opts)
<_@r1 = [E|Es],Opts> when 'true' -> apply 'guard_no_when'/2 ([_@r1|[]],Opts)
<[],_5> when 'true' -> apply 'leaf'/1 ([116|[114|[117|[101]]]])
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'guard_no_when',2}}] )-|['compiler_generated'] ) end
'cr_clauses'/2 = fun (_0,_1) -> let <_2> = 'cr_clause'/2 in apply 'clauses'/3 (_2,_1,_0)
'cr_clause'/2 = fun (_0,_1) -> case <_0,_1> of <{'clause',_7,[T|[]],G,B},Opts> when 'true' -> let <El> = apply 'lexpr'/3 (T,0,Opts) in let <Gl> = apply 'guard_when'/3 (El,G,Opts) in let <Bl> = apply 'body'/2 (B,Opts) in {'step',Gl,Bl}
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'cr_clause',2}}] )-|['compiler_generated'] ) end
'try_clauses'/2 = fun (_0,_1) -> let <_2> = 'try_clause'/2 in apply 'clauses'/3 (_2,_1,_0)
'try_clause'/2 = fun (_0,_1) -> case <_0,_1> of <{'clause',_10,[{'tuple',_11,[C|[V|[S|[]]]]}|[]],G,B},Opts> when 'true' -> let <Cs> = apply 'lexpr'/3 (C,0,Opts) in let <El> = apply 'lexpr'/3 (V,0,Opts) in let <CsEl> = [Cs|[58|[El|[]]]] in let <Sl> = apply 'stack_backtrace'/3 (S,CsEl,Opts) in let <Gl> = apply 'guard_when'/3 (Sl,G,Opts) in let <Bl> = apply 'body'/2 (B,Opts) in {'step',Gl,Bl}
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'try_clause',2}}] )-|['compiler_generated'] ) end
'stack_backtrace'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'var',_7,'_'},El,_X_Opts> when 'true' -> El
<S,El,Opts> when 'true' -> let <_3> = apply 'lexpr'/3 (S,0,Opts) in call 'erlang':'++' (El,[58|[_3|[]]]) end
'fun_clauses'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Cs,Opts,'unnamed'> when 'true' -> let <_3> = 'fun_clause'/2 in apply 'nl_clauses'/4 (_3,[59],Opts,Cs)
<Cs,Opts,{'named',Name}> when 'true' -> let <_10> = fun (_7,_6) -> case apply 'fun_clause'/2 (_7,_6) of <{'step',Gl,Bl}> when 'true' -> let <_5> = call 'erlang':'atom_to_list' (Name) in {'step',[_5|[Gl|[]]],Bl}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end in apply 'nl_clauses'/4 (_10,[59],Opts,Cs)
(<_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11})-|[{'function_name',{'fun_clauses',3}}] )-|['compiler_generated'] ) end
'fun_clause'/2 = fun (_0,_1) -> case <_0,_1> of <{'clause',_7,A,G,B},Opts> when 'true' -> let <El> = apply 'args'/2 (A,Opts) in let <Gl> = apply 'guard_when'/3 (El,G,Opts) in let <Bl> = apply 'body'/2 (B,Opts) in {'step',Gl,Bl}
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'fun_clause',2}}] )-|['compiler_generated'] ) end
'cond_clauses'/2 = fun (_0,_1) -> let <_2> = 'cond_clause'/2 in apply 'clauses'/3 (_2,_1,_0)
'cond_clause'/2 = fun (_0,_1) -> case <_0,_1> of <{'clause',_6,[],[[E|[]]|[]],B},Opts> when 'true' -> let <_3> = apply 'lexpr'/2 (E,Opts) in let <_2> = apply 'body'/2 (B,Opts) in {'step',[_3|[' ->']],_2}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'cond_clause',2}}] )-|['compiler_generated'] ) end
'nl_clauses'/4 = fun (_0,_1,_2,_3) -> let <_4> = apply 'lexprs'/3 (_3,_0,_2) in {'prefer_nl',_1,_4}
'clauses'/3 = fun (_0,_1,_2) -> let <_3> = apply 'lexprs'/3 (_2,_0,_1) in {'prefer_nl',[59],_3}
'lc_quals'/2 = fun (_0,_1) -> let <_2> = 'lc_qual'/2 in let <_3> = apply 'lexprs'/3 (_0,_2,_1) in {'prefer_nl',[44],_3}
'lc_qual'/2 = fun (_0,_1) -> case <_0,_1> of <{'b_generate',_10,Pat,E},Opts> when 'true' -> let <Pl> = apply 'lexpr'/3 (Pat,0,Opts) in let <_4> = apply 'leaf'/1 ([32|[60|[61]]]) in let <_3> = apply 'lexpr'/3 (E,0,Opts) in {'list',[{'step',[Pl|[_4|[]]],_3}|[]]}
<{'generate',_11,Pat,E},Opts> when 'true' -> let <Pl> = apply 'lexpr'/3 (Pat,0,Opts) in let <_7> = apply 'leaf'/1 ([32|[60|[45]]]) in let <_6> = apply 'lexpr'/3 (E,0,Opts) in {'list',[{'step',[Pl|[_7|[]]],_6}|[]]}
<Q,Opts> when 'true' -> apply 'lexpr'/3 (Q,0,Opts) end
'proper_list'/2 = fun (_0,_1) -> let <_2> = apply 'lexprs'/2 (_0,_1) in {'seq',91,93,[44],_2}
'improper_list'/2 = fun (_0,_1) -> let <_2> = apply 'lexprs'/2 (_0,_1) in {'seq',91,93,[{44,' |'}],_2}
'tuple'/2 = fun (_0,_1) -> let <_2> = 'lexpr'/2 in apply 'tuple'/3 (_0,_2,_1)
'tuple'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],_X_F,_X_Opts> when 'true' -> apply 'leaf'/1 ([123|[125]])
<Es,F,Opts> when 'true' -> let <_3> = apply 'lexprs'/3 (Es,F,Opts) in {'seq',123,125,[44],_3} end
'args'/2 = fun (_0,_1) -> let <_2> = apply 'lexprs'/2 (_0,_1) in {'seq',40,41,[44],_2}
'expr_list'/4 = fun (_0,_1,_2,_3) -> let <_4> = apply 'lexprs'/3 (_0,_2,_3) in {'seq',[],[],_1,_4}
'lexprs'/2 = fun (_0,_1) -> let <_2> = 'lexpr'/2 in apply 'lexprs'/3 (_0,_2,_1)
'lexprs'/3 = fun (_0,_1,_2) -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[E|_4]> when 'true' -> let <_6> = apply _1 (E,_2) in let <_7> = apply 'lc$^0'/1 (_4) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'maybe_paren'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <P,Prec,Expr> when call 'erlang':'<' (P,Prec) -> [40|[Expr|[41]]]
<_X_P,_X_Prec,Expr> when 'true' -> Expr end
'leaf'/1 = fun (_0) -> let <_1> = call 'string':'length' (_0) in {'leaf',_1,_0}
'frmt'/2 = fun (_0,_1) -> apply 'frmt'/3 (_0,0,_1)
'frmt'/3 = fun (_0,_1,_2) -> let <ST> = apply 'spacetab'/0 () in let <WT> = apply 'wordtable'/0 () in case apply 'f'/5 (_0,_1,ST,WT,_2) of <{Chars,_X_Length}> when 'true' -> [Chars|[]]
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'f'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Nil = [],_X_I0,_X_ST,_X_WT,_X_PP> when 'true' -> {Nil,0}
<C,_X_I0,_X_ST,_X_WT,_X_PP> when call 'erlang':'is_integer' (C) -> {C,1}
<{'leaf',Length,Chars},_X_I0,_X_ST,_X_WT,_X_PP> when 'true' -> {Chars,Length}
<[Item|Items],I0,ST,WT,PP> when 'true' -> let <_5> = apply 'f'/5 (Item,I0,ST,WT,PP) in apply 'consecutive'/6 (Items,_5,I0,ST,WT,PP)
<{'list',Items},I0,ST,WT,PP> when 'true' -> apply 'f'/5 ({'seq',[],[],[[]],Items},I0,ST,WT,PP)
<{'first',E,Item},I0,ST,WT,PP> when 'true' -> apply 'f'/5 ({'seq',E,[],[[]],[Item|[]]},I0,ST,WT,PP)
<{'seq',Before,After,Sep,LItems},I0,ST,WT,PP> when 'true' -> let <BCharsSize> = apply 'f'/5 (Before,I0,ST,WT,PP) in let <I> = apply 'indent'/2 (BCharsSize,I0) in let <CharsSizeL> = apply 'fl'/7 (LItems,Sep,I,After,ST,WT,PP) in case apply 'unz'/1 (CharsSizeL) of <{CharsL,SizeL}> when 'true' -> case apply 'unz1'/1 ([BCharsSize|[]]) of <{BCharsL,BSizeL}> when 'true' -> let <Sizes> = call 'erlang':'++' (BSizeL,SizeL) in let <_16> = case <> of <> when let <_12> = call 'erlang':'is_list' (Sep) in let <_13> = call 'erlang':'=/=' (Sep,[]) in call 'erlang':'and' (_12,_13) -> let <_14> = call 'erlang':'length' (CharsL) in let <_15> = call 'erlang':'-' (_14,1) in call 'erlang':'max' (0,_15)
<> when 'true' -> 0 end in case apply 'same_line'/4 (I0,Sizes,_16,PP) of <{'yes',Size}> when 'true' -> let <_18> = case <> of <> when call 'erlang':'>' (_16,0) -> apply 'insert_sep'/2 (CharsL,32)
<> when 'true' -> CharsL end in let <_20> = call 'erlang':'++' (BCharsL,_18) in {_20,Size}
<'no'> when 'true' -> let <CharsList> = apply 'handle_step'/4 (CharsSizeL,I,ST,PP) in case apply 'maybe_newlines'/6 (CharsList,LItems,I,_16,ST,PP) of <{LChars,LSize}> when 'true' -> let <_23> = apply 'nsz'/2 (LSize,I0) in {[BCharsL|[LChars|[]]],_23}
(<_22> when 'true' -> primop 'match_fail' ({'badmatch',_22})-|['compiler_generated'] ) end
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<{'force_nl',_X_ExtraInfoItem,Item},I,ST,WT,PP> when call 'erlang':'<' (I,0) -> apply 'f'/5 (Item,I,ST,WT,PP)
<{'force_nl',ExtraInfoItem,Item},I,ST,WT,PP> when 'true' -> apply 'f'/5 ({'prefer_nl',[],[ExtraInfoItem|[Item|[]]]},I,ST,WT,PP)
<{'prefer_nl',Sep,LItems},I,ST,WT,PP> when call 'erlang':'<' (I,0) -> apply 'f'/5 ({'seq',[],[],Sep,LItems},I,ST,WT,PP)
<{'prefer_nl',Sep,LItems},I0,ST,WT,PP> when 'true' -> let <CharsSize2L> = apply 'fl'/7 (LItems,Sep,I0,[],ST,WT,PP) in case apply 'unz'/1 (CharsSize2L) of <{_X_CharsL,Sizes}> when 'true' -> case <> of <> when call 'erlang':'=:=' (Sizes,[]) -> {[],0}
<> when 'true' -> let <_29> = apply 'insert_newlines'/4 (CharsSize2L,I0,ST,PP) in let <_27> = call 'lists':'last' (Sizes) in let <_28> = apply 'nsz'/2 (_27,I0) in {_29,_28} end
(<_26> when 'true' -> primop 'match_fail' ({'badmatch',_26})-|['compiler_generated'] ) end
<{'value',V},I,ST,WT,PP> when 'true' -> let <_30> = apply 'write_a_value'/2 (V,PP) in apply 'f'/5 (_30,I,ST,WT,PP)
<{'atom',A},I,ST,WT,PP> when 'true' -> let <_31> = apply 'write_an_atom'/2 (A,PP) in apply 'f'/5 (_31,I,ST,WT,PP)
<{'singleton_atom_type',A},I,ST,WT,PP> when 'true' -> let <_32> = apply 'write_a_singleton_atom_type'/2 (A,PP) in apply 'f'/5 (_32,I,ST,WT,PP)
<{'char',C},I,ST,WT,PP> when 'true' -> let <_33> = apply 'write_a_char'/2 (C,PP) in apply 'f'/5 (_33,I,ST,WT,PP)
<{'string',S},I,ST,WT,PP> when 'true' -> let <_34> = apply 'write_a_string'/3 (S,I,PP) in apply 'f'/5 (_34,I,ST,WT,PP)
<{'reserved',R},I,ST,WT,PP> when 'true' -> apply 'f'/5 (R,I,ST,WT,PP)
<{'hook',HookExpr,Precedence,Func,Options},I,_X_ST,_X_WT,_X_PP> when 'true' -> let <Chars> = apply Func (HookExpr,I,Precedence,Options) in let <_36> = apply 'indentation'/2 (Chars,I) in {Chars,_36}
<{'ehook',HookExpr,Precedence,ModFuncEas = {Mod,Func,Eas}},I,_X_ST,_X_WT,_X_PP> when 'true' -> let <Chars> = call 'erlang':'apply' (Mod,Func,[HookExpr|[I|[Precedence|[ModFuncEas|Eas]]]]) in let <_38> = apply 'indentation'/2 (Chars,I) in {Chars,_38}
<WordName,_X_I,_X_ST,WT,_X_PP> when call 'erlang':'is_atom' (WordName) -> apply 'word'/2 (WordName,WT)
(<_43,_42,_41,_40,_39> when 'true' -> (primop 'match_fail' ({'function_clause',_43,_42,_41,_40,_39})-|[{'function_name',{'f',5}}] )-|['compiler_generated'] ) end
'fl'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[],_X_Sep,I0,After,ST,WT,PP> when 'true' -> let <_7> = apply 'f'/5 (After,I0,ST,WT,PP) in [[_7|[{[],0}]]|[]]
<CItems,Sep0,I0,After,ST,WT,PP> when 'true' -> let <F> = fun (_32,_31) -> case <_32,_31> of <{'step',Item1,Item2},S> when 'true' -> let <_8> = apply 'f'/5 (Item1,I0,ST,WT,PP) in (case PP of (<({'pp',_44,_45,_46,_47,_48,_rec1}-|['compiler_generated'] )> when 'true' -> let <_11> = apply 'incr'/2 (I0,_rec1) in let <_12> = apply 'f'/5 ([Item2|[S|[]]],_11,ST,WT,PP) in [_8|[_12|[]]]-|['compiler_generated'] )
(<_49> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<{'cstep',Item1,Item2},S> when 'true' -> case apply 'f'/5 (Item1,I0,ST,WT,PP) of <CharSize1 = {_50,Sz1}> when 'true' -> case <> of <> when try let <_14> = call 'erlang':'is_integer' (Sz1) in (let <_17> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (PP,('pp'-|['compiler_generated'] ),(7-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_15-|['compiler_generated'] )> when 'true' -> (_15-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_18> = call 'erlang':'=:=' ((_17-|['compiler_generated'] ),'true') in let <_19> = call 'erlang':'element' (7,PP) in let <_20> = call 'erlang':'<' (Sz1,_19) in let <_21> = call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_18,_20) in call 'erlang':'and' (_14,_21)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_22> = apply 'leaf'/1 ([32]) in let <Item2p> = [_22|[Item2|[S|[]]]] in let <_24> = apply 'consecutive'/6 (Item2p,CharSize1,I0,ST,WT,PP) in [_24|[{[],0}]]
<> when 'true' -> (case PP of (<({'pp',_51,_52,_53,_54,_55,_rec2}-|['compiler_generated'] )> when 'true' -> let <_27> = apply 'incr'/2 (I0,_rec2) in let <_28> = apply 'f'/5 ([Item2|[S|[]]],_27,ST,WT,PP) in [CharSize1|[_28|[]]]-|['compiler_generated'] )
(<_56> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<{'reserved',Word},S> when 'true' -> let <_29> = apply 'f'/5 ([Word|[S|[]]],I0,ST,WT,PP) in [_29|[{[],0}]]
<Item,S> when 'true' -> let <_30> = apply 'f'/5 ([Item|[S|[]]],I0,ST,WT,PP) in [_30|[{[],0}]] end in case apply 'sep'/1 (Sep0) of <{Sep,LastSep}> when 'true' -> apply 'fl1'/5 (CItems,F,Sep,LastSep,After)
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end end
'sep'/1 = fun (_0) -> case _0 of <[{S,LS}|[]]> when 'true' -> {[S|[]],[LS|[]]}
<Sep = {_2,_3}> when 'true' -> Sep
<S> when 'true' -> {S,S} end
'fl1'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[CItem|[]],F,_X_Sep,_X_LastSep,After> when 'true' -> let <_5> = apply F (CItem,After) in [_5|[]]
<[CItem1|[CItem2|[]]],F,_X_Sep,LastSep,After> when 'true' -> let <_6> = apply F (CItem1,LastSep) in let <_7> = apply F (CItem2,After) in [_6|[_7|[]]]
<[CItem|CItems],F,Sep,LastSep,After> when 'true' -> let <_8> = apply F (CItem,Sep) in let <_9> = apply 'fl1'/5 (CItems,F,Sep,LastSep,After) in [_8|_9]
(<_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11,_10})-|[{'function_name',{'fl1',5}}] )-|['compiler_generated'] ) end
'consecutive'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <_13> = fun (_10,_9) -> let <CharsSize> = apply 'f'/5 (_10,_9,_3,_4,_5) in let <_8> = apply 'indent'/2 (CharsSize,_9) in {CharsSize,_8} in let <_6> = apply 'indent'/2 (_1,_2) in case call 'lists':'mapfoldl' (_13,_6,_0) of <{CharsSizes,_X_Length}> when 'true' -> case apply 'unz1'/1 ([_1|CharsSizes]) of <{CharsL,SizeL}> when 'true' -> let <_16> = apply 'line_size'/1 (SizeL) in {CharsL,_16}
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
'unz'/1 = fun (_0) -> let <_1> = call 'lists':'append' (_0) in apply 'unz1'/1 (_1)
'unz1'/1 = fun (_0) -> let <_1> = apply 'nonzero'/1 (_0) in call 'lists':'unzip' (_1)
'nonzero'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{_5,Sz}> when 'true' -> call 'erlang':'=/=' (Sz,0)
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-nonzero/1-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'filter' (_3,_0)
'maybe_newlines'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[_@r0 = {Chars,Size}|[]],[],_X_I,_X_NSepChars,_X_ST,_X_PP> when 'true' -> _@r0
<CharsSizeList,Items,I,NSepChars,ST,PP> when call 'erlang':'>=' (I,0) -> let <_6> = apply 'nl_indent'/2 (I,ST) in apply 'maybe_sep'/6 (CharsSizeList,Items,I,NSepChars,_6,PP)
(<_12,_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9,_8,_7})-|[{'function_name',{'maybe_newlines',6}}] )-|['compiler_generated'] ) end
'maybe_sep'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[{Chars1,Size1}|CharsSizeL],[Item|Items],I0,NSepChars,Sep,PP> when 'true' -> let <_9> = case apply 'classify_item'/1 (Item) of <'atomic'> when 'true' -> call 'erlang':'+' (I0,Size1)
<_17> when 'true' -> (case PP of (<({'pp',_18,_19,_20,_21,_rec3,_22}-|['compiler_generated'] )> when 'true' -> call 'erlang':'+' (_rec3,1)-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end in apply 'maybe_sep1'/9 (CharsSizeL,Items,I0,_9,Sep,NSepChars,Size1,[Chars1|[]],PP)
(<_16,_15,_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14,_13,_12,_11})-|[{'function_name',{'maybe_sep',6}}] )-|['compiler_generated'] ) end
'maybe_sep1'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> case <_0,_1,_2,_3,_4,_5,_6,_7,_8> of <[{Chars,Size}|CharsSizeL],[Item|Items],I0,I,Sep,NSepChars,Sz0,A,PP> when 'true' -> case apply 'classify_item'/1 (Item) of <'atomic'> when call 'erlang':'is_integer' (Size) -> let <Size1> = call 'erlang':'+' (Size,1) in let <I1> = call 'erlang':'+' (I,Size1) in case <> of <> when (try (let <_13> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (PP,('pp'-|['compiler_generated'] ),(7-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_11-|['compiler_generated'] )> when 'true' -> (_11-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_14> = call 'erlang':'=:=' ((_13-|['compiler_generated'] ),'true') in let <_15> = call 'erlang':'element' (6,PP) in let <_16> = call 'erlang':'=<' (I1,_15) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_14,_16)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> let <_17> = case <> of <> when call 'erlang':'>' (NSepChars,0) -> [Chars|[32|A]]
<> when 'true' -> [Chars|A] end in let <_19> = call 'erlang':'+' (Sz0,Size1) in apply 'maybe_sep1'/9 (CharsSizeL,Items,I0,I1,Sep,NSepChars,_19,_17,PP)
<> when 'true' -> let <A1> = [Chars|[Sep|A]] in let <_21> = call 'erlang':'+' (I0,Size) in apply 'maybe_sep1'/9 (CharsSizeL,Items,I0,_21,Sep,NSepChars,Size1,A1,PP) end
<_37> when 'true' -> let <A1> = [Chars|[Sep|A]] in (case PP of (<({'pp',_38,_39,_40,_41,_rec4,_42}-|['compiler_generated'] )> when 'true' -> let <_25> = call 'erlang':'+' (_rec4,1) in apply 'maybe_sep1'/9 (CharsSizeL,Items,I0,_25,Sep,NSepChars,0,A1,PP)-|['compiler_generated'] )
(<_43> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
<_X_CharsSizeL,_X_Items,_X_Io,_X_I,_X_Sep,_X_NSepChars,Sz,A,_X_PP> when 'true' -> let <_27> = call 'lists':'reverse' (A) in {_27,Sz} end
'insert_newlines'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <CharsSizesL,I,ST,PP> when call 'erlang':'>=' (I,0) -> let <_4> = apply 'handle_step'/4 (CharsSizesL,I,ST,PP) in case apply 'unz1'/1 (_4) of <{CharsL,_10}> when 'true' -> apply 'insert_nl'/3 (CharsL,I,ST)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'insert_newlines',4}}] )-|['compiler_generated'] ) end
'handle_step'/4 = fun (_0,_1,_2,_3) -> let <_11> = fun (_9) -> case _9 of <[{_X_C1,0}|[{_X_C2,0}|[]]]> when 'true' -> {[],0}
<[_@r0 = {C1,Sz1}|[{_X_C2,0}|[]]]> when 'true' -> _@r0
<[{C1,Sz1}|[{C2,Sz2}|[]]]> when call 'erlang':'>' (Sz2,0) -> (case _3 of (<({'pp',_16,_17,_18,_19,_20,_rec5}-|['compiler_generated'] )> when 'true' -> let <_7> = call 'erlang':'+' (_1,_rec5) in let <_8> = apply 'insert_nl'/3 ([C1|[C2|[]]],_7,_2) in let <_4> = apply 'line_size'/1 ([Sz1|[Sz2|[]]]) in {_8,_4}-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'-handle_step/4-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'map' (_11,_0)
'insert_nl'/3 = fun (_0,_1,_2) -> let <_3> = apply 'nl_indent'/2 (_1,_2) in apply 'insert_sep'/2 (_0,_3)
'insert_sep'/2 = fun (_0,_1) -> case <_0,_1> of <[Chars1|CharsL],Sep> when 'true' -> let <_6> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[Chars|_3]> when 'true' -> let <_5> = apply 'lc$^0'/1 (_3) in ([[Sep|[Chars|[]]]|_5]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (CharsL) in [Chars1|_6]
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'insert_sep',2}}] )-|['compiler_generated'] ) end
'nl_indent'/2 = fun (_0,_1) -> case <_0,_1> of <0,_X_T> when 'true' -> 10
<I,T> when call 'erlang':'>' (I,0) -> let <_2> = apply 'spaces'/2 (I,T) in [10|_2]
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'nl_indent',2}}] )-|['compiler_generated'] ) end
'classify_item'/1 = fun (_0) -> case _0 of <{'atom',_2}> when 'true' -> 'atomic'
<{'singleton_atom_type',_3}> when 'true' -> 'atomic'
<Atom> when call 'erlang':'is_atom' (_0) -> 'atomic'
<{'leaf',_4,_5}> when 'true' -> 'atomic'
<_6> when 'true' -> 'complex' end
'same_line'/4 = fun (_0,_1,_2,_3) -> try let <_4> = call 'lists':'sum' (_1) in let <Size> = call 'erlang':'+' (_4,_2) in let <_8> = apply 'incr'/2 (_0,Size) in (case _3 of (<({'pp',_18,_19,_20,_21,_rec6,_22}-|['compiler_generated'] )> when 'true' -> case call 'erlang':'=<' (_8,_rec6) of <'true'> when 'true' -> {'yes',Size}
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <_10> -> _10 catch <_13,_12,_11> -> 'no'
'line_size'/1 = fun (_0) -> apply 'line_size'/3 (_0,0,'false')
'line_size'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],Size,'false'> when 'true' -> Size
<[],Size,'true'> when 'true' -> {'line',Size}
<[{'line',Len}|SizeL],_7,_8> when 'true' -> apply 'line_size'/3 (SizeL,Len,'true')
<[Sz|SizeL],SizeSoFar,LF> when 'true' -> let <_3> = call 'erlang':'+' (SizeSoFar,Sz) in apply 'line_size'/3 (SizeL,_3,LF)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'line_size',3}}] )-|['compiler_generated'] ) end
'nsz'/2 = fun (_0,_1) -> case <_0,_1> of <Sz = {'line',_X_Len},_X_I> when 'true' -> Sz
<Size,I> when call 'erlang':'>=' (I,0) -> let <_2> = call 'erlang':'+' (Size,I) in {'line',_2}
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'nsz',2}}] )-|['compiler_generated'] ) end
'indent'/2 = fun (_0,_1) -> case <_0,_1> of <{_X_Chars,{'line',Len}},_X_I> when 'true' -> Len
<{_X_Chars,Size},I> when 'true' -> apply 'incr'/2 (I,Size)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'indent',2}}] )-|['compiler_generated'] ) end
'incr'/2 = fun (_0,_1) -> case <_0,_1> of <I,_X_Incr> when call 'erlang':'<' (I,0) -> I
<I,Incr> when 'true' -> call 'erlang':'+' (I,Incr) end
'indentation'/2 = fun (_0,_1) -> case <_0,_1> of <E,I> when call 'erlang':'<' (I,0) -> call 'string':'length' (E)
<E,I0> when 'true' -> let <I> = call 'io_lib_format':'indentation' (E,I0) in case apply 'has_nl'/1 (E) of <'true'> when 'true' -> {'line',I}
<'false'> when 'true' -> I
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end end
'has_nl'/1 = fun (_0) -> case _0 of <[10|_4]> when 'true' -> 'true'
<[C|Cs]> when call 'erlang':'is_integer' (C) -> apply 'has_nl'/1 (Cs)
<[C|Cs]> when 'true' -> (case apply 'has_nl'/1 (C) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'has_nl'/1 (Cs)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[]> when 'true' -> 'false'
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'has_nl',1}}] )-|['compiler_generated'] ) end
'write_a_value'/2 = fun (_0,_1) -> let <_2> = apply 'write_value'/2 (_0,_1) in apply 'flat_leaf'/1 (_2)
'write_an_atom'/2 = fun (_0,_1) -> let <_2> = apply 'write_atom'/2 (_0,_1) in apply 'flat_leaf'/1 (_2)
'write_a_singleton_atom_type'/2 = fun (_0,_1) -> let <_2> = apply 'write_singleton_atom_type'/2 (_0,_1) in apply 'flat_leaf'/1 (_2)
'write_a_char'/2 = fun (_0,_1) -> let <_2> = apply 'write_char'/2 (_0,_1) in apply 'flat_leaf'/1 (_2)
'write_a_string'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <S,I,PP> when let <_3> = call 'erlang':'<' (I,0) in let <_4> = call 'erlang':'=:=' (S,[]) in call 'erlang':'or' (_3,_4) -> let <_5> = apply 'write_string'/2 (S,PP) in apply 'flat_leaf'/1 (_5)
<S,I,PP> when 'true' -> (case PP of (<({'pp',_14,_15,_16,_17,_rec7,_18}-|['compiler_generated'] )> when 'true' -> let <_8> = call 'erlang':'-' (_rec7,I) in let <Len> = call 'erlang':'max' (_8,5) in let <_10> = apply 'write_a_string'/4 (S,Len,Len,PP) in {'list',_10}-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'write_a_string'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],_X_N,_X_Len,_X_PP> when 'true' -> []
<S,N,Len,PP> when 'true' -> let <SS> = call 'string':'slice' (S,0,N) in let <Sl> = apply 'write_string'/2 (SS,PP) in let <_7> = call 'string':'length' (Sl) in let <_8> = call 'erlang':'>' (_7,Len) in let <_6> = call 'erlang':'>' (N,5) in case call 'erlang':'and' (_8,_6) of <'true'> when 'true' -> let <_9> = call 'erlang':'-' (N,1) in apply 'write_a_string'/4 (S,_9,Len,PP)
<'false'> when 'true' -> let <_10> = apply 'flat_leaf'/1 (Sl) in let <_11> = call 'string':'length' (SS) in let <_12> = call 'string':'slice' (S,_11) in let <_13> = apply 'write_a_string'/4 (_12,Len,Len,PP) in [_10|_13] end end
'flat_leaf'/1 = fun (_0) -> let <L> = call 'lists':'flatten' (_0) in let <_2> = call 'string':'length' (L) in {'leaf',_2,L}
'write_value'/2 = fun (_0,_1) -> (case _1 of (<({'pp',_rec8,_6,_7,_8,_9,_10}-|['compiler_generated'] )> when 'true' -> apply _rec8 (_0)-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'write_atom'/2 = fun (_0,_1) -> (case _1 of (<({'pp',_rec9,_6,_7,_8,_9,_10}-|['compiler_generated'] )> when 'true' -> apply _rec9 (_0)-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'write_singleton_atom_type'/2 = fun (_0,_1) -> (case _1 of (<({'pp',_6,_rec10,_7,_8,_9,_10}-|['compiler_generated'] )> when 'true' -> apply _rec10 (_0)-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'write_string'/2 = fun (_0,_1) -> (case _1 of (<({'pp',_6,_7,_rec11,_8,_9,_10}-|['compiler_generated'] )> when 'true' -> apply _rec11 (_0)-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'write_char'/2 = fun (_0,_1) -> (case _1 of (<({'pp',_6,_7,_8,_rec12,_9,_10}-|['compiler_generated'] )> when 'true' -> apply _rec12 (_0)-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','pp'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'a0'/0 = fun () -> call 'erl_anno':'new' (0)
'spacetab'/0 = fun () -> let <_5> = fun (_2,_1) -> {_1,[32|_1]} in let <_0> = call 'lists':'seq' (0,30) in case call 'lists':'mapfoldl' (_5,[],_0) of <{[_8|L],_9}> when 'true' -> call 'erlang':'list_to_tuple' (L)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'spaces'/2 = fun (_0,_1) -> case <_0,_1> of <N,T> when call 'erlang':'=<' (N,30) -> call 'erlang':'element' (N,T)
<N,T> when 'true' -> let <_2> = call 'erlang':'element' (30,T) in let <_3> = call 'erlang':'-' (N,30) in let <_4> = apply 'spaces'/2 (_3,T) in [_2|_4] end
'wordtable'/0 = fun () -> let <_5> = letrec 'lc$^0'/1 = fun (_2) -> case _2 of <[W|_1]> when 'true' -> case apply 'leaf'/1 (W) of <{'leaf',Sz,S}> when 'true' -> let <_4> = apply 'lc$^0'/1 (_1) in ([{S,Sz}|_4]-|['compiler_generated'] )
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 ([[32|[45|[62]]]|[[32|[61]]|[[60|[60]]|[[62|[62]]|[[91|[93]]|[[97|[102|[116|[101|[114]]]]]|[[98|[101|[103|[105|[110]]]]]|[[99|[97|[115|[101]]]]|[[99|[97|[116|[99|[104]]]]]|[[101|[110|[100]]]|[[102|[117|[110]]]|[[105|[102]]|[[111|[102]]|[[114|[101|[99|[101|[105|[118|[101]]]]]]]|[[116|[114|[121]]]|[[119|[104|[101|[110]]]]|[[32|[58|[58]]]|[[46|[46]]|[[32|[124]]]]]]]]]]]]]]]]]]]]]) in call 'erlang':'list_to_tuple' (_5)
'word'/2 = fun (_0,_1) -> case <_0,_1> of <' ->',WT> when 'true' -> call 'erlang':'element' (1,WT)
<' =',WT> when 'true' -> call 'erlang':'element' (2,WT)
<'<<',WT> when 'true' -> call 'erlang':'element' (3,WT)
<'>>',WT> when 'true' -> call 'erlang':'element' (4,WT)
<'[]',WT> when 'true' -> call 'erlang':'element' (5,WT)
<'after',WT> when 'true' -> call 'erlang':'element' (6,WT)
<'begin',WT> when 'true' -> call 'erlang':'element' (7,WT)
<'case',WT> when 'true' -> call 'erlang':'element' (8,WT)
<'catch',WT> when 'true' -> call 'erlang':'element' (9,WT)
<'end',WT> when 'true' -> call 'erlang':'element' (10,WT)
<'fun',WT> when 'true' -> call 'erlang':'element' (11,WT)
<'if',WT> when 'true' -> call 'erlang':'element' (12,WT)
<'of',WT> when 'true' -> call 'erlang':'element' (13,WT)
<'receive',WT> when 'true' -> call 'erlang':'element' (14,WT)
<'try',WT> when 'true' -> call 'erlang':'element' (15,WT)
<'when',WT> when 'true' -> call 'erlang':'element' (16,WT)
<' ::',WT> when 'true' -> call 'erlang':'element' (17,WT)
<'..',WT> when 'true' -> call 'erlang':'element' (18,WT)
<' |',WT> when 'true' -> call 'erlang':'element' (19,WT)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'word',2}}] )-|['compiler_generated'] ) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('erl_pp')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('erl_pp',_0) end