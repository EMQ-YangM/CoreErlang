module 'uri_string' ['compose_query'/1,'compose_query'/2,'dissect_query'/1,'is_host'/1,'is_path'/1,'module_info'/0,'module_info'/1,'normalize'/1,'normalize'/2,'parse'/1,'recompose'/1,'resolve'/2,'resolve'/3,'transcode'/2] attributes [ 'file' = [{[115|[114|[99|[47|[117|[114|[105|[95|[115|[116|[114|[105|[110|[103|[46|[101|[114|[108]]]]]]]]]]]]]]]]]],1}]
, 'export_type' = [{'error',0}|[{'uri_map',0}|[{'uri_string',0}]]]
, 'type' = [{'uri_string',{'type',275,'iodata',[]},[]}]
, 'type' = [{'error',{'type',276,'tuple',[{'atom',276,'error'}|[{'type',276,'atom',[]}|[{'type',276,'term',[]}]]]},[]}]
, 'type' = [{'uri_map',{'type',283,'union',[{'type',283,'map',[{'type',283,'map_field_assoc',[{'atom',283,'fragment'}|[{'remote_type',283,[{'atom',283,'unicode'}|[{'atom',283,'chardata'}|[[]]]]}]]}|[{'type',284,'map_field_assoc',[{'atom',284,'host'}|[{'remote_type',284,[{'atom',284,'unicode'}|[{'atom',284,'chardata'}|[[]]]]}]]}|[{'type',285,'map_field_assoc',[{'atom',285,'path'}|[{'remote_type',285,[{'atom',285,'unicode'}|[{'atom',285,'chardata'}|[[]]]]}]]}|[{'type',286,'map_field_assoc',[{'atom',286,'port'}|[{'type',286,'union',[{'type',286,'non_neg_integer',[]}|[{'atom',286,'undefined'}]]}]]}|[{'type',287,'map_field_assoc',[{'atom',287,'query'}|[{'remote_type',287,[{'atom',287,'unicode'}|[{'atom',287,'chardata'}|[[]]]]}]]}|[{'type',288,'map_field_assoc',[{'atom',288,'scheme'}|[{'remote_type',288,[{'atom',288,'unicode'}|[{'atom',288,'chardata'}|[[]]]]}]]}|[{'type',289,'map_field_assoc',[{'atom',289,'userinfo'}|[{'remote_type',289,[{'atom',289,'unicode'}|[{'atom',289,'chardata'}|[[]]]]}]]}]]]]]]]}|[{'type',289,'map',[]}]]},[]}]
, 'spec' = [{{'normalize',1},[{'type',295,'bounded_fun',[{'type',295,'fun',[{'type',295,'product',[{'var',295,'URI'}]}|[{'var',295,'NormalizedURI'}]]}|[[{'type',296,'constraint',[{'atom',296,'is_subtype'}|[[{'var',296,'URI'}|[{'type',296,'union',[{'user_type',296,'uri_string',[]}|[{'user_type',296,'uri_map',[]}]]}]]]]}|[{'type',297,'constraint',[{'atom',297,'is_subtype'}|[[{'var',297,'NormalizedURI'}|[{'type',297,'union',[{'user_type',297,'uri_string',[]}|[{'user_type',298,'error',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'normalize',2},[{'type',303,'bounded_fun',[{'type',303,'fun',[{'type',303,'product',[{'var',303,'URI'}|[{'var',303,'Options'}]]}|[{'var',303,'NormalizedURI'}]]}|[[{'type',304,'constraint',[{'atom',304,'is_subtype'}|[[{'var',304,'URI'}|[{'type',304,'union',[{'user_type',304,'uri_string',[]}|[{'user_type',304,'uri_map',[]}]]}]]]]}|[{'type',305,'constraint',[{'atom',305,'is_subtype'}|[[{'var',305,'Options'}|[{'type',305,'list',[{'atom',305,'return_map'}]}]]]]}|[{'type',306,'constraint',[{'atom',306,'is_subtype'}|[[{'var',306,'NormalizedURI'}|[{'type',306,'union',[{'user_type',306,'uri_string',[]}|[{'user_type',306,'uri_map',[]}|[{'user_type',307,'error',[]}]]]}]]]]}]]]]]}]}]
, 'spec' = [{{'parse',1},[{'type',343,'bounded_fun',[{'type',343,'fun',[{'type',343,'product',[{'var',343,'URIString'}]}|[{'var',343,'URIMap'}]]}|[[{'type',344,'constraint',[{'atom',344,'is_subtype'}|[[{'var',344,'URIString'}|[{'user_type',344,'uri_string',[]}]]]]}|[{'type',345,'constraint',[{'atom',345,'is_subtype'}|[[{'var',345,'URIMap'}|[{'type',345,'union',[{'user_type',345,'uri_map',[]}|[{'user_type',346,'error',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'recompose',1},[{'type',365,'bounded_fun',[{'type',365,'fun',[{'type',365,'product',[{'var',365,'URIMap'}]}|[{'var',365,'URIString'}]]}|[[{'type',366,'constraint',[{'atom',366,'is_subtype'}|[[{'var',366,'URIMap'}|[{'user_type',366,'uri_map',[]}]]]]}|[{'type',367,'constraint',[{'atom',367,'is_subtype'}|[[{'var',367,'URIString'}|[{'type',367,'union',[{'user_type',367,'uri_string',[]}|[{'user_type',368,'error',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'resolve',2},[{'type',391,'bounded_fun',[{'type',391,'fun',[{'type',391,'product',[{'var',391,'RefURI'}|[{'var',391,'BaseURI'}]]}|[{'var',391,'TargetURI'}]]}|[[{'type',392,'constraint',[{'atom',392,'is_subtype'}|[[{'var',392,'RefURI'}|[{'type',392,'union',[{'user_type',392,'uri_string',[]}|[{'user_type',392,'uri_map',[]}]]}]]]]}|[{'type',393,'constraint',[{'atom',393,'is_subtype'}|[[{'var',393,'BaseURI'}|[{'type',393,'union',[{'user_type',393,'uri_string',[]}|[{'user_type',393,'uri_map',[]}]]}]]]]}|[{'type',394,'constraint',[{'atom',394,'is_subtype'}|[[{'var',394,'TargetURI'}|[{'type',394,'union',[{'user_type',394,'uri_string',[]}|[{'user_type',395,'error',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'resolve',3},[{'type',400,'bounded_fun',[{'type',400,'fun',[{'type',400,'product',[{'var',400,'RefURI'}|[{'var',400,'BaseURI'}|[{'var',400,'Options'}]]]}|[{'var',400,'TargetURI'}]]}|[[{'type',401,'constraint',[{'atom',401,'is_subtype'}|[[{'var',401,'RefURI'}|[{'type',401,'union',[{'user_type',401,'uri_string',[]}|[{'user_type',401,'uri_map',[]}]]}]]]]}|[{'type',402,'constraint',[{'atom',402,'is_subtype'}|[[{'var',402,'BaseURI'}|[{'type',402,'union',[{'user_type',402,'uri_string',[]}|[{'user_type',402,'uri_map',[]}]]}]]]]}|[{'type',403,'constraint',[{'atom',403,'is_subtype'}|[[{'var',403,'Options'}|[{'type',403,'list',[{'atom',403,'return_map'}]}]]]]}|[{'type',404,'constraint',[{'atom',404,'is_subtype'}|[[{'var',404,'TargetURI'}|[{'type',404,'union',[{'user_type',404,'uri_string',[]}|[{'user_type',404,'uri_map',[]}|[{'user_type',405,'error',[]}]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'transcode',2},[{'type',430,'bounded_fun',[{'type',430,'fun',[{'type',430,'product',[{'var',430,'URIString'}|[{'var',430,'Options'}]]}|[{'var',430,'Result'}]]}|[[{'type',431,'constraint',[{'atom',431,'is_subtype'}|[[{'var',431,'URIString'}|[{'user_type',431,'uri_string',[]}]]]]}|[{'type',432,'constraint',[{'atom',432,'is_subtype'}|[[{'var',432,'Options'}|[{'type',432,'list',[{'type',432,'union',[{'type',432,'tuple',[{'atom',432,'in_encoding'}|[{'remote_type',432,[{'atom',432,'unicode'}|[{'atom',432,'encoding'}|[[]]]]}]]}|[{'type',432,'tuple',[{'atom',432,'out_encoding'}|[{'remote_type',432,[{'atom',432,'unicode'}|[{'atom',432,'encoding'}|[[]]]]}]]}]]}]}]]]]}|[{'type',433,'constraint',[{'atom',433,'is_subtype'}|[[{'var',433,'Result'}|[{'type',433,'union',[{'user_type',433,'uri_string',[]}|[{'user_type',434,'error',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'compose_query',1},[{'type',466,'bounded_fun',[{'type',466,'fun',[{'type',466,'product',[{'var',466,'QueryList'}]}|[{'var',466,'QueryString'}]]}|[[{'type',467,'constraint',[{'atom',467,'is_subtype'}|[[{'var',467,'QueryList'}|[{'type',467,'list',[{'type',467,'tuple',[{'remote_type',467,[{'atom',467,'unicode'}|[{'atom',467,'chardata'}|[[]]]]}|[{'type',467,'union',[{'remote_type',467,[{'atom',467,'unicode'}|[{'atom',467,'chardata'}|[[]]]]}|[{'atom',467,'true'}]]}]]}]}]]]]}|[{'type',468,'constraint',[{'atom',468,'is_subtype'}|[[{'var',468,'QueryString'}|[{'type',468,'union',[{'user_type',468,'uri_string',[]}|[{'user_type',469,'error',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'compose_query',2},[{'type',474,'bounded_fun',[{'type',474,'fun',[{'type',474,'product',[{'var',474,'QueryList'}|[{'var',474,'Options'}]]}|[{'var',474,'QueryString'}]]}|[[{'type',475,'constraint',[{'atom',475,'is_subtype'}|[[{'var',475,'QueryList'}|[{'type',475,'list',[{'type',475,'tuple',[{'remote_type',475,[{'atom',475,'unicode'}|[{'atom',475,'chardata'}|[[]]]]}|[{'type',475,'union',[{'remote_type',475,[{'atom',475,'unicode'}|[{'atom',475,'chardata'}|[[]]]]}|[{'atom',475,'true'}]]}]]}]}]]]]}|[{'type',476,'constraint',[{'atom',476,'is_subtype'}|[[{'var',476,'Options'}|[{'type',476,'list',[{'type',476,'tuple',[{'atom',476,'encoding'}|[{'type',476,'atom',[]}]]}]}]]]]}|[{'type',477,'constraint',[{'atom',477,'is_subtype'}|[[{'var',477,'QueryString'}|[{'type',477,'union',[{'user_type',477,'uri_string',[]}|[{'user_type',478,'error',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'dissect_query',1},[{'type',509,'bounded_fun',[{'type',509,'fun',[{'type',509,'product',[{'var',509,'QueryString'}]}|[{'var',509,'QueryList'}]]}|[[{'type',510,'constraint',[{'atom',510,'is_subtype'}|[[{'var',510,'QueryString'}|[{'user_type',510,'uri_string',[]}]]]]}|[{'type',511,'constraint',[{'atom',511,'is_subtype'}|[[{'var',511,'QueryList'}|[{'type',511,'union',[{'type',511,'list',[{'type',511,'tuple',[{'remote_type',511,[{'atom',511,'unicode'}|[{'atom',511,'chardata'}|[[]]]]}|[{'type',511,'union',[{'remote_type',511,[{'atom',511,'unicode'}|[{'atom',511,'chardata'}|[[]]]]}|[{'atom',511,'true'}]]}]]}]}|[{'user_type',512,'error',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'parse_uri_reference',2},[{'type',552,'fun',[{'type',552,'product',[{'type',552,'binary',[]}|[{'user_type',552,'uri_map',[]}]]}|[{'user_type',552,'uri_map',[]}]]}]}]
, 'spec' = [{{'parse_relative_part',2},[{'type',576,'fun',[{'type',576,'product',[{'type',576,'binary',[]}|[{'user_type',576,'uri_map',[]}]]}|[{'user_type',576,'uri_map',[]}]]}]}]
, 'spec' = [{{'parse_segment',2},[{'type',647,'fun',[{'type',647,'product',[{'type',647,'binary',[]}|[{'user_type',647,'uri_map',[]}]]}|[{'type',647,'tuple',[{'type',647,'binary',[]}|[{'user_type',647,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'parse_segment_nz_nc',2},[{'type',670,'fun',[{'type',670,'product',[{'type',670,'binary',[]}|[{'user_type',670,'uri_map',[]}]]}|[{'type',670,'tuple',[{'type',670,'binary',[]}|[{'user_type',670,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_pchar',1},[{'type',691,'fun',[{'type',691,'product',[{'type',691,'char',[]}]}|[{'type',691,'boolean',[]}]]}]}]
, 'spec' = [{{'is_segment_nz_nc',1},[{'type',698,'fun',[{'type',698,'product',[{'type',698,'char',[]}]}|[{'type',698,'boolean',[]}]]}]}]
, 'spec' = [{{'parse_scheme_start',2},[{'type',712,'fun',[{'type',712,'product',[{'type',712,'binary',[]}|[{'user_type',712,'uri_map',[]}]]}|[{'user_type',712,'uri_map',[]}]]}]}]
, 'spec' = [{{'parse_scheme',2},[{'type',736,'fun',[{'type',736,'product',[{'type',736,'binary',[]}|[{'user_type',736,'uri_map',[]}]]}|[{'type',736,'tuple',[{'type',736,'binary',[]}|[{'user_type',736,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_scheme',1},[{'type',750,'fun',[{'type',750,'product',[{'type',750,'char',[]}]}|[{'type',750,'boolean',[]}]]}]}]
, 'spec' = [{{'parse_hier',2},[{'type',763,'fun',[{'type',763,'product',[{'type',763,'binary',[]}|[{'user_type',763,'uri_map',[]}]]}|[{'type',763,'tuple',[{'type',763,'binary',[]}|[{'user_type',763,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'parse_userinfo',2},[{'type',824,'fun',[{'type',824,'product',[{'type',824,'binary',[]}|[{'user_type',824,'uri_map',[]}]]}|[{'type',824,'tuple',[{'type',824,'binary',[]}|[{'user_type',824,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_userinfo',1},[{'type',842,'fun',[{'type',842,'product',[{'type',842,'char',[]}]}|[{'type',842,'boolean',[]}]]}]}]
, 'spec' = [{{'parse_host',2},[{'type',887,'fun',[{'type',887,'product',[{'type',887,'binary',[]}|[{'user_type',887,'uri_map',[]}]]}|[{'type',887,'tuple',[{'type',887,'binary',[]}|[{'user_type',887,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'parse_reg_name',2},[{'type',921,'fun',[{'type',921,'product',[{'type',921,'binary',[]}|[{'user_type',921,'uri_map',[]}]]}|[{'type',921,'tuple',[{'type',921,'binary',[]}|[{'user_type',921,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_reg_name',1},[{'type',948,'fun',[{'type',948,'product',[{'type',948,'char',[]}]}|[{'type',948,'boolean',[]}]]}]}]
, 'spec' = [{{'parse_ipv4_bin',3},[{'type',953,'fun',[{'type',953,'product',[{'type',953,'binary',[]}|[{'type',953,'list',[]}|[{'user_type',953,'uri_map',[]}]]]}|[{'type',953,'tuple',[{'type',953,'binary',[]}|[{'user_type',953,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_ipv4',1},[{'type',986,'fun',[{'type',986,'product',[{'type',986,'char',[]}]}|[{'type',986,'boolean',[]}]]}]}]
, 'spec' = [{{'validate_ipv4_address',1},[{'type',990,'fun',[{'type',990,'product',[{'type',990,'list',[]}]}|[{'type',990,'list',[]}]]}]}]
, 'spec' = [{{'parse_ipv6_bin',3},[{'type',998,'fun',[{'type',998,'product',[{'type',998,'binary',[]}|[{'type',998,'list',[]}|[{'user_type',998,'uri_map',[]}]]]}|[{'type',998,'tuple',[{'type',998,'binary',[]}|[{'user_type',998,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_ipv6',1},[{'type',1011,'fun',[{'type',1011,'product',[{'type',1011,'char',[]}]}|[{'type',1011,'boolean',[]}]]}]}]
, 'spec' = [{{'parse_ipv6_bin_end',2},[{'type',1017,'fun',[{'type',1017,'product',[{'type',1017,'binary',[]}|[{'user_type',1017,'uri_map',[]}]]}|[{'type',1017,'tuple',[{'type',1017,'binary',[]}|[{'user_type',1017,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'validate_ipv6_address',1},[{'type',1043,'fun',[{'type',1043,'product',[{'type',1043,'list',[]}]}|[{'type',1043,'list',[]}]]}]}]
, 'spec' = [{{'parse_port',2},[{'type',1060,'fun',[{'type',1060,'product',[{'type',1060,'binary',[]}|[{'user_type',1060,'uri_map',[]}]]}|[{'type',1060,'tuple',[{'type',1060,'binary',[]}|[{'user_type',1060,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'parse_query',2},[{'type',1094,'fun',[{'type',1094,'product',[{'type',1094,'binary',[]}|[{'user_type',1094,'uri_map',[]}]]}|[{'type',1094,'tuple',[{'type',1094,'binary',[]}|[{'user_type',1094,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_query',1},[{'type',1109,'fun',[{'type',1109,'product',[{'type',1109,'char',[]}]}|[{'type',1109,'boolean',[]}]]}]}]
, 'spec' = [{{'parse_fragment',2},[{'type',1124,'fun',[{'type',1124,'product',[{'type',1124,'binary',[]}|[{'user_type',1124,'uri_map',[]}]]}|[{'type',1124,'tuple',[{'type',1124,'binary',[]}|[{'user_type',1124,'uri_map',[]}]]}]]}]}]
, 'spec' = [{{'is_fragment',1},[{'type',1135,'fun',[{'type',1135,'product',[{'type',1135,'char',[]}]}|[{'type',1135,'boolean',[]}]]}]}]
, 'spec' = [{{'is_reserved',1},[{'type',1154,'fun',[{'type',1154,'product',[{'type',1154,'char',[]}]}|[{'type',1154,'boolean',[]}]]}]}]
, 'spec' = [{{'is_sub_delim',1},[{'type',1179,'fun',[{'type',1179,'product',[{'type',1179,'char',[]}]}|[{'type',1179,'boolean',[]}]]}]}]
, 'spec' = [{{'is_unreserved',1},[{'type',1201,'fun',[{'type',1201,'product',[{'type',1201,'char',[]}]}|[{'type',1201,'boolean',[]}]]}]}]
, 'spec' = [{{'is_alpha',1},[{'type',1208,'fun',[{'type',1208,'product',[{'type',1208,'char',[]}]}|[{'type',1208,'boolean',[]}]]}]}]
, 'spec' = [{{'is_digit',1},[{'type',1214,'fun',[{'type',1214,'product',[{'type',1214,'char',[]}]}|[{'type',1214,'boolean',[]}]]}]}]
, 'spec' = [{{'is_hex_digit',1},[{'type',1219,'fun',[{'type',1219,'product',[{'type',1219,'char',[]}]}|[{'type',1219,'boolean',[]}]]}]}]
, 'spec' = [{{'remove_brackets',1},[{'type',1226,'fun',[{'type',1226,'product',[{'type',1226,'binary',[]}]}|[{'type',1226,'binary',[]}]]}]}]
, 'spec' = [{{'calculate_parsed_scheme',2},[{'type',1239,'fun',[{'type',1239,'product',[{'type',1239,'binary',[]}|[{'type',1239,'binary',[]}]]}|[{'type',1239,'binary',[]}]]}]}]
, 'spec' = [{{'calculate_parsed_part',2},[{'type',1246,'fun',[{'type',1246,'product',[{'type',1246,'binary',[]}|[{'type',1246,'binary',[]}]]}|[{'type',1246,'binary',[]}]]}]}]
, 'spec' = [{{'calculate_parsed_userinfo',2},[{'type',1253,'fun',[{'type',1253,'product',[{'type',1253,'binary',[]}|[{'type',1253,'binary',[]}]]}|[{'type',1253,'binary',[]}]]}]}]
, 'spec' = [{{'calculate_parsed_host_port',2},[{'type',1260,'fun',[{'type',1260,'product',[{'type',1260,'binary',[]}|[{'type',1260,'binary',[]}]]}|[{'type',1260,'binary',[]}]]}]}]
, 'spec' = [{{'byte_size_exl_head',1},[{'type',1345,'fun',[{'type',1345,'product',[{'type',1345,'binary',[]}]}|[{'type',1345,'number',[]}]]}]}]
, 'spec' = [{{'encode_scheme',1},[{'type',1372,'fun',[{'type',1372,'product',[{'type',1372,'union',[{'type',1372,'list',[]}|[{'type',1372,'binary',[]}]]}]}|[{'type',1372,'union',[{'type',1372,'list',[]}|[{'type',1372,'binary',[]}]]}]]}]}]
, 'spec' = [{{'encode_userinfo',1},[{'type',1383,'fun',[{'type',1383,'product',[{'type',1383,'union',[{'type',1383,'list',[]}|[{'type',1383,'binary',[]}]]}]}|[{'type',1383,'union',[{'type',1383,'list',[]}|[{'type',1383,'binary',[]}]]}]]}]}]
, 'spec' = [{{'encode_host',1},[{'type',1387,'fun',[{'type',1387,'product',[{'type',1387,'union',[{'type',1387,'list',[]}|[{'type',1387,'binary',[]}]]}]}|[{'type',1387,'union',[{'type',1387,'list',[]}|[{'type',1387,'binary',[]}]]}]]}]}]
, 'spec' = [{{'encode_path',1},[{'type',1396,'fun',[{'type',1396,'product',[{'type',1396,'union',[{'type',1396,'list',[]}|[{'type',1396,'binary',[]}]]}]}|[{'type',1396,'union',[{'type',1396,'list',[]}|[{'type',1396,'binary',[]}]]}]]}]}]
, 'spec' = [{{'encode_query',1},[{'type',1400,'fun',[{'type',1400,'product',[{'type',1400,'union',[{'type',1400,'list',[]}|[{'type',1400,'binary',[]}]]}]}|[{'type',1400,'union',[{'type',1400,'list',[]}|[{'type',1400,'binary',[]}]]}]]}]}]
, 'spec' = [{{'encode_fragment',1},[{'type',1404,'fun',[{'type',1404,'product',[{'type',1404,'union',[{'type',1404,'list',[]}|[{'type',1404,'binary',[]}]]}]}|[{'type',1404,'union',[{'type',1404,'list',[]}|[{'type',1404,'binary',[]}]]}]]}]}]
, 'spec' = [{{'decode',1},[{'type',1412,'fun',[{'type',1412,'product',[{'type',1412,'union',[{'type',1412,'list',[]}|[{'type',1412,'binary',[]}]]}]}|[{'type',1412,'union',[{'type',1412,'list',[]}|[{'type',1412,'binary',[]}]]}]]}]}]
, 'spec' = [{{'is_host',1},[{'type',1463,'fun',[{'type',1463,'product',[{'type',1463,'char',[]}]}|[{'type',1463,'boolean',[]}]]}]}]
, 'spec' = [{{'is_path',1},[{'type',1468,'fun',[{'type',1468,'product',[{'type',1468,'char',[]}]}|[{'type',1468,'boolean',[]}]]}]}]
, 'spec' = [{{'encode',2},[{'type',1476,'fun',[{'type',1476,'product',[{'type',1476,'union',[{'type',1476,'list',[]}|[{'type',1476,'binary',[]}]]}|[{'type',1476,'fun',[]}]]}|[{'type',1476,'union',[{'type',1476,'list',[]}|[{'type',1476,'binary',[]}]]}]]}]}]
, 'spec' = [{{'encode_codepoint_binary',2},[{'type',1492,'fun',[{'type',1492,'product',[{'type',1492,'integer',[]}|[{'type',1492,'fun',[]}]]}|[{'type',1492,'binary',[]}]]}]}]
, 'spec' = [{{'percent_encode_binary',1},[{'type',1500,'fun',[{'type',1500,'product',[{'type',1500,'integer',[]}]}|[{'type',1500,'binary',[]}]]}]}] ] 'normalize'/1 = fun (_0) -> apply 'normalize'/2 (_0,[])
'normalize'/2 = fun (_0,_1) -> case <_0,_1> of <URIMap,[]> when call 'erlang':'is_map' (URIMap) -> try let <_2> = apply 'normalize_map'/1 (URIMap) in apply 'recompose'/1 (_2) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),((_@r0-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_24> when 'true' -> _@r0
(<_28,_29,_30> when 'true' -> primop 'raise' (_30,_29)-|['compiler_generated'] ) end
<URIMap,['return_map']> when call 'erlang':'is_map' (URIMap) -> try apply 'normalize_map'/1 (URIMap) of <_7> -> _7 catch <_10,_9,_8> -> case <_10,_9,_8> of <('throw'-|['compiler_generated'] ),((_@r1-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_25> when 'true' -> _@r1
(<_31,_32,_33> when 'true' -> primop 'raise' (_33,_32)-|['compiler_generated'] ) end
<URIString,[]> when 'true' -> case apply 'parse'/1 (URIString) of <Value> when call 'erlang':'is_map' (Value) -> try let <_11> = apply 'normalize_map'/1 (Value) in apply 'recompose'/1 (_11) of <_12> -> _12 catch <_15,_14,_13> -> case <_15,_14,_13> of <('throw'-|['compiler_generated'] ),((_@r2-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_26> when 'true' -> _@r2
(<_34,_35,_36> when 'true' -> primop 'raise' (_36,_35)-|['compiler_generated'] ) end
<Error> when 'true' -> Error end
<URIString,['return_map']> when 'true' -> case apply 'parse'/1 (URIString) of <Value> when call 'erlang':'is_map' (Value) -> try apply 'normalize_map'/1 (Value) of <_17> -> _17 catch <_20,_19,_18> -> case <_20,_19,_18> of <('throw'-|['compiler_generated'] ),((_@r3-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_27> when 'true' -> _@r3
(<_37,_38,_39> when 'true' -> primop 'raise' (_39,_38)-|['compiler_generated'] ) end
<Error> when 'true' -> Error end
(<_23,_22> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22})-|[{'function_name',{'normalize',2}}] )-|['compiler_generated'] ) end
'parse'/1 = fun (_0) -> case _0 of <URIString> when call 'erlang':'is_binary' (_0) -> try apply 'parse_uri_reference'/2 (URIString,~{}~) of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('throw'-|['compiler_generated'] ),((_@r0-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_12> when 'true' -> _@r0
(<_14,_15,_16> when 'true' -> primop 'raise' (_16,_15)-|['compiler_generated'] ) end
<URIString> when call 'erlang':'is_list' (_0) -> try let <Binary> = call 'unicode':'characters_to_binary' (URIString) in let <Map> = apply 'parse_uri_reference'/2 (Binary,~{}~) in apply 'convert_mapfields_to_list'/1 (Map) of <_7> -> _7 catch <_10,_9,_8> -> case <_10,_9,_8> of <('throw'-|['compiler_generated'] ),((_@r1-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_13> when 'true' -> _@r1
(<_17,_18,_19> when 'true' -> primop 'raise' (_19,_18)-|['compiler_generated'] ) end
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'parse',1}}] )-|['compiler_generated'] ) end
'recompose'/1 = fun (_0) -> case apply 'is_valid_map'/1 (_0) of <'false'> when 'true' -> {'error','invalid_map',_0}
<'true'> when 'true' -> try let <T0> = apply 'update_scheme'/2 (_0,'empty') in let <T1> = apply 'update_userinfo'/2 (_0,T0) in let <T2> = apply 'update_host'/2 (_0,T1) in let <T3> = apply 'update_port'/2 (_0,T2) in let <T4> = apply 'update_path'/2 (_0,T3) in let <T5> = apply 'update_query'/2 (_0,T4) in apply 'update_fragment'/2 (_0,T5) of <_7> -> _7 catch <_10,_9,_8> -> case <_10,_9,_8> of <('throw'-|['compiler_generated'] ),((_@r0-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_13> when 'true' -> _@r0
(<_14,_15,_16> when 'true' -> primop 'raise' (_16,_15)-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
'resolve'/2 = fun (_0,_1) -> apply 'resolve'/3 (_0,_1,[])
'resolve'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <URIMap,BaseURIMap,Options> when call 'erlang':'is_map' (URIMap) -> case apply 'resolve_map'/2 (URIMap,BaseURIMap) of <TargetURIMap> when call 'erlang':'is_map' (TargetURIMap) -> case Options of <['return_map']> when 'true' -> TargetURIMap
<[]> when 'true' -> apply 'recompose'/1 (TargetURIMap)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<Error> when 'true' -> Error end
<URIString,BaseURIMap,Options> when 'true' -> case apply 'parse'/1 (URIString) of <URIMap> when call 'erlang':'is_map' (URIMap) -> apply 'resolve'/3 (URIMap,BaseURIMap,Options)
<Error> when 'true' -> Error end end
'transcode'/2 = fun (_0,_1) -> case <_0,_1> of <URIString,Options> when call 'erlang':'is_binary' (URIString) -> try let <InEnc> = call 'proplists':'get_value' ('in_encoding',Options,'utf8') in let <OutEnc> = call 'proplists':'get_value' ('out_encoding',Options,'utf8') in let <List> = apply 'convert_to_list'/2 (URIString,InEnc) in let <Output> = apply 'transcode'/4 (List,[],InEnc,OutEnc) in apply 'convert_to_binary'/3 (Output,'utf8',OutEnc) of <_6> -> _6 catch <_9,_8,_7> -> case <_9,_8,_7> of <('throw'-|['compiler_generated'] ),((_@r0-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_19> when 'true' -> _@r0
(<_21,_22,_23> when 'true' -> primop 'raise' (_23,_22)-|['compiler_generated'] ) end
<URIString,Options> when call 'erlang':'is_list' (URIString) -> let <InEnc> = call 'proplists':'get_value' ('in_encoding',Options,'utf8') in let <OutEnc> = call 'proplists':'get_value' ('out_encoding',Options,'utf8') in let <Flattened> = apply 'flatten_list'/2 (URIString,InEnc) in try apply 'transcode'/4 (Flattened,[],InEnc,OutEnc) of <_13> -> _13 catch <_16,_15,_14> -> case <_16,_15,_14> of <('throw'-|['compiler_generated'] ),((_@r1-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_20> when 'true' -> _@r1
(<_24,_25,_26> when 'true' -> primop 'raise' (_26,_25)-|['compiler_generated'] ) end
(<_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17})-|[{'function_name',{'transcode',2}}] )-|['compiler_generated'] ) end
'compose_query'/1 = fun (_0) -> apply 'compose_query'/2 (_0,[{'encoding','utf8'}])
'compose_query'/2 = fun (_0,_1) -> case <_0,_1> of <[],_X_Options> when 'true' -> []
<List,Options> when 'true' -> try apply 'compose_query'/4 (List,Options,'false',#{}#) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),((_@r0-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_8> when 'true' -> _@r0
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end end
'compose_query'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{Key,'true'}|Rest],Options,IsList,Acc> when 'true' -> let <Separator> = apply 'get_separator'/1 (Rest) in let <K> = apply 'form_urlencode'/2 (Key,Options) in let <_8> = case IsList of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> call 'erlang':'is_list' (Key)-|['compiler_generated'] )
(<_6> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_6}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_10> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<K>('all',8,'binary',['unsigned'|['big']]),#<Separator>('all',8,'binary',['unsigned'|['big']])}# in apply 'compose_query'/4 (Rest,Options,_8,_10)
<[{Key,Value}|Rest],Options,IsList,Acc> when 'true' -> let <Separator> = apply 'get_separator'/1 (Rest) in let <K> = apply 'form_urlencode'/2 (Key,Options) in let <V> = apply 'form_urlencode'/2 (Value,Options) in let <_18> = case IsList of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> (case <> of (<> when call 'erlang':'is_list' (Key) -> 'true'-|['compiler_generated'] )
(<> when 'true' -> call 'erlang':'is_list' (Value)-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_14}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_20> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<K>('all',8,'binary',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']]),#<V>('all',8,'binary',['unsigned'|['big']]),#<Separator>('all',8,'binary',['unsigned'|['big']])}# in apply 'compose_query'/4 (Rest,Options,_18,_20)
<[],_X_Options,IsList,Acc> when 'true' -> case IsList of <'true'> when 'true' -> apply 'convert_to_list'/2 (Acc,'utf8')
<'false'> when 'true' -> Acc
(<_21> when 'true' -> primop 'match_fail' ({'case_clause',_21})-|['compiler_generated'] ) end
(<_25,_24,_23,_22> when 'true' -> (primop 'match_fail' ({'function_clause',_25,_24,_23,_22})-|[{'function_name',{'compose_query',4}}] )-|['compiler_generated'] ) end
'dissect_query'/1 = fun (_0) -> case _0 of <#{}#> when 'true' -> []
<[]> when 'true' -> []
<QueryString> when call 'erlang':'is_list' (_0) -> try let <B> = apply 'convert_to_binary'/3 (QueryString,'utf8','utf8') in apply 'dissect_query_key'/5 (B,'true',[],#{}#,#{}#) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),((_@r0-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_11> when 'true' -> _@r0
(<_13,_14,_15> when 'true' -> primop 'raise' (_15,_14)-|['compiler_generated'] ) end
<QueryString> when 'true' -> try apply 'dissect_query_key'/5 (QueryString,'false',[],#{}#,#{}#) of <_6> -> _6 catch <_9,_8,_7> -> case <_9,_8,_7> of <('throw'-|['compiler_generated'] ),((_@r1-|['compiler_generated'] ) = ({('error'-|['compiler_generated'] ),Atom,RestData}-|['compiler_generated'] )-|['compiler_generated'] ),_12> when 'true' -> _@r1
(<_16,_17,_18> when 'true' -> primop 'raise' (_18,_17)-|['compiler_generated'] ) end end
'convert_mapfields_to_list'/1 = fun (_0) -> let <Fun> = fun (_2,_1) -> case <_2,_1> of <_7,V> when call 'erlang':'is_binary' (V) -> call 'unicode':'characters_to_list' (V)
<_8,V> when 'true' -> V end in call 'maps':'map' (Fun,_0)
'parse_uri_reference'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,_8> when 'true' -> ~{'path'=>#{}#}~
<URIString,URI> when 'true' -> try apply 'parse_scheme_start'/2 (URIString,URI) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),({_9,_10,_11}-|['compiler_generated'] ),_12> when 'true' -> apply 'parse_relative_part'/2 (URIString,URI)
(<_13,_14,_15> when 'true' -> primop 'raise' (_15,_14)-|['compiler_generated'] ) end end
'parse_relative_part'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> try apply 'parse_userinfo'/2 (Rest,URI) of <_2> -> case _2 of <{T,URI1}> when 'true' -> let <Userinfo> = apply 'calculate_parsed_userinfo'/2 (Rest,T) in let <URI2> = apply 'maybe_add_path'/1 (URI1) in case <> of (<> when call 'erlang':'is_map' (URI2) -> ~{'userinfo'=>Userinfo|URI2}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI2})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'try_clause',_5})-|['compiler_generated'] ) end catch <_8,_7,_6> -> case <_8,_7,_6> of <('throw'-|['compiler_generated'] ),({_28,_29,_30}-|['compiler_generated'] ),_31> when 'true' -> case apply 'parse_host'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Host> = apply 'calculate_parsed_host_port'/2 (Rest,T) in let <URI2> = apply 'maybe_add_path'/1 (URI1) in let <_12> = apply 'remove_brackets'/1 (Host) in case <> of (<> when call 'erlang':'is_map' (URI2) -> ~{'host'=>_12|URI2}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI2})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_32,_33,_34> when 'true' -> primop 'raise' (_34,_33)-|['compiler_generated'] ) end
<#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_15> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> ~{'path'=>_15|URI1}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in let <URI2> = apply 'maybe_add_path'/1 (URI1) in case <> of (<> when call 'erlang':'is_map' (URI2) -> ~{'query'=>Query|URI2}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI2})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in let <URI2> = apply 'maybe_add_path'/1 (URI1) in case <> of (<> when call 'erlang':'is_map' (URI2) -> ~{'fragment'=>Fragment|URI2}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI2})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_segment_nz_nc'/1 (Char) of <'true'> when 'true' -> case apply 'parse_segment_nz_nc'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_24> = #{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> ~{'path'=>_24|URI1}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_22> when 'true' -> primop 'match_fail' ({'badmatch',_22})-|['compiler_generated'] ) end
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_25> when 'true' -> primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end
(<_27,_26> when 'true' -> (primop 'match_fail' ({'function_clause',_27,_26})-|[{'function_name',{'parse_relative_part',2}}] )-|['compiler_generated'] ) end
'parse_segment'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> apply 'parse_segment'/2 (Rest,URI)
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_4> = ~{'query'=>Query|URI1}~ in {Rest,_4}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_7> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_7}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_pchar'/1 (Char) of <'true'> when 'true' -> apply 'parse_segment'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'parse_segment',2}}] )-|['compiler_generated'] ) end
'parse_segment_nz_nc'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> apply 'parse_segment'/2 (Rest,URI)
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_4> = ~{'query'=>Query|URI1}~ in {Rest,_4}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_7> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_7}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_segment_nz_nc'/1 (Char) of <'true'> when 'true' -> apply 'parse_segment_nz_nc'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'parse_segment_nz_nc',2}}] )-|['compiler_generated'] ) end
'is_pchar'/1 = fun (_0) -> case _0 of <37> when 'true' -> 'true'
<58> when 'true' -> 'true'
<64> when 'true' -> 'true'
<Char> when 'true' -> (case apply 'is_unreserved'/1 (Char) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'is_sub_delim'/1 (Char)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'is_segment_nz_nc'/1 = fun (_0) -> case _0 of <37> when 'true' -> 'true'
<64> when 'true' -> 'true'
<Char> when 'true' -> (case apply 'is_unreserved'/1 (Char) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'is_sub_delim'/1 (Char)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'parse_scheme_start'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_alpha'/1 (Char) of <'true'> when 'true' -> case apply 'parse_scheme'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Scheme> = apply 'calculate_parsed_scheme'/2 (Rest,T) in let <URI2> = apply 'maybe_add_path'/1 (URI1) in let <_5> = #{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Scheme>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI2) -> ~{'scheme'=>_5|URI2}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI2})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'parse_scheme_start',2}}] )-|['compiler_generated'] ) end
'maybe_add_path'/1 = fun (_0) -> case call 'maps':'is_key' ('path',_0) of <'false'> when 'true' -> case <> of (<> when call 'erlang':'is_map' (_0) -> ~{'path'=>#{}#|_0}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',_0})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<_X_Else> when 'true' -> _0 end
'parse_scheme'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<58>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_hier'/2 (Rest,URI) of <{_6,URI1}> when 'true' -> {Rest,URI1}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_scheme'/1 (Char) of <'true'> when 'true' -> apply 'parse_scheme'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<#{}#,_X_URI> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',#{}#})
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'parse_scheme',2}}] )-|['compiler_generated'] ) end
'is_scheme'/1 = fun (_0) -> case _0 of <43> when 'true' -> 'true'
<45> when 'true' -> 'true'
<46> when 'true' -> 'true'
<Char> when 'true' -> (case apply 'is_alpha'/1 (Char) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'is_digit'/1 (Char)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'parse_hier'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> try apply 'parse_userinfo'/2 (Rest,URI) of <_2> -> case _2 of <{T,URI1}> when 'true' -> let <Userinfo> = apply 'calculate_parsed_userinfo'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_4> = ~{'userinfo'=>Userinfo|URI1}~ in {Rest,_4}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'try_clause',_5})-|['compiler_generated'] ) end catch <_8,_7,_6> -> case <_8,_7,_6> of <('throw'-|['compiler_generated'] ),({_30,_31,_32}-|['compiler_generated'] ),_33> when 'true' -> case apply 'parse_host'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Host> = apply 'calculate_parsed_host_port'/2 (Rest,T) in let <_11> = apply 'remove_brackets'/1 (Host) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_12> = ~{'host'=>_11|URI1}~ in {Rest,_12}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_34,_35,_36> when 'true' -> primop 'raise' (_36,_35)-|['compiler_generated'] ) end
<#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_15> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_16> = ~{'path'=>_15|URI1}~ in {Rest,_16}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_19> = ~{'query'=>Query|URI1}~ in {Rest,_19}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_22> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_22}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_pchar'/1 (Char) of <'true'> when 'true' -> case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_25> = #{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_26> = ~{'path'=>_25|URI1}~ in {Rest,_26}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_27> when 'true' -> primop 'match_fail' ({'case_clause',_27})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_29,_28> when 'true' -> (primop 'match_fail' ({'function_clause',_29,_28})-|[{'function_name',{'parse_hier',2}}] )-|['compiler_generated'] ) end
'parse_userinfo'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<64>('undefined','undefined','utf8',['unsigned'|['big']])}#,URI> when 'true' -> case <> of (<> when call 'erlang':'is_map' (URI) -> let <_2> = ~{'host'=>#{}#|URI}~ in {#{}#,_2}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<#{#<64>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_host'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Host> = apply 'calculate_parsed_host_port'/2 (Rest,T) in let <_5> = apply 'remove_brackets'/1 (Host) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_6> = ~{'host'=>_5|URI1}~ in {Rest,_6}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_userinfo'/1 (Char) of <'true'> when 'true' -> apply 'parse_userinfo'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<#{}#,_X_URI> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',#{}#})
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'parse_userinfo',2}}] )-|['compiler_generated'] ) end
'is_userinfo'/1 = fun (_0) -> case _0 of <37> when 'true' -> 'true'
<58> when 'true' -> 'true'
<Char> when 'true' -> (case apply 'is_unreserved'/1 (Char) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'is_sub_delim'/1 (Char)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'parse_host'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<58>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_port'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <H> = apply 'calculate_parsed_host_port'/2 (Rest,T) in let <Port> = apply 'get_port'/1 (H) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_5> = ~{'port'=>Port|URI1}~ in {Rest,_5}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_8> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_9> = ~{'path'=>_8|URI1}~ in {Rest,_9}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_12> = ~{'query'=>Query|URI1}~ in {Rest,_12}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<#{#<91>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> apply 'parse_ipv6_bin'/3 (Rest,[],URI)
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_15> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_15}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_digit'/1 (Char) of <'true'> when 'true' -> try apply 'parse_ipv4_bin'/3 (Rest,[Char|[]],URI) of <_16> -> _16 catch <_19,_18,_17> -> case <_19,_18,_17> of <('throw'-|['compiler_generated'] ),({_25,_26,_27}-|['compiler_generated'] ),_28> when 'true' -> let <_20> = #{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}# in apply 'parse_reg_name'/2 (_20,URI)
(<_29,_30,_31> when 'true' -> primop 'raise' (_31,_30)-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_21> = #{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}# in apply 'parse_reg_name'/2 (_21,URI)
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_24,_23> when 'true' -> (primop 'match_fail' ({'function_clause',_24,_23})-|[{'function_name',{'parse_host',2}}] )-|['compiler_generated'] ) end
'parse_reg_name'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<58>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_port'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <H> = apply 'calculate_parsed_host_port'/2 (Rest,T) in let <Port> = apply 'get_port'/1 (H) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_5> = ~{'port'=>Port|URI1}~ in {Rest,_5}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_8> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_9> = ~{'path'=>_8|URI1}~ in {Rest,_9}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_12> = ~{'query'=>Query|URI1}~ in {Rest,_12}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_15> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_15}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_reg_name'/1 (Char) of <'true'> when 'true' -> apply 'parse_reg_name'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17})-|[{'function_name',{'parse_reg_name',2}}] )-|['compiler_generated'] ) end
'is_reg_name'/1 = fun (_0) -> case _0 of <37> when 'true' -> 'true'
<Char> when 'true' -> (case apply 'is_unreserved'/1 (Char) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'is_sub_delim'/1 (Char)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'parse_ipv4_bin'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<58>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc,URI> when 'true' -> let <_3> = call ('lists'-|['result_not_wanted'] ):('reverse'-|['result_not_wanted'] ) (Acc) in do apply 'validate_ipv4_address'/1 (_3) case apply 'parse_port'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <H> = apply 'calculate_parsed_host_port'/2 (Rest,T) in let <Port> = apply 'get_port'/1 (H) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_8> = ~{'port'=>Port|URI1}~ in {Rest,_8}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc,URI> when 'true' -> let <_9> = call ('lists'-|['result_not_wanted'] ):('reverse'-|['result_not_wanted'] ) (Acc) in do apply 'validate_ipv4_address'/1 (_9) case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_13> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_14> = ~{'path'=>_13|URI1}~ in {Rest,_14}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc,URI> when 'true' -> let <_15> = call ('lists'-|['result_not_wanted'] ):('reverse'-|['result_not_wanted'] ) (Acc) in do apply 'validate_ipv4_address'/1 (_15) case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_19> = ~{'query'=>Query|URI1}~ in {Rest,_19}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc,URI> when 'true' -> let <_20> = call ('lists'-|['result_not_wanted'] ):('reverse'-|['result_not_wanted'] ) (Acc) in do apply 'validate_ipv4_address'/1 (_20) case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_24> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_24}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_22> when 'true' -> primop 'match_fail' ({'badmatch',_22})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc,URI> when 'true' -> case apply 'is_ipv4'/1 (Char) of <'true'> when 'true' -> apply 'parse_ipv4_bin'/3 (Rest,[Char|Acc],URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_25> when 'true' -> primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end
<#{}#,Acc,URI> when 'true' -> let <_26> = call ('lists'-|['result_not_wanted'] ):('reverse'-|['result_not_wanted'] ) (Acc) in do apply 'validate_ipv4_address'/1 (_26) {#{}#,URI}
(<_30,_29,_28> when 'true' -> (primop 'match_fail' ({'function_clause',_30,_29,_28})-|[{'function_name',{'parse_ipv4_bin',3}}] )-|['compiler_generated'] ) end
'is_ipv4'/1 = fun (_0) -> case _0 of <46> when 'true' -> 'true'
<Char> when 'true' -> apply 'is_digit'/1 (Char) end
'validate_ipv4_address'/1 = fun (_0) -> case call 'inet':'parse_ipv4strict_address' (_0) of <{'ok',_3}> when 'true' -> _0
<{'error',_4}> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',_0})
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'parse_ipv6_bin'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<93>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc,URI> when 'true' -> let <_3> = call ('lists'-|['result_not_wanted'] ):('reverse'-|['result_not_wanted'] ) (Acc) in do apply 'validate_ipv6_address'/1 (_3) apply 'parse_ipv6_bin_end'/2 (Rest,URI)
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc,URI> when 'true' -> case apply 'is_ipv6'/1 (Char) of <'true'> when 'true' -> apply 'parse_ipv6_bin'/3 (Rest,[Char|Acc],URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<#{}#,_X_Acc,_X_URI> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',#{}#})
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'parse_ipv6_bin',3}}] )-|['compiler_generated'] ) end
'is_ipv6'/1 = fun (_0) -> case _0 of <58> when 'true' -> 'true'
<46> when 'true' -> 'true'
<Char> when 'true' -> apply 'is_hex_digit'/1 (Char) end
'parse_ipv6_bin_end'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<58>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_port'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <H> = apply 'calculate_parsed_host_port'/2 (Rest,T) in let <Port> = apply 'get_port'/1 (H) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_5> = ~{'port'=>Port|URI1}~ in {Rest,_5}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_8> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_9> = ~{'path'=>_8|URI1}~ in {Rest,_9}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_12> = ~{'query'=>Query|URI1}~ in {Rest,_12}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_15> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_15}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_ipv6'/1 (Char) of <'true'> when 'true' -> apply 'parse_ipv6_bin_end'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17})-|[{'function_name',{'parse_ipv6_bin_end',2}}] )-|['compiler_generated'] ) end
'validate_ipv6_address'/1 = fun (_0) -> case call 'inet':'parse_ipv6strict_address' (_0) of <{'ok',_3}> when 'true' -> _0
<{'error',_4}> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',_0})
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'parse_port'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_segment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Path> = apply 'calculate_parsed_part'/2 (Rest,T) in let <_4> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}# in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_5> = ~{'path'=>_4|URI1}~ in {Rest,_5}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<63>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_query'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Query> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_8> = ~{'query'=>Query|URI1}~ in {Rest,_8}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_11> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_11}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_digit'/1 (Char) of <'true'> when 'true' -> apply 'parse_port'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'parse_port',2}}] )-|['compiler_generated'] ) end
'parse_query'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<35>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'parse_fragment'/2 (Rest,URI) of <{T,URI1}> when 'true' -> let <Fragment> = apply 'calculate_parsed_query_fragment'/2 (Rest,T) in case <> of (<> when call 'erlang':'is_map' (URI1) -> let <_4> = ~{'fragment'=>Fragment|URI1}~ in {Rest,_4}-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI1})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_query'/1 (Char) of <'true'> when 'true' -> apply 'parse_query'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'parse_query',2}}] )-|['compiler_generated'] ) end
'is_query'/1 = fun (_0) -> case _0 of <47> when 'true' -> 'true'
<63> when 'true' -> 'true'
<Char> when 'true' -> apply 'is_pchar'/1 (Char) end
'parse_fragment'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,URI> when 'true' -> case apply 'is_fragment'/1 (Char) of <'true'> when 'true' -> apply 'parse_fragment'/2 (Rest,URI)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',[Char|[]]})
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<#{}#,URI> when 'true' -> {#{}#,URI}
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'parse_fragment',2}}] )-|['compiler_generated'] ) end
'is_fragment'/1 = fun (_0) -> case _0 of <47> when 'true' -> 'true'
<63> when 'true' -> 'true'
<Char> when 'true' -> apply 'is_pchar'/1 (Char) end
'is_reserved'/1 = fun (_0) -> case _0 of <58> when 'true' -> 'true'
<47> when 'true' -> 'true'
<63> when 'true' -> 'true'
<35> when 'true' -> 'true'
<91> when 'true' -> 'true'
<93> when 'true' -> 'true'
<64> when 'true' -> 'true'
<33> when 'true' -> 'true'
<36> when 'true' -> 'true'
<38> when 'true' -> 'true'
<39> when 'true' -> 'true'
<40> when 'true' -> 'true'
<41> when 'true' -> 'true'
<42> when 'true' -> 'true'
<43> when 'true' -> 'true'
<44> when 'true' -> 'true'
<59> when 'true' -> 'true'
<61> when 'true' -> 'true'
<_2> when 'true' -> 'false' end
'is_sub_delim'/1 = fun (_0) -> case _0 of <33> when 'true' -> 'true'
<36> when 'true' -> 'true'
<38> when 'true' -> 'true'
<39> when 'true' -> 'true'
<40> when 'true' -> 'true'
<41> when 'true' -> 'true'
<42> when 'true' -> 'true'
<43> when 'true' -> 'true'
<44> when 'true' -> 'true'
<59> when 'true' -> 'true'
<61> when 'true' -> 'true'
<_2> when 'true' -> 'false' end
'is_unreserved'/1 = fun (_0) -> case _0 of <45> when 'true' -> 'true'
<46> when 'true' -> 'true'
<95> when 'true' -> 'true'
<126> when 'true' -> 'true'
<Char> when 'true' -> (case apply 'is_alpha'/1 (Char) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'is_digit'/1 (Char)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'is_alpha'/1 = fun (_0) -> case _0 of <C> when let <_1> = call 'erlang':'=<' (65,_0) in let <_2> = call 'erlang':'=<' (_0,90) in let <_3> = call 'erlang':'and' (_1,_2) in let <_4> = call 'erlang':'=<' (97,_0) in let <_5> = call 'erlang':'=<' (_0,122) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'or' (_3,_6) -> 'true'
<_8> when 'true' -> 'false' end
'is_digit'/1 = fun (_0) -> case _0 of <C> when let <_1> = call 'erlang':'=<' (48,_0) in let <_2> = call 'erlang':'=<' (_0,57) in call 'erlang':'and' (_1,_2) -> 'true'
<_4> when 'true' -> 'false' end
'is_hex_digit'/1 = fun (_0) -> case _0 of <C> when let <_1> = call 'erlang':'=<' (48,_0) in let <_2> = call 'erlang':'=<' (_0,57) in let <_3> = call 'erlang':'and' (_1,_2) in let <_4> = call 'erlang':'=<' (97,_0) in let <_5> = call 'erlang':'=<' (_0,102) in let <_6> = call 'erlang':'and' (_4,_5) in let <_7> = call 'erlang':'=<' (65,_0) in let <_8> = call 'erlang':'=<' (_0,70) in let <_9> = call 'erlang':'and' (_7,_8) in let <_10> = call 'erlang':'or' (_6,_9) in call 'erlang':'or' (_3,_10) -> 'true'
<_12> when 'true' -> 'false' end
'remove_brackets'/1 = fun (_0) -> case _0 of <#{#<91>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_1> = call 'erlang':'byte_size' (Rest) in let <_2> = call 'erlang':'-' (_1,1) in case call 'erlang':'split_binary' (Rest,_2) of <{H,T}> when 'true' -> case <> of <> when call 'erlang':'=:=' (T,#{#<93>(8,1,'integer',['unsigned'|['big']])}#) -> H
<> when 'true' -> Rest end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<Addr> when 'true' -> Addr end
'calculate_parsed_scheme'/2 = fun (_0,_1) -> case <_0,_1> of <Input,#{}#> when 'true' -> apply 'strip_last_char'/2 (Input,[58])
<Input,Unparsed> when 'true' -> apply 'get_parsed_binary'/2 (Input,Unparsed) end
'calculate_parsed_part'/2 = fun (_0,_1) -> case <_0,_1> of <Input,#{}#> when 'true' -> apply 'strip_last_char'/2 (Input,[63|[35]])
<Input,Unparsed> when 'true' -> apply 'get_parsed_binary'/2 (Input,Unparsed) end
'calculate_parsed_userinfo'/2 = fun (_0,_1) -> case <_0,_1> of <Input,#{}#> when 'true' -> apply 'strip_last_char'/2 (Input,[63|[35|[64]]])
<Input,Unparsed> when 'true' -> apply 'get_parsed_binary'/2 (Input,Unparsed) end
'calculate_parsed_host_port'/2 = fun (_0,_1) -> case <_0,_1> of <Input,#{}#> when 'true' -> apply 'strip_last_char'/2 (Input,[58|[63|[35|[47]]]])
<Input,Unparsed> when 'true' -> apply 'get_parsed_binary'/2 (Input,Unparsed) end
'calculate_parsed_query_fragment'/2 = fun (_0,_1) -> case <_0,_1> of <Input,#{}#> when 'true' -> apply 'strip_last_char'/2 (Input,[35])
<Input,Unparsed> when 'true' -> apply 'get_parsed_binary'/2 (Input,Unparsed) end
'get_port'/1 = fun (_0) -> case _0 of <#{}#> when 'true' -> 'undefined'
<B> when 'true' -> try call 'erlang':'binary_to_integer' (B) of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_6> when 'true' -> call 'erlang':'throw' ({'error','invalid_uri',B})
(<_7,_8,_9> when 'true' -> primop 'raise' (_9,_8)-|['compiler_generated'] ) end end
'strip_last_char'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,_8> when 'true' -> #{}#
<Input,[C0|[]]> when 'true' -> case call 'binary':'last' (Input) of <_9> when call 'erlang':'=:=' (_9,C0) -> apply 'init_binary'/1 (Input)
<_X_Else> when 'true' -> Input end
<Input,[C0|[C1|[]]]> when 'true' -> case call 'binary':'last' (Input) of <_10> when call 'erlang':'=:=' (_10,C0) -> apply 'init_binary'/1 (Input)
<_11> when call 'erlang':'=:=' (_11,C1) -> apply 'init_binary'/1 (Input)
<_X_Else> when 'true' -> Input end
<Input,[C0|[C1|[C2|[]]]]> when 'true' -> case call 'binary':'last' (Input) of <_12> when call 'erlang':'=:=' (_12,C0) -> apply 'init_binary'/1 (Input)
<_13> when call 'erlang':'=:=' (_13,C1) -> apply 'init_binary'/1 (Input)
<_14> when call 'erlang':'=:=' (_14,C2) -> apply 'init_binary'/1 (Input)
<_X_Else> when 'true' -> Input end
<Input,[C0|[C1|[C2|[C3|[]]]]]> when 'true' -> case call 'binary':'last' (Input) of <_15> when call 'erlang':'=:=' (_15,C0) -> apply 'init_binary'/1 (Input)
<_16> when call 'erlang':'=:=' (_16,C1) -> apply 'init_binary'/1 (Input)
<_17> when call 'erlang':'=:=' (_17,C2) -> apply 'init_binary'/1 (Input)
<_18> when call 'erlang':'=:=' (_18,C3) -> apply 'init_binary'/1 (Input)
<_X_Else> when 'true' -> Input end
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'strip_last_char',2}}] )-|['compiler_generated'] ) end
'get_parsed_binary'/2 = fun (_0,_1) -> let <_3> = call 'erlang':'byte_size' (_0) in let <_2> = apply 'byte_size_exl_head'/1 (_1) in let <_4> = call 'erlang':'-' (_3,_2) in case call 'erlang':'split_binary' (_0,_4) of <{First,_8}> when 'true' -> First
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'init_binary'/1 = fun (_0) -> let <_1> = call 'erlang':'byte_size' (_0) in let <_2> = call 'erlang':'-' (_1,1) in case call 'erlang':'split_binary' (_0,_2) of <{Init,_5}> when 'true' -> Init
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'byte_size_exl_head'/1 = fun (_0) -> case _0 of <#{}#> when 'true' -> 0
<Binary> when 'true' -> let <_1> = call 'erlang':'byte_size' (Binary) in call 'erlang':'+' (_1,1) end
'encode_scheme'/1 = fun (_0) -> case _0 of <[]> when 'true' -> call 'erlang':'throw' ({'error','invalid_scheme',[]})
<#{}#> when 'true' -> call 'erlang':'throw' ({'error','invalid_scheme',#{}#})
<Scheme> when 'true' -> case apply 'validate_scheme'/1 (Scheme) of <'true'> when 'true' -> Scheme
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_scheme',Scheme})
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end end
'encode_userinfo'/1 = fun (_0) -> let <_1> = 'is_userinfo'/1 in apply 'encode'/2 (_0,_1)
'encode_host'/1 = fun (_0) -> case apply 'classify_host'/1 (_0) of <'regname'> when 'true' -> _0
<'ipv4'> when 'true' -> _0
<'ipv6'> when 'true' -> apply 'bracket_ipv6'/1 (_0)
<'other'> when 'true' -> let <_1> = 'is_reg_name'/1 in apply 'encode'/2 (_0,_1)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'encode_path'/1 = fun (_0) -> let <_1> = 'is_path'/1 in apply 'encode'/2 (_0,_1)
'encode_query'/1 = fun (_0) -> let <_1> = 'is_query'/1 in apply 'encode'/2 (_0,_1)
'encode_fragment'/1 = fun (_0) -> let <_1> = 'is_fragment'/1 in apply 'encode'/2 (_0,_1)
'decode'/1 = fun (_0) -> apply 'decode'/2 (_0,#{}#)
'decode'/2 = fun (_0,_1) -> case <_0,_1> of <L,Acc> when call 'erlang':'is_list' (L) -> let <B0> = call 'unicode':'characters_to_binary' (L) in let <B1> = apply 'decode'/2 (B0,Acc) in call 'unicode':'characters_to_list' (B1)
<#{#<37>(8,1,'integer',['unsigned'|['big']]),#<C0>(8,1,'integer',['unsigned'|['big']]),#<C1>(8,1,'integer',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_6> = case apply 'is_hex_digit'/1 (C0) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_hex_digit'/1 (C1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_4> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_4}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case _6 of <'true'> when 'true' -> let <_30> = case <> of <> when try (let <_21> = case call 'erlang':'>=' (C0,48) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,57)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_19> when 'true' -> _19-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_21-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C0,48)
<> when try (let <_24> = case call 'erlang':'>=' (C0,65) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,70)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_22> when 'true' -> _22-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_24-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_25> = call 'erlang':'-' (C0,65) in call 'erlang':'+' (_25,10)
<> when try (let <_28> = case call 'erlang':'>=' (C0,97) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,102)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_26> when 'true' -> _26-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_28-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_29> = call 'erlang':'-' (C0,97) in call 'erlang':'+' (_29,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <_31> = call 'erlang':'*' (_30,16) in let <_18> = case <> of <> when try (let <_9> = case call 'erlang':'>=' (C1,48) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,57)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_7> when 'true' -> _7-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_9-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C1,48)
<> when try (let <_12> = case call 'erlang':'>=' (C1,65) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,70)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_10> when 'true' -> _10-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_12-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_13> = call 'erlang':'-' (C1,65) in call 'erlang':'+' (_13,10)
<> when try (let <_16> = case call 'erlang':'>=' (C1,97) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,102)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_14> when 'true' -> _14-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_16-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_17> = call 'erlang':'-' (C1,97) in call 'erlang':'+' (_17,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <B> = call 'erlang':'+' (_31,_18) in case apply 'is_reserved'/1 (B) of <'true'> when 'true' -> let <H0> = apply 'hex_to_upper'/1 (C0) in let <H1> = apply 'hex_to_upper'/1 (C1) in let <_35> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<37>(8,1,'integer',['unsigned'|['big']]),#<H0>(8,1,'integer',['unsigned'|['big']]),#<H1>(8,1,'integer',['unsigned'|['big']])}# in apply 'decode'/2 (Cs,_35)
<'false'> when 'true' -> let <_36> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<B>(8,1,'integer',['unsigned'|['big']])}# in apply 'decode'/2 (Cs,_36)
(<_37> when 'true' -> primop 'match_fail' ({'case_clause',_37})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_38> = #{#<37>(8,1,'integer',['unsigned'|['big']]),#<C0>(8,1,'integer',['unsigned'|['big']]),#<C1>(8,1,'integer',['unsigned'|['big']])}# in call 'erlang':'throw' ({'error','invalid_percent_encoding',_38})
(<_39> when 'true' -> primop 'match_fail' ({'case_clause',_39})-|['compiler_generated'] ) end
<#{#<C>(8,1,'integer',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_40> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<C>(8,1,'integer',['unsigned'|['big']])}# in apply 'decode'/2 (Cs,_40)
<#{}#,Acc> when 'true' -> apply 'check_utf8'/1 (Acc)
(<_42,_41> when 'true' -> (primop 'match_fail' ({'function_clause',_42,_41})-|[{'function_name',{'decode',2}}] )-|['compiler_generated'] ) end
'check_utf8'/1 = fun (_0) -> case call 'unicode':'characters_to_list' (_0) of <{'incomplete',_3,_4}> when 'true' -> call 'erlang':'throw' ({'error','invalid_utf8',_0})
<{'error',_5,_6}> when 'true' -> call 'erlang':'throw' ({'error','invalid_utf8',_0})
<_7> when 'true' -> _0 end
'hex_to_upper'/1 = fun (_0) -> case _0 of <H> when let <_1> = call 'erlang':'=<' (97,_0) in let <_2> = call 'erlang':'=<' (_0,102) in call 'erlang':'and' (_1,_2) -> call 'erlang':'-' (H,32)
<H> when let <_3> = call 'erlang':'=<' (48,_0) in let <_4> = call 'erlang':'=<' (_0,57) in let <_5> = call 'erlang':'and' (_3,_4) in let <_6> = call 'erlang':'=<' (65,_0) in let <_7> = call 'erlang':'=<' (_0,70) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'or' (_5,_8) -> H
<H> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',H}) end
'is_host'/1 = fun (_0) -> case _0 of <58> when 'true' -> 'true'
<Char> when 'true' -> (case apply 'is_unreserved'/1 (Char) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'is_sub_delim'/1 (Char)-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'is_path'/1 = fun (_0) -> case _0 of <47> when 'true' -> 'true'
<Char> when 'true' -> apply 'is_pchar'/1 (Char) end
'encode'/2 = fun (_0,_1) -> case <_0,_1> of <Component,Fun> when call 'erlang':'is_list' (Component) -> let <B> = call 'unicode':'characters_to_binary' (Component) in let <_3> = apply 'encode'/3 (B,Fun,#{}#) in call 'unicode':'characters_to_list' (_3)
<Component,Fun> when call 'erlang':'is_binary' (Component) -> apply 'encode'/3 (Component,Fun,#{}#)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'encode',2}}] )-|['compiler_generated'] ) end
'encode'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<Char>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Fun,Acc> when 'true' -> let <C> = apply 'encode_codepoint_binary'/2 (Char,Fun) in let <_4> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<C>('all',8,'binary',['unsigned'|['big']])}# in apply 'encode'/3 (Rest,Fun,_4)
<#{#<Char>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,_X_Fun,_X_Acc> when 'true' -> let <_5> = #{#<Char>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}# in call 'erlang':'throw' ({'error','invalid_input',_5})
<#{}#,_X_Fun,Acc> when 'true' -> Acc
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'encode',3}}] )-|['compiler_generated'] ) end
'encode_codepoint_binary'/2 = fun (_0,_1) -> case apply _1 (_0) of <'false'> when 'true' -> apply 'percent_encode_binary'/1 (_0)
<'true'> when 'true' -> #{#<_0>(8,1,'integer',['unsigned'|['big']])}#
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'percent_encode_binary'/1 = fun (_0) -> let <_1> = #{#<_0>('undefined','undefined','utf8',['unsigned'|['big']])}# in apply 'percent_encode_binary'/2 (_1,#{}#)
'percent_encode_binary'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<A>(4,1,'integer',['unsigned'|['big']]),#<B>(4,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_17> = case <> of <> when try (let <_12> = case call 'erlang':'>=' (A,0) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (A,9)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_10> when 'true' -> _10-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_12-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (A,48)
<> when try (let <_15> = case call 'erlang':'>=' (A,10) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (A,15)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_13> when 'true' -> _13-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_15-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_16> = call 'erlang':'+' (A,65) in call 'erlang':'-' (_16,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <_9> = case <> of <> when try (let <_4> = case call 'erlang':'>=' (B,0) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (B,9)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_2> when 'true' -> _2-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_4-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (B,48)
<> when try (let <_7> = case call 'erlang':'>=' (B,10) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (B,15)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_8> = call 'erlang':'+' (B,65) in call 'erlang':'-' (_8,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <_18> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<37>(8,1,'integer',['unsigned'|['big']]),#<_17>(8,1,'integer',['unsigned'|['big']]),#<_9>(8,1,'integer',['unsigned'|['big']])}# in apply 'percent_encode_binary'/2 (Rest,_18)
<#{}#,Acc> when 'true' -> Acc
(<_20,_19> when 'true' -> (primop 'match_fail' ({'function_clause',_20,_19})-|[{'function_name',{'percent_encode_binary',2}}] )-|['compiler_generated'] ) end
'validate_scheme'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'true'
<[H|T]> when 'true' -> case apply 'is_scheme'/1 (H) of <'true'> when 'true' -> apply 'validate_scheme'/1 (T)
<'false'> when 'true' -> 'false'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
<#{}#> when 'true' -> 'true'
<#{#<H>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case apply 'is_scheme'/1 (H) of <'true'> when 'true' -> apply 'validate_scheme'/1 (Rest)
<'false'> when 'true' -> 'false'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'validate_scheme',1}}] )-|['compiler_generated'] ) end
'classify_host'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'other'
<Addr> when call 'erlang':'is_binary' (_0) -> let <A> = call 'unicode':'characters_to_list' (Addr) in apply 'classify_host_ipv6'/1 (A)
<Addr> when 'true' -> apply 'classify_host_ipv6'/1 (Addr) end
'classify_host_ipv6'/1 = fun (_0) -> case apply 'is_ipv6_address'/1 (_0) of <'true'> when 'true' -> 'ipv6'
<'false'> when 'true' -> apply 'classify_host_ipv4'/1 (_0)
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'classify_host_ipv4'/1 = fun (_0) -> case apply 'is_ipv4_address'/1 (_0) of <'true'> when 'true' -> 'ipv4'
<'false'> when 'true' -> apply 'classify_host_regname'/1 (_0)
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'classify_host_regname'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'regname'
<[H|T]> when 'true' -> case apply 'is_reg_name'/1 (H) of <'true'> when 'true' -> apply 'classify_host_regname'/1 (T)
<'false'> when 'true' -> 'other'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'classify_host_regname',1}}] )-|['compiler_generated'] ) end
'is_ipv4_address'/1 = fun (_0) -> case call 'inet':'parse_ipv4strict_address' (_0) of <{'ok',_3}> when 'true' -> 'true'
<{'error',_4}> when 'true' -> 'false'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'is_ipv6_address'/1 = fun (_0) -> case call 'inet':'parse_ipv6strict_address' (_0) of <{'ok',_3}> when 'true' -> 'true'
<{'error',_4}> when 'true' -> 'false'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'bracket_ipv6'/1 = fun (_0) -> case _0 of <Addr> when call 'erlang':'is_binary' (_0) -> let <_1> = #{#<91>(8,1,'integer',['unsigned'|['big']]),#<Addr>('all',8,'binary',['unsigned'|['big']])}# in apply 'concat'/2 (_1,#{#<93>(8,1,'integer',['unsigned'|['big']])}#)
<Addr> when call 'erlang':'is_list' (_0) -> [91|call 'erlang':'++' (Addr,[93])]
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'bracket_ipv6',1}}] )-|['compiler_generated'] ) end
'is_valid_map'/1 = fun (_0) -> case _0 of <Map = ~{'path':=Path}~> when 'true' -> let <_4> = case apply 'starts_with_two_slash'/1 (Path) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_valid_map_host'/1 (Map)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_2> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_2}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in (case _4 of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> let <_8> = case call 'maps':'is_key' ('userinfo',Map) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_valid_map_host'/1 (Map)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_6> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_6}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in (case _8 of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> let <_12> = case call 'maps':'is_key' ('port',Map) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_valid_map_host'/1 (Map)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_10> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_10}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in (case _12 of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'all_fields_valid'/1 (Map)-|['compiler_generated'] )
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_9}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_5> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_5}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<~{}~> when 'true' -> 'false'
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'is_valid_map',1}}] )-|['compiler_generated'] ) end
'is_valid_map_host'/1 = fun (_0) -> (case call 'maps':'is_key' ('host',_0) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'all_fields_valid'/1 (_0)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'all_fields_valid'/1 = fun (_0) -> let <Fun> = fun (_3,_2,_1) -> case <_3,_2,_1> of <'scheme',_9,Acc> when 'true' -> Acc
<'userinfo',_10,Acc> when 'true' -> Acc
<'host',_11,Acc> when 'true' -> Acc
<'port',_12,Acc> when 'true' -> Acc
<'path',_13,Acc> when 'true' -> Acc
<'query',_14,Acc> when 'true' -> Acc
<'fragment',_15,Acc> when 'true' -> Acc
<_16,_17,_18> when 'true' -> 'false' end in call 'maps':'fold' (Fun,'true',_0)
'starts_with_two_slash'/1 = fun (_0) -> case _0 of <[47|[47|_2]]> when 'true' -> 'true'
<#{#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<47>('undefined','undefined','utf8',['unsigned'|['big']]),#<_3>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> 'true'
<_4> when 'true' -> 'false' end
'update_scheme'/2 = fun (_0,_1) -> case <_0,_1> of <~{'scheme':=Scheme}~,_5> when 'true' -> let <_2> = apply 'encode_scheme'/1 (Scheme) in apply 'add_colon_postfix'/1 (_2)
<~{}~,_6> when 'true' -> 'empty'
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'update_scheme',2}}] )-|['compiler_generated'] ) end
'update_userinfo'/2 = fun (_0,_1) -> case <_0,_1> of <~{'userinfo':=Userinfo}~,'empty'> when 'true' -> let <_2> = apply 'encode_userinfo'/1 (Userinfo) in apply 'add_auth_prefix'/1 (_2)
<~{'userinfo':=Userinfo}~,URI> when 'true' -> let <_3> = apply 'encode_userinfo'/1 (Userinfo) in let <_4> = apply 'add_auth_prefix'/1 (_3) in apply 'concat'/2 (URI,_4)
<~{}~,'empty'> when 'true' -> 'empty'
<~{}~,URI> when 'true' -> URI
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'update_userinfo',2}}] )-|['compiler_generated'] ) end
'update_host'/2 = fun (_0,_1) -> case <_0,_1> of <~{'host':=Host}~,'empty'> when 'true' -> let <_2> = apply 'encode_host'/1 (Host) in apply 'add_auth_prefix'/1 (_2)
<Map = ~{'host':=Host}~,URI> when 'true' -> let <_3> = apply 'encode_host'/1 (Host) in let <_4> = apply 'add_host_prefix'/2 (Map,_3) in apply 'concat'/2 (URI,_4)
<~{}~,'empty'> when 'true' -> 'empty'
<~{}~,URI> when 'true' -> URI
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'update_host',2}}] )-|['compiler_generated'] ) end
'update_port'/2 = fun (_0,_1) -> case <_0,_1> of <~{'port':='undefined'}~,URI> when 'true' -> apply 'concat'/2 (URI,#{#<58>(8,1,'integer',['unsigned'|['big']])}#)
<~{'port':=Port}~,URI> when 'true' -> let <_2> = apply 'encode_port'/1 (Port) in let <_3> = apply 'add_colon'/1 (_2) in apply 'concat'/2 (URI,_3)
<~{}~,URI> when 'true' -> URI
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'update_port',2}}] )-|['compiler_generated'] ) end
'update_path'/2 = fun (_0,_1) -> case <_0,_1> of <~{'path':=Path}~,'empty'> when 'true' -> apply 'encode_path'/1 (Path)
<~{'path':=Path}~,URI> when 'true' -> let <_2> = apply 'encode_path'/1 (Path) in apply 'concat'/2 (URI,_2)
<~{}~,'empty'> when 'true' -> 'empty'
<~{}~,URI> when 'true' -> URI
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'update_path',2}}] )-|['compiler_generated'] ) end
'update_query'/2 = fun (_0,_1) -> case <_0,_1> of <~{'query':=Query}~,'empty'> when 'true' -> apply 'encode_query'/1 (Query)
<~{'query':=Query}~,URI> when 'true' -> let <_2> = apply 'encode_query'/1 (Query) in let <_3> = apply 'add_question_mark'/1 (_2) in apply 'concat'/2 (URI,_3)
<~{}~,'empty'> when 'true' -> 'empty'
<~{}~,URI> when 'true' -> URI
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'update_query',2}}] )-|['compiler_generated'] ) end
'update_fragment'/2 = fun (_0,_1) -> case <_0,_1> of <~{'fragment':=Fragment}~,'empty'> when 'true' -> let <_2> = apply 'encode_fragment'/1 (Fragment) in apply 'add_hashmark'/1 (_2)
<~{'fragment':=Fragment}~,URI> when 'true' -> let <_3> = apply 'encode_fragment'/1 (Fragment) in let <_4> = apply 'add_hashmark'/1 (_3) in apply 'concat'/2 (URI,_4)
<~{}~,'empty'> when 'true' -> []
<~{}~,URI> when 'true' -> URI
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'update_fragment',2}}] )-|['compiler_generated'] ) end
'concat'/2 = fun (_0,_1) -> case <_0,_1> of <A,B> when let <_2> = call 'erlang':'is_binary' (A) in let <_3> = call 'erlang':'is_binary' (B) in call 'erlang':'and' (_2,_3) -> #{#<A>('all',8,'binary',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}#
<A,B> when let <_4> = call 'erlang':'is_binary' (A) in let <_5> = call 'erlang':'is_list' (B) in call 'erlang':'and' (_4,_5) -> let <_6> = call 'unicode':'characters_to_list' (A) in call 'erlang':'++' (_6,B)
<A,B> when call 'erlang':'is_list' (A) -> let <_7> = apply 'maybe_to_list'/1 (B) in call 'erlang':'++' (A,_7)
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'concat',2}}] )-|['compiler_generated'] ) end
'add_hashmark'/1 = fun (_0) -> case _0 of <Comp> when call 'erlang':'is_binary' (_0) -> #{#<35>(8,1,'integer',['unsigned'|['big']]),#<Comp>('all',8,'binary',['unsigned'|['big']])}#
<Comp> when call 'erlang':'is_list' (_0) -> [35|Comp]
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'add_hashmark',1}}] )-|['compiler_generated'] ) end
'add_question_mark'/1 = fun (_0) -> case _0 of <Comp> when call 'erlang':'is_binary' (_0) -> #{#<63>(8,1,'integer',['unsigned'|['big']]),#<Comp>('all',8,'binary',['unsigned'|['big']])}#
<Comp> when call 'erlang':'is_list' (_0) -> [63|Comp]
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'add_question_mark',1}}] )-|['compiler_generated'] ) end
'add_colon'/1 = fun (_0) -> case _0 of <Comp> when call 'erlang':'is_binary' (_0) -> #{#<58>(8,1,'integer',['unsigned'|['big']]),#<Comp>('all',8,'binary',['unsigned'|['big']])}#
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'add_colon',1}}] )-|['compiler_generated'] ) end
'add_colon_postfix'/1 = fun (_0) -> case _0 of <Comp> when call 'erlang':'is_binary' (_0) -> #{#<Comp>('all',8,'binary',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']])}#
<Comp> when call 'erlang':'is_list' (_0) -> call 'erlang':'++' (Comp,[58])
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'add_colon_postfix',1}}] )-|['compiler_generated'] ) end
'add_auth_prefix'/1 = fun (_0) -> case _0 of <Comp> when call 'erlang':'is_binary' (_0) -> #{#<12079>(16,1,'integer',['unsigned'|['big']]),#<Comp>('all',8,'binary',['unsigned'|['big']])}#
<Comp> when call 'erlang':'is_list' (_0) -> [47|[47|Comp]]
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'add_auth_prefix',1}}] )-|['compiler_generated'] ) end
'add_host_prefix'/2 = fun (_0,_1) -> case <_0,_1> of <~{'userinfo':=_4}~,Host> when call 'erlang':'is_binary' (Host) -> #{#<64>(8,1,'integer',['unsigned'|['big']]),#<Host>('all',8,'binary',['unsigned'|['big']])}#
<~{}~,Host> when call 'erlang':'is_binary' (Host) -> #{#<12079>(16,1,'integer',['unsigned'|['big']]),#<Host>('all',8,'binary',['unsigned'|['big']])}#
<~{'userinfo':=_5}~,Host> when call 'erlang':'is_list' (Host) -> [64|Host]
<~{}~,Host> when call 'erlang':'is_list' (Host) -> [47|[47|Host]]
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'add_host_prefix',2}}] )-|['compiler_generated'] ) end
'maybe_to_list'/1 = fun (_0) -> case _0 of <Comp> when call 'erlang':'is_binary' (_0) -> call 'unicode':'characters_to_list' (Comp)
<Comp> when 'true' -> Comp end
'encode_port'/1 = fun (_0) -> call 'erlang':'integer_to_binary' (_0)
'resolve_map'/2 = fun (_0,_1) -> case <_0,_1> of <URIMap = ~{'scheme':=_7}~,_8> when 'true' -> apply 'normalize_path_segment'/1 (URIMap)
<URIMap,BaseURIMap = ~{'scheme':=_9}~> when 'true' -> let <_2> = apply 'resolve_path_type'/1 (URIMap) in apply 'resolve_map'/3 (URIMap,BaseURIMap,_2)
<_X_URIMap,BaseURIMap> when call 'erlang':'is_map' (BaseURIMap) -> {'error','invalid_scheme',[]}
<URIMap,BaseURIString> when 'true' -> case apply 'parse'/1 (BaseURIString) of <BaseURIMap = ~{'scheme':=_10}~> when 'true' -> let <_3> = apply 'resolve_path_type'/1 (URIMap) in apply 'resolve_map'/3 (URIMap,BaseURIMap,_3)
<BaseURIMap> when call 'erlang':'is_map' (BaseURIMap) -> {'error','invalid_scheme',[]}
<Error> when 'true' -> Error end end
'resolve_path_type'/1 = fun (_0) -> let <_1> = call 'maps':'get' ('path',_0,#{}#) in case call 'erlang':'iolist_to_binary' (_1) of <#{}#> when 'true' -> 'empty_path'
<#{#<47>(8,1,'integer',['unsigned'|['big']]),#<_4>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> 'absolute_path'
<_5> when 'true' -> 'relative_path' end
'resolve_map'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <URI = ~{'host':=_17}~,~{'scheme':=Scheme}~,_18> when 'true' -> case <> of (<> when call 'erlang':'is_map' (URI) -> let <_3> = ~{'scheme'=>Scheme|URI}~ in apply 'normalize_path_segment'/1 (_3)-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<URI,BaseURI,'empty_path'> when 'true' -> let <_5> = case call 'maps':'is_key' ('query',URI) of <'true'> when 'true' -> ['scheme'|['userinfo'|['host'|['port'|['path']]]]]
<'false'> when 'true' -> ['scheme'|['userinfo'|['host'|['port'|['path'|['query']]]]]]
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in let <_7> = call 'maps':'with' (_5,BaseURI) in call 'maps':'merge' (URI,_7)
<URI,BaseURI,'absolute_path'> when 'true' -> let <_8> = call 'maps':'with' (['scheme'|['userinfo'|['host'|['port']]]],BaseURI) in let <_9> = call 'maps':'merge' (URI,_8) in apply 'normalize_path_segment'/1 (_9)
<URI = ~{'path':=Path}~,BaseURI,'relative_path'> when 'true' -> let <_11> = apply 'merge_paths'/2 (Path,BaseURI) in case <> of (<> when call 'erlang':'is_map' (URI) -> let <_12> = ~{'path'=>_11|URI}~ in let <_10> = call 'maps':'with' (['scheme'|['userinfo'|['host'|['port']]]],BaseURI) in let <_13> = call 'maps':'merge' (_12,_10) in apply 'normalize_path_segment'/1 (_13)-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',URI})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_16,_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14})-|[{'function_name',{'resolve_map',3}}] )-|['compiler_generated'] ) end
'merge_paths'/2 = fun (_0,_1) -> case <_0,_1> of <Path,BaseURI = ~{'path':=BasePath0}~> when 'true' -> let <_2> = call 'erlang':'iolist_size' (BasePath0) in case <BaseURI,_2> of <(~{(('host'-|['compiler_generated'] ):=_7-|['compiler_generated'] )}~-|['compiler_generated'] ),(0-|['compiler_generated'] )> when 'true' -> apply 'merge_paths_absolute'/1 (Path)
<(_12-|['compiler_generated'] ),(_13-|['compiler_generated'] )> when 'true' -> case call 'string':'split' (BasePath0,#{#<47>(8,1,'integer',['unsigned'|['big']])}#,'trailing') of <[BasePath|[_9|[]]]> when call 'erlang':'is_binary' (Path) -> call 'unicode':'characters_to_binary' ([BasePath|[47|[Path|[]]]])
<[BasePath|[_10|[]]]> when call 'erlang':'is_list' (Path) -> call 'unicode':'characters_to_list' ([BasePath|[47|[Path|[]]]])
<[_11|[]]> when 'true' -> Path
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end end
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'merge_paths',2}}] )-|['compiler_generated'] ) end
'merge_paths_absolute'/1 = fun (_0) -> case _0 of <Path> when call 'erlang':'is_binary' (_0) -> #{#<47>(8,1,'integer',['unsigned'|['big']]),#<Path>('all',8,'binary',['unsigned'|['big']])}#
<Path> when call 'erlang':'is_list' (_0) -> call 'unicode':'characters_to_list' ([47|[Path|[]]])
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'merge_paths_absolute',1}}] )-|['compiler_generated'] ) end
'transcode'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L = [37|[_X_C0|[_X_C1|_X_Rest]]],Acc,InEnc,OutEnc> when 'true' -> apply 'transcode_pct'/5 (L,Acc,#{}#,InEnc,OutEnc)
<L = [_X_C|_X_Rest],Acc,InEnc,OutEnc> when 'true' -> apply 'transcode'/5 (L,Acc,[],InEnc,OutEnc)
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'transcode',4}}] )-|['compiler_generated'] ) end
'transcode'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <L = [37|[_X_C0|[_X_C1|_X_Rest]]],Acc,List,InEncoding,OutEncoding> when 'true' -> let <_5> = call 'erlang':'++' (List,Acc) in apply 'transcode_pct'/5 (L,_5,#{}#,InEncoding,OutEncoding)
<[C|Rest],Acc,List,InEncoding,OutEncoding> when 'true' -> apply 'transcode'/5 (Rest,Acc,[C|List],InEncoding,OutEncoding)
<[],Acc,List,_X_InEncoding,_X_OutEncoding> when 'true' -> let <_6> = call 'erlang':'++' (List,Acc) in call 'lists':'reverse' (_6)
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'transcode',5}}] )-|['compiler_generated'] ) end
'transcode_pct'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <L = [37|[C0|[C1|Rest]]],Acc,B,InEncoding,OutEncoding> when 'true' -> let <_7> = case apply 'is_hex_digit'/1 (C0) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_hex_digit'/1 (C1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_5}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case _7 of <'true'> when 'true' -> let <_31> = case <> of <> when try (let <_22> = case call 'erlang':'>=' (C0,48) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,57)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_20> when 'true' -> _20-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_22-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C0,48)
<> when try (let <_25> = case call 'erlang':'>=' (C0,65) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,70)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_23> when 'true' -> _23-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_25-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_26> = call 'erlang':'-' (C0,65) in call 'erlang':'+' (_26,10)
<> when try (let <_29> = case call 'erlang':'>=' (C0,97) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,102)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_27> when 'true' -> _27-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_29-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_30> = call 'erlang':'-' (C0,97) in call 'erlang':'+' (_30,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <_32> = call 'erlang':'*' (_31,16) in let <_19> = case <> of <> when try (let <_10> = case call 'erlang':'>=' (C1,48) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,57)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_8> when 'true' -> _8-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_10-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C1,48)
<> when try (let <_13> = case call 'erlang':'>=' (C1,65) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,70)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_11> when 'true' -> _11-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_13-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_14> = call 'erlang':'-' (C1,65) in call 'erlang':'+' (_14,10)
<> when try (let <_17> = case call 'erlang':'>=' (C1,97) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,102)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_15> when 'true' -> _15-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_17-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_18> = call 'erlang':'-' (C1,97) in call 'erlang':'+' (_18,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <Int> = call 'erlang':'+' (_32,_19) in let <_34> = #{#<B>('all',8,'binary',['unsigned'|['big']]),#<Int>(8,1,'integer',['unsigned'|['big']])}# in apply 'transcode_pct'/5 (Rest,Acc,_34,InEncoding,OutEncoding)
<'false'> when 'true' -> call 'erlang':'throw' ({'error','invalid_percent_encoding',L})
(<_35> when 'true' -> primop 'match_fail' ({'case_clause',_35})-|['compiler_generated'] ) end
<L = [_X_C|_X_Rest],Acc,B,InEncoding,OutEncoding> when 'true' -> let <OutBinary> = apply 'convert_to_binary'/3 (B,InEncoding,OutEncoding) in let <PctEncUtf8> = apply 'percent_encode_segment'/1 (OutBinary) in let <_38> = apply 'convert_to_list'/2 (PctEncUtf8,'utf8') in let <Out> = call 'lists':'reverse' (_38) in let <_40> = call 'erlang':'++' (Out,Acc) in apply 'transcode'/5 (L,_40,[],InEncoding,OutEncoding)
<[],Acc,B,InEncoding,OutEncoding> when 'true' -> let <OutBinary> = apply 'convert_to_binary'/3 (B,InEncoding,OutEncoding) in let <PctEncUtf8> = apply 'percent_encode_segment'/1 (OutBinary) in let <Out> = apply 'convert_to_list'/2 (PctEncUtf8,'utf8') in let <_44> = call 'lists':'reverse' (Acc) in call 'erlang':'++' (_44,Out)
(<_49,_48,_47,_46,_45> when 'true' -> (primop 'match_fail' ({'function_clause',_49,_48,_47,_46,_45})-|[{'function_name',{'transcode_pct',5}}] )-|['compiler_generated'] ) end
'convert_to_binary'/3 = fun (_0,_1,_2) -> case call 'unicode':'characters_to_binary' (_0,_1,_2) of <{'error',_X_List,RestData}> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',RestData})
<{'incomplete',_X_List,RestData}> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',RestData})
<Result> when 'true' -> Result end
'convert_to_list'/2 = fun (_0,_1) -> case call 'unicode':'characters_to_list' (_0,_1) of <{'error',_X_List,RestData}> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',RestData})
<{'incomplete',_X_List,RestData}> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',RestData})
<Result> when 'true' -> Result end
'flatten_list'/2 = fun (_0,_1) -> case <_0,_1> of <[],_4> when 'true' -> []
<L,InEnc> when 'true' -> apply 'flatten_list'/3 (L,InEnc,[]) end
'flatten_list'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[H|T],InEnc,Acc> when call 'erlang':'is_binary' (H) -> let <L> = apply 'convert_to_list'/2 (H,InEnc) in let <_4> = call 'lists':'reverse' (L) in let <_5> = call 'erlang':'++' (_4,Acc) in apply 'flatten_list'/3 (T,InEnc,_5)
<[H|T],InEnc,Acc> when call 'erlang':'is_list' (H) -> let <_6> = call 'erlang':'++' (H,T) in apply 'flatten_list'/3 (_6,InEnc,Acc)
<[H|T],InEnc,Acc> when 'true' -> apply 'flatten_list'/3 (T,InEnc,[H|Acc])
<[],_X_InEnc,Acc> when 'true' -> call 'lists':'reverse' (Acc)
<Arg,_10,_11> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',Arg}) end
'percent_encode_segment'/1 = fun (_0) -> apply 'percent_encode_binary'/2 (_0,#{}#)
'get_separator'/1 = fun (_0) -> case _0 of <L> when try let <_1> = call 'erlang':'length' (_0) in call 'erlang':'=:=' (_1,0) of <Try> -> Try catch <T,R> -> 'false' -> #{}#
<_X_L> when 'true' -> #{#<38>(8,1,'integer',['unsigned'|['big']])}# end
'form_urlencode'/2 = fun (_0,_1) -> case <_0,_1> of <Cs,[{'encoding','latin1'}]> when call 'erlang':'is_list' (Cs) -> let <B> = apply 'convert_to_binary'/3 (Cs,'utf8','utf8') in let <_3> = apply 'base10_encode'/1 (B) in apply 'html5_byte_encode'/1 (_3)
<Cs,[{'encoding','latin1'}]> when call 'erlang':'is_binary' (Cs) -> let <_4> = apply 'base10_encode'/1 (Cs) in apply 'html5_byte_encode'/1 (_4)
<Cs,[{'encoding',Encoding}|[]]> when let <_5> = call 'erlang':'is_list' (Cs) in let <_6> = call 'erlang':'=:=' (Encoding,'utf8') in let <_7> = call 'erlang':'and' (_5,_6) in let <_8> = call 'erlang':'=:=' (Encoding,'unicode') in call 'erlang':'or' (_7,_8) -> let <B> = apply 'convert_to_binary'/3 (Cs,'utf8',Encoding) in apply 'html5_byte_encode'/1 (B)
<Cs,[{'encoding',Encoding}|[]]> when let <_10> = call 'erlang':'is_binary' (Cs) in let <_11> = call 'erlang':'=:=' (Encoding,'utf8') in let <_12> = call 'erlang':'and' (_10,_11) in let <_13> = call 'erlang':'=:=' (Encoding,'unicode') in call 'erlang':'or' (_12,_13) -> apply 'html5_byte_encode'/1 (Cs)
<Cs,[{'encoding',Encoding}|[]]> when let <_14> = call 'erlang':'is_list' (Cs) in let <_15> = call 'erlang':'is_binary' (Cs) in call 'erlang':'or' (_14,_15) -> call 'erlang':'throw' ({'error','invalid_encoding',Encoding})
<Cs,_18> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',Cs}) end
'base10_encode'/1 = fun (_0) -> apply 'base10_encode'/2 (_0,#{}#)
'base10_encode'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,Acc> when 'true' -> Acc
<#{#<H>('undefined','undefined','utf8',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when call 'erlang':'>' (H,255) -> let <_2> = call 'erlang':'integer_to_list' (H,10) in let <Base10> = apply 'convert_to_binary'/3 (_2,'utf8','utf8') in let <_4> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<9763>(16,1,'integer',['unsigned'|['big']]),#<Base10>('all',8,'binary',['unsigned'|['big']]),#<59>(8,1,'integer',['unsigned'|['big']])}# in apply 'base10_encode'/2 (T,_4)
<#{#<H>('undefined','undefined','utf8',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_5> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<H>(8,1,'integer',['unsigned'|['big']])}# in apply 'base10_encode'/2 (T,_5)
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'base10_encode',2}}] )-|['compiler_generated'] ) end
'html5_byte_encode'/1 = fun (_0) -> apply 'html5_byte_encode'/2 (_0,#{}#)
'html5_byte_encode'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,Acc> when 'true' -> Acc
<#{#<32>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_2> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<43>(8,1,'integer',['unsigned'|['big']])}# in apply 'html5_byte_encode'/2 (T,_2)
<#{#<H>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> case apply 'is_url_char'/1 (H) of <'true'> when 'true' -> let <_3> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<H>(8,1,'integer',['unsigned'|['big']])}# in apply 'html5_byte_encode'/2 (T,_3)
<'false'> when 'true' -> case #{#<H>(8,1,'integer',['unsigned'|['big']])}# of <#{#<A>(4,1,'integer',['unsigned'|['big']]),#<B>(4,1,'integer',['unsigned'|['big']])}#> when 'true' -> let <_20> = case <> of <> when try (let <_15> = case call 'erlang':'>=' (A,0) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (A,9)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_13> when 'true' -> _13-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_15-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (A,48)
<> when try (let <_18> = case call 'erlang':'>=' (A,10) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (A,15)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_16> when 'true' -> _16-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_18-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_19> = call 'erlang':'+' (A,65) in call 'erlang':'-' (_19,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <_12> = case <> of <> when try (let <_7> = case call 'erlang':'>=' (B,0) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (B,9)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (B,48)
<> when try (let <_10> = case call 'erlang':'>=' (B,10) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (B,15)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_8> when 'true' -> _8-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_10-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_11> = call 'erlang':'+' (B,65) in call 'erlang':'-' (_11,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <_21> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<37>(8,1,'integer',['unsigned'|['big']]),#<_20>(8,1,'integer',['unsigned'|['big']]),#<_12>(8,1,'integer',['unsigned'|['big']])}# in apply 'html5_byte_encode'/2 (T,_21)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end
<H,_X_Acc> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',H}) end
'is_url_char'/1 = fun (_0) -> case _0 of <C> when let <_1> = call 'erlang':'=:=' (_0,42) in let <_2> = call 'erlang':'=:=' (_0,45) in let <_3> = call 'erlang':'=:=' (_0,46) in let <_4> = call 'erlang':'=:=' (_0,95) in let <_5> = call 'erlang':'=<' (48,_0) in let <_6> = call 'erlang':'=<' (_0,57) in let <_7> = call 'erlang':'and' (_5,_6) in let <_8> = call 'erlang':'=<' (65,_0) in let <_9> = call 'erlang':'=<' (_0,90) in let <_10> = call 'erlang':'and' (_8,_9) in let <_11> = call 'erlang':'=<' (97,_0) in let <_12> = call 'erlang':'=<' (_0,122) in let <_13> = call 'erlang':'and' (_11,_12) in let <_14> = call 'erlang':'or' (_10,_13) in let <_15> = call 'erlang':'or' (_7,_14) in let <_16> = call 'erlang':'or' (_4,_15) in let <_17> = call 'erlang':'or' (_3,_16) in let <_18> = call 'erlang':'or' (_2,_17) in call 'erlang':'or' (_1,_18) -> 'true'
<_20> when 'true' -> 'false' end
'dissect_query_key'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <#{#<61>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,IsList,Acc,Key,Value> when 'true' -> apply 'dissect_query_value'/5 (T,IsList,Acc,Key,Value)
<#{#<38>(8,1,'integer',['unsigned'|['big']]),#<35>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,IsList,Acc,Key,Value> when 'true' -> let <_5> = #{#<Key>('all',8,'binary',['unsigned'|['big']]),#<9763>(16,1,'integer',['unsigned'|['big']])}# in apply 'dissect_query_key'/5 (T,IsList,Acc,_5,Value)
<T = #{#<38>(8,1,'integer',['unsigned'|['big']]),#<_12>('all',8,'binary',['unsigned'|['big']])}#,IsList,Acc,Key,#{}#> when 'true' -> apply 'dissect_query_value'/5 (T,IsList,Acc,Key,'true')
<#{#<H>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,IsList,Acc,Key,Value> when 'true' -> let <_6> = #{#<Key>('all',8,'binary',['unsigned'|['big']]),#<H>(8,1,'integer',['unsigned'|['big']])}# in apply 'dissect_query_key'/5 (T,IsList,Acc,_6,Value)
<T = #{}#,IsList,Acc,Key,#{}#> when 'true' -> apply 'dissect_query_value'/5 (T,IsList,Acc,Key,'true')
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'dissect_query_key',5}}] )-|['compiler_generated'] ) end
'dissect_query_value'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <#{#<38>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,IsList,Acc,Key,Value> when 'true' -> let <K> = apply 'form_urldecode'/2 (IsList,Key) in let <V> = apply 'form_urldecode'/2 (IsList,Value) in apply 'dissect_query_key'/5 (T,IsList,[{K,V}|Acc],#{}#,#{}#)
<#{#<H>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,IsList,Acc,Key,Value> when 'true' -> let <_7> = #{#<Value>('all',8,'binary',['unsigned'|['big']]),#<H>(8,1,'integer',['unsigned'|['big']])}# in apply 'dissect_query_value'/5 (T,IsList,Acc,Key,_7)
<#{}#,IsList,Acc,Key,Value> when 'true' -> let <K> = apply 'form_urldecode'/2 (IsList,Key) in let <V> = apply 'form_urldecode'/2 (IsList,Value) in call 'lists':'reverse' ([{K,V}|Acc])
(<_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11,_10})-|[{'function_name',{'dissect_query_value',5}}] )-|['compiler_generated'] ) end
'form_urldecode'/2 = fun (_0,_1) -> case <_0,_1> of <_42,'true'> when 'true' -> 'true'
<'true',B> when 'true' -> let <_2> = apply 'form_urldecode'/2 (B,#{}#) in let <Result> = apply 'base10_decode'/1 (_2) in apply 'convert_to_list'/2 (Result,'utf8')
<'false',B> when 'true' -> let <_4> = apply 'form_urldecode'/2 (B,#{}#) in apply 'base10_decode'/1 (_4)
<#{}#,Acc> when 'true' -> Acc
<#{#<43>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_5> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}# in apply 'form_urldecode'/2 (T,_5)
<#{#<37>(8,1,'integer',['unsigned'|['big']]),#<C0>(8,1,'integer',['unsigned'|['big']]),#<C1>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_8> = case apply 'is_hex_digit'/1 (C0) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_hex_digit'/1 (C1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_6> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_6}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case _8 of <'true'> when 'true' -> let <_32> = case <> of <> when try (let <_23> = case call 'erlang':'>=' (C0,48) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,57)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_21> when 'true' -> _21-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_23-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C0,48)
<> when try (let <_26> = case call 'erlang':'>=' (C0,65) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,70)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_24> when 'true' -> _24-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_26-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_27> = call 'erlang':'-' (C0,65) in call 'erlang':'+' (_27,10)
<> when try (let <_30> = case call 'erlang':'>=' (C0,97) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C0,102)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_28> when 'true' -> _28-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_30-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_31> = call 'erlang':'-' (C0,97) in call 'erlang':'+' (_31,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <_33> = call 'erlang':'*' (_32,16) in let <_20> = case <> of <> when try (let <_11> = case call 'erlang':'>=' (C1,48) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,57)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_9> when 'true' -> _9-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_11-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'-' (C1,48)
<> when try (let <_14> = case call 'erlang':'>=' (C1,65) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,70)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_12> when 'true' -> _12-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_14-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_15> = call 'erlang':'-' (C1,65) in call 'erlang':'+' (_15,10)
<> when try (let <_18> = case call 'erlang':'>=' (C1,97) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=<' (C1,102)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_16> when 'true' -> _16-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_18-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_19> = call 'erlang':'-' (C1,97) in call 'erlang':'+' (_19,10)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end in let <V> = call 'erlang':'+' (_33,_20) in let <_35> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<V>(8,1,'integer',['unsigned'|['big']])}# in apply 'form_urldecode'/2 (T,_35)
<'false'> when 'true' -> let <_36> = #{#<37>(8,1,'integer',['unsigned'|['big']]),#<C0>(8,1,'integer',['unsigned'|['big']]),#<C1>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}# in let <L> = apply 'convert_to_list'/2 (_36,'utf8') in call 'erlang':'throw' ({'error','invalid_percent_encoding',L})
(<_38> when 'true' -> primop 'match_fail' ({'case_clause',_38})-|['compiler_generated'] ) end
<#{#<H>('undefined','undefined','utf8',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_39> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<H>('undefined','undefined','utf8',['unsigned'|['big']])}# in apply 'form_urldecode'/2 (T,_39)
<#{#<H>(8,1,'integer',['unsigned'|['big']]),#<_43>('all',8,'binary',['unsigned'|['big']])}#,_X_Acc> when 'true' -> call 'erlang':'throw' ({'error','invalid_character',[H|[]]})
(<_41,_40> when 'true' -> (primop 'match_fail' ({'function_clause',_41,_40})-|[{'function_name',{'form_urldecode',2}}] )-|['compiler_generated'] ) end
'base10_decode'/1 = fun (_0) -> apply 'base10_decode'/2 (_0,#{}#)
'base10_decode'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,Acc> when 'true' -> Acc
<#{#<38>(8,1,'integer',['unsigned'|['big']]),#<35>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> apply 'base10_decode_unicode'/2 (T,Acc)
<#{#<H>('undefined','undefined','utf8',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_2> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<H>('undefined','undefined','utf8',['unsigned'|['big']])}# in apply 'base10_decode'/2 (T,_2)
<#{#<H>(8,1,'integer',['unsigned'|['big']]),#<_5>('all',8,'binary',['unsigned'|['big']])}#,_6> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',[H|[]]})
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'base10_decode',2}}] )-|['compiler_generated'] ) end
'base10_decode_unicode'/2 = fun (_0,_1) -> apply 'base10_decode_unicode'/3 (_0,0,_1)
'base10_decode_unicode'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<H>('undefined','undefined','utf8',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Codepoint,Acc> when let <_3> = call 'erlang':'=<' (48,H) in let <_4> = call 'erlang':'=<' (H,57) in call 'erlang':'and' (_3,_4) -> let <_6> = call 'erlang':'*' (Codepoint,10) in let <_5> = call 'erlang':'-' (H,48) in let <Res> = call 'erlang':'+' (_6,_5) in apply 'base10_decode_unicode'/3 (T,Res,Acc)
<#{#<59>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Codepoint,Acc> when 'true' -> let <_8> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<Codepoint>('undefined','undefined','utf8',['unsigned'|['big']])}# in apply 'base10_decode'/2 (T,_8)
<#{#<H>(8,1,'integer',['unsigned'|['big']]),#<_12>('all',8,'binary',['unsigned'|['big']])}#,_13,_14> when 'true' -> call 'erlang':'throw' ({'error','invalid_input',[H|[]]})
(<_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9})-|[{'function_name',{'base10_decode_unicode',3}}] )-|['compiler_generated'] ) end
'normalize_map'/1 = fun (_0) -> let <_1> = apply 'normalize_case'/1 (_0) in let <_2> = apply 'normalize_percent_encoding'/1 (_1) in let <_3> = apply 'normalize_scheme_based'/1 (_2) in apply 'normalize_path_segment'/1 (_3)
'normalize_case'/1 = fun (_0) -> case _0 of <Map = ~{'host':=Host,'scheme':=Scheme}~> when 'true' -> let <_1> = apply 'to_lower'/1 (Scheme) in let <_2> = apply 'to_lower'/1 (Host) in case <> of (<> when call 'erlang':'is_map' (Map) -> ~{'scheme'=>_1,'host'=>_2|Map}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Map})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<Map = ~{'host':=Host}~> when 'true' -> let <_3> = apply 'to_lower'/1 (Host) in case <> of (<> when call 'erlang':'is_map' (Map) -> ~{'host'=>_3|Map}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Map})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<Map = ~{'scheme':=Scheme}~> when 'true' -> let <_4> = apply 'to_lower'/1 (Scheme) in case <> of (<> when call 'erlang':'is_map' (Map) -> ~{'scheme'=>_4|Map}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Map})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<Map = ~{}~> when 'true' -> Map
(<_5> when 'true' -> (primop 'match_fail' ({'function_clause',_5})-|[{'function_name',{'normalize_case',1}}] )-|['compiler_generated'] ) end
'normalize_percent_encoding'/1 = fun (_0) -> let <Fun> = fun (_10,_9) -> case <_10,_9> of <K,V> when let <_1> = call 'erlang':'=:=' (K,'userinfo') in let <_2> = call 'erlang':'=:=' (K,'host') in let <_3> = call 'erlang':'=:=' (K,'path') in let <_4> = call 'erlang':'=:=' (K,'query') in let <_5> = call 'erlang':'=:=' (K,'fragment') in let <_6> = call 'erlang':'or' (_4,_5) in let <_7> = call 'erlang':'or' (_3,_6) in let <_8> = call 'erlang':'or' (_2,_7) in call 'erlang':'or' (_1,_8) -> apply 'decode'/1 (V)
<_15,V> when 'true' -> V end in call 'maps':'map' (Fun,_0)
'to_lower'/1 = fun (_0) -> case _0 of <Cs> when call 'erlang':'is_list' (_0) -> let <B> = apply 'convert_to_binary'/3 (Cs,'utf8','utf8') in let <_2> = apply 'to_lower'/1 (B) in apply 'convert_to_list'/2 (_2,'utf8')
<Cs> when call 'erlang':'is_binary' (_0) -> apply 'to_lower'/2 (Cs,#{}#)
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'to_lower',1}}] )-|['compiler_generated'] ) end
'to_lower'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<C>(8,1,'integer',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#,Acc> when let <_2> = call 'erlang':'=<' (65,C) in let <_3> = call 'erlang':'=<' (C,90) in call 'erlang':'and' (_2,_3) -> let <_4> = call 'erlang':'+' (C,32) in let <_5> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<_4>(8,1,'integer',['unsigned'|['big']])}# in apply 'to_lower'/2 (Cs,_5)
<#{#<C>(8,1,'integer',['unsigned'|['big']]),#<Cs>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_6> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<C>(8,1,'integer',['unsigned'|['big']])}# in apply 'to_lower'/2 (Cs,_6)
<#{}#,Acc> when 'true' -> Acc
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'to_lower',2}}] )-|['compiler_generated'] ) end
'normalize_path_segment'/1 = fun (_0) -> let <Path> = call 'maps':'get' ('path',_0,'undefined') in let <_2> = apply 'remove_dot_segments'/1 (Path) in case <> of (<> when call 'erlang':'is_map' (_0) -> ~{'path'=>_2|_0}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',_0})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
'remove_dot_segments'/1 = fun (_0) -> case _0 of <Path> when call 'erlang':'is_binary' (_0) -> apply 'remove_dot_segments'/2 (Path,#{}#)
<Path> when call 'erlang':'is_list' (_0) -> let <B> = apply 'convert_to_binary'/3 (Path,'utf8','utf8') in let <B1> = apply 'remove_dot_segments'/2 (B,#{}#) in apply 'convert_to_list'/2 (B1,'utf8')
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'remove_dot_segments',1}}] )-|['compiler_generated'] ) end
'remove_dot_segments'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,Output> when 'true' -> Output
<#{#<46>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Output> when 'true' -> apply 'remove_dot_segments'/2 (T,Output)
<#{#<46>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Output> when 'true' -> apply 'remove_dot_segments'/2 (T,Output)
<#{#<47>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Output> when 'true' -> let <_2> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}# in apply 'remove_dot_segments'/2 (_2,Output)
<#{#<47>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']])}#,Output> when 'true' -> apply 'remove_dot_segments'/2 (#{#<47>(8,1,'integer',['unsigned'|['big']])}#,Output)
<#{#<47>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Output> when 'true' -> let <Out1> = apply 'remove_last_segment'/1 (Output) in let <_4> = #{#<47>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}# in apply 'remove_dot_segments'/2 (_4,Out1)
<#{#<47>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']])}#,Output> when 'true' -> let <Out1> = apply 'remove_last_segment'/1 (Output) in apply 'remove_dot_segments'/2 (#{#<47>(8,1,'integer',['unsigned'|['big']])}#,Out1)
<#{#<46>(8,1,'integer',['unsigned'|['big']])}#,Output> when 'true' -> apply 'remove_dot_segments'/2 (#{}#,Output)
<#{#<46>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']])}#,Output> when 'true' -> apply 'remove_dot_segments'/2 (#{}#,Output)
<Input,Output> when 'true' -> case apply 'first_path_segment'/1 (Input) of <{First,Rest}> when 'true' -> let <_7> = #{#<Output>('all',8,'binary',['unsigned'|['big']]),#<First>('all',8,'binary',['unsigned'|['big']])}# in apply 'remove_dot_segments'/2 (Rest,_7)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end end
'first_path_segment'/1 = fun (_0) -> let <F> = apply 'first_path_segment'/2 (_0,#{}#) in let <_2> = call 'erlang':'byte_size' (F) in call 'erlang':'split_binary' (_0,_2)
'first_path_segment'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<47>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_3> = #{#<T>('all',8,'binary',['unsigned'|['big']])}# in let <_2> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']])}# in apply 'first_path_segment_end'/2 (_3,_2)
<#{#<C>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_5> = #{#<T>('all',8,'binary',['unsigned'|['big']])}# in let <_4> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<C>(8,1,'integer',['unsigned'|['big']])}# in apply 'first_path_segment_end'/2 (_5,_4)
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'first_path_segment',2}}] )-|['compiler_generated'] ) end
'first_path_segment_end'/2 = fun (_0,_1) -> case <_0,_1> of <#{}#,Acc> when 'true' -> Acc
<#{#<47>(8,1,'integer',['unsigned'|['big']]),#<_6>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> Acc
<#{#<C>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Acc> when 'true' -> let <_3> = #{#<T>('all',8,'binary',['unsigned'|['big']])}# in let <_2> = #{#<Acc>('all',8,'binary',['unsigned'|['big']]),#<C>(8,1,'integer',['unsigned'|['big']])}# in apply 'first_path_segment_end'/2 (_3,_2)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'first_path_segment_end',2}}] )-|['compiler_generated'] ) end
'remove_last_segment'/1 = fun (_0) -> case _0 of <#{}#> when 'true' -> #{}#
<B> when 'true' -> let <_1> = call 'erlang':'byte_size' (B) in let <_2> = call 'erlang':'-' (_1,1) in case call 'erlang':'split_binary' (B,_2) of <{Init,Last}> when 'true' -> case Last of <#{#<47>(8,1,'integer',['unsigned'|['big']])}#> when 'true' -> Init
<_X_Char> when 'true' -> apply 'remove_last_segment'/1 (Init) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end end
'normalize_scheme_based'/1 = fun (_0) -> let <Scheme> = call 'maps':'get' ('scheme',_0,'undefined') in let <Port> = call 'maps':'get' ('port',_0,'undefined') in let <Path> = call 'maps':'get' ('path',_0,'undefined') in apply 'normalize_scheme_based'/4 (_0,Scheme,Port,Path)
'normalize_scheme_based'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Map,Scheme,Port,Path> when let <_4> = call 'erlang':'=:=' (Scheme,[104|[116|[116|[112]]]]) in let <_5> = call 'erlang':'=:=' (Scheme,#{#<104>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']])}#) in call 'erlang':'or' (_4,_5) -> apply 'normalize_http'/3 (Map,Port,Path)
<Map,Scheme,Port,Path> when let <_6> = call 'erlang':'=:=' (Scheme,[104|[116|[116|[112|[115]]]]]) in let <_7> = call 'erlang':'=:=' (Scheme,#{#<104>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#) in call 'erlang':'or' (_6,_7) -> apply 'normalize_https'/3 (Map,Port,Path)
<Map,Scheme,Port,_X_Path> when let <_8> = call 'erlang':'=:=' (Scheme,[102|[116|[112]]]) in let <_9> = call 'erlang':'=:=' (Scheme,#{#<102>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']])}#) in call 'erlang':'or' (_8,_9) -> apply 'normalize_ftp'/2 (Map,Port)
<Map,Scheme,Port,_X_Path> when let <_10> = call 'erlang':'=:=' (Scheme,[115|[115|[104]]]) in let <_11> = call 'erlang':'=:=' (Scheme,#{#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']])}#) in call 'erlang':'or' (_10,_11) -> apply 'normalize_ssh_sftp'/2 (Map,Port)
<Map,Scheme,Port,_X_Path> when let <_12> = call 'erlang':'=:=' (Scheme,[115|[102|[116|[112]]]]) in let <_13> = call 'erlang':'=:=' (Scheme,#{#<115>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']])}#) in call 'erlang':'or' (_12,_13) -> apply 'normalize_ssh_sftp'/2 (Map,Port)
<Map,Scheme,Port,_X_Path> when let <_14> = call 'erlang':'=:=' (Scheme,[116|[102|[116|[112]]]]) in let <_15> = call 'erlang':'=:=' (Scheme,#{#<116>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']])}#) in call 'erlang':'or' (_14,_15) -> apply 'normalize_tftp'/2 (Map,Port)
<Map,_20,_21,_22> when 'true' -> Map end
'normalize_http'/3 = fun (_0,_1,_2) -> let <M1> = apply 'normalize_port'/3 (_0,_1,80) in apply 'normalize_http_path'/2 (M1,_2)
'normalize_https'/3 = fun (_0,_1,_2) -> let <M1> = apply 'normalize_port'/3 (_0,_1,443) in apply 'normalize_http_path'/2 (M1,_2)
'normalize_ftp'/2 = fun (_0,_1) -> apply 'normalize_port'/3 (_0,_1,21)
'normalize_ssh_sftp'/2 = fun (_0,_1) -> apply 'normalize_port'/3 (_0,_1,22)
'normalize_tftp'/2 = fun (_0,_1) -> apply 'normalize_port'/3 (_0,_1,69)
'normalize_port'/3 = fun (_0,_1,_2) -> case _1 of <_7> when call 'erlang':'=:=' (_1,_2) -> call 'maps':'remove' ('port',_0)
<_X_Else> when 'true' -> _0 end
'normalize_http_path'/2 = fun (_0,_1) -> case _1 of <[]> when 'true' -> case <> of (<> when call 'erlang':'is_map' (_0) -> ~{'path'=>[47]|_0}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',_0})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<#{}#> when 'true' -> case <> of (<> when call 'erlang':'is_map' (_0) -> ~{'path'=>#{#<47>(8,1,'integer',['unsigned'|['big']])}#|_0}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',_0})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<_X_Else> when 'true' -> _0 end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('uri_string')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('uri_string',_0) end