module 'eval_bits' ['bin_gen'/6,'expr_grp'/3,'expr_grp'/5,'match_bits'/6,'match_bits'/7,'module_info'/0,'module_info'/1] attributes [ 'file' = [{[115|[114|[99|[47|[101|[118|[97|[108|[95|[98|[105|[116|[115|[46|[101|[114|[108]]]]]]]]]]]]]]]]],1}]
, 'compile' = [{'no_auto_import',[{'error',1}]}] ] 'expr_grp'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Fields,Bindings,EvalFun,[],_11> when 'true' -> apply 'expr_grp'/4 (Fields,Bindings,EvalFun,#{}#)
<Fields,Bindings,EvalFun,ListOfBits,_12> when 'true' -> let <Bin> = apply 'convert_list'/1 (ListOfBits) in apply 'expr_grp'/4 (Fields,Bindings,EvalFun,Bin) end
'convert_list'/1 = fun (_0) -> let <_3> = call 'erlang':'length' (_0) in let <_4> = call 'erlang':'+' (_3,7) in let <_2> = call 'erlang':'bsr' (_4,3) in let <_1> = primop 'bs_init_writable' (_2) in (letrec 'lbc$^0'/2 = fun (_9,_8) -> case <_9,_8> of <[X|_7],_11> when 'true' -> let <_12> = #{#<_11>('all',1,'binary',['unsigned'|['big']]),#<X>(1,1,'integer',['unsigned'|['big']])}# in apply 'lbc$^0'/2 (_7,_12)
<[],_13> when 'true' -> _13
(<_14,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_15})-|[{'function_name',{'lbc$^0',2}}] )-|['compiler_generated'] ) end in apply 'lbc$^0'/2 (_0,_1)-|['list_comprehension'] )
'expr_grp'/3 = fun (_0,_1,_2) -> apply 'expr_grp'/4 (_0,_1,_2,#{}#)
'expr_grp'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[Field|FS],Bs0,Lf,Acc> when 'true' -> case apply 'eval_field'/3 (Field,Bs0,Lf) of <{Bin,Bs}> when 'true' -> let <_5> = #{#<Acc>('all',1,'binary',['unsigned'|['big']]),#<Bin>('all',1,'binary',['unsigned'|['big']])}# in apply 'expr_grp'/4 (FS,Bs,Lf,_5)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[],Bs0,_X_Lf,Acc> when 'true' -> {'value',Acc,Bs0}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'expr_grp',4}}] )-|['compiler_generated'] ) end
'eval_field'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'bin_element',_36,{'string',_37,S},{'integer',_38,8},['integer'|[{'unit',1}|['unsigned'|['big']]]]},Bs0,_X_Fun> when 'true' -> let <_8> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[C|_4]> when 'true' -> let <_6> = call 'erlang':'band' (C,255) in let <_7> = apply 'lc$^0'/1 (_4) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_42> when 'true' -> (primop 'match_fail' ({'function_clause',_42})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (S) in let <_10> = call 'erlang':'list_to_binary' (_8) in {_10,Bs0}
<{'bin_element',_39,{'string',_40,S},'default','default'},Bs0,_X_Fun> when 'true' -> let <_16> = letrec 'lc$^1'/1 = fun (_13) -> case _13 of <[C|_12]> when 'true' -> let <_14> = call 'erlang':'band' (C,255) in let <_15> = apply 'lc$^1'/1 (_12) in ([_14|_15]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_43> when 'true' -> (primop 'match_fail' ({'function_clause',_43})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (S) in let <_18> = call 'erlang':'list_to_binary' (_16) in {_18,Bs0}
<{'bin_element',Line,{'string',_41,S},Size0,Options0},Bs0,Fun> when 'true' -> case apply 'make_bit_type'/3 (Line,Size0,Options0) of <{Size1,[Type|[{'unit',Unit}|[Sign|[Endian|[]]]]]}> when 'true' -> case apply Fun (Size1,Bs0) of <{'value',Size,Bs1}> when 'true' -> let <_21> = primop 'bs_init_writable' (256) in let <_27> = letrec 'lbc$^2'/2 = fun (_25,_24) -> case <_25,_24> of <[C|_23],_44> when 'true' -> let <_26> = apply 'eval_exp_field1'/6 (C,Size,Unit,Type,Endian,Sign) in let <_45> = #{#<_44>('all',1,'binary',['unsigned'|['big']]),#<_26>('all',8,'binary',['unsigned'|['big']])}# in apply 'lbc$^2'/2 (_23,_45)
<[],_46> when 'true' -> _46
(<_47,_48> when 'true' -> (primop 'match_fail' ({'function_clause',_47,_48})-|[{'function_name',{'lbc$^2',2}}] )-|['compiler_generated'] ) end in apply 'lbc$^2'/2 (S,_21) in {_27,Bs1}
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<{'bin_element',Line,E,Size0,Options0},Bs0,Fun> when 'true' -> case apply Fun (E,Bs0) of <{'value',V,Bs1}> when 'true' -> case apply 'make_bit_type'/3 (Line,Size0,Options0) of <{Size1,[Type|[{'unit',Unit}|[Sign|[Endian|[]]]]]}> when 'true' -> case apply Fun (Size1,Bs1) of <{'value',Size,Bs}> when 'true' -> let <_32> = apply 'eval_exp_field1'/6 (V,Size,Unit,Type,Endian,Sign) in {_32,Bs}
(<_31> when 'true' -> primop 'match_fail' ({'badmatch',_31})-|['compiler_generated'] ) end
(<_30> when 'true' -> primop 'match_fail' ({'badmatch',_30})-|['compiler_generated'] ) end
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end
(<_35,_34,_33> when 'true' -> (primop 'match_fail' ({'function_clause',_35,_34,_33})-|[{'function_name',{'eval_field',3}}] )-|['compiler_generated'] ) end
'eval_exp_field1'/6 = fun (_0,_1,_2,_3,_4,_5) -> try apply 'eval_exp_field'/6 (_0,_1,_2,_3,_4,_5) of <_6> -> _6 catch <_9,_8,_7> -> case <_9,_8,_7> of <('error'-|['compiler_generated'] ),('system_limit'-|['compiler_generated'] ),_22> when 'true' -> let <_10> = call 'erlang':'self' () in let <_11> = call 'erlang':'process_info' (_10,'current_stacktrace') in let <_12> = call 'erlang':'element' (2,_11) in call 'erlang':'raise' ('error','system_limit',_12)
<('error'-|['compiler_generated'] ),_23,_24> when 'true' -> let <_13> = call 'erlang':'self' () in let <_14> = call 'erlang':'process_info' (_13,'current_stacktrace') in let <_15> = call 'erlang':'element' (2,_14) in call 'erlang':'raise' ('error','badarg',_15)
(<_25,_26,_27> when 'true' -> primop 'raise' (_27,_26)-|['compiler_generated'] ) end
'eval_exp_field'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Val,Size,Unit,'integer','little','signed'> when 'true' -> let <_6> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_6,1,'integer',['signed'|['little']])}#
<Val,Size,Unit,'integer','little','unsigned'> when 'true' -> let <_7> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_7,1,'integer',['unsigned'|['little']])}#
<Val,Size,Unit,'integer','native','signed'> when 'true' -> let <_8> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_8,1,'integer',['signed'|['native']])}#
<Val,Size,Unit,'integer','native','unsigned'> when 'true' -> let <_9> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_9,1,'integer',['unsigned'|['native']])}#
<Val,Size,Unit,'integer','big','signed'> when 'true' -> let <_10> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_10,1,'integer',['signed'|['big']])}#
<Val,Size,Unit,'integer','big','unsigned'> when 'true' -> let <_11> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_11,1,'integer',['unsigned'|['big']])}#
<Val,_X_Size,_X_Unit,'utf8',_27,_28> when 'true' -> #{#<Val>('undefined','undefined','utf8',['unsigned'|['big']])}#
<Val,_X_Size,_X_Unit,'utf16','big',_29> when 'true' -> #{#<Val>('undefined','undefined','utf16',['unsigned'|['big']])}#
<Val,_X_Size,_X_Unit,'utf16','little',_30> when 'true' -> #{#<Val>('undefined','undefined','utf16',['unsigned'|['little']])}#
<Val,_X_Size,_X_Unit,'utf32','big',_31> when 'true' -> #{#<Val>('undefined','undefined','utf32',['unsigned'|['big']])}#
<Val,_X_Size,_X_Unit,'utf32','little',_32> when 'true' -> #{#<Val>('undefined','undefined','utf32',['unsigned'|['little']])}#
<Val,Size,Unit,'float','little',_33> when 'true' -> let <_12> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_12,1,'float',['unsigned'|['little']])}#
<Val,Size,Unit,'float','native',_34> when 'true' -> let <_13> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_13,1,'float',['unsigned'|['native']])}#
<Val,Size,Unit,'float','big',_35> when 'true' -> let <_14> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_14,1,'float',['unsigned'|['big']])}#
<Val,'all',Unit,'binary',_36,_37> when 'true' -> case call 'erlang':'bit_size' (Val) of <Size> when try let <_15> = call 'erlang':'rem' (Size,Unit) in call 'erlang':'=:=' (_15,0) of <Try> -> Try catch <T,R> -> 'false' -> #{#<Val>(Size,1,'binary',['unsigned'|['big']])}#
<_38> when 'true' -> let <_16> = call 'erlang':'self' () in let <_17> = call 'erlang':'process_info' (_16,'current_stacktrace') in let <_18> = call 'erlang':'element' (2,_17) in call 'erlang':'raise' ('error','badarg',_18) end
<Val,Size,Unit,'binary',_39,_40> when 'true' -> let <_20> = call 'erlang':'*' (Size,Unit) in #{#<Val>(_20,1,'binary',['unsigned'|['big']])}#
(<_26,_25,_24,_23,_22,_21> when 'true' -> (primop 'match_fail' ({'function_clause',_26,_25,_24,_23,_22,_21})-|[{'function_name',{'eval_exp_field',6}}] )-|['compiler_generated'] ) end
'bin_gen'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <{'bin',_12,Fs},Bin,Bs0,BBs0,Mfun,Efun> when 'true' -> apply 'bin_gen'/7 (Fs,Bin,Bs0,BBs0,Mfun,Efun,'true')
(<_11,_10,_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7,_6})-|[{'function_name',{'bin_gen',6}}] )-|['compiler_generated'] ) end
'bin_gen'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[F|Fs],Bin,Bs0,BBs0,Mfun,Efun,Flag> when try let <_7> = call 'erlang':'is_function' (Mfun,2) in let <_8> = call 'erlang':'is_function' (Efun,2) in call 'erlang':'and' (_7,_8) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'bin_gen_field'/6 (F,Bin,Bs0,BBs0,Mfun,Efun) of <{'match',Bs,BBs,Rest}> when 'true' -> apply 'bin_gen'/7 (Fs,Rest,Bs,BBs,Mfun,Efun,Flag)
<{'nomatch',Rest}> when 'true' -> apply 'bin_gen'/7 (Fs,Rest,Bs0,BBs0,Mfun,Efun,'false')
<'done'> when 'true' -> 'done'
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<[],Bin,Bs0,_X_BBs0,_X_Mfun,_X_Efun,'true'> when 'true' -> {'match',Bin,Bs0}
<[],Bin,_X_Bs0,_X_BBs0,_X_Mfun,_X_Efun,'false'> when 'true' -> {'nomatch',Bin}
(<_16,_15,_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14,_13,_12,_11,_10})-|[{'function_name',{'bin_gen',7}}] )-|['compiler_generated'] ) end
'bin_gen_field'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <{'bin_element',_35,{'string',_36,S},'default','default'},Bin,Bs,BBs,_X_Mfun,_X_Efun> when 'true' -> let <_10> = try call 'erlang':'list_to_binary' (S) of <_6> -> _6 catch <_9,_8,_7> -> #{}# in let <Size> = call 'erlang':'length' (S) in case Bin of <#{#<_40>(Size,8,'binary',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when call 'erlang':'=:=' (_40,_10) -> {'match',Bs,BBs,Rest}
<#{#<_41>(Size,8,'binary',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {'nomatch',Rest}
<_42> when 'true' -> 'done' end
<{'bin_element',Line,{'string',SLine,S},Size0,Options0},Bin0,Bs0,BBs0,Mfun,Efun> when 'true' -> case apply 'make_bit_type'/3 (Line,Size0,Options0) of <{Size1,[Type|[{'unit',Unit}|[Sign|[Endian|[]]]]]}> when 'true' -> case apply Efun (Size1,BBs0) of <{'value',Size,_X_BBs}> when 'true' -> let <F> = fun (_19,_18,_17,_16) -> apply 'bin_gen_field1'/10 (_18,Type,Size,Unit,Sign,Endian,{'integer',SLine,_19},_17,_16,Mfun) in apply 'bin_gen_field_string'/5 (S,Bin0,Bs0,BBs0,F)
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<{'bin_element',Line,VE,Size0,Options0},Bin,Bs0,BBs0,Mfun,Efun> when 'true' -> case apply 'make_bit_type'/3 (Line,Size0,Options0) of <{Size1,[Type|[{'unit',Unit}|[Sign|[Endian|[]]]]]}> when 'true' -> let <V> = call 'erl_eval':'partial_eval' (VE) in let <NewV> = apply 'coerce_to_float'/2 (V,Type) in case apply Efun (Size1,BBs0) of <{'value',Size,_X_BBs}> when 'true' -> apply 'bin_gen_field1'/10 (Bin,Type,Size,Unit,Sign,Endian,NewV,Bs0,BBs0,Mfun)
(<_28> when 'true' -> primop 'match_fail' ({'badmatch',_28})-|['compiler_generated'] ) end
(<_25> when 'true' -> primop 'match_fail' ({'badmatch',_25})-|['compiler_generated'] ) end
(<_34,_33,_32,_31,_30,_29> when 'true' -> (primop 'match_fail' ({'function_clause',_34,_33,_32,_31,_30,_29})-|[{'function_name',{'bin_gen_field',6}}] )-|['compiler_generated'] ) end
'bin_gen_field_string'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[],Rest,Bs,BBs,_X_F> when 'true' -> {'match',Bs,BBs,Rest}
<[C|Cs],Bin0,Bs0,BBs0,Fun> when 'true' -> case apply Fun (C,Bin0,Bs0,BBs0) of <{'match',Bs,BBs,Rest}> when 'true' -> apply 'bin_gen_field_string'/5 (Cs,Rest,Bs,BBs,Fun)
<_@r0 = {'nomatch',Rest}> when 'true' -> _@r0
<'done'> when 'true' -> 'done'
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
(<_10,_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7,_6})-|[{'function_name',{'bin_gen_field_string',5}}] )-|['compiler_generated'] ) end
'bin_gen_field1'/10 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8,_9) -> let <_10> = catch apply 'get_value'/6 (_0,_1,_2,_3,_4,_5) in case _10 of <{Val,Rest = #{#<_25>('all',1,'binary',['unsigned'|['big']])}#}> when 'true' -> let <_11> = catch apply _9 ('match',{_6,Val,_7}) in case _11 of <{'match',Bs}> when 'true' -> let <BBs> = apply 'add_bin_binding'/4 (_9,_6,Bs,_8) in {'match',Bs,BBs,Rest}
<_26> when 'true' -> {'nomatch',Rest} end
<_27> when 'true' -> 'done' end
'match_bits'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> apply 'match_bits'/6 (_0,_1,_2,_3,_4,_5)
'match_bits'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Fs,Bin,Bs0,BBs,Mfun,Efun> when try let <_6> = call 'erlang':'is_function' (Mfun,2) in let <_7> = call 'erlang':'is_function' (Efun,2) in call 'erlang':'and' (_6,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <_8> = catch apply 'match_bits_1'/6 (Fs,Bin,Bs0,BBs,Mfun,Efun) in case _8 of <_@r0 = {'match',Bs}> when 'true' -> _@r0
<'invalid'> when 'true' -> call 'erlang':'throw' ('invalid')
<_X_Error> when 'true' -> call 'erlang':'throw' ('nomatch') end
(<_15,_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12,_11,_10})-|[{'function_name',{'match_bits',6}}] )-|['compiler_generated'] ) end
'match_bits_1'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[],#{}#,Bs,_X_BBs,_X_Mfun,_X_Efun> when 'true' -> {'match',Bs}
<[F|Fs],Bits0,Bs0,BBs0,Mfun,Efun> when 'true' -> case apply 'match_field_1'/6 (F,Bits0,Bs0,BBs0,Mfun,Efun) of <{Bs,BBs,Bits}> when 'true' -> apply 'match_bits_1'/6 (Fs,Bits,Bs,BBs,Mfun,Efun)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_12,_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9,_8,_7})-|[{'function_name',{'match_bits_1',6}}] )-|['compiler_generated'] ) end
'match_field_1'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <{'bin_element',_32,{'string',_33,S},'default','default'},Bin,Bs,BBs,_X_Mfun,_X_Efun> when 'true' -> let <Bits> = call 'erlang':'list_to_binary' (S) in let <Size> = call 'erlang':'byte_size' (Bits) in case Bin of <#{#<_34>(Size,8,'binary',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when call 'erlang':'=:=' (_34,Bits) -> {Bs,BBs,Rest}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<{'bin_element',Line,{'string',SLine,S},Size0,Options0},Bin0,Bs0,BBs0,Mfun,Efun> when 'true' -> case apply 'make_bit_type'/3 (Line,Size0,Options0) of <{Size1,[Type|[{'unit',Unit}|[Sign|[Endian|[]]]]]}> when 'true' -> let <Size2> = call 'erl_eval':'partial_eval' (Size1) in case apply Efun (Size2,BBs0) of <{'value',Size,_X_BBs}> when 'true' -> let <F> = fun (_15,_14,_13,_12) -> apply 'match_field'/10 (_14,Type,Size,Unit,Sign,Endian,{'integer',SLine,_15},_13,_12,Mfun) in apply 'match_field_string'/5 (S,Bin0,Bs0,BBs0,F)
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<{'bin_element',Line,VE,Size0,Options0},Bin,Bs0,BBs0,Mfun,Efun> when 'true' -> case apply 'make_bit_type'/3 (Line,Size0,Options0) of <{Size1,[Type|[{'unit',Unit}|[Sign|[Endian|[]]]]]}> when 'true' -> let <V> = call 'erl_eval':'partial_eval' (VE) in let <NewV> = apply 'coerce_to_float'/2 (V,Type) in let <Size2> = call 'erl_eval':'partial_eval' (Size1) in case apply Efun (Size2,BBs0) of <{'value',Size,_X_BBs}> when 'true' -> apply 'match_field'/10 (Bin,Type,Size,Unit,Sign,Endian,NewV,Bs0,BBs0,Mfun)
(<_25> when 'true' -> primop 'match_fail' ({'badmatch',_25})-|['compiler_generated'] ) end
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
(<_31,_30,_29,_28,_27,_26> when 'true' -> (primop 'match_fail' ({'function_clause',_31,_30,_29,_28,_27,_26})-|[{'function_name',{'match_field_1',6}}] )-|['compiler_generated'] ) end
'match_field_string'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[],Rest,Bs,BBs,_X_Fun> when 'true' -> {Bs,BBs,Rest}
<[C|Cs],Bin0,Bs0,BBs0,Fun> when 'true' -> case apply Fun (C,Bin0,Bs0,BBs0) of <{Bs,BBs,Bin}> when 'true' -> apply 'match_field_string'/5 (Cs,Bin,Bs,BBs,Fun)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_10,_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7,_6})-|[{'function_name',{'match_field_string',5}}] )-|['compiler_generated'] ) end
'match_field'/10 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8,_9) -> case apply 'get_value'/6 (_0,_1,_2,_3,_4,_5) of <{Val,Rest}> when 'true' -> case apply _9 ('match',{_6,Val,_7}) of <{'match',Bs}> when 'true' -> let <BBs> = apply 'add_bin_binding'/4 (_9,_6,Bs,_8) in {Bs,BBs,Rest}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
'coerce_to_float'/2 = fun (_0,_1) -> case <_0,_1> of <E = {'integer',L,I},'float'> when 'true' -> try let <_2> = call 'erlang':'float' (I) in {'float',L,_2} of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_9> when 'true' -> E
<('error'-|['compiler_generated'] ),('badarith'-|['compiler_generated'] ),_10> when 'true' -> E
(<_11,_12,_13> when 'true' -> primop 'raise' (_13,_12)-|['compiler_generated'] ) end
<E,_X_Type> when 'true' -> E end
'add_bin_binding'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_9,{'var',_10,'_'},_X_Bs,BBs> when 'true' -> BBs
<Mfun,{'var',_11,Name},Bs,BBs> when 'true' -> case apply Mfun ('binding',{Name,Bs}) of <{'value',Value}> when 'true' -> apply Mfun ('add_binding',{Name,Value,BBs})
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<_12,_13,_X_Bs,BBs> when 'true' -> BBs end
'get_value'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Bin,'integer',Size,Unit,Sign,Endian> when 'true' -> let <_6> = call 'erlang':'*' (Size,Unit) in apply 'get_integer'/4 (Bin,_6,Sign,Endian)
<Bin,'float',Size,Unit,_X_Sign,Endian> when 'true' -> let <_7> = call 'erlang':'*' (Size,Unit) in apply 'get_float'/3 (Bin,_7,Endian)
<Bin,'utf8','undefined',_X_Unit,_X_Sign,_X_Endian> when 'true' -> case Bin of <#{#<I>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {I,Rest}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<Bin,'utf16','undefined',_X_Unit,_X_Sign,'big'> when 'true' -> case Bin of <#{#<I>('undefined','undefined','utf16',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {I,Rest}
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<Bin,'utf16','undefined',_X_Unit,_X_Sign,'little'> when 'true' -> case Bin of <#{#<I>('undefined','undefined','utf16',['unsigned'|['little']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {I,Rest}
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<Bin,'utf32','undefined',_X_Unit,_X_Sign,'big'> when 'true' -> case Bin of <#{#<Val>('undefined','undefined','utf32',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
<Bin,'utf32','undefined',_X_Unit,_X_Sign,'little'> when 'true' -> case Bin of <#{#<Val>('undefined','undefined','utf32',['unsigned'|['little']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<Bin,'binary','all',Unit,_X_Sign,_X_Endian> when 'true' -> let <_13> = call 'erlang':'bit_size' (Bin) in case call 'erlang':'rem' (_13,Unit) of <0> when 'true' -> {Bin,#{}#}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<Bin,'binary',Size,Unit,_X_Sign,_X_Endian> when 'true' -> let <TotSize> = call 'erlang':'*' (Size,Unit) in case Bin of <#{#<Val>(TotSize,1,'binary',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_22,_21,_20,_19,_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_22,_21,_20,_19,_18,_17})-|[{'function_name',{'get_value',6}}] )-|['compiler_generated'] ) end
'get_integer'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Bin,Size,'signed','little'> when 'true' -> case Bin of <#{#<Val>(Size,1,'integer',['signed'|['little']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<Bin,Size,'unsigned','little'> when 'true' -> case Bin of <#{#<Val>(Size,1,'integer',['unsigned'|['little']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<Bin,Size,'signed','native'> when 'true' -> case Bin of <#{#<Val>(Size,1,'integer',['signed'|['native']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<Bin,Size,'unsigned','native'> when 'true' -> case Bin of <#{#<Val>(Size,1,'integer',['unsigned'|['native']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<Bin,Size,'signed','big'> when 'true' -> case Bin of <#{#<Val>(Size,1,'integer',['signed'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<Bin,Size,'unsigned','big'> when 'true' -> case Bin of <#{#<Val>(Size,1,'integer',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10})-|[{'function_name',{'get_integer',4}}] )-|['compiler_generated'] ) end
'get_float'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Bin,Size,'little'> when 'true' -> case Bin of <#{#<Val>(Size,1,'float',['unsigned'|['little']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<Bin,Size,'native'> when 'true' -> case Bin of <#{#<Val>(Size,1,'float',['unsigned'|['native']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<Bin,Size,'big'> when 'true' -> case Bin of <#{#<Val>(Size,1,'float',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> {Val,Rest}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'get_float',3}}] )-|['compiler_generated'] ) end
'make_bit_type'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Line,'default',Type0> when 'true' -> case call 'erl_bits':'set_bit_type' ('default',Type0) of <{'ok','all',Bt}> when 'true' -> let <_3> = call 'erl_bits':'as_list' (Bt) in {{'atom',Line,'all'},_3}
<{'ok','undefined',Bt}> when 'true' -> let <_4> = call 'erl_bits':'as_list' (Bt) in {{'atom',Line,'undefined'},_4}
<{'ok',Size,Bt}> when 'true' -> let <_5> = call 'erl_bits':'as_list' (Bt) in {{'integer',Line,Size},_5}
<{'error',Reason}> when 'true' -> let <_6> = call 'erlang':'self' () in let <_7> = call 'erlang':'process_info' (_6,'current_stacktrace') in let <_8> = call 'erlang':'element' (2,_7) in call 'erlang':'raise' ('error',Reason,_8)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<_X_Line,Size,Type0> when 'true' -> case call 'erl_bits':'set_bit_type' (Size,Type0) of <{'ok',_18,Bt}> when call 'erlang':'=:=' (_18,Size) -> let <_10> = call 'erl_bits':'as_list' (Bt) in {Size,_10}
<{'error',Reason}> when 'true' -> let <_11> = call 'erlang':'self' () in let <_12> = call 'erlang':'process_info' (_11,'current_stacktrace') in let <_13> = call 'erlang':'element' (2,_12) in call 'erlang':'raise' ('error',Reason,_13)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('eval_bits')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('eval_bits',_0) end