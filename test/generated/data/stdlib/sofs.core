module 'sofs' ['a_function'/1,'a_function'/2,'canonical_relation'/1,'composite'/2,'constant_function'/2,'converse'/1,'difference'/2,'digraph_to_family'/1,'digraph_to_family'/2,'domain'/1,'drestriction'/2,'drestriction'/3,'empty_set'/0,'extension'/3,'fam2rel'/1,'family'/1,'family'/2,'family_difference'/2,'family_domain'/1,'family_field'/1,'family_intersection'/1,'family_intersection'/2,'family_projection'/2,'family_range'/1,'family_specification'/2,'family_to_digraph'/1,'family_to_digraph'/2,'family_to_relation'/1,'family_union'/1,'family_union'/2,'field'/1,'from_external'/2,'from_sets'/1,'from_term'/1,'from_term'/2,'image'/2,'intersection'/1,'intersection'/2,'intersection_of_family'/1,'inverse'/1,'inverse_image'/2,'is_a_function'/1,'is_disjoint'/2,'is_empty_set'/1,'is_equal'/2,'is_set'/1,'is_sofs_set'/1,'is_subset'/2,'is_type'/1,'join'/4,'module_info'/0,'module_info'/1,'multiple_relative_product'/2,'no_elements'/1,'partition'/1,'partition'/2,'partition'/3,'partition_family'/2,'product'/1,'product'/2,'projection'/2,'range'/1,'rel2fam'/1,'relation'/1,'relation'/2,'relation_to_family'/1,'relative_product'/1,'relative_product'/2,'relative_product1'/2,'restriction'/2,'restriction'/3,'set'/1,'set'/2,'specification'/2,'strict_relation'/1,'substitution'/2,'symdiff'/2,'symmetric_partition'/2,'to_external'/1,'to_sets'/1,'type'/1,'union'/1,'union'/2,'union_of_family'/1,'weak_relation'/1] attributes [ 'file' = [{[115|[114|[99|[47|[115|[111|[102|[115|[46|[101|[114|[108]]]]]]]]]]]],1}]
, 'compile' = [{'inline',[{'family_to_relation',1}|[{'relation_to_family',1}]]}]
, 'compile' = [{'inline',[{'rel',2}|[{'a_func',2}|[{'fam',2}|[{'term2set',2}]]]]}]
, 'compile' = [{'inline',[{'external_fun',1}|[{'element_type',1}]]}]
, 'compile' = [{'inline',[{'unify_types',2}|[{'match_types',2}|[{'test_rel',3}|[{'symdiff',3}|[{'subst',3}]]]]]}]
, 'compile' = [{'inline',[{'fam_binop',3}]}]
, 'record' = [{'Set',[{'typed_record_field',{'record_field',84,{'atom',84,'data'},{'nil',84}},{'type',84,'list',[]}}|[{'typed_record_field',{'record_field',84,{'atom',84,'type'},{'atom',84,'type'}},{'type',84,'term',[]}}]]}]
, 'record' = [{'OrdSet',[{'typed_record_field',{'record_field',85,{'atom',85,'orddata'},{'tuple',85,[]}},{'type',85,'union',[{'type',85,'tuple','any'}|[{'type',85,'atom',[]}]]}}|[{'typed_record_field',{'record_field',86,{'atom',86,'ordtype'},{'atom',86,'type'}},{'type',86,'term',[]}}]]}]
, 'export_type' = [{'anyset',0}|[{'binary_relation',0}|[{'external_set',0}|[{'a_function',0}|[{'family',0}|[{'relation',0}|[{'set_of_sets',0}|[{'set_fun',0}|[{'spec_fun',0}|[{'type',0}]]]]]]]]]]
, 'export_type' = [{'ordset',0}|[{'a_set',0}]]
, 'type' = [{'anyset',{'type',117,'union',[{'user_type',117,'ordset',[]}|[{'user_type',117,'a_set',[]}]]},[]}]
, 'type' = [{'binary_relation',{'user_type',118,'relation',[]},[]}]
, 'type' = [{'external_set',{'type',119,'term',[]},[]}]
, 'type' = [{'a_function',{'user_type',120,'relation',[]},[]}]
, 'type' = [{'family',{'user_type',121,'a_function',[]},[]}]
, 'opaque' = [{'ordset',{'type',122,'record',[{'atom',122,'OrdSet'}]},[]}]
, 'type' = [{'relation',{'user_type',123,'a_set',[]},[]}]
, 'opaque' = [{'a_set',{'type',124,'record',[{'atom',124,'Set'}]},[]}]
, 'type' = [{'set_of_sets',{'user_type',125,'a_set',[]},[]}]
, 'type' = [{'set_fun',{'type',126,'union',[{'type',126,'pos_integer',[]}|[{'type',127,'tuple',[{'atom',127,'external'}|[{'type',127,'fun',[{'type',127,'product',[{'user_type',127,'external_set',[]}]}|[{'user_type',127,'external_set',[]}]]}]]}|[{'type',128,'fun',[{'type',128,'product',[{'user_type',128,'anyset',[]}]}|[{'user_type',128,'anyset',[]}]]}]]]},[]}]
, 'type' = [{'spec_fun',{'type',129,'union',[{'type',129,'tuple',[{'atom',129,'external'}|[{'type',129,'fun',[{'type',129,'product',[{'user_type',129,'external_set',[]}]}|[{'type',129,'boolean',[]}]]}]]}|[{'type',130,'fun',[{'type',130,'product',[{'user_type',130,'anyset',[]}]}|[{'type',130,'boolean',[]}]]}]]},[]}]
, 'type' = [{'type',{'type',131,'term',[]},[]}]
, 'type' = [{'tuple_of',{'type',133,'tuple','any'},[{'var',133,'_T'}]}]
, 'spec' = [{{'from_term',1},[{'type',143,'bounded_fun',[{'type',143,'fun',[{'type',143,'product',[{'var',143,'Term'}]}|[{'var',143,'AnySet'}]]}|[[{'type',144,'constraint',[{'atom',144,'is_subtype'}|[[{'var',144,'AnySet'}|[{'user_type',144,'anyset',[]}]]]]}|[{'type',145,'constraint',[{'atom',145,'is_subtype'}|[[{'var',145,'Term'}|[{'type',145,'term',[]}]]]]}]]]]}]}]
, 'spec' = [{{'from_term',2},[{'type',155,'bounded_fun',[{'type',155,'fun',[{'type',155,'product',[{'var',155,'Term'}|[{'var',155,'Type'}]]}|[{'var',155,'AnySet'}]]}|[[{'type',156,'constraint',[{'atom',156,'is_subtype'}|[[{'var',156,'AnySet'}|[{'user_type',156,'anyset',[]}]]]]}|[{'type',157,'constraint',[{'atom',157,'is_subtype'}|[[{'var',157,'Term'}|[{'type',157,'term',[]}]]]]}|[{'type',158,'constraint',[{'atom',158,'is_subtype'}|[[{'var',158,'Type'}|[{'user_type',158,'type',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'from_external',2},[{'type',169,'bounded_fun',[{'type',169,'fun',[{'type',169,'product',[{'var',169,'ExternalSet'}|[{'var',169,'Type'}]]}|[{'var',169,'AnySet'}]]}|[[{'type',170,'constraint',[{'atom',170,'is_subtype'}|[[{'var',170,'ExternalSet'}|[{'user_type',170,'external_set',[]}]]]]}|[{'type',171,'constraint',[{'atom',171,'is_subtype'}|[[{'var',171,'AnySet'}|[{'user_type',171,'anyset',[]}]]]]}|[{'type',172,'constraint',[{'atom',172,'is_subtype'}|[[{'var',172,'Type'}|[{'user_type',172,'type',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'empty_set',0},[{'type',178,'bounded_fun',[{'type',178,'fun',[{'type',178,'product',[]}|[{'var',178,'Set'}]]}|[[{'type',179,'constraint',[{'atom',179,'is_subtype'}|[[{'var',179,'Set'}|[{'user_type',179,'a_set',[]}]]]]}]]]}]}]
, 'spec' = [{{'is_type',1},[{'type',183,'bounded_fun',[{'type',183,'fun',[{'type',183,'product',[{'var',183,'Term'}]}|[{'var',183,'Bool'}]]}|[[{'type',184,'constraint',[{'atom',184,'is_subtype'}|[[{'var',184,'Bool'}|[{'type',184,'boolean',[]}]]]]}|[{'type',185,'constraint',[{'atom',185,'is_subtype'}|[[{'var',185,'Term'}|[{'type',185,'term',[]}]]]]}]]]]}]}]
, 'spec' = [{{'set',1},[{'type',195,'bounded_fun',[{'type',195,'fun',[{'type',195,'product',[{'var',195,'Terms'}]}|[{'var',195,'Set'}]]}|[[{'type',196,'constraint',[{'atom',196,'is_subtype'}|[[{'var',196,'Set'}|[{'user_type',196,'a_set',[]}]]]]}|[{'type',197,'constraint',[{'atom',197,'is_subtype'}|[[{'var',197,'Terms'}|[{'type',197,'list',[{'type',197,'term',[]}]}]]]]}]]]]}]}]
, 'spec' = [{{'set',2},[{'type',204,'bounded_fun',[{'type',204,'fun',[{'type',204,'product',[{'var',204,'Terms'}|[{'var',204,'Type'}]]}|[{'var',204,'Set'}]]}|[[{'type',205,'constraint',[{'atom',205,'is_subtype'}|[[{'var',205,'Set'}|[{'user_type',205,'a_set',[]}]]]]}|[{'type',206,'constraint',[{'atom',206,'is_subtype'}|[[{'var',206,'Terms'}|[{'type',206,'list',[{'type',206,'term',[]}]}]]]]}|[{'type',207,'constraint',[{'atom',207,'is_subtype'}|[[{'var',207,'Type'}|[{'user_type',207,'type',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'from_sets',1},[{'type',220,'bounded_fun',[{'type',220,'fun',[{'type',220,'product',[{'var',220,'ListOfSets'}]}|[{'var',220,'Set'}]]}|[[{'type',221,'constraint',[{'atom',221,'is_subtype'}|[[{'var',221,'Set'}|[{'user_type',221,'a_set',[]}]]]]}|[{'type',222,'constraint',[{'atom',222,'is_subtype'}|[[{'var',222,'ListOfSets'}|[{'type',222,'list',[{'user_type',222,'anyset',[]}]}]]]]}]]]]}|[{'type',223,'bounded_fun',[{'type',223,'fun',[{'type',223,'product',[{'var',223,'TupleOfSets'}]}|[{'var',223,'Ordset'}]]}|[[{'type',224,'constraint',[{'atom',224,'is_subtype'}|[[{'var',224,'Ordset'}|[{'user_type',224,'ordset',[]}]]]]}|[{'type',225,'constraint',[{'atom',225,'is_subtype'}|[[{'var',225,'TupleOfSets'}|[{'user_type',225,'tuple_of',[{'user_type',225,'anyset',[]}]}]]]]}]]]]}]]}]
, 'spec' = [{{'relation',1},[{'type',243,'bounded_fun',[{'type',243,'fun',[{'type',243,'product',[{'var',243,'Tuples'}]}|[{'var',243,'Relation'}]]}|[[{'type',244,'constraint',[{'atom',244,'is_subtype'}|[[{'var',244,'Relation'}|[{'user_type',244,'relation',[]}]]]]}|[{'type',245,'constraint',[{'atom',245,'is_subtype'}|[[{'var',245,'Tuples'}|[{'type',245,'list',[{'type',245,'tuple','any'}]}]]]]}]]]]}]}]
, 'spec' = [{{'relation',2},[{'type',255,'bounded_fun',[{'type',255,'fun',[{'type',255,'product',[{'var',255,'Tuples'}|[{'var',255,'Type'}]]}|[{'var',255,'Relation'}]]}|[[{'type',256,'constraint',[{'atom',256,'is_subtype'}|[[{'var',256,'N'}|[{'type',256,'integer',[]}]]]]}|[{'type',257,'constraint',[{'atom',257,'is_subtype'}|[[{'var',257,'Type'}|[{'type',257,'union',[{'var',257,'N'}|[{'user_type',257,'type',[]}]]}]]]]}|[{'type',258,'constraint',[{'atom',258,'is_subtype'}|[[{'var',258,'Relation'}|[{'user_type',258,'relation',[]}]]]]}|[{'type',259,'constraint',[{'atom',259,'is_subtype'}|[[{'var',259,'Tuples'}|[{'type',259,'list',[{'type',259,'tuple','any'}]}]]]]}]]]]]]}]}]
, 'spec' = [{{'a_function',1},[{'type',265,'bounded_fun',[{'type',265,'fun',[{'type',265,'product',[{'var',265,'Tuples'}]}|[{'var',265,'Function'}]]}|[[{'type',266,'constraint',[{'atom',266,'is_subtype'}|[[{'var',266,'Function'}|[{'user_type',266,'a_function',[]}]]]]}|[{'type',267,'constraint',[{'atom',267,'is_subtype'}|[[{'var',267,'Tuples'}|[{'type',267,'list',[{'type',267,'tuple','any'}]}]]]]}]]]]}]}]
, 'spec' = [{{'a_function',2},[{'type',277,'bounded_fun',[{'type',277,'fun',[{'type',277,'product',[{'var',277,'Tuples'}|[{'var',277,'Type'}]]}|[{'var',277,'Function'}]]}|[[{'type',278,'constraint',[{'atom',278,'is_subtype'}|[[{'var',278,'Function'}|[{'user_type',278,'a_function',[]}]]]]}|[{'type',279,'constraint',[{'atom',279,'is_subtype'}|[[{'var',279,'Tuples'}|[{'type',279,'list',[{'type',279,'tuple','any'}]}]]]]}|[{'type',280,'constraint',[{'atom',280,'is_subtype'}|[[{'var',280,'Type'}|[{'user_type',280,'type',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'family',1},[{'type',290,'bounded_fun',[{'type',290,'fun',[{'type',290,'product',[{'var',290,'Tuples'}]}|[{'var',290,'Family'}]]}|[[{'type',291,'constraint',[{'atom',291,'is_subtype'}|[[{'var',291,'Family'}|[{'user_type',291,'family',[]}]]]]}|[{'type',292,'constraint',[{'atom',292,'is_subtype'}|[[{'var',292,'Tuples'}|[{'type',292,'list',[{'type',292,'tuple','any'}]}]]]]}]]]]}]}]
, 'spec' = [{{'family',2},[{'type',302,'bounded_fun',[{'type',302,'fun',[{'type',302,'product',[{'var',302,'Tuples'}|[{'var',302,'Type'}]]}|[{'var',302,'Family'}]]}|[[{'type',303,'constraint',[{'atom',303,'is_subtype'}|[[{'var',303,'Family'}|[{'user_type',303,'family',[]}]]]]}|[{'type',304,'constraint',[{'atom',304,'is_subtype'}|[[{'var',304,'Tuples'}|[{'type',304,'list',[{'type',304,'tuple','any'}]}]]]]}|[{'type',305,'constraint',[{'atom',305,'is_subtype'}|[[{'var',305,'Type'}|[{'user_type',305,'type',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'to_external',1},[{'type',319,'bounded_fun',[{'type',319,'fun',[{'type',319,'product',[{'var',319,'AnySet'}]}|[{'var',319,'ExternalSet'}]]}|[[{'type',320,'constraint',[{'atom',320,'is_subtype'}|[[{'var',320,'ExternalSet'}|[{'user_type',320,'external_set',[]}]]]]}|[{'type',321,'constraint',[{'atom',321,'is_subtype'}|[[{'var',321,'AnySet'}|[{'user_type',321,'anyset',[]}]]]]}]]]]}]}]
, 'spec' = [{{'type',1},[{'type',327,'bounded_fun',[{'type',327,'fun',[{'type',327,'product',[{'var',327,'AnySet'}]}|[{'var',327,'Type'}]]}|[[{'type',328,'constraint',[{'atom',328,'is_subtype'}|[[{'var',328,'AnySet'}|[{'user_type',328,'anyset',[]}]]]]}|[{'type',329,'constraint',[{'atom',329,'is_subtype'}|[[{'var',329,'Type'}|[{'user_type',329,'type',[]}]]]]}]]]]}]}]
, 'spec' = [{{'to_sets',1},[{'type',335,'bounded_fun',[{'type',335,'fun',[{'type',335,'product',[{'var',335,'ASet'}]}|[{'var',335,'Sets'}]]}|[[{'type',336,'constraint',[{'atom',336,'is_subtype'}|[[{'var',336,'ASet'}|[{'type',336,'union',[{'user_type',336,'a_set',[]}|[{'user_type',336,'ordset',[]}]]}]]]]}|[{'type',337,'constraint',[{'atom',337,'is_subtype'}|[[{'var',337,'Sets'}|[{'type',337,'union',[{'user_type',337,'tuple_of',[{'var',337,'AnySet'}]}|[{'type',337,'list',[{'var',337,'AnySet'}]}]]}]]]]}|[{'type',338,'constraint',[{'atom',338,'is_subtype'}|[[{'var',338,'AnySet'}|[{'user_type',338,'anyset',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'no_elements',1},[{'type',349,'bounded_fun',[{'type',349,'fun',[{'type',349,'product',[{'var',349,'ASet'}]}|[{'var',349,'NoElements'}]]}|[[{'type',350,'constraint',[{'atom',350,'is_subtype'}|[[{'var',350,'ASet'}|[{'type',350,'union',[{'user_type',350,'a_set',[]}|[{'user_type',350,'ordset',[]}]]}]]]]}|[{'type',351,'constraint',[{'atom',351,'is_subtype'}|[[{'var',351,'NoElements'}|[{'type',351,'non_neg_integer',[]}]]]]}]]]]}]}]
, 'spec' = [{{'specification',2},[{'type',359,'bounded_fun',[{'type',359,'fun',[{'type',359,'product',[{'var',359,'Fun'}|[{'var',359,'Set1'}]]}|[{'var',359,'Set2'}]]}|[[{'type',360,'constraint',[{'atom',360,'is_subtype'}|[[{'var',360,'Fun'}|[{'user_type',360,'spec_fun',[]}]]]]}|[{'type',361,'constraint',[{'atom',361,'is_subtype'}|[[{'var',361,'Set1'}|[{'user_type',361,'a_set',[]}]]]]}|[{'type',362,'constraint',[{'atom',362,'is_subtype'}|[[{'var',362,'Set2'}|[{'user_type',362,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'union',2},[{'type',378,'bounded_fun',[{'type',378,'fun',[{'type',378,'product',[{'var',378,'Set1'}|[{'var',378,'Set2'}]]}|[{'var',378,'Set3'}]]}|[[{'type',379,'constraint',[{'atom',379,'is_subtype'}|[[{'var',379,'Set1'}|[{'user_type',379,'a_set',[]}]]]]}|[{'type',380,'constraint',[{'atom',380,'is_subtype'}|[[{'var',380,'Set2'}|[{'user_type',380,'a_set',[]}]]]]}|[{'type',381,'constraint',[{'atom',381,'is_subtype'}|[[{'var',381,'Set3'}|[{'user_type',381,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'intersection',2},[{'type',388,'bounded_fun',[{'type',388,'fun',[{'type',388,'product',[{'var',388,'Set1'}|[{'var',388,'Set2'}]]}|[{'var',388,'Set3'}]]}|[[{'type',389,'constraint',[{'atom',389,'is_subtype'}|[[{'var',389,'Set1'}|[{'user_type',389,'a_set',[]}]]]]}|[{'type',390,'constraint',[{'atom',390,'is_subtype'}|[[{'var',390,'Set2'}|[{'user_type',390,'a_set',[]}]]]]}|[{'type',391,'constraint',[{'atom',391,'is_subtype'}|[[{'var',391,'Set3'}|[{'user_type',391,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'difference',2},[{'type',398,'bounded_fun',[{'type',398,'fun',[{'type',398,'product',[{'var',398,'Set1'}|[{'var',398,'Set2'}]]}|[{'var',398,'Set3'}]]}|[[{'type',399,'constraint',[{'atom',399,'is_subtype'}|[[{'var',399,'Set1'}|[{'user_type',399,'a_set',[]}]]]]}|[{'type',400,'constraint',[{'atom',400,'is_subtype'}|[[{'var',400,'Set2'}|[{'user_type',400,'a_set',[]}]]]]}|[{'type',401,'constraint',[{'atom',401,'is_subtype'}|[[{'var',401,'Set3'}|[{'user_type',401,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'symdiff',2},[{'type',408,'bounded_fun',[{'type',408,'fun',[{'type',408,'product',[{'var',408,'Set1'}|[{'var',408,'Set2'}]]}|[{'var',408,'Set3'}]]}|[[{'type',409,'constraint',[{'atom',409,'is_subtype'}|[[{'var',409,'Set1'}|[{'user_type',409,'a_set',[]}]]]]}|[{'type',410,'constraint',[{'atom',410,'is_subtype'}|[[{'var',410,'Set2'}|[{'user_type',410,'a_set',[]}]]]]}|[{'type',411,'constraint',[{'atom',411,'is_subtype'}|[[{'var',411,'Set3'}|[{'user_type',411,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'symmetric_partition',2},[{'type',418,'bounded_fun',[{'type',418,'fun',[{'type',418,'product',[{'var',418,'Set1'}|[{'var',418,'Set2'}]]}|[{'type',418,'tuple',[{'var',418,'Set3'}|[{'var',418,'Set4'}|[{'var',418,'Set5'}]]]}]]}|[[{'type',419,'constraint',[{'atom',419,'is_subtype'}|[[{'var',419,'Set1'}|[{'user_type',419,'a_set',[]}]]]]}|[{'type',420,'constraint',[{'atom',420,'is_subtype'}|[[{'var',420,'Set2'}|[{'user_type',420,'a_set',[]}]]]]}|[{'type',421,'constraint',[{'atom',421,'is_subtype'}|[[{'var',421,'Set3'}|[{'user_type',421,'a_set',[]}]]]]}|[{'type',422,'constraint',[{'atom',422,'is_subtype'}|[[{'var',422,'Set4'}|[{'user_type',422,'a_set',[]}]]]]}|[{'type',423,'constraint',[{'atom',423,'is_subtype'}|[[{'var',423,'Set5'}|[{'user_type',423,'a_set',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'product',2},[{'type',430,'bounded_fun',[{'type',430,'fun',[{'type',430,'product',[{'var',430,'Set1'}|[{'var',430,'Set2'}]]}|[{'var',430,'BinRel'}]]}|[[{'type',431,'constraint',[{'atom',431,'is_subtype'}|[[{'var',431,'BinRel'}|[{'user_type',431,'binary_relation',[]}]]]]}|[{'type',432,'constraint',[{'atom',432,'is_subtype'}|[[{'var',432,'Set1'}|[{'user_type',432,'a_set',[]}]]]]}|[{'type',433,'constraint',[{'atom',433,'is_subtype'}|[[{'var',433,'Set2'}|[{'user_type',433,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'product',1},[{'type',444,'bounded_fun',[{'type',444,'fun',[{'type',444,'product',[{'var',444,'TupleOfSets'}]}|[{'var',444,'Relation'}]]}|[[{'type',445,'constraint',[{'atom',445,'is_subtype'}|[[{'var',445,'Relation'}|[{'user_type',445,'relation',[]}]]]]}|[{'type',446,'constraint',[{'atom',446,'is_subtype'}|[[{'var',446,'TupleOfSets'}|[{'user_type',446,'tuple_of',[{'user_type',446,'a_set',[]}]}]]]]}]]]]}]}]
, 'spec' = [{{'constant_function',2},[{'type',465,'bounded_fun',[{'type',465,'fun',[{'type',465,'product',[{'var',465,'Set'}|[{'var',465,'AnySet'}]]}|[{'var',465,'Function'}]]}|[[{'type',466,'constraint',[{'atom',466,'is_subtype'}|[[{'var',466,'AnySet'}|[{'user_type',466,'anyset',[]}]]]]}|[{'type',467,'constraint',[{'atom',467,'is_subtype'}|[[{'var',467,'Function'}|[{'user_type',467,'a_function',[]}]]]]}|[{'type',468,'constraint',[{'atom',468,'is_subtype'}|[[{'var',468,'Set'}|[{'user_type',468,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'is_equal',2},[{'type',480,'bounded_fun',[{'type',480,'fun',[{'type',480,'product',[{'var',480,'AnySet1'}|[{'var',480,'AnySet2'}]]}|[{'var',480,'Bool'}]]}|[[{'type',481,'constraint',[{'atom',481,'is_subtype'}|[[{'var',481,'AnySet1'}|[{'user_type',481,'anyset',[]}]]]]}|[{'type',482,'constraint',[{'atom',482,'is_subtype'}|[[{'var',482,'AnySet2'}|[{'user_type',482,'anyset',[]}]]]]}|[{'type',483,'constraint',[{'atom',483,'is_subtype'}|[[{'var',483,'Bool'}|[{'type',483,'boolean',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'is_subset',2},[{'type',499,'bounded_fun',[{'type',499,'fun',[{'type',499,'product',[{'var',499,'Set1'}|[{'var',499,'Set2'}]]}|[{'var',499,'Bool'}]]}|[[{'type',500,'constraint',[{'atom',500,'is_subtype'}|[[{'var',500,'Bool'}|[{'type',500,'boolean',[]}]]]]}|[{'type',501,'constraint',[{'atom',501,'is_subtype'}|[[{'var',501,'Set1'}|[{'user_type',501,'a_set',[]}]]]]}|[{'type',502,'constraint',[{'atom',502,'is_subtype'}|[[{'var',502,'Set2'}|[{'user_type',502,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'is_sofs_set',1},[{'type',509,'bounded_fun',[{'type',509,'fun',[{'type',509,'product',[{'var',509,'Term'}]}|[{'var',509,'Bool'}]]}|[[{'type',510,'constraint',[{'atom',510,'is_subtype'}|[[{'var',510,'Bool'}|[{'type',510,'boolean',[]}]]]]}|[{'type',511,'constraint',[{'atom',511,'is_subtype'}|[[{'var',511,'Term'}|[{'type',511,'term',[]}]]]]}]]]]}]}]
, 'spec' = [{{'is_set',1},[{'type',519,'bounded_fun',[{'type',519,'fun',[{'type',519,'product',[{'var',519,'AnySet'}]}|[{'var',519,'Bool'}]]}|[[{'type',520,'constraint',[{'atom',520,'is_subtype'}|[[{'var',520,'AnySet'}|[{'user_type',520,'anyset',[]}]]]]}|[{'type',521,'constraint',[{'atom',521,'is_subtype'}|[[{'var',521,'Bool'}|[{'type',521,'boolean',[]}]]]]}]]]]}]}]
, 'spec' = [{{'is_empty_set',1},[{'type',527,'bounded_fun',[{'type',527,'fun',[{'type',527,'product',[{'var',527,'AnySet'}]}|[{'var',527,'Bool'}]]}|[[{'type',528,'constraint',[{'atom',528,'is_subtype'}|[[{'var',528,'AnySet'}|[{'user_type',528,'anyset',[]}]]]]}|[{'type',529,'constraint',[{'atom',529,'is_subtype'}|[[{'var',529,'Bool'}|[{'type',529,'boolean',[]}]]]]}]]]]}]}]
, 'spec' = [{{'is_disjoint',2},[{'type',535,'bounded_fun',[{'type',535,'fun',[{'type',535,'product',[{'var',535,'Set1'}|[{'var',535,'Set2'}]]}|[{'var',535,'Bool'}]]}|[[{'type',536,'constraint',[{'atom',536,'is_subtype'}|[[{'var',536,'Bool'}|[{'type',536,'boolean',[]}]]]]}|[{'type',537,'constraint',[{'atom',537,'is_subtype'}|[[{'var',537,'Set1'}|[{'user_type',537,'a_set',[]}]]]]}|[{'type',538,'constraint',[{'atom',538,'is_subtype'}|[[{'var',538,'Set2'}|[{'user_type',538,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'union',1},[{'type',553,'bounded_fun',[{'type',553,'fun',[{'type',553,'product',[{'var',553,'SetOfSets'}]}|[{'var',553,'Set'}]]}|[[{'type',554,'constraint',[{'atom',554,'is_subtype'}|[[{'var',554,'Set'}|[{'user_type',554,'a_set',[]}]]]]}|[{'type',555,'constraint',[{'atom',555,'is_subtype'}|[[{'var',555,'SetOfSets'}|[{'user_type',555,'set_of_sets',[]}]]]]}]]]]}]}]
, 'spec' = [{{'intersection',1},[{'type',563,'bounded_fun',[{'type',563,'fun',[{'type',563,'product',[{'var',563,'SetOfSets'}]}|[{'var',563,'Set'}]]}|[[{'type',564,'constraint',[{'atom',564,'is_subtype'}|[[{'var',564,'Set'}|[{'user_type',564,'a_set',[]}]]]]}|[{'type',565,'constraint',[{'atom',565,'is_subtype'}|[[{'var',565,'SetOfSets'}|[{'user_type',565,'set_of_sets',[]}]]]]}]]]]}]}]
, 'spec' = [{{'canonical_relation',1},[{'type',577,'bounded_fun',[{'type',577,'fun',[{'type',577,'product',[{'var',577,'SetOfSets'}]}|[{'var',577,'BinRel'}]]}|[[{'type',578,'constraint',[{'atom',578,'is_subtype'}|[[{'var',578,'BinRel'}|[{'user_type',578,'binary_relation',[]}]]]]}|[{'type',579,'constraint',[{'atom',579,'is_subtype'}|[[{'var',579,'SetOfSets'}|[{'user_type',579,'set_of_sets',[]}]]]]}]]]]}]}]
, 'spec' = [{{'rel2fam',1},[{'type',594,'bounded_fun',[{'type',594,'fun',[{'type',594,'product',[{'var',594,'BinRel'}]}|[{'var',594,'Family'}]]}|[[{'type',595,'constraint',[{'atom',595,'is_subtype'}|[[{'var',595,'Family'}|[{'user_type',595,'family',[]}]]]]}|[{'type',596,'constraint',[{'atom',596,'is_subtype'}|[[{'var',596,'BinRel'}|[{'user_type',596,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'relation_to_family',1},[{'type',600,'bounded_fun',[{'type',600,'fun',[{'type',600,'product',[{'var',600,'BinRel'}]}|[{'var',600,'Family'}]]}|[[{'type',601,'constraint',[{'atom',601,'is_subtype'}|[[{'var',601,'Family'}|[{'user_type',601,'family',[]}]]]]}|[{'type',602,'constraint',[{'atom',602,'is_subtype'}|[[{'var',602,'BinRel'}|[{'user_type',602,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'domain',1},[{'type',612,'bounded_fun',[{'type',612,'fun',[{'type',612,'product',[{'var',612,'BinRel'}]}|[{'var',612,'Set'}]]}|[[{'type',613,'constraint',[{'atom',613,'is_subtype'}|[[{'var',613,'BinRel'}|[{'user_type',613,'binary_relation',[]}]]]]}|[{'type',614,'constraint',[{'atom',614,'is_subtype'}|[[{'var',614,'Set'}|[{'user_type',614,'a_set',[]}]]]]}]]]]}]}]
, 'spec' = [{{'range',1},[{'type',622,'bounded_fun',[{'type',622,'fun',[{'type',622,'product',[{'var',622,'BinRel'}]}|[{'var',622,'Set'}]]}|[[{'type',623,'constraint',[{'atom',623,'is_subtype'}|[[{'var',623,'BinRel'}|[{'user_type',623,'binary_relation',[]}]]]]}|[{'type',624,'constraint',[{'atom',624,'is_subtype'}|[[{'var',624,'Set'}|[{'user_type',624,'a_set',[]}]]]]}]]]]}]}]
, 'spec' = [{{'field',1},[{'type',632,'bounded_fun',[{'type',632,'fun',[{'type',632,'product',[{'var',632,'BinRel'}]}|[{'var',632,'Set'}]]}|[[{'type',633,'constraint',[{'atom',633,'is_subtype'}|[[{'var',633,'BinRel'}|[{'user_type',633,'binary_relation',[]}]]]]}|[{'type',634,'constraint',[{'atom',634,'is_subtype'}|[[{'var',634,'Set'}|[{'user_type',634,'a_set',[]}]]]]}]]]]}]}]
, 'spec' = [{{'relative_product',1},[{'type',641,'bounded_fun',[{'type',641,'fun',[{'type',641,'product',[{'var',641,'ListOfBinRels'}]}|[{'var',641,'BinRel2'}]]}|[[{'type',642,'constraint',[{'atom',642,'is_subtype'}|[[{'var',642,'ListOfBinRels'}|[{'type',642,'nonempty_list',[{'var',642,'BinRel'}]}]]]]}|[{'type',643,'constraint',[{'atom',643,'is_subtype'}|[[{'var',643,'BinRel'}|[{'user_type',643,'binary_relation',[]}]]]]}|[{'type',644,'constraint',[{'atom',644,'is_subtype'}|[[{'var',644,'BinRel2'}|[{'user_type',644,'binary_relation',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'relative_product',2},[{'type',657,'bounded_fun',[{'type',657,'fun',[{'type',657,'product',[{'var',657,'ListOfBinRels'}|[{'var',657,'BinRel1'}]]}|[{'var',657,'BinRel2'}]]}|[[{'type',658,'constraint',[{'atom',658,'is_subtype'}|[[{'var',658,'ListOfBinRels'}|[{'type',658,'nonempty_list',[{'var',658,'BinRel'}]}]]]]}|[{'type',659,'constraint',[{'atom',659,'is_subtype'}|[[{'var',659,'BinRel'}|[{'user_type',659,'binary_relation',[]}]]]]}|[{'type',660,'constraint',[{'atom',660,'is_subtype'}|[[{'var',660,'BinRel1'}|[{'user_type',660,'binary_relation',[]}]]]]}|[{'type',661,'constraint',[{'atom',661,'is_subtype'}|[[{'var',661,'BinRel2'}|[{'user_type',661,'binary_relation',[]}]]]]}]]]]]]}|[{'type',662,'bounded_fun',[{'type',662,'fun',[{'type',662,'product',[{'var',662,'BinRel1'}|[{'var',662,'BinRel2'}]]}|[{'var',662,'BinRel3'}]]}|[[{'type',663,'constraint',[{'atom',663,'is_subtype'}|[[{'var',663,'BinRel1'}|[{'user_type',663,'binary_relation',[]}]]]]}|[{'type',664,'constraint',[{'atom',664,'is_subtype'}|[[{'var',664,'BinRel2'}|[{'user_type',664,'binary_relation',[]}]]]]}|[{'type',665,'constraint',[{'atom',665,'is_subtype'}|[[{'var',665,'BinRel3'}|[{'user_type',665,'binary_relation',[]}]]]]}]]]]]}]]}]
, 'spec' = [{{'relative_product1',2},[{'type',685,'bounded_fun',[{'type',685,'fun',[{'type',685,'product',[{'var',685,'BinRel1'}|[{'var',685,'BinRel2'}]]}|[{'var',685,'BinRel3'}]]}|[[{'type',686,'constraint',[{'atom',686,'is_subtype'}|[[{'var',686,'BinRel1'}|[{'user_type',686,'binary_relation',[]}]]]]}|[{'type',687,'constraint',[{'atom',687,'is_subtype'}|[[{'var',687,'BinRel2'}|[{'user_type',687,'binary_relation',[]}]]]]}|[{'type',688,'constraint',[{'atom',688,'is_subtype'}|[[{'var',688,'BinRel3'}|[{'user_type',688,'binary_relation',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'converse',1},[{'type',707,'bounded_fun',[{'type',707,'fun',[{'type',707,'product',[{'var',707,'BinRel1'}]}|[{'var',707,'BinRel2'}]]}|[[{'type',708,'constraint',[{'atom',708,'is_subtype'}|[[{'var',708,'BinRel1'}|[{'user_type',708,'binary_relation',[]}]]]]}|[{'type',709,'constraint',[{'atom',709,'is_subtype'}|[[{'var',709,'BinRel2'}|[{'user_type',709,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'image',2},[{'type',717,'bounded_fun',[{'type',717,'fun',[{'type',717,'product',[{'var',717,'BinRel'}|[{'var',717,'Set1'}]]}|[{'var',717,'Set2'}]]}|[[{'type',718,'constraint',[{'atom',718,'is_subtype'}|[[{'var',718,'BinRel'}|[{'user_type',718,'binary_relation',[]}]]]]}|[{'type',719,'constraint',[{'atom',719,'is_subtype'}|[[{'var',719,'Set1'}|[{'user_type',719,'a_set',[]}]]]]}|[{'type',720,'constraint',[{'atom',720,'is_subtype'}|[[{'var',720,'Set2'}|[{'user_type',720,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'inverse_image',2},[{'type',734,'bounded_fun',[{'type',734,'fun',[{'type',734,'product',[{'var',734,'BinRel'}|[{'var',734,'Set1'}]]}|[{'var',734,'Set2'}]]}|[[{'type',735,'constraint',[{'atom',735,'is_subtype'}|[[{'var',735,'BinRel'}|[{'user_type',735,'binary_relation',[]}]]]]}|[{'type',736,'constraint',[{'atom',736,'is_subtype'}|[[{'var',736,'Set1'}|[{'user_type',736,'a_set',[]}]]]]}|[{'type',737,'constraint',[{'atom',737,'is_subtype'}|[[{'var',737,'Set2'}|[{'user_type',737,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'strict_relation',1},[{'type',752,'bounded_fun',[{'type',752,'fun',[{'type',752,'product',[{'var',752,'BinRel1'}]}|[{'var',752,'BinRel2'}]]}|[[{'type',753,'constraint',[{'atom',753,'is_subtype'}|[[{'var',753,'BinRel1'}|[{'user_type',753,'binary_relation',[]}]]]]}|[{'type',754,'constraint',[{'atom',754,'is_subtype'}|[[{'var',754,'BinRel2'}|[{'user_type',754,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'weak_relation',1},[{'type',763,'bounded_fun',[{'type',763,'fun',[{'type',763,'product',[{'var',763,'BinRel1'}]}|[{'var',763,'BinRel2'}]]}|[[{'type',764,'constraint',[{'atom',764,'is_subtype'}|[[{'var',764,'BinRel1'}|[{'user_type',764,'binary_relation',[]}]]]]}|[{'type',765,'constraint',[{'atom',765,'is_subtype'}|[[{'var',765,'BinRel2'}|[{'user_type',765,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'extension',3},[{'type',779,'bounded_fun',[{'type',779,'fun',[{'type',779,'product',[{'var',779,'BinRel1'}|[{'var',779,'Set'}|[{'var',779,'AnySet'}]]]}|[{'var',779,'BinRel2'}]]}|[[{'type',780,'constraint',[{'atom',780,'is_subtype'}|[[{'var',780,'AnySet'}|[{'user_type',780,'anyset',[]}]]]]}|[{'type',781,'constraint',[{'atom',781,'is_subtype'}|[[{'var',781,'BinRel1'}|[{'user_type',781,'binary_relation',[]}]]]]}|[{'type',782,'constraint',[{'atom',782,'is_subtype'}|[[{'var',782,'BinRel2'}|[{'user_type',782,'binary_relation',[]}]]]]}|[{'type',783,'constraint',[{'atom',783,'is_subtype'}|[[{'var',783,'Set'}|[{'user_type',783,'a_set',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'is_a_function',1},[{'type',812,'bounded_fun',[{'type',812,'fun',[{'type',812,'product',[{'var',812,'BinRel'}]}|[{'var',812,'Bool'}]]}|[[{'type',813,'constraint',[{'atom',813,'is_subtype'}|[[{'var',813,'Bool'}|[{'type',813,'boolean',[]}]]]]}|[{'type',814,'constraint',[{'atom',814,'is_subtype'}|[[{'var',814,'BinRel'}|[{'user_type',814,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'restriction',2},[{'type',826,'bounded_fun',[{'type',826,'fun',[{'type',826,'product',[{'var',826,'BinRel1'}|[{'var',826,'Set'}]]}|[{'var',826,'BinRel2'}]]}|[[{'type',827,'constraint',[{'atom',827,'is_subtype'}|[[{'var',827,'BinRel1'}|[{'user_type',827,'binary_relation',[]}]]]]}|[{'type',828,'constraint',[{'atom',828,'is_subtype'}|[[{'var',828,'BinRel2'}|[{'user_type',828,'binary_relation',[]}]]]]}|[{'type',829,'constraint',[{'atom',829,'is_subtype'}|[[{'var',829,'Set'}|[{'user_type',829,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'drestriction',2},[{'type',833,'bounded_fun',[{'type',833,'fun',[{'type',833,'product',[{'var',833,'BinRel1'}|[{'var',833,'Set'}]]}|[{'var',833,'BinRel2'}]]}|[[{'type',834,'constraint',[{'atom',834,'is_subtype'}|[[{'var',834,'BinRel1'}|[{'user_type',834,'binary_relation',[]}]]]]}|[{'type',835,'constraint',[{'atom',835,'is_subtype'}|[[{'var',835,'BinRel2'}|[{'user_type',835,'binary_relation',[]}]]]]}|[{'type',836,'constraint',[{'atom',836,'is_subtype'}|[[{'var',836,'Set'}|[{'user_type',836,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'composite',2},[{'type',844,'bounded_fun',[{'type',844,'fun',[{'type',844,'product',[{'var',844,'Function1'}|[{'var',844,'Function2'}]]}|[{'var',844,'Function3'}]]}|[[{'type',845,'constraint',[{'atom',845,'is_subtype'}|[[{'var',845,'Function1'}|[{'user_type',845,'a_function',[]}]]]]}|[{'type',846,'constraint',[{'atom',846,'is_subtype'}|[[{'var',846,'Function2'}|[{'user_type',846,'a_function',[]}]]]]}|[{'type',847,'constraint',[{'atom',847,'is_subtype'}|[[{'var',847,'Function3'}|[{'user_type',847,'a_function',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'inverse',1},[{'type',872,'bounded_fun',[{'type',872,'fun',[{'type',872,'product',[{'var',872,'Function1'}]}|[{'var',872,'Function2'}]]}|[[{'type',873,'constraint',[{'atom',873,'is_subtype'}|[[{'var',873,'Function1'}|[{'user_type',873,'a_function',[]}]]]]}|[{'type',874,'constraint',[{'atom',874,'is_subtype'}|[[{'var',874,'Function2'}|[{'user_type',874,'a_function',[]}]]]]}]]]]}]}]
, 'spec' = [{{'restriction',3},[{'type',892,'bounded_fun',[{'type',892,'fun',[{'type',892,'product',[{'var',892,'SetFun'}|[{'var',892,'Set1'}|[{'var',892,'Set2'}]]]}|[{'var',892,'Set3'}]]}|[[{'type',893,'constraint',[{'atom',893,'is_subtype'}|[[{'var',893,'SetFun'}|[{'user_type',893,'set_fun',[]}]]]]}|[{'type',894,'constraint',[{'atom',894,'is_subtype'}|[[{'var',894,'Set1'}|[{'user_type',894,'a_set',[]}]]]]}|[{'type',895,'constraint',[{'atom',895,'is_subtype'}|[[{'var',895,'Set2'}|[{'user_type',895,'a_set',[]}]]]]}|[{'type',896,'constraint',[{'atom',896,'is_subtype'}|[[{'var',896,'Set3'}|[{'user_type',896,'a_set',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'drestriction',3},[{'type',960,'bounded_fun',[{'type',960,'fun',[{'type',960,'product',[{'var',960,'SetFun'}|[{'var',960,'Set1'}|[{'var',960,'Set2'}]]]}|[{'var',960,'Set3'}]]}|[[{'type',961,'constraint',[{'atom',961,'is_subtype'}|[[{'var',961,'SetFun'}|[{'user_type',961,'set_fun',[]}]]]]}|[{'type',962,'constraint',[{'atom',962,'is_subtype'}|[[{'var',962,'Set1'}|[{'user_type',962,'a_set',[]}]]]]}|[{'type',963,'constraint',[{'atom',963,'is_subtype'}|[[{'var',963,'Set2'}|[{'user_type',963,'a_set',[]}]]]]}|[{'type',964,'constraint',[{'atom',964,'is_subtype'}|[[{'var',964,'Set3'}|[{'user_type',964,'a_set',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'projection',2},[{'type',1029,'bounded_fun',[{'type',1029,'fun',[{'type',1029,'product',[{'var',1029,'SetFun'}|[{'var',1029,'Set1'}]]}|[{'var',1029,'Set2'}]]}|[[{'type',1030,'constraint',[{'atom',1030,'is_subtype'}|[[{'var',1030,'SetFun'}|[{'user_type',1030,'set_fun',[]}]]]]}|[{'type',1031,'constraint',[{'atom',1031,'is_subtype'}|[[{'var',1031,'Set1'}|[{'user_type',1031,'a_set',[]}]]]]}|[{'type',1032,'constraint',[{'atom',1032,'is_subtype'}|[[{'var',1032,'Set2'}|[{'user_type',1032,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'substitution',2},[{'type',1048,'bounded_fun',[{'type',1048,'fun',[{'type',1048,'product',[{'var',1048,'SetFun'}|[{'var',1048,'Set1'}]]}|[{'var',1048,'Set2'}]]}|[[{'type',1049,'constraint',[{'atom',1049,'is_subtype'}|[[{'var',1049,'SetFun'}|[{'user_type',1049,'set_fun',[]}]]]]}|[{'type',1050,'constraint',[{'atom',1050,'is_subtype'}|[[{'var',1050,'Set1'}|[{'user_type',1050,'a_set',[]}]]]]}|[{'type',1051,'constraint',[{'atom',1051,'is_subtype'}|[[{'var',1051,'Set2'}|[{'user_type',1051,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'partition',1},[{'type',1091,'bounded_fun',[{'type',1091,'fun',[{'type',1091,'product',[{'var',1091,'SetOfSets'}]}|[{'var',1091,'Partition'}]]}|[[{'type',1092,'constraint',[{'atom',1092,'is_subtype'}|[[{'var',1092,'SetOfSets'}|[{'user_type',1092,'set_of_sets',[]}]]]]}|[{'type',1093,'constraint',[{'atom',1093,'is_subtype'}|[[{'var',1093,'Partition'}|[{'user_type',1093,'a_set',[]}]]]]}]]]]}]}]
, 'spec' = [{{'partition',2},[{'type',1099,'bounded_fun',[{'type',1099,'fun',[{'type',1099,'product',[{'var',1099,'SetFun'}|[{'var',1099,'Set'}]]}|[{'var',1099,'Partition'}]]}|[[{'type',1100,'constraint',[{'atom',1100,'is_subtype'}|[[{'var',1100,'SetFun'}|[{'user_type',1100,'set_fun',[]}]]]]}|[{'type',1101,'constraint',[{'atom',1101,'is_subtype'}|[[{'var',1101,'Partition'}|[{'user_type',1101,'a_set',[]}]]]]}|[{'type',1102,'constraint',[{'atom',1102,'is_subtype'}|[[{'var',1102,'Set'}|[{'user_type',1102,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'partition',3},[{'type',1118,'bounded_fun',[{'type',1118,'fun',[{'type',1118,'product',[{'var',1118,'SetFun'}|[{'var',1118,'Set1'}|[{'var',1118,'Set2'}]]]}|[{'type',1118,'tuple',[{'var',1118,'Set3'}|[{'var',1118,'Set4'}]]}]]}|[[{'type',1119,'constraint',[{'atom',1119,'is_subtype'}|[[{'var',1119,'SetFun'}|[{'user_type',1119,'set_fun',[]}]]]]}|[{'type',1120,'constraint',[{'atom',1120,'is_subtype'}|[[{'var',1120,'Set1'}|[{'user_type',1120,'a_set',[]}]]]]}|[{'type',1121,'constraint',[{'atom',1121,'is_subtype'}|[[{'var',1121,'Set2'}|[{'user_type',1121,'a_set',[]}]]]]}|[{'type',1122,'constraint',[{'atom',1122,'is_subtype'}|[[{'var',1122,'Set3'}|[{'user_type',1122,'a_set',[]}]]]]}|[{'type',1123,'constraint',[{'atom',1123,'is_subtype'}|[[{'var',1123,'Set4'}|[{'user_type',1123,'a_set',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'multiple_relative_product',2},[{'type',1190,'bounded_fun',[{'type',1190,'fun',[{'type',1190,'product',[{'var',1190,'TupleOfBinRels'}|[{'var',1190,'BinRel1'}]]}|[{'var',1190,'BinRel2'}]]}|[[{'type',1191,'constraint',[{'atom',1191,'is_subtype'}|[[{'var',1191,'TupleOfBinRels'}|[{'user_type',1191,'tuple_of',[{'var',1191,'BinRel'}]}]]]]}|[{'type',1192,'constraint',[{'atom',1192,'is_subtype'}|[[{'var',1192,'BinRel'}|[{'user_type',1192,'binary_relation',[]}]]]]}|[{'type',1193,'constraint',[{'atom',1193,'is_subtype'}|[[{'var',1193,'BinRel1'}|[{'user_type',1193,'binary_relation',[]}]]]]}|[{'type',1194,'constraint',[{'atom',1194,'is_subtype'}|[[{'var',1194,'BinRel2'}|[{'user_type',1194,'binary_relation',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'join',4},[{'type',1206,'bounded_fun',[{'type',1206,'fun',[{'type',1206,'product',[{'var',1206,'Relation1'}|[{'var',1206,'I'}|[{'var',1206,'Relation2'}|[{'var',1206,'J'}]]]]}|[{'var',1206,'Relation3'}]]}|[[{'type',1207,'constraint',[{'atom',1207,'is_subtype'}|[[{'var',1207,'Relation1'}|[{'user_type',1207,'relation',[]}]]]]}|[{'type',1208,'constraint',[{'atom',1208,'is_subtype'}|[[{'var',1208,'Relation2'}|[{'user_type',1208,'relation',[]}]]]]}|[{'type',1209,'constraint',[{'atom',1209,'is_subtype'}|[[{'var',1209,'Relation3'}|[{'user_type',1209,'relation',[]}]]]]}|[{'type',1210,'constraint',[{'atom',1210,'is_subtype'}|[[{'var',1210,'I'}|[{'type',1210,'pos_integer',[]}]]]]}|[{'type',1211,'constraint',[{'atom',1211,'is_subtype'}|[[{'var',1211,'J'}|[{'type',1211,'pos_integer',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'fam2rel',1},[{'type',1247,'bounded_fun',[{'type',1247,'fun',[{'type',1247,'product',[{'var',1247,'Family'}]}|[{'var',1247,'BinRel'}]]}|[[{'type',1248,'constraint',[{'atom',1248,'is_subtype'}|[[{'var',1248,'Family'}|[{'user_type',1248,'family',[]}]]]]}|[{'type',1249,'constraint',[{'atom',1249,'is_subtype'}|[[{'var',1249,'BinRel'}|[{'user_type',1249,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_to_relation',1},[{'type',1253,'bounded_fun',[{'type',1253,'fun',[{'type',1253,'product',[{'var',1253,'Family'}]}|[{'var',1253,'BinRel'}]]}|[[{'type',1254,'constraint',[{'atom',1254,'is_subtype'}|[[{'var',1254,'Family'}|[{'user_type',1254,'family',[]}]]]]}|[{'type',1255,'constraint',[{'atom',1255,'is_subtype'}|[[{'var',1255,'BinRel'}|[{'user_type',1255,'binary_relation',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_specification',2},[{'type',1265,'bounded_fun',[{'type',1265,'fun',[{'type',1265,'product',[{'var',1265,'Fun'}|[{'var',1265,'Family1'}]]}|[{'var',1265,'Family2'}]]}|[[{'type',1266,'constraint',[{'atom',1266,'is_subtype'}|[[{'var',1266,'Fun'}|[{'user_type',1266,'spec_fun',[]}]]]]}|[{'type',1267,'constraint',[{'atom',1267,'is_subtype'}|[[{'var',1267,'Family1'}|[{'user_type',1267,'family',[]}]]]]}|[{'type',1268,'constraint',[{'atom',1268,'is_subtype'}|[[{'var',1268,'Family2'}|[{'user_type',1268,'family',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'union_of_family',1},[{'type',1288,'bounded_fun',[{'type',1288,'fun',[{'type',1288,'product',[{'var',1288,'Family'}]}|[{'var',1288,'Set'}]]}|[[{'type',1289,'constraint',[{'atom',1289,'is_subtype'}|[[{'var',1289,'Family'}|[{'user_type',1289,'family',[]}]]]]}|[{'type',1290,'constraint',[{'atom',1290,'is_subtype'}|[[{'var',1290,'Set'}|[{'user_type',1290,'a_set',[]}]]]]}]]]]}]}]
, 'spec' = [{{'intersection_of_family',1},[{'type',1299,'bounded_fun',[{'type',1299,'fun',[{'type',1299,'product',[{'var',1299,'Family'}]}|[{'var',1299,'Set'}]]}|[[{'type',1300,'constraint',[{'atom',1300,'is_subtype'}|[[{'var',1300,'Family'}|[{'user_type',1300,'family',[]}]]]]}|[{'type',1301,'constraint',[{'atom',1301,'is_subtype'}|[[{'var',1301,'Set'}|[{'user_type',1301,'a_set',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_union',1},[{'type',1314,'bounded_fun',[{'type',1314,'fun',[{'type',1314,'product',[{'var',1314,'Family1'}]}|[{'var',1314,'Family2'}]]}|[[{'type',1315,'constraint',[{'atom',1315,'is_subtype'}|[[{'var',1315,'Family1'}|[{'user_type',1315,'family',[]}]]]]}|[{'type',1316,'constraint',[{'atom',1316,'is_subtype'}|[[{'var',1316,'Family2'}|[{'user_type',1316,'family',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_intersection',1},[{'type',1325,'bounded_fun',[{'type',1325,'fun',[{'type',1325,'product',[{'var',1325,'Family1'}]}|[{'var',1325,'Family2'}]]}|[[{'type',1326,'constraint',[{'atom',1326,'is_subtype'}|[[{'var',1326,'Family1'}|[{'user_type',1326,'family',[]}]]]]}|[{'type',1327,'constraint',[{'atom',1327,'is_subtype'}|[[{'var',1327,'Family2'}|[{'user_type',1327,'family',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_domain',1},[{'type',1341,'bounded_fun',[{'type',1341,'fun',[{'type',1341,'product',[{'var',1341,'Family1'}]}|[{'var',1341,'Family2'}]]}|[[{'type',1342,'constraint',[{'atom',1342,'is_subtype'}|[[{'var',1342,'Family1'}|[{'user_type',1342,'family',[]}]]]]}|[{'type',1343,'constraint',[{'atom',1343,'is_subtype'}|[[{'var',1343,'Family2'}|[{'user_type',1343,'family',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_range',1},[{'type',1353,'bounded_fun',[{'type',1353,'fun',[{'type',1353,'product',[{'var',1353,'Family1'}]}|[{'var',1353,'Family2'}]]}|[[{'type',1354,'constraint',[{'atom',1354,'is_subtype'}|[[{'var',1354,'Family1'}|[{'user_type',1354,'family',[]}]]]]}|[{'type',1355,'constraint',[{'atom',1355,'is_subtype'}|[[{'var',1355,'Family2'}|[{'user_type',1355,'family',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_field',1},[{'type',1365,'bounded_fun',[{'type',1365,'fun',[{'type',1365,'product',[{'var',1365,'Family1'}]}|[{'var',1365,'Family2'}]]}|[[{'type',1366,'constraint',[{'atom',1366,'is_subtype'}|[[{'var',1366,'Family1'}|[{'user_type',1366,'family',[]}]]]]}|[{'type',1367,'constraint',[{'atom',1367,'is_subtype'}|[[{'var',1367,'Family2'}|[{'user_type',1367,'family',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_union',2},[{'type',1371,'bounded_fun',[{'type',1371,'fun',[{'type',1371,'product',[{'var',1371,'Family1'}|[{'var',1371,'Family2'}]]}|[{'var',1371,'Family3'}]]}|[[{'type',1372,'constraint',[{'atom',1372,'is_subtype'}|[[{'var',1372,'Family1'}|[{'user_type',1372,'family',[]}]]]]}|[{'type',1373,'constraint',[{'atom',1373,'is_subtype'}|[[{'var',1373,'Family2'}|[{'user_type',1373,'family',[]}]]]]}|[{'type',1374,'constraint',[{'atom',1374,'is_subtype'}|[[{'var',1374,'Family3'}|[{'user_type',1374,'family',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'family_intersection',2},[{'type',1378,'bounded_fun',[{'type',1378,'fun',[{'type',1378,'product',[{'var',1378,'Family1'}|[{'var',1378,'Family2'}]]}|[{'var',1378,'Family3'}]]}|[[{'type',1379,'constraint',[{'atom',1379,'is_subtype'}|[[{'var',1379,'Family1'}|[{'user_type',1379,'family',[]}]]]]}|[{'type',1380,'constraint',[{'atom',1380,'is_subtype'}|[[{'var',1380,'Family2'}|[{'user_type',1380,'family',[]}]]]]}|[{'type',1381,'constraint',[{'atom',1381,'is_subtype'}|[[{'var',1381,'Family3'}|[{'user_type',1381,'family',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'family_difference',2},[{'type',1385,'bounded_fun',[{'type',1385,'fun',[{'type',1385,'product',[{'var',1385,'Family1'}|[{'var',1385,'Family2'}]]}|[{'var',1385,'Family3'}]]}|[[{'type',1386,'constraint',[{'atom',1386,'is_subtype'}|[[{'var',1386,'Family1'}|[{'user_type',1386,'family',[]}]]]]}|[{'type',1387,'constraint',[{'atom',1387,'is_subtype'}|[[{'var',1387,'Family2'}|[{'user_type',1387,'family',[]}]]]]}|[{'type',1388,'constraint',[{'atom',1388,'is_subtype'}|[[{'var',1388,'Family3'}|[{'user_type',1388,'family',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'partition_family',2},[{'type',1404,'bounded_fun',[{'type',1404,'fun',[{'type',1404,'product',[{'var',1404,'SetFun'}|[{'var',1404,'Set'}]]}|[{'var',1404,'Family'}]]}|[[{'type',1405,'constraint',[{'atom',1405,'is_subtype'}|[[{'var',1405,'Family'}|[{'user_type',1405,'family',[]}]]]]}|[{'type',1406,'constraint',[{'atom',1406,'is_subtype'}|[[{'var',1406,'SetFun'}|[{'user_type',1406,'set_fun',[]}]]]]}|[{'type',1407,'constraint',[{'atom',1407,'is_subtype'}|[[{'var',1407,'Set'}|[{'user_type',1407,'a_set',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'family_projection',2},[{'type',1451,'bounded_fun',[{'type',1451,'fun',[{'type',1451,'product',[{'var',1451,'SetFun'}|[{'var',1451,'Family1'}]]}|[{'var',1451,'Family2'}]]}|[[{'type',1452,'constraint',[{'atom',1452,'is_subtype'}|[[{'var',1452,'SetFun'}|[{'user_type',1452,'set_fun',[]}]]]]}|[{'type',1453,'constraint',[{'atom',1453,'is_subtype'}|[[{'var',1453,'Family1'}|[{'user_type',1453,'family',[]}]]]]}|[{'type',1454,'constraint',[{'atom',1454,'is_subtype'}|[[{'var',1454,'Family2'}|[{'user_type',1454,'family',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'family_to_digraph',1},[{'type',1479,'bounded_fun',[{'type',1479,'fun',[{'type',1479,'product',[{'var',1479,'Family'}]}|[{'var',1479,'Graph'}]]}|[[{'type',1480,'constraint',[{'atom',1480,'is_subtype'}|[[{'var',1480,'Graph'}|[{'remote_type',1480,[{'atom',1480,'digraph'}|[{'atom',1480,'graph'}|[[]]]]}]]]]}|[{'type',1481,'constraint',[{'atom',1481,'is_subtype'}|[[{'var',1481,'Family'}|[{'user_type',1481,'family',[]}]]]]}]]]]}]}]
, 'spec' = [{{'family_to_digraph',2},[{'type',1489,'bounded_fun',[{'type',1489,'fun',[{'type',1489,'product',[{'var',1489,'Family'}|[{'var',1489,'GraphType'}]]}|[{'var',1489,'Graph'}]]}|[[{'type',1490,'constraint',[{'atom',1490,'is_subtype'}|[[{'var',1490,'Graph'}|[{'remote_type',1490,[{'atom',1490,'digraph'}|[{'atom',1490,'graph'}|[[]]]]}]]]]}|[{'type',1491,'constraint',[{'atom',1491,'is_subtype'}|[[{'var',1491,'Family'}|[{'user_type',1491,'family',[]}]]]]}|[{'type',1492,'constraint',[{'atom',1492,'is_subtype'}|[[{'var',1492,'GraphType'}|[{'type',1492,'list',[{'remote_type',1492,[{'atom',1492,'digraph'}|[{'atom',1492,'d_type'}|[[]]]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'digraph_to_family',1},[{'type',1511,'bounded_fun',[{'type',1511,'fun',[{'type',1511,'product',[{'var',1511,'Graph'}]}|[{'var',1511,'Family'}]]}|[[{'type',1512,'constraint',[{'atom',1512,'is_subtype'}|[[{'var',1512,'Graph'}|[{'remote_type',1512,[{'atom',1512,'digraph'}|[{'atom',1512,'graph'}|[[]]]]}]]]]}|[{'type',1513,'constraint',[{'atom',1513,'is_subtype'}|[[{'var',1513,'Family'}|[{'user_type',1513,'family',[]}]]]]}]]]]}]}]
, 'spec' = [{{'digraph_to_family',2},[{'type',1520,'bounded_fun',[{'type',1520,'fun',[{'type',1520,'product',[{'var',1520,'Graph'}|[{'var',1520,'Type'}]]}|[{'var',1520,'Family'}]]}|[[{'type',1521,'constraint',[{'atom',1521,'is_subtype'}|[[{'var',1521,'Graph'}|[{'remote_type',1521,[{'atom',1521,'digraph'}|[{'atom',1521,'graph'}|[[]]]]}]]]]}|[{'type',1522,'constraint',[{'atom',1522,'is_subtype'}|[[{'var',1522,'Family'}|[{'user_type',1522,'family',[]}]]]]}|[{'type',1523,'constraint',[{'atom',1523,'is_subtype'}|[[{'var',1523,'Type'}|[{'user_type',1523,'type',[]}]]]]}]]]]]}]}] ] 'from_term'/1 = fun (_0) -> let <_2> = case _0 of <_9> when call 'erlang':'is_list' (_0) -> ['_']
<_10> when 'true' -> '_' end in try apply 'setify'/2 (_0,_2) of <_4> -> _4 catch <_7,_6,_5> -> call 'erlang':'error' ('badarg')
'from_term'/2 = fun (_0,_1) -> case apply 'is_type'/1 (_1) of <'true'> when 'true' -> try apply 'setify'/2 (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> call 'erlang':'error' ('badarg')
<'false'> when 'true' -> call 'erlang':'error' ('badarg')
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
'from_external'/2 = fun (_0,_1) -> case <_0,_1> of <L,[Type|[]]> when 'true' -> {'Set',L,Type}
<T,Type> when 'true' -> {'OrdSet',T,Type} end
'empty_set'/0 = fun () -> {'Set',[],'_'}
'is_type'/1 = fun (_0) -> case _0 of <Atom> when let <_1> = call 'erlang':'is_atom' (_0) in let <_2> = call 'erlang':'=/=' (_0,'_') in call 'erlang':'and' (_1,_2) -> 'true'
<[T|[]]> when 'true' -> apply 'is_element_type'/1 (T)
<T> when try let <_3> = call 'erlang':'tuple_size' (_0) in call 'erlang':'>' (_3,0) of <Try> -> Try catch <T,R> -> 'false' -> let <_4> = call 'erlang':'tuple_size' (T) in apply 'is_types'/2 (_4,T)
<_X_T> when 'true' -> 'false' end
'set'/1 = fun (_0) -> try call 'lists':'usort' (_0) of <_1> -> {'Set',_1,'atom'} catch <_5,_4,_3> -> call 'erlang':'error' ('badarg')
'set'/2 = fun (_0,_1) -> case <_0,_1> of <L,[Type|[]]> when let <_2> = call 'erlang':'is_atom' (Type) in let <_3> = call 'erlang':'=/=' (Type,'_') in call 'erlang':'and' (_2,_3) -> try call 'lists':'usort' (L) of <_4> -> {'Set',_4,Type} catch <_8,_7,_6> -> call 'erlang':'error' ('badarg')
<L,T = [_18|[]]> when 'true' -> try apply 'setify'/2 (L,T) of <_9> -> _9 catch <_12,_11,_10> -> call 'erlang':'error' ('badarg')
<_22,_23> when 'true' -> call 'erlang':'error' ('badarg') end
'from_sets'/1 = fun (_0) -> case _0 of <Ss> when call 'erlang':'is_list' (_0) -> case apply 'set_of_sets'/3 (Ss,[],'_') of <{'error',Error}> when 'true' -> call 'erlang':'error' (Error)
<Set> when 'true' -> Set end
<Tuple> when call 'erlang':'is_tuple' (_0) -> let <_2> = call 'erlang':'tuple_to_list' (Tuple) in case apply 'ordset_of_sets'/3 (_2,[],[]) of <'error'> when 'true' -> call 'erlang':'error' ('badarg')
<Set> when 'true' -> Set end
<_5> when 'true' -> call 'erlang':'error' ('badarg') end
'relation'/1 = fun (_0) -> case _0 of <[]> when 'true' -> {'Set',[],{'atom','atom'}}
<Ts = [T|_7]> when call 'erlang':'is_tuple' (T) -> try let <_1> = call 'erlang':'tuple_size' (T) in (case <Ts,_1> of (<_14,([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_3> = apply 'is_type'/1 (Type) in (let <_2> = apply 'atoms_only'/2 (Type,(1-|['compiler_generated'] )) in (case (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_3,_2)-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_4> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Type) in (apply 'rel'/3 (_14,_4,Type)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (apply 'rel_type'/3 (_14,([]-|['compiler_generated'] ),Type)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_15,Sz> when ('true'-|['compiler_generated'] ) -> (let <_6> = call ('erlang'-|['compiler_generated'] ):('make_tuple'-|['compiler_generated'] ) (Sz,('atom'-|['compiler_generated'] )) in (apply 'rel'/3 (_15,Sz,_6)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <_2> -> _2 catch <_5,_4,_3> -> call 'erlang':'error' ('badarg')
<_11> when 'true' -> call 'erlang':'error' ('badarg') end
'relation'/2 = fun (_0,_1) -> try (case <_0,_1> of (<_13,([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_3> = apply 'is_type'/1 (Type) in (let <_2> = apply 'atoms_only'/2 (Type,(1-|['compiler_generated'] )) in (case (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_3,_2)-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_4> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Type) in (apply 'rel'/3 (_13,_4,Type)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (apply 'rel_type'/3 (_13,([]-|['compiler_generated'] ),Type)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_14,Sz> when ('true'-|['compiler_generated'] ) -> (let <_6> = call ('erlang'-|['compiler_generated'] ):('make_tuple'-|['compiler_generated'] ) (Sz,('atom'-|['compiler_generated'] )) in (apply 'rel'/3 (_14,Sz,_6)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <_2> -> _2 catch <_5,_4,_3> -> call 'erlang':'error' ('badarg')
'a_function'/1 = fun (_0) -> try apply 'func'/2 (_0,{'atom','atom'}) of <_1> -> case _1 of <Bad> when call 'erlang':'is_atom' (_1) -> call 'erlang':'error' (Bad)
<Set> when 'true' -> Set end catch <_5,_4,_3> -> call 'erlang':'error' ('badarg')
'a_function'/2 = fun (_0,_1) -> try (let <_2> = apply 'is_type'/1 (_1) in (case <_1,_2> of (<([(Type = ({DT,RT}-|['compiler_generated'] )-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when (let <_3> = call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (DT) in (let <_4> = call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (RT) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_3,_4)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) -> (apply 'func'/2 (_0,Type)-|['compiler_generated'] )-|['compiler_generated'] )
(<([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_7> = fun (_5) -> (case _5 of (<({_11,_12}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_6> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_6}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) in (apply 'func_type'/4 (_0,([]-|['compiler_generated'] ),Type,_7)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(_17-|['compiler_generated'] ),(_18-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_8> = {(_17-|['compiler_generated'] ),(_18-|['compiler_generated'] )} in (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_8}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] ) of <_2> -> case _2 of <Bad> when call 'erlang':'is_atom' (_2) -> call 'erlang':'error' (Bad)
<Set> when 'true' -> Set end catch <_6,_5,_4> -> call 'erlang':'error' ('badarg')
'family'/1 = fun (_0) -> try apply 'fam2'/2 (_0,{'atom',['atom']}) of <_1> -> case _1 of <Bad> when call 'erlang':'is_atom' (_1) -> call 'erlang':'error' (Bad)
<Set> when 'true' -> Set end catch <_5,_4,_3> -> call 'erlang':'error' ('badarg')
'family'/2 = fun (_0,_1) -> try (let <_2> = apply 'is_type'/1 (_1) in (case <_1,_2> of (<([(Type = ({DT,([RT|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when (let <_3> = call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (DT) in (let <_4> = call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (RT) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_3,_4)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) -> (apply 'fam2'/2 (_0,Type)-|['compiler_generated'] )-|['compiler_generated'] )
(<([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_7> = fun (_5) -> (case _5 of (<({_11,([_12|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_6> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_6}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) in (apply 'func_type'/4 (_0,([]-|['compiler_generated'] ),Type,_7)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<(_17-|['compiler_generated'] ),(_18-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_8> = {(_17-|['compiler_generated'] ),(_18-|['compiler_generated'] )} in (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_8}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] ) of <_2> -> case _2 of <Bad> when call 'erlang':'is_atom' (_2) -> call 'erlang':'error' (Bad)
<Set> when 'true' -> Set end catch <_6,_5,_4> -> call 'erlang':'error' ('badarg')
'to_external'/1 = fun (_0) -> case _0 of <S = {'Set',_4,_5}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_rec0,_6}-|['compiler_generated'] )> when 'true' -> _rec0-|['compiler_generated'] )
(<_7> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'OrdSet',_rec1,_10}-|['compiler_generated'] )> when 'true' -> _rec1-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'to_external',1}}] )-|['compiler_generated'] ) end
'type'/1 = fun (_0) -> case _0 of <S = {'Set',_5,_6}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_7,_rec2}-|['compiler_generated'] )> when 'true' -> [_rec2|[]]-|['compiler_generated'] )
(<_8> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_9,_10}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'OrdSet',_11,_rec3}-|['compiler_generated'] )> when 'true' -> _rec3-|['compiler_generated'] )
(<_12> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'type',1}}] )-|['compiler_generated'] ) end
'to_sets'/1 = fun (_0) -> case _0 of <S = {'Set',_22,_23}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_24,_rec4}-|['compiler_generated'] )> when 'true' -> case _rec4 of <[Type|[]]> when 'true' -> (case S of (<({'Set',_rec5,_26}-|['compiler_generated'] )> when 'true' -> apply 'list_of_sets'/3 (_rec5,Type,[])-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Type> when 'true' -> (case S of (<({'Set',_rec6,_28}-|['compiler_generated'] )> when 'true' -> apply 'list_of_ordsets'/3 (_rec6,Type,[])-|['compiler_generated'] )
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_30,_31}> when (try let <_12> = call 'erlang':'element' (3,S) in call 'erlang':'is_tuple' (_12) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case S of (<({'OrdSet',_rec7,_32}-|['compiler_generated'] )> when 'true' -> let <_20> = call 'erlang':'tuple_to_list' (_rec7) in (case S of (<({'OrdSet',_34,_rec8}-|['compiler_generated'] )> when 'true' -> let <_17> = call 'erlang':'tuple_to_list' (_rec8) in apply 'tuple_of_sets'/3 (_20,_17,[])-|['compiler_generated'] )
(<_35> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_36,_37}> when ('true'-|['compiler_generated'] ) -> call 'erlang':'error' ('badarg')
(<_21> when 'true' -> (primop 'match_fail' ({'function_clause',_21})-|[{'function_name',{'to_sets',1}}] )-|['compiler_generated'] ) end
'no_elements'/1 = fun (_0) -> case _0 of <S = {'Set',_13,_14}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_rec9,_15}-|['compiler_generated'] )> when 'true' -> call 'erlang':'length' (_rec9)-|['compiler_generated'] )
(<_16> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_17,_18}> when (try let <_7> = call 'erlang':'element' (3,S) in call 'erlang':'is_tuple' (_7) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case S of (<({'OrdSet',_rec10,_19}-|['compiler_generated'] )> when 'true' -> call 'erlang':'tuple_size' (_rec10)-|['compiler_generated'] )
(<_20> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_21,_22}> when ('true'-|['compiler_generated'] ) -> call 'erlang':'error' ('badarg')
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'no_elements',1}}] )-|['compiler_generated'] ) end
'specification'/2 = fun (_0,_1) -> case <_0,_1> of <Fun,S = {'Set',_16,_17}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_18,_rec11}-|['compiler_generated'] )> when 'true' -> let <_11> = case (case Fun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),_25}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _25-|['compiler_generated'] )
(<_2> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when 'true' -> (case S of (<({'Set',_rec12,_20}-|['compiler_generated'] )> when 'true' -> let <_5> = case _rec11 of (<([_27|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _27-|['compiler_generated'] )
(<_28> when ('true'-|['compiler_generated'] ) -> _28-|['compiler_generated'] ) end in apply 'spec'/4 (_rec12,Fun,_5,[])-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<XFun> when 'true' -> (case S of (<({'Set',_rec13,_22}-|['compiler_generated'] )> when 'true' -> apply 'specification'/3 (_rec13,XFun,[])-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end in case _11 of <SL> when call 'erlang':'is_list' (_11) -> {'Set',SL,_rec11}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14})-|[{'function_name',{'specification',2}}] )-|['compiler_generated'] ) end
'union'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_14,_15},S2 = {'Set',_16,_17}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_18,_rec14}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_20,_rec15}-|['compiler_generated'] )> when 'true' -> case (case <_rec14,_rec15> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> call 'erlang':'error' ('type_mismatch')
<Type> when 'true' -> (case S1 of (<({'Set',_rec16,_22}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_rec17,_24}-|['compiler_generated'] )> when 'true' -> let <_10> = call 'lists':'umerge' (_rec16,_rec17) in {'Set',_10,Type}-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'union',2}}] )-|['compiler_generated'] ) end
'intersection'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_14,_15},S2 = {'Set',_16,_17}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_18,_rec18}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_20,_rec19}-|['compiler_generated'] )> when 'true' -> case (case <_rec18,_rec19> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> call 'erlang':'error' ('type_mismatch')
<Type> when 'true' -> (case S1 of (<({'Set',_rec20,_22}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_rec21,_24}-|['compiler_generated'] )> when 'true' -> let <_10> = apply 'intersection'/3 (_rec20,_rec21,[]) in {'Set',_10,Type}-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'intersection',2}}] )-|['compiler_generated'] ) end
'difference'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_14,_15},S2 = {'Set',_16,_17}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_18,_rec22}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_20,_rec23}-|['compiler_generated'] )> when 'true' -> case (case <_rec22,_rec23> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> call 'erlang':'error' ('type_mismatch')
<Type> when 'true' -> (case S1 of (<({'Set',_rec24,_22}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_rec25,_24}-|['compiler_generated'] )> when 'true' -> let <_10> = apply 'difference'/3 (_rec24,_rec25,[]) in {'Set',_10,Type}-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'difference',2}}] )-|['compiler_generated'] ) end
'symdiff'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_14,_15},S2 = {'Set',_16,_17}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_18,_rec26}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_20,_rec27}-|['compiler_generated'] )> when 'true' -> case (case <_rec26,_rec27> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> call 'erlang':'error' ('type_mismatch')
<Type> when 'true' -> (case S1 of (<({'Set',_rec28,_22}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_rec29,_24}-|['compiler_generated'] )> when 'true' -> let <_10> = case <_rec28,_rec29> of (<([H1|T1]-|['compiler_generated'] ),T2> when ('true'-|['compiler_generated'] ) -> (apply 'symdiff2'/4 (T1,T2,([]-|['compiler_generated'] ),H1)-|['compiler_generated'] )-|['compiler_generated'] )
(<_6,T2> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (([]-|['compiler_generated'] ),T2)-|['compiler_generated'] )-|['compiler_generated'] ) end in {'Set',_10,Type}-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'symdiff',2}}] )-|['compiler_generated'] ) end
'symmetric_partition'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_13,_14},S2 = {'Set',_15,_16}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_17,_rec30}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_19,_rec31}-|['compiler_generated'] )> when 'true' -> case (case <_rec30,_rec31> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> call 'erlang':'error' ('type_mismatch')
<Type> when 'true' -> (case S1 of (<({'Set',_rec32,_21}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_rec33,_23}-|['compiler_generated'] )> when 'true' -> apply 'sympart'/6 (_rec32,_rec33,[],[],[],Type)-|['compiler_generated'] )
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_20> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_18> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'symmetric_partition',2}}] )-|['compiler_generated'] ) end
'product'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_31,_32},S2 = {'Set',_33,_34}> when ('true'-|['compiler_generated'] ) -> case <> of <> when (try (let <_4> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (S1,('Set'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_2-|['compiler_generated'] )> when 'true' -> (_2-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_5> = call 'erlang':'=:=' ((_4-|['compiler_generated'] ),'true') in let <_6> = call 'erlang':'element' (3,S1) in let <_7> = call 'erlang':'=:=' (_6,'_') in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_5,_7)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> S1
<> when (try (let <_10> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (S2,('Set'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_8-|['compiler_generated'] )> when 'true' -> (_8-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_11> = call 'erlang':'=:=' ((_10-|['compiler_generated'] ),'true') in let <_12> = call 'erlang':'element' (3,S2) in let <_13> = call 'erlang':'=:=' (_12,'_') in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_11,_13)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> S2
<> when 'true' -> let <F> = fun (_14) -> {0,_14} in (case S1 of (<({'Set',_35,_rec34}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_37,_rec35}-|['compiler_generated'] )> when 'true' -> let <T> = {_rec34,_rec35} in (case S1 of (<({'Set',_rec36,_39}-|['compiler_generated'] )> when 'true' -> let <_27> = call 'lists':'map' (F,_rec36) in (case S2 of (<({'Set',_rec37,_41}-|['compiler_generated'] )> when 'true' -> let <_24> = call 'lists':'map' (F,_rec37) in let <_28> = apply 'relprod'/2 (_27,_24) in {'Set',_28,T}-|['compiler_generated'] )
(<_42> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_40> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_38> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_36> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
(<_30,_29> when 'true' -> (primop 'match_fail' ({'function_clause',_30,_29})-|[{'function_name',{'product',2}}] )-|['compiler_generated'] ) end
'product'/1 = fun (_0) -> case _0 of <{S1,S2}> when 'true' -> apply 'product'/2 (S1,S2)
<T> when call 'erlang':'is_tuple' (_0) -> let <Ss> = call 'erlang':'tuple_to_list' (T) in try apply 'sets_to_list'/1 (Ss) of <_2> -> case _2 of <[]> when 'true' -> call 'erlang':'error' ('badarg')
<L> when 'true' -> let <Type> = apply 'types'/2 (Ss,[]) in case call 'lists':'member' ([],L) of <'true'> when 'true' -> apply 'empty_set'/0 ()
<'false'> when 'true' -> let <_4> = apply 'prod'/3 (L,[],[]) in let <_5> = call 'lists':'reverse' (_4) in {'Set',_5,Type}
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end end catch <_10,_9,_8> -> call 'erlang':'error' ('badarg')
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'product',1}}] )-|['compiler_generated'] ) end
'constant_function'/2 = fun (_0,_1) -> case <_0,_1> of <S = {'Set',_14,_15},E> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_16,_rec38}-|['compiler_generated'] )> when 'true' -> let <_2> = apply 'is_sofs_set'/1 (E) in case <_rec38,_2> of <'_','true'> when 'true' -> S
<Type,('true'-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'type'/1 (E) in let <NType> = {Type,_5} in (case S of (<({'Set',_rec39,_18}-|['compiler_generated'] )> when 'true' -> let <_7> = apply 'to_external'/1 (E) in let <_10> = apply 'constant_function'/3 (_rec39,_7,[]) in {'Set',_10,NType}-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<(_24-|['compiler_generated'] ),(_25-|['compiler_generated'] )> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_17> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_21,_22},_23> when ('true'-|['compiler_generated'] ) -> call 'erlang':'error' ('badarg')
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'constant_function',2}}] )-|['compiler_generated'] ) end
'is_equal'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_22,_23},S2 = {'Set',_24,_25}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_26,_rec40}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_28,_rec41}-|['compiler_generated'] )> when 'true' -> case (case <_rec40,_rec41> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S1 of (<({'Set',_rec42,_30}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_rec43,_32}-|['compiler_generated'] )> when 'true' -> call 'erlang':'==' (_rec42,_rec43)-|['compiler_generated'] )
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_31> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S1 = {'OrdSet',_34,_35},S2 = {'OrdSet',_36,_37}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'OrdSet',_38,_rec44}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'OrdSet',_40,_rec45}-|['compiler_generated'] )> when 'true' -> case (case <_rec44,_rec45> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S1 of (<({'OrdSet',_rec46,_42}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'OrdSet',_rec47,_44}-|['compiler_generated'] )> when 'true' -> call 'erlang':'==' (_rec46,_rec47)-|['compiler_generated'] )
(<_45> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_43> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_19> when 'true' -> primop 'match_fail' ({'case_clause',_19})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_39> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S1 = {'Set',_46,_47},S2 = {'OrdSet',_48,_49}> when ('true'-|['compiler_generated'] ) -> call 'erlang':'error' ('type_mismatch')
<S1 = {'OrdSet',_50,_51},S2 = {'Set',_52,_53}> when ('true'-|['compiler_generated'] ) -> call 'erlang':'error' ('type_mismatch')
(<_21,_20> when 'true' -> (primop 'match_fail' ({'function_clause',_21,_20})-|[{'function_name',{'is_equal',2}}] )-|['compiler_generated'] ) end
'is_subset'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_13,_14},S2 = {'Set',_15,_16}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_17,_rec48}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_19,_rec49}-|['compiler_generated'] )> when 'true' -> case (case <_rec48,_rec49> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S1 of (<({'Set',_rec50,_21}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_rec51,_23}-|['compiler_generated'] )> when 'true' -> apply 'subset'/2 (_rec50,_rec51)-|['compiler_generated'] )
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_20> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_18> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'is_subset',2}}] )-|['compiler_generated'] ) end
'is_sofs_set'/1 = fun (_0) -> case _0 of <S = {'Set',_2,_3}> when ('true'-|['compiler_generated'] ) -> 'true'
<S = {'OrdSet',_4,_5}> when ('true'-|['compiler_generated'] ) -> 'true'
<_X_S> when 'true' -> 'false' end
'is_set'/1 = fun (_0) -> case _0 of <S = {'Set',_2,_3}> when ('true'-|['compiler_generated'] ) -> 'true'
<S = {'OrdSet',_4,_5}> when ('true'-|['compiler_generated'] ) -> 'false'
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'is_set',1}}] )-|['compiler_generated'] ) end
'is_empty_set'/1 = fun (_0) -> case _0 of <S = {'Set',_4,_5}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_rec52,_6}-|['compiler_generated'] )> when 'true' -> call 'erlang':'=:=' (_rec52,[])-|['compiler_generated'] )
(<_7> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<S = {'OrdSet',_8,_9}> when ('true'-|['compiler_generated'] ) -> 'false'
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'is_empty_set',1}}] )-|['compiler_generated'] ) end
'is_disjoint'/2 = fun (_0,_1) -> case <_0,_1> of <S1 = {'Set',_14,_15},S2 = {'Set',_16,_17}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_18,_rec53}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_20,_rec54}-|['compiler_generated'] )> when 'true' -> case (case <_rec53,_rec54> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S1 of (<({'Set',_rec55,_22}-|['compiler_generated'] )> when 'true' -> case _rec55 of <[]> when 'true' -> 'true'
<[A|As]> when 'true' -> (case S2 of (<({'Set',_rec56,_24}-|['compiler_generated'] )> when 'true' -> apply 'disjoint'/3 (_rec56,A,As)-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'is_disjoint',2}}] )-|['compiler_generated'] ) end
'union'/1 = fun (_0) -> case _0 of <Sets = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case Sets of (<({'Set',_10,_rec57}-|['compiler_generated'] )> when 'true' -> case _rec57 of <[Type|[]]> when 'true' -> (case Sets of (<({'Set',_rec58,_12}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'lunion'/1 (_rec58) in {'Set',_5,Type}-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> Sets
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'union',1}}] )-|['compiler_generated'] ) end
'intersection'/1 = fun (_0) -> case _0 of <Sets = {'Set',_9,_10}> when ('true'-|['compiler_generated'] ) -> (case Sets of (<({'Set',_rec59,_11}-|['compiler_generated'] )> when 'true' -> case _rec59 of <[]> when 'true' -> call 'erlang':'error' ('badarg')
<[L|Ls]> when 'true' -> (case Sets of (<({'Set',_13,_rec60}-|['compiler_generated'] )> when 'true' -> case _rec60 of <[Type|[]]> when 'true' -> let <_5> = apply 'lintersection'/2 (Ls,L) in {'Set',_5,Type}
<_15> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_12> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'intersection',1}}] )-|['compiler_generated'] ) end
'canonical_relation'/1 = fun (_0) -> case _0 of <Sets = {'Set',_9,_10}> when ('true'-|['compiler_generated'] ) -> (case Sets of (<({'Set',_11,_rec61}-|['compiler_generated'] )> when 'true' -> case _rec61 of <['_']> when 'true' -> apply 'empty_set'/0 ()
<[Type|[]]> when 'true' -> (case Sets of (<({'Set',_rec62,_13}-|['compiler_generated'] )> when 'true' -> let <_6> = apply 'can_rel'/2 (_rec62,[]) in {'Set',_6,{Type,_rec61}}-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> Sets
<_15> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_12> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'canonical_relation',1}}] )-|['compiler_generated'] ) end
'rel2fam'/1 = fun (_0) -> (case _0 of (<(_15 = ({('Set'-|['compiler_generated'] ),_8,_9}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _15 of (<({('Set'-|['compiler_generated'] ),_10,_rec63}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _rec63 of (<({DT,RT}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _15 of (<({('Set'-|['compiler_generated'] ),_rec64,_12}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_5> = apply 'rel2family'/1 (_rec64) in ({('Set'-|['compiler_generated'] ),_5,({DT,([RT|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_13> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _15-|['compiler_generated'] )
(<_X_Else> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('badarg'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_11> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_7> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_7}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'relation_to_family'/1 = fun (_0) -> case _0 of <R = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_10,_rec63}-|['compiler_generated'] )> when 'true' -> case _rec63 of <{DT,RT}> when 'true' -> (case R of (<({'Set',_rec64,_12}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'rel2family'/1 (_rec64) in {'Set',_5,{DT,[RT|[]]}}-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> R
<_X_Else> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'relation_to_family',1}}] )-|['compiler_generated'] ) end
'domain'/1 = fun (_0) -> case _0 of <R = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_10,_rec65}-|['compiler_generated'] )> when 'true' -> case _rec65 of <{DT,_12}> when 'true' -> (case R of (<({'Set',_rec66,_13}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'dom'/1 (_rec66) in {'Set',_5,DT}-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> R
<_X_Else> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'domain',1}}] )-|['compiler_generated'] ) end
'range'/1 = fun (_0) -> case _0 of <R = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_10,_rec67}-|['compiler_generated'] )> when 'true' -> case _rec67 of <{_12,RT}> when 'true' -> (case R of (<({'Set',_rec68,_13}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'ran'/2 (_rec68,[]) in {'Set',_5,RT}-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> R
<_15> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'range',1}}] )-|['compiler_generated'] ) end
'field'/1 = fun (_0) -> let <_2> = apply 'domain'/1 (_0) in let <_1> = apply 'range'/1 (_0) in apply 'union'/2 (_2,_1)
'relative_product'/1 = fun (_0) -> case _0 of <RT> when call 'erlang':'is_tuple' (_0) -> let <_1> = call 'erlang':'tuple_to_list' (RT) in apply 'relative_product'/1 (_1)
<RL> when call 'erlang':'is_list' (_0) -> case apply 'relprod_n'/4 (RL,'foo','false','false') of <{'error',Reason}> when 'true' -> call 'erlang':'error' (Reason)
<Reply> when 'true' -> Reply end
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'relative_product',1}}] )-|['compiler_generated'] ) end
'relative_product'/2 = fun (_0,_1) -> case <_0,_1> of <R1 = {'Set',_16,_17},R2 = {'Set',_18,_19}> when ('true'-|['compiler_generated'] ) -> let <_2> = apply 'converse'/1 (R1) in apply 'relative_product1'/2 (_2,R2)
<RT,R = {'Set',_20,_21}> when call 'erlang':'is_tuple' (RT) -> let <_4> = call 'erlang':'tuple_to_list' (RT) in apply 'relative_product'/2 (_4,R)
<RL,R = {'Set',_22,_23}> when call 'erlang':'is_list' (RL) -> (case R of (<({'Set',_24,_rec69}-|['compiler_generated'] )> when 'true' -> let <_11> = case _rec69 of <{_26,_27}> when 'true' -> (case R of (<({'Set',_rec70,_28}-|['compiler_generated'] )> when 'true' -> call 'erlang':'=:=' (_rec70,[])-|['compiler_generated'] )
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> 'true'
<_30> when 'true' -> call 'erlang':'error' ('badarg') end in case apply 'relprod_n'/4 (RL,R,_11,'true') of <{'error',Reason}> when 'true' -> call 'erlang':'error' (Reason)
<Reply> when 'true' -> Reply end-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14})-|[{'function_name',{'relative_product',2}}] )-|['compiler_generated'] ) end
'relative_product1'/2 = fun (_0,_1) -> case <_0,_1> of <R1 = {'Set',_20,_21},R2 = {'Set',_22,_23}> when ('true'-|['compiler_generated'] ) -> (case R1 of (<({'Set',_24,_rec71}-|['compiler_generated'] )> when 'true' -> let <_5> = case _rec71 of <R1T = {_26,_27}> when 'true' -> R1T
<'_'> when 'true' -> {'_','_'}
<_28> when 'true' -> call 'erlang':'error' ('badarg') end in case _5 of <{DTR1,RTR1}> when 'true' -> (case R2 of (<({'Set',_29,_rec72}-|['compiler_generated'] )> when 'true' -> let <_10> = case _rec72 of <R2T = {_31,_32}> when 'true' -> R2T
<'_'> when 'true' -> {'_','_'}
<_33> when 'true' -> call 'erlang':'error' ('badarg') end in case _10 of <{DTR2,RTR2}> when 'true' -> case (case <DTR1,DTR2> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when call 'erlang':'=:=' (DTR1,'_') -> R1
<'true'> when call 'erlang':'=:=' (DTR2,'_') -> R2
<'true'> when 'true' -> (case R1 of (<({'Set',_rec73,_34}-|['compiler_generated'] )> when 'true' -> (case R2 of (<({'Set',_rec74,_36}-|['compiler_generated'] )> when 'true' -> let <_16> = apply 'relprod'/2 (_rec73,_rec74) in {'Set',_16,{RTR1,RTR2}}-|['compiler_generated'] )
(<_37> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_35> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_17> when 'true' -> primop 'match_fail' ({'case_clause',_17})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_30> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_19,_18> when 'true' -> (primop 'match_fail' ({'function_clause',_19,_18})-|[{'function_name',{'relative_product1',2}}] )-|['compiler_generated'] ) end
'converse'/1 = fun (_0) -> case _0 of <R = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_10,_rec75}-|['compiler_generated'] )> when 'true' -> case _rec75 of <{DT,RT}> when 'true' -> (case R of (<({'Set',_rec76,_12}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'converse'/2 (_rec76,[]) in {'Set',_5,{RT,DT}}-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> R
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'converse',1}}] )-|['compiler_generated'] ) end
'image'/2 = fun (_0,_1) -> case <_0,_1> of <R = {'Set',_16,_17},S = {'Set',_18,_19}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_20,_rec77}-|['compiler_generated'] )> when 'true' -> case _rec77 of <{DT,RT}> when 'true' -> (case S of (<({'Set',_22,_rec78}-|['compiler_generated'] )> when 'true' -> case (case <DT,_rec78> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S of (<({'Set',_rec79,_24}-|['compiler_generated'] )> when 'true' -> (case R of (<({'Set',_rec80,_26}-|['compiler_generated'] )> when 'true' -> let <_10> = apply 'restrict'/2 (_rec79,_rec80) in let <_11> = call 'lists':'usort' (_10) in {'Set',_11,RT}-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> R
<_28> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_15,_14> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14})-|[{'function_name',{'image',2}}] )-|['compiler_generated'] ) end
'inverse_image'/2 = fun (_0,_1) -> case <_0,_1> of <R = {'Set',_17,_18},S = {'Set',_19,_20}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_21,_rec81}-|['compiler_generated'] )> when 'true' -> case _rec81 of <{DT,RT}> when 'true' -> (case S of (<({'Set',_23,_rec82}-|['compiler_generated'] )> when 'true' -> case (case <RT,_rec82> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S of (<({'Set',_rec83,_25}-|['compiler_generated'] )> when 'true' -> (case R of (<({'Set',_rec84,_27}-|['compiler_generated'] )> when 'true' -> let <_8> = apply 'converse'/2 (_rec84,[]) in let <NL> = apply 'restrict'/2 (_rec83,_8) in let <_12> = call 'lists':'usort' (NL) in {'Set',_12,DT}-|['compiler_generated'] )
(<_28> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_26> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> R
<_29> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15})-|[{'function_name',{'inverse_image',2}}] )-|['compiler_generated'] ) end
'strict_relation'/1 = fun (_0) -> case _0 of <R = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_10,_rec85}-|['compiler_generated'] )> when 'true' -> case _rec85 of <Type = {_12,_13}> when 'true' -> (case R of (<({'Set',_rec86,_14}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'strict'/2 (_rec86,[]) in {'Set',_5,Type}-|['compiler_generated'] )
(<_15> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> R
<_16> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'strict_relation',1}}] )-|['compiler_generated'] ) end
'weak_relation'/1 = fun (_0) -> case _0 of <R = {'Set',_9,_10}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_11,_rec87}-|['compiler_generated'] )> when 'true' -> case _rec87 of <{DT,RT}> when 'true' -> case (case <DT,RT> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> call 'erlang':'error' ('badarg')
<Type> when 'true' -> (case R of (<({'Set',_rec88,_13}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'weak'/1 (_rec88) in {'Set',_5,{Type,Type}}-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
<'_'> when 'true' -> R
<_15> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_12> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'weak_relation',1}}] )-|['compiler_generated'] ) end
'extension'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <R = {'Set',_26,_27},S = {'Set',_28,_29},E> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_30,_rec89}-|['compiler_generated'] )> when 'true' -> (case S of (<({'Set',_32,_rec90}-|['compiler_generated'] )> when 'true' -> let <_3> = apply 'is_sofs_set'/1 (E) in case <_rec89,_rec90,_3> of <T = ({DT,RT}-|['compiler_generated'] ),ST,('true'-|['compiler_generated'] )> when 'true' -> let <_10> = case <DT,ST> of (<_45,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,_45)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_8> = apply 'type'/1 (E) in let <_9> = case <RT,_8> of (<_48,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,_48)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end in case call 'erlang':'and' (_10,_9) of <'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
<'true'> when 'true' -> (case R of (<({'Set',_rec91,_34}-|['compiler_generated'] )> when 'true' -> (case S of (<({'Set',_rec92,_36}-|['compiler_generated'] )> when 'true' -> let <_14> = apply 'to_external'/1 (E) in case apply 'extc'/4 ([],_rec92,_14,_rec91) of <[]> when 'true' -> R
<L> when 'true' -> let <_17> = call 'lists':'reverse' (L) in let <_18> = call 'lists':'merge' (_rec91,_17) in {'Set',_18,T} end-|['compiler_generated'] )
(<_37> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_35> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
<'_','_','true'> when 'true' -> R
<('_'-|['compiler_generated'] ),ST,('true'-|['compiler_generated'] )> when 'true' -> case apply 'type'/1 (E) of <['_']> when 'true' -> R
<ET> when 'true' -> {'Set',[],{ST,ET}} end
<_38,_39,('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'error' ('badarg')
(<(_40-|['compiler_generated'] ),(_41-|['compiler_generated'] ),(_42-|['compiler_generated'] )> when 'true' -> let <_22> = {(_40-|['compiler_generated'] ),(_41-|['compiler_generated'] ),(_42-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_31> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_25,_24,_23> when 'true' -> (primop 'match_fail' ({'function_clause',_25,_24,_23})-|[{'function_name',{'extension',3}}] )-|['compiler_generated'] ) end
'is_a_function'/1 = fun (_0) -> case _0 of <R = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case R of (<({'Set',_10,_rec93}-|['compiler_generated'] )> when 'true' -> case _rec93 of <{_12,_13}> when 'true' -> (case R of (<({'Set',_rec94,_14}-|['compiler_generated'] )> when 'true' -> case _rec94 of <[]> when 'true' -> 'true'
<[{V,_16}|Es]> when 'true' -> apply 'is_a_func'/2 (Es,V)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_15> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> 'true'
<_17> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'is_a_function',1}}] )-|['compiler_generated'] ) end
'restriction'/2 = fun (_0,_1) -> apply 'restriction'/3 (1,_0,_1)
'drestriction'/2 = fun (_0,_1) -> apply 'drestriction'/3 (1,_0,_1)
'composite'/2 = fun (_0,_1) -> case <_0,_1> of <Fn1 = {'Set',_21,_22},Fn2 = {'Set',_23,_24}> when ('true'-|['compiler_generated'] ) -> (case Fn1 of (<({'Set',_25,_rec95}-|['compiler_generated'] )> when 'true' -> let <_5> = case _rec95 of <F1T = {_27,_28}> when 'true' -> F1T
<'_'> when 'true' -> {'_','_'}
<_29> when 'true' -> call 'erlang':'error' ('badarg') end in case _5 of <{DTF1,RTF1}> when 'true' -> (case Fn2 of (<({'Set',_30,_rec96}-|['compiler_generated'] )> when 'true' -> let <_10> = case _rec96 of <F2T = {_32,_33}> when 'true' -> F2T
<'_'> when 'true' -> {'_','_'}
<_34> when 'true' -> call 'erlang':'error' ('badarg') end in case _10 of <{DTF2,RTF2}> when 'true' -> case (case <RTF1,DTF2> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when call 'erlang':'=:=' (DTF1,'_') -> Fn1
<'true'> when call 'erlang':'=:=' (DTF2,'_') -> Fn2
<'true'> when 'true' -> (case Fn1 of (<({'Set',_rec97,_35}-|['compiler_generated'] )> when 'true' -> (case Fn2 of (<({'Set',_rec98,_37}-|['compiler_generated'] )> when 'true' -> case apply 'comp'/2 (_rec97,_rec98) of <SL> when call 'erlang':'is_list' (SL) -> let <_16> = call 'lists':'sort' (SL) in {'Set',_16,{DTF1,RTF2}}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end-|['compiler_generated'] )
(<_38> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_36> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_31> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_26> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_20,_19> when 'true' -> (primop 'match_fail' ({'function_clause',_20,_19})-|[{'function_name',{'composite',2}}] )-|['compiler_generated'] ) end
'inverse'/1 = fun (_0) -> case _0 of <Fn = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case Fn of (<({'Set',_10,_rec99}-|['compiler_generated'] )> when 'true' -> case _rec99 of <{DT,RT}> when 'true' -> (case Fn of (<({'Set',_rec100,_12}-|['compiler_generated'] )> when 'true' -> case apply 'inverse1'/1 (_rec100) of <SL> when call 'erlang':'is_list' (SL) -> {'Set',SL,{RT,DT}}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> Fn
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'inverse',1}}] )-|['compiler_generated'] ) end
'restriction'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <I,R = {'Set',_58,_59},S = {'Set',_60,_61}> when call 'erlang':'is_integer' (I) -> (case R of (<({'Set',_62,_rec101}-|['compiler_generated'] )> when 'true' -> (case S of (<({'Set',_64,_rec102}-|['compiler_generated'] )> when 'true' -> case apply 'check_for_sort'/2 (_rec101,I) of <'empty'> when 'true' -> R
<'error'> when 'true' -> call 'erlang':'error' ('badarg')
<Sort> when 'true' -> (case R of (<({'Set',_rec103,_66}-|['compiler_generated'] )> when 'true' -> let <_16> = call 'erlang':'element' (I,_rec101) in let <_17> = case <_16,_rec102> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end in (case S of (<({'Set',_rec104,_68}-|['compiler_generated'] )> when 'true' -> case <_17,_rec104> of <('true'-|['compiler_generated'] ),_X_SL> when call 'erlang':'=:=' (_rec103,[]) -> R
<'true',[]> when 'true' -> {'Set',[],_rec101}
<('true'-|['compiler_generated'] ),([E|Es]-|['compiler_generated'] )> when call 'erlang':'=:=' (Sort,'false') -> let <_18> = apply 'restrict_n'/5 (I,_rec103,E,Es,[]) in let <_19> = call 'lists':'reverse' (_18) in {'Set',_19,_rec101}
<('true'-|['compiler_generated'] ),([E|Es]-|['compiler_generated'] )> when 'true' -> let <_20> = call 'lists':'keysort' (I,_rec103) in let <_21> = apply 'restrict_n'/5 (I,_20,E,Es,[]) in let <_22> = call 'lists':'sort' (_21) in {'Set',_22,_rec101}
<('false'-|['compiler_generated'] ),_X_SL> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<(_90-|['compiler_generated'] ),(_91-|['compiler_generated'] )> when 'true' -> let <_23> = {(_90-|['compiler_generated'] ),(_91-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_69> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_67> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_65> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_63> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<SetFun,S1 = {'Set',_70,_71},S2 = {'Set',_72,_73}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_74,_rec105}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_76,_rec106}-|['compiler_generated'] )> when 'true' -> (case S1 of (<({'Set',_rec107,_78}-|['compiler_generated'] )> when 'true' -> case (case SetFun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),Fun}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Fun-|['compiler_generated'] )
(<_93> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when call 'erlang':'=:=' (_rec106,'_') -> S2
<'false'> when 'true' -> let <_34> = case _rec105 of (<([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Type-|['compiler_generated'] )
(<Type> when ('true'-|['compiler_generated'] ) -> Type-|['compiler_generated'] ) end in case (apply 'subst'/5 (_rec107,SetFun,_34,('_'-|['compiler_generated'] ),([]-|['compiler_generated'] ))-|['compiler_generated'] ) of <{NSL,NewType}> when 'true' -> case (case <NewType,_rec106> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_103,_104> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (_103,_104)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S2 of (<({'Set',_rec108,_80}-|['compiler_generated'] )> when 'true' -> let <_35> = apply 'converse'/2 (NSL,[]) in let <_38> = apply 'restrict'/2 (_rec108,_35) in let <NL> = call 'lists':'sort' (_38) in {'Set',NL,_rec105}-|['compiler_generated'] )
(<_81> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_40> when 'true' -> primop 'match_fail' ({'case_clause',_40})-|['compiler_generated'] ) end
<Bad> when 'true' -> call 'erlang':'error' (Bad) end
<_82> when call 'erlang':'=:=' (_rec105,'_') -> S1
<_X_XFun> when call 'erlang':'is_list' (_rec105) -> call 'erlang':'error' ('badarg')
<XFun> when 'true' -> let <FunT> = apply XFun (_rec105) in try apply 'check_fun'/3 (_rec105,XFun,FunT) of <_43> -> case (case <FunT,_rec106> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_107,_108> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (_107,_108)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> let <R1> = apply 'inverse_substitution'/3 (_rec107,XFun,_43) in (case S2 of (<({'Set',_rec109,_83}-|['compiler_generated'] )> when 'true' -> let <_47> = apply 'restrict'/2 (_rec109,R1) in let <_48> = apply 'sort'/2 (_43,_47) in {'Set',_48,_rec105}-|['compiler_generated'] )
(<_84> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_49> when 'true' -> primop 'match_fail' ({'case_clause',_49})-|['compiler_generated'] ) end catch <_53,_52,_51> -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_79> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_77> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_75> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_57,_56,_55> when 'true' -> (primop 'match_fail' ({'function_clause',_57,_56,_55})-|[{'function_name',{'restriction',3}}] )-|['compiler_generated'] ) end
'drestriction'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <I,R = {'Set',_58,_59},S = {'Set',_60,_61}> when call 'erlang':'is_integer' (I) -> (case R of (<({'Set',_62,_rec110}-|['compiler_generated'] )> when 'true' -> (case S of (<({'Set',_64,_rec111}-|['compiler_generated'] )> when 'true' -> case apply 'check_for_sort'/2 (_rec110,I) of <'empty'> when 'true' -> R
<'error'> when 'true' -> call 'erlang':'error' ('badarg')
<Sort> when 'true' -> (case R of (<({'Set',_rec112,_66}-|['compiler_generated'] )> when 'true' -> let <_16> = call 'erlang':'element' (I,_rec110) in let <_17> = case <_16,_rec111> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end in (case S of (<({'Set',_rec113,_68}-|['compiler_generated'] )> when 'true' -> case <_17,_rec113> of <'true',[]> when 'true' -> R
<('true'-|['compiler_generated'] ),_X_SL> when call 'erlang':'=:=' (_rec112,[]) -> R
<('true'-|['compiler_generated'] ),([E|Es]-|['compiler_generated'] )> when call 'erlang':'=:=' (Sort,'false') -> let <_18> = apply 'diff_restrict_n'/5 (I,_rec112,E,Es,[]) in {'Set',_18,_rec110}
<('true'-|['compiler_generated'] ),([E|Es]-|['compiler_generated'] )> when 'true' -> let <_19> = call 'lists':'keysort' (I,_rec112) in let <_20> = apply 'diff_restrict_n'/5 (I,_19,E,Es,[]) in {'Set',_20,_rec110}
<('false'-|['compiler_generated'] ),_X_SL> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<(_90-|['compiler_generated'] ),(_91-|['compiler_generated'] )> when 'true' -> let <_21> = {(_90-|['compiler_generated'] ),(_91-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_21})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_69> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_67> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_65> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_63> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<SetFun,S1 = {'Set',_70,_71},S2 = {'Set',_72,_73}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_74,_rec114}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_76,_rec115}-|['compiler_generated'] )> when 'true' -> (case S1 of (<({'Set',_rec116,_78}-|['compiler_generated'] )> when 'true' -> case (case SetFun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),Fun}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Fun-|['compiler_generated'] )
(<_93> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when call 'erlang':'=:=' (_rec115,'_') -> S1
<'false'> when 'true' -> let <_32> = case _rec114 of (<([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Type-|['compiler_generated'] )
(<Type> when ('true'-|['compiler_generated'] ) -> Type-|['compiler_generated'] ) end in case (apply 'subst'/5 (_rec116,SetFun,_32,('_'-|['compiler_generated'] ),([]-|['compiler_generated'] ))-|['compiler_generated'] ) of <{NSL,NewType}> when 'true' -> case (case <NewType,_rec115> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_103,_104> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (_103,_104)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> (case S2 of (<({'Set',_rec117,_80}-|['compiler_generated'] )> when 'true' -> let <_36> = apply 'converse'/2 (NSL,[]) in let <_37> = apply 'diff_restrict'/2 (_rec117,_36) in let <NL> = call 'lists':'sort' (_37) in {'Set',NL,_rec114}-|['compiler_generated'] )
(<_81> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_39> when 'true' -> primop 'match_fail' ({'case_clause',_39})-|['compiler_generated'] ) end
<Bad> when 'true' -> call 'erlang':'error' (Bad) end
<_82> when call 'erlang':'=:=' (_rec114,'_') -> S1
<_X_XFun> when call 'erlang':'is_list' (_rec114) -> call 'erlang':'error' ('badarg')
<XFun> when 'true' -> let <FunT> = apply XFun (_rec114) in try apply 'check_fun'/3 (_rec114,XFun,FunT) of <_42> -> case (case <FunT,_rec115> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_107,_108> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (_107,_108)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> let <R1> = apply 'inverse_substitution'/3 (_rec116,XFun,_42) in (case S2 of (<({'Set',_rec118,_83}-|['compiler_generated'] )> when 'true' -> let <_47> = apply 'diff_restrict'/2 (_rec118,R1) in let <_48> = apply 'sort'/2 (_42,_47) in {'Set',_48,_rec114}-|['compiler_generated'] )
(<_84> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_49> when 'true' -> primop 'match_fail' ({'case_clause',_49})-|['compiler_generated'] ) end catch <_53,_52,_51> -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_79> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_77> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_75> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_57,_56,_55> when 'true' -> (primop 'match_fail' ({'function_clause',_57,_56,_55})-|[{'function_name',{'drestriction',3}}] )-|['compiler_generated'] ) end
'projection'/2 = fun (_0,_1) -> case <_0,_1> of <I,Set = {'Set',_18,_19}> when call 'erlang':'is_integer' (I) -> (case Set of (<({'Set',_20,_rec119}-|['compiler_generated'] )> when 'true' -> case apply 'check_for_sort'/2 (_rec119,I) of <'empty'> when 'true' -> Set
<'error'> when 'true' -> call 'erlang':'error' ('badarg')
<_22> when call 'erlang':'=:=' (I,1) -> (case Set of (<({'Set',_rec120,_23}-|['compiler_generated'] )> when 'true' -> let <_9> = apply 'projection1'/1 (_rec120) in let <_6> = call 'erlang':'element' (I,_rec119) in {'Set',_9,_6}-|['compiler_generated'] )
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_25> when 'true' -> (case Set of (<({'Set',_rec121,_26}-|['compiler_generated'] )> when 'true' -> let <_13> = apply 'projection_n'/3 (_rec121,I,[]) in let <_10> = call 'erlang':'element' (I,_rec119) in {'Set',_13,_10}-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Fun,Set> when 'true' -> let <_15> = apply 'substitution'/2 (Fun,Set) in apply 'range'/1 (_15) end
'substitution'/2 = fun (_0,_1) -> case <_0,_1> of <I,Set = {'Set',_30,_31}> when call 'erlang':'is_integer' (I) -> (case Set of (<({'Set',_32,_rec122}-|['compiler_generated'] )> when 'true' -> case apply 'check_for_sort'/2 (_rec122,I) of <'empty'> when 'true' -> Set
<'error'> when 'true' -> call 'erlang':'error' ('badarg')
<_X_Sort> when 'true' -> let <NType> = call 'erlang':'element' (I,_rec122) in (case Set of (<({'Set',_rec123,_34}-|['compiler_generated'] )> when 'true' -> let <NSL> = apply 'substitute_element'/3 (_rec123,I,[]) in {'Set',NSL,{_rec122,NType}}-|['compiler_generated'] )
(<_35> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<SetFun,Set = {'Set',_36,_37}> when ('true'-|['compiler_generated'] ) -> (case Set of (<({'Set',_38,_rec124}-|['compiler_generated'] )> when 'true' -> (case Set of (<({'Set',_rec125,_40}-|['compiler_generated'] )> when 'true' -> case (case SetFun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),Fun}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Fun-|['compiler_generated'] )
(<_2> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when call 'erlang':'=/=' (_rec125,[]) -> let <_17> = case _rec124 of (<([_48|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _48-|['compiler_generated'] )
(<_49> when ('true'-|['compiler_generated'] ) -> _49-|['compiler_generated'] ) end in case (apply 'subst'/5 (_rec125,SetFun,_17,('_'-|['compiler_generated'] ),([]-|['compiler_generated'] ))-|['compiler_generated'] ) of <{SL,NewType}> when 'true' -> let <_18> = call 'lists':'reverse' (SL) in {'Set',_18,{_rec124,NewType}}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end
<'false'> when 'true' -> apply 'empty_set'/0 ()
<_42> when call 'erlang':'=:=' (_rec124,'_') -> apply 'empty_set'/0 ()
<_X_XFun> when call 'erlang':'is_list' (_rec124) -> call 'erlang':'error' ('badarg')
<XFun> when 'true' -> let <FunT> = apply XFun (_rec124) in try apply 'check_fun'/3 (_rec124,XFun,FunT) of <_21> -> let <SL> = apply 'substitute'/3 (_rec125,XFun,[]) in {'Set',SL,{_rec124,FunT}} catch <_26,_25,_24> -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_39> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_29,_28> when 'true' -> (primop 'match_fail' ({'function_clause',_29,_28})-|[{'function_name',{'substitution',2}}] )-|['compiler_generated'] ) end
'partition'/1 = fun (_0) -> (case apply 'canonical_relation'/1 (_0) of (<(R = ({('Set'-|['compiler_generated'] ),_8,_9}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case R of (<({('Set'-|['compiler_generated'] ),_10,_rec63}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> let <F1> = case _rec63 of (<({DT,RT}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case R of (<({('Set'-|['compiler_generated'] ),_rec64,_12}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_5> = apply 'rel2family'/1 (_rec64) in ({('Set'-|['compiler_generated'] ),_5,({DT,([RT|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_13> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> R-|['compiler_generated'] )
(<_X_Else> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('badarg'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in (case apply 'converse'/1 (F1) of (<(_20 = ({('Set'-|['compiler_generated'] ),_21,_22}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _20 of (<({('Set'-|['compiler_generated'] ),_23,_24}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> let <F2> = case _24 of (<({DT,RT}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _20 of (<({('Set'-|['compiler_generated'] ),_rec64,_12}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_5> = apply 'rel2family'/1 (_rec64) in ({('Set'-|['compiler_generated'] ),_5,({DT,([RT|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_13> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _20-|['compiler_generated'] )
(<_X_Else> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('badarg'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'range'/1 (F2)-|['compiler_generated'] )
(<_11> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_7> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_7}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_11> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_7> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_7}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'partition'/2 = fun (_0,_1) -> case <_0,_1> of <I,Set = {'Set',_17,_18}> when call 'erlang':'is_integer' (I) -> (case Set of (<({'Set',_19,_rec126}-|['compiler_generated'] )> when 'true' -> case apply 'check_for_sort'/2 (_rec126,I) of <'empty'> when 'true' -> Set
<'error'> when 'true' -> call 'erlang':'error' ('badarg')
<'false'> when 'true' -> (case Set of (<({'Set',_rec127,_21}-|['compiler_generated'] )> when 'true' -> let <_8> = apply 'partition_n'/2 (I,_rec127) in {'Set',_8,[_rec126|[]]}-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'true'> when 'true' -> (case Set of (<({'Set',_rec128,_23}-|['compiler_generated'] )> when 'true' -> let <_11> = call 'lists':'keysort' (I,_rec128) in let <_12> = apply 'partition_n'/2 (I,_11) in {'Set',_12,[_rec126|[]]}-|['compiler_generated'] )
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_20> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Fun,Set> when 'true' -> let <_14> = apply 'partition_family'/2 (Fun,Set) in apply 'range'/1 (_14) end
'partition'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <I,R = {'Set',_58,_59},S = {'Set',_60,_61}> when call 'erlang':'is_integer' (I) -> (case R of (<({'Set',_62,_rec129}-|['compiler_generated'] )> when 'true' -> (case S of (<({'Set',_64,_rec130}-|['compiler_generated'] )> when 'true' -> case apply 'check_for_sort'/2 (_rec129,I) of <'empty'> when 'true' -> {R,R}
<'error'> when 'true' -> call 'erlang':'error' ('badarg')
<Sort> when 'true' -> (case R of (<({'Set',_rec131,_66}-|['compiler_generated'] )> when 'true' -> let <_16> = call 'erlang':'element' (I,_rec129) in let <_17> = case <_16,_rec130> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] ) end in (case S of (<({'Set',_rec132,_68}-|['compiler_generated'] )> when 'true' -> case <_17,_rec132> of <('true'-|['compiler_generated'] ),_X_SL> when call 'erlang':'=:=' (_rec131,[]) -> {R,R}
<'true',[]> when 'true' -> {{'Set',[],_rec129},R}
<('true'-|['compiler_generated'] ),([E|Es]-|['compiler_generated'] )> when call 'erlang':'=:=' (Sort,'false') -> case apply 'partition3_n'/6 (I,_rec131,E,Es,[],[]) of <[L1|L2]> when 'true' -> {{'Set',L1,_rec129},{'Set',L2,_rec129}}
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
<('true'-|['compiler_generated'] ),([E|Es]-|['compiler_generated'] )> when 'true' -> let <_19> = call 'lists':'keysort' (I,_rec131) in case apply 'partition3_n'/6 (I,_19,E,Es,[],[]) of <[L1|L2]> when 'true' -> {{'Set',L1,_rec129},{'Set',L2,_rec129}}
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
<('false'-|['compiler_generated'] ),_X_SL> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<(_90-|['compiler_generated'] ),(_91-|['compiler_generated'] )> when 'true' -> let <_21> = {(_90-|['compiler_generated'] ),(_91-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_21})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_69> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_67> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_65> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_63> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<SetFun,S1 = {'Set',_70,_71},S2 = {'Set',_72,_73}> when ('true'-|['compiler_generated'] ) -> (case S1 of (<({'Set',_74,_rec133}-|['compiler_generated'] )> when 'true' -> (case S2 of (<({'Set',_76,_rec134}-|['compiler_generated'] )> when 'true' -> (case S1 of (<({'Set',_rec135,_78}-|['compiler_generated'] )> when 'true' -> case (case SetFun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),Fun}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Fun-|['compiler_generated'] )
(<_93> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when call 'erlang':'=:=' (_rec134,'_') -> {S2,S1}
<'false'> when 'true' -> let <_32> = case _rec133 of (<([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Type-|['compiler_generated'] )
(<Type> when ('true'-|['compiler_generated'] ) -> Type-|['compiler_generated'] ) end in case (apply 'subst'/5 (_rec135,SetFun,_32,('_'-|['compiler_generated'] ),([]-|['compiler_generated'] ))-|['compiler_generated'] ) of <{NSL,NewType}> when 'true' -> case (case <NewType,_rec134> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_103,_104> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (_103,_104)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> let <R1> = apply 'converse'/2 (NSL,[]) in (case S2 of (<({'Set',_rec136,_80}-|['compiler_generated'] )> when 'true' -> case apply 'partition3'/2 (_rec136,R1) of <[L1|L2]> when 'true' -> let <_38> = call 'lists':'sort' (L1) in let <_37> = call 'lists':'sort' (L2) in {{'Set',_38,_rec133},{'Set',_37,_rec133}}
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_81> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_39> when 'true' -> primop 'match_fail' ({'case_clause',_39})-|['compiler_generated'] ) end
<Bad> when 'true' -> call 'erlang':'error' (Bad) end
<_82> when call 'erlang':'=:=' (_rec133,'_') -> {S1,S1}
<_X_XFun> when call 'erlang':'is_list' (_rec133) -> call 'erlang':'error' ('badarg')
<XFun> when 'true' -> let <FunT> = apply XFun (_rec133) in try apply 'check_fun'/3 (_rec133,XFun,FunT) of <_42> -> case (case <FunT,_rec134> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_107,_108> when ('true'-|['compiler_generated'] ) -> (apply 'match_types1'/2 (_107,_108)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when 'true' -> let <R1> = apply 'inverse_substitution'/3 (_rec135,XFun,_42) in (case S2 of (<({'Set',_rec137,_83}-|['compiler_generated'] )> when 'true' -> case apply 'partition3'/2 (_rec137,R1) of <[L1|L2]> when 'true' -> let <_48> = call 'lists':'sort' (L1) in let <_47> = call 'lists':'sort' (L2) in {{'Set',_48,_rec133},{'Set',_47,_rec133}}
(<_46> when 'true' -> primop 'match_fail' ({'badmatch',_46})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_84> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> call 'erlang':'error' ('type_mismatch')
(<_49> when 'true' -> primop 'match_fail' ({'case_clause',_49})-|['compiler_generated'] ) end catch <_53,_52,_51> -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_79> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_77> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_75> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_57,_56,_55> when 'true' -> (primop 'match_fail' ({'function_clause',_57,_56,_55})-|[{'function_name',{'partition',3}}] )-|['compiler_generated'] ) end
'multiple_relative_product'/2 = fun (_0,_1) -> case <_0,_1> of <T,R = {'Set',_15,_16}> when call 'erlang':'is_tuple' (T) -> let <_3> = call 'erlang':'tuple_size' (T) in (case R of (<({('Set'-|['compiler_generated'] ),_21,_rec142}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> case (case _rec142 of (<Rel> when (try (let <_5> = call ('erlang'-|['compiler_generated'] ):('is_tuple'-|['compiler_generated'] ) (_rec142) in (let <_7> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_rec142) in (let <_8> = call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_3,_7) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_5,_8)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'true'> when (try (let <_6> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (R,('Set'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_4-|['compiler_generated'] )> when 'true' -> (_4-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_7> = call 'erlang':'=:=' ((_6-|['compiler_generated'] ),'true') in let <_8> = call 'erlang':'element' (3,R) in let <_9> = call 'erlang':'=:=' (_8,'_') in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_7,_9)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> apply 'empty_set'/0 ()
<'true'> when 'true' -> let <_10> = call 'erlang':'tuple_to_list' (T) in let <MProd> = apply 'mul_relprod'/3 (_10,1,R) in apply 'relative_product'/1 (MProd)
<'false'> when 'true' -> call 'erlang':'error' ('badarg')
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_22> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'multiple_relative_product',2}}] )-|['compiler_generated'] ) end
'join'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <R1 = {'Set',_50,_51},I1,R2 = {'Set',_52,_53},I2> when let <_4> = call 'erlang':'is_integer' (I1) in let <_5> = call 'erlang':'is_integer' (I2) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_4,_5)-|['compiler_generated'] ) -> (case R1 of (<({('Set'-|['compiler_generated'] ),_21,_rec142}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> let <_9> = case _rec142 of (<Rel> when (try (let <_10> = call ('erlang'-|['compiler_generated'] ):('is_tuple'-|['compiler_generated'] ) (_rec142) in (let <_12> = call ('erlang'-|['compiler_generated'] ):('>='-|['compiler_generated'] ) (I1,(1-|['compiler_generated'] )) in (let <_13> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_rec142) in (let <_14> = call ('erlang'-|['compiler_generated'] ):('=<'-|['compiler_generated'] ) (I1,_13) in (let <_15> = call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_12,_14) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_10,_15)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end in (case R2 of (<({('Set'-|['compiler_generated'] ),_77,_78}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> let <_8> = case _78 of (<Rel> when (try (let <_10> = call ('erlang'-|['compiler_generated'] ):('is_tuple'-|['compiler_generated'] ) (_78) in (let <_12> = call ('erlang'-|['compiler_generated'] ):('>='-|['compiler_generated'] ) (I2,(1-|['compiler_generated'] )) in (let <_13> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_78) in (let <_14> = call ('erlang'-|['compiler_generated'] ):('=<'-|['compiler_generated'] ) (I2,_13) in (let <_15> = call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_12,_14) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_10,_15)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end in case call 'erlang':'and' (_9,_8) of <'false'> when 'true' -> call 'erlang':'error' ('badarg')
<'true'> when (try (let <_12> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (R1,('Set'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_10-|['compiler_generated'] )> when 'true' -> (_10-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_13> = call 'erlang':'=:=' ((_12-|['compiler_generated'] ),'true') in let <_14> = call 'erlang':'element' (3,R1) in let <_15> = call 'erlang':'=:=' (_14,'_') in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_13,_15)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> R1
<'true'> when (try (let <_18> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (R2,('Set'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_16-|['compiler_generated'] )> when 'true' -> (_16-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_19> = call 'erlang':'=:=' ((_18-|['compiler_generated'] ),'true') in let <_20> = call 'erlang':'element' (3,R2) in let <_79> = call 'erlang':'=:=' (_20,'_') in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_19,_79)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> R2
<'true'> when 'true' -> (case apply 'raise_element'/2 (R1,I1) of (<({'Set',_rec138,_54}-|['compiler_generated'] )> when 'true' -> (case apply 'raise_element'/2 (R2,I2) of (<({'Set',_rec139,_56}-|['compiler_generated'] )> when 'true' -> let <T> = apply 'relprod1'/2 (_rec138,_rec139) in let <_30> = call 'erlang':'=:=' (I1,1) in let <_29> = call 'erlang':'=:=' (I2,1) in let <_37> = case call 'erlang':'and' (_30,_29) of <'true'> when 'true' -> (fun (_31) -> case _31 of <{X,Y}> when 'true' -> apply 'join_element'/2 (X,Y)
(<_32> when 'true' -> (primop 'match_fail' ({'function_clause',_32})-|[{'function_name',{'-join/4-fun-0-',1}}] )-|['compiler_generated'] ) end-|[{'id',{0,0,'-join/4-fun-0-'}}] )
<'false'> when 'true' -> (fun (_34) -> case _34 of <{X,Y}> when 'true' -> let <_33> = apply 'join_element'/3 (X,Y,I2) in call 'erlang':'list_to_tuple' (_33)
(<_35> when 'true' -> (primop 'match_fail' ({'function_clause',_35})-|[{'function_name',{'-join/4-fun-1-',1}}] )-|['compiler_generated'] ) end-|[{'id',{0,0,'-join/4-fun-1-'}}] ) end in let <_44> = apply 'replace'/3 (T,_37,[]) in (case R1 of (<({'Set',_58,_rec140}-|['compiler_generated'] )> when 'true' -> (case R2 of (<({'Set',_60,_rec141}-|['compiler_generated'] )> when 'true' -> let <_43> = apply _37 ({_rec140,_rec141}) in {'Set',_44,_43}-|['compiler_generated'] )
(<_61> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_59> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_57> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_55> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_45> when 'true' -> primop 'match_fail' ({'case_clause',_45})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_22> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_22> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_49,_48,_47,_46> when 'true' -> (primop 'match_fail' ({'function_clause',_49,_48,_47,_46})-|[{'function_name',{'join',4}}] )-|['compiler_generated'] ) end
'test_rel'/3 = fun (_0,_1,_2) -> (case _0 of (<({'Set',_21,_rec142}-|['compiler_generated'] )> when 'true' -> case _rec142 of <Rel> when try let <_5> = call 'erlang':'is_tuple' (_rec142) in let <_6> = call 'erlang':'=:=' (_2,'eq') in let <_7> = call 'erlang':'tuple_size' (_rec142) in let <_8> = call 'erlang':'=:=' (_1,_7) in let <_9> = call 'erlang':'and' (_6,_8) in call 'erlang':'and' (_5,_9) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<Rel> when try let <_10> = call 'erlang':'is_tuple' (_rec142) in let <_11> = call 'erlang':'=:=' (_2,'lte') in let <_12> = call 'erlang':'>=' (_1,1) in let <_13> = call 'erlang':'tuple_size' (_rec142) in let <_14> = call 'erlang':'=<' (_1,_13) in let <_15> = call 'erlang':'and' (_12,_14) in let <_16> = call 'erlang':'and' (_11,_15) in call 'erlang':'and' (_10,_16) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<'_'> when 'true' -> 'true'
<_23> when 'true' -> 'false' end-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'fam2rel'/1 = fun (_0) -> (case _0 of (<(_16 = ({('Set'-|['compiler_generated'] ),_8,_9}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _16 of (<({('Set'-|['compiler_generated'] ),_10,_rec143}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _rec143 of (<({DT,([RT|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _16 of (<({('Set'-|['compiler_generated'] ),_rec144,_12}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_5> = apply 'family2rel'/2 (_rec144,([]-|['compiler_generated'] )) in ({('Set'-|['compiler_generated'] ),_5,({DT,RT}-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_13> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _16-|['compiler_generated'] )
(<_14> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('badarg'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_11> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_7> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_7}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'family_to_relation'/1 = fun (_0) -> case _0 of <F = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_10,_rec143}-|['compiler_generated'] )> when 'true' -> case _rec143 of <{DT,[RT|[]]}> when 'true' -> (case F of (<({'Set',_rec144,_12}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'family2rel'/2 (_rec144,[]) in {'Set',_5,{DT,RT}}-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> F
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'family_to_relation',1}}] )-|['compiler_generated'] ) end
'family_specification'/2 = fun (_0,_1) -> case <_0,_1> of <Fun,F = {'Set',_15,_16}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_17,_rec145}-|['compiler_generated'] )> when 'true' -> case _rec145 of <FType = {_X_DT,[Type|[]]}> when 'true' -> let <_9> = case (case Fun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),_25}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _25-|['compiler_generated'] )
(<_2> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when 'true' -> (case F of (<({'Set',_rec146,_19}-|['compiler_generated'] )> when 'true' -> apply 'fam_spec'/4 (_rec146,Fun,Type,[])-|['compiler_generated'] )
(<_20> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<XFun> when 'true' -> (case F of (<({'Set',_rec147,_21}-|['compiler_generated'] )> when 'true' -> apply 'fam_specification'/3 (_rec147,XFun,[])-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end in case _9 of <SL> when call 'erlang':'is_list' (_9) -> {'Set',SL,FType}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end
<'_'> when 'true' -> F
<_23> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_18> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'family_specification',2}}] )-|['compiler_generated'] ) end
'union_of_family'/1 = fun (_0) -> case _0 of <F = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_10,_rec148}-|['compiler_generated'] )> when 'true' -> case _rec148 of <{_X_DT,[Type|[]]}> when 'true' -> (case F of (<({'Set',_rec149,_12}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'un_of_fam'/2 (_rec149,[]) in {'Set',_5,Type}-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> F
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'union_of_family',1}}] )-|['compiler_generated'] ) end
'intersection_of_family'/1 = fun (_0) -> case _0 of <F = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_10,_rec150}-|['compiler_generated'] )> when 'true' -> case _rec150 of <{_X_DT,[Type|[]]}> when 'true' -> (case F of (<({'Set',_rec151,_12}-|['compiler_generated'] )> when 'true' -> case apply 'int_of_fam'/1 (_rec151) of <FU> when call 'erlang':'is_list' (FU) -> {'Set',FU,Type}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'intersection_of_family',1}}] )-|['compiler_generated'] ) end
'family_union'/1 = fun (_0) -> case _0 of <F = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_10,_rec152}-|['compiler_generated'] )> when 'true' -> case _rec152 of <{DT,[_@r0 = [Type|[]]|[]]}> when 'true' -> (case F of (<({'Set',_rec153,_12}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'fam_un'/2 (_rec153,[]) in {'Set',_5,{DT,_@r0}}-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> F
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'family_union',1}}] )-|['compiler_generated'] ) end
'family_intersection'/1 = fun (_0) -> case _0 of <F = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_10,_rec154}-|['compiler_generated'] )> when 'true' -> case _rec154 of <{DT,[_@r0 = [Type|[]]|[]]}> when 'true' -> (case F of (<({'Set',_rec155,_12}-|['compiler_generated'] )> when 'true' -> case apply 'fam_int'/2 (_rec155,[]) of <FU> when call 'erlang':'is_list' (FU) -> {'Set',FU,{DT,_@r0}}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> F
<_14> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'family_intersection',1}}] )-|['compiler_generated'] ) end
'family_domain'/1 = fun (_0) -> case _0 of <F = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_10,_rec156}-|['compiler_generated'] )> when 'true' -> case _rec156 of <{FDT,[{DT,_12}|[]]}> when 'true' -> (case F of (<({'Set',_rec157,_13}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'fam_dom'/2 (_rec157,[]) in {'Set',_5,{FDT,[DT|[]]}}-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> F
<{_15,['_']}> when 'true' -> F
<_16> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'family_domain',1}}] )-|['compiler_generated'] ) end
'family_range'/1 = fun (_0) -> case _0 of <F = {'Set',_8,_9}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_10,_rec158}-|['compiler_generated'] )> when 'true' -> case _rec158 of <{DT,[{_12,RT}|[]]}> when 'true' -> (case F of (<({'Set',_rec159,_13}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'fam_ran'/2 (_rec159,[]) in {'Set',_5,{DT,[RT|[]]}}-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'_'> when 'true' -> F
<{_15,['_']}> when 'true' -> F
<_16> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'family_range',1}}] )-|['compiler_generated'] ) end
'family_field'/1 = fun (_0) -> let <_2> = apply 'family_domain'/1 (_0) in let <_1> = apply 'family_range'/1 (_0) in apply 'family_union'/2 (_2,_1)
'family_union'/2 = fun (_0,_1) -> let <_2> = 'fam_union'/3 in (case <_0,_1,_2> of (<(_34 = ({('Set'-|['compiler_generated'] ),_16,_17}-|['compiler_generated'] )-|['compiler_generated'] ),(_35 = ({('Set'-|['compiler_generated'] ),_18,_19}-|['compiler_generated'] )-|['compiler_generated'] ),FF> when ('true'-|['compiler_generated'] ) -> (case _34 of (<({('Set'-|['compiler_generated'] ),_20,_rec160}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _35 of (<({('Set'-|['compiler_generated'] ),_22,_rec161}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case (case <_rec160,_rec161> of (<T,_38> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_38,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of (<([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('type_mismatch'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _34-|['compiler_generated'] )
(<(Type = ({_24,([_25|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _34 of (<({('Set'-|['compiler_generated'] ),_rec162,_26}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _35 of (<({('Set'-|['compiler_generated'] ),_rec163,_28}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_11> = apply FF (_rec162,_rec163,([]-|['compiler_generated'] )) in ({('Set'-|['compiler_generated'] ),_11,Type}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_29> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_27> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_30> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('badarg'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_21> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_15,_14,_13> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_15,_14,_13}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'family_intersection'/2 = fun (_0,_1) -> let <_2> = 'fam_intersect'/3 in (case <_0,_1,_2> of (<(_34 = ({('Set'-|['compiler_generated'] ),_16,_17}-|['compiler_generated'] )-|['compiler_generated'] ),(_35 = ({('Set'-|['compiler_generated'] ),_18,_19}-|['compiler_generated'] )-|['compiler_generated'] ),FF> when ('true'-|['compiler_generated'] ) -> (case _34 of (<({('Set'-|['compiler_generated'] ),_20,_rec160}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _35 of (<({('Set'-|['compiler_generated'] ),_22,_rec161}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case (case <_rec160,_rec161> of (<T,_38> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_38,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of (<([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('type_mismatch'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _34-|['compiler_generated'] )
(<(Type = ({_24,([_25|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _34 of (<({('Set'-|['compiler_generated'] ),_rec162,_26}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _35 of (<({('Set'-|['compiler_generated'] ),_rec163,_28}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_11> = apply FF (_rec162,_rec163,([]-|['compiler_generated'] )) in ({('Set'-|['compiler_generated'] ),_11,Type}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_29> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_27> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_30> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('badarg'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_21> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_15,_14,_13> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_15,_14,_13}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'family_difference'/2 = fun (_0,_1) -> let <_2> = 'fam_difference'/3 in (case <_0,_1,_2> of (<(_34 = ({('Set'-|['compiler_generated'] ),_16,_17}-|['compiler_generated'] )-|['compiler_generated'] ),(_35 = ({('Set'-|['compiler_generated'] ),_18,_19}-|['compiler_generated'] )-|['compiler_generated'] ),FF> when ('true'-|['compiler_generated'] ) -> (case _34 of (<({('Set'-|['compiler_generated'] ),_20,_rec160}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _35 of (<({('Set'-|['compiler_generated'] ),_22,_rec161}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case (case <_rec160,_rec161> of (<T,_38> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_38,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of (<([]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('type_mismatch'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )
(<('_'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _34-|['compiler_generated'] )
(<(Type = ({_24,([_25|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _34 of (<({('Set'-|['compiler_generated'] ),_rec162,_26}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (case _35 of (<({('Set'-|['compiler_generated'] ),_rec163,_28}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_11> = apply FF (_rec162,_rec163,([]-|['compiler_generated'] )) in ({('Set'-|['compiler_generated'] ),_11,Type}-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_29> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_27> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_30> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (('badarg'-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_23> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_21> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_15,_14,_13> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_15,_14,_13}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'fam_binop'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F1 = {'Set',_16,_17},F2 = {'Set',_18,_19},FF> when ('true'-|['compiler_generated'] ) -> (case F1 of (<({'Set',_20,_rec160}-|['compiler_generated'] )> when 'true' -> (case F2 of (<({'Set',_22,_rec161}-|['compiler_generated'] )> when 'true' -> case (case <_rec160,_rec161> of (<T,_33> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_33,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> call 'erlang':'error' ('type_mismatch')
<'_'> when 'true' -> F1
<Type = {_24,[_25|[]]}> when 'true' -> (case F1 of (<({'Set',_rec162,_26}-|['compiler_generated'] )> when 'true' -> (case F2 of (<({'Set',_rec163,_28}-|['compiler_generated'] )> when 'true' -> let <_11> = apply FF (_rec162,_rec163,[]) in {'Set',_11,Type}-|['compiler_generated'] )
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_30> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_15,_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13})-|[{'function_name',{'fam_binop',3}}] )-|['compiler_generated'] ) end
'partition_family'/2 = fun (_0,_1) -> case <_0,_1> of <I,Set = {'Set',_41,_42}> when call 'erlang':'is_integer' (I) -> (case Set of (<({'Set',_43,_rec164}-|['compiler_generated'] )> when 'true' -> case apply 'check_for_sort'/2 (_rec164,I) of <'empty'> when 'true' -> Set
<'error'> when 'true' -> call 'erlang':'error' ('badarg')
<'false'> when 'true' -> (case Set of (<({'Set',_rec165,_45}-|['compiler_generated'] )> when 'true' -> let <_9> = apply 'fam_partition_n'/2 (I,_rec165) in let <_6> = call 'erlang':'element' (I,_rec164) in {'Set',_9,{_6,[_rec164|[]]}}-|['compiler_generated'] )
(<_46> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'true'> when 'true' -> (case Set of (<({'Set',_rec166,_47}-|['compiler_generated'] )> when 'true' -> let <_13> = call 'lists':'keysort' (I,_rec166) in let <_14> = apply 'fam_partition_n'/2 (I,_13) in let <_10> = call 'erlang':'element' (I,_rec164) in {'Set',_14,{_10,[_rec164|[]]}}-|['compiler_generated'] )
(<_48> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_44> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<SetFun,Set = {'Set',_49,_50}> when ('true'-|['compiler_generated'] ) -> (case Set of (<({'Set',_51,_rec167}-|['compiler_generated'] )> when 'true' -> (case Set of (<({'Set',_rec168,_53}-|['compiler_generated'] )> when 'true' -> case (case SetFun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),Fun}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Fun-|['compiler_generated'] )
(<_2> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when call 'erlang':'=/=' (_rec168,[]) -> let <_22> = case _rec167 of (<([_63|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> _63-|['compiler_generated'] )
(<_64> when ('true'-|['compiler_generated'] ) -> _64-|['compiler_generated'] ) end in case (apply 'subst'/5 (_rec168,SetFun,_22,('_'-|['compiler_generated'] ),([]-|['compiler_generated'] ))-|['compiler_generated'] ) of <{NSL,NewType}> when 'true' -> let <_23> = apply 'converse'/2 (NSL,[]) in let <P> = apply 'fam_partition'/2 (_23,'true') in let <_25> = call 'lists':'reverse' (P) in {'Set',_25,{NewType,[_rec167|[]]}}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end
<'false'> when 'true' -> apply 'empty_set'/0 ()
<_55> when call 'erlang':'=:=' (_rec167,'_') -> apply 'empty_set'/0 ()
<_X_XFun> when call 'erlang':'is_list' (_rec167) -> call 'erlang':'error' ('badarg')
<XFun> when 'true' -> let <DType> = apply XFun (_rec167) in try apply 'check_fun'/3 (_rec167,XFun,DType) of <_28> -> (case Set of (<({'Set',_rec169,_56}-|['compiler_generated'] )> when 'true' -> let <Ts> = apply 'inverse_substitution'/3 (_rec169,XFun,_28) in let <P> = apply 'fam_partition'/2 (Ts,_28) in let <_33> = call 'lists':'reverse' (P) in {'Set',_33,{DType,[_rec167|[]]}}-|['compiler_generated'] )
(<_57> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) catch <_37,_36,_35> -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_54> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_52> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_40,_39> when 'true' -> (primop 'match_fail' ({'function_clause',_40,_39})-|[{'function_name',{'partition_family',2}}] )-|['compiler_generated'] ) end
'family_projection'/2 = fun (_0,_1) -> case <_0,_1> of <SetFun,F = {'Set',_17,_18}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_19,_rec170}-|['compiler_generated'] )> when 'true' -> case _rec170 of <{_21,[_22|[]]}> when (try (let <_6> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (F,('Set'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_4-|['compiler_generated'] )> when 'true' -> (_4-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_7> = call 'erlang':'=:=' ((_6-|['compiler_generated'] ),'true') in let <_8> = call 'erlang':'element' (2,F) in let <_9> = call 'erlang':'=:=' ([],_8) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_7,_9)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> apply 'empty_set'/0 ()
<{DT,[Type|[]]}> when 'true' -> case (case SetFun of (<({('external'-|['compiler_generated'] ),Function}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (Function)-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] )
(<({('external'-|['compiler_generated'] ),Fun}-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> Fun-|['compiler_generated'] )
(<_2> when ('true'-|['compiler_generated'] ) -> ('false'-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <'false'> when 'true' -> (case F of (<({'Set',_rec171,_23}-|['compiler_generated'] )> when 'true' -> case apply 'fam_proj'/5 (_rec171,SetFun,Type,'_',[]) of <{SL,NewType}> when 'true' -> {'Set',SL,{DT,NewType}}
<Bad> when 'true' -> call 'erlang':'error' (Bad) end-|['compiler_generated'] )
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_25> when 'true' -> call 'erlang':'error' ('badarg') end
<'_'> when 'true' -> F
<_26> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_20> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15})-|[{'function_name',{'family_projection',2}}] )-|['compiler_generated'] ) end
'family_to_digraph'/1 = fun (_0) -> case _0 of <F = {'Set',_6,_7}> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_8,_rec172}-|['compiler_generated'] )> when 'true' -> case _rec172 of <{_10,[_11|[]]}> when 'true' -> let <_3> = call 'digraph':'new' () in apply 'fam2digraph'/2 (F,_3)
<'_'> when 'true' -> call 'digraph':'new' ()
<_X_Else> when 'true' -> call 'erlang':'error' ('badarg') end-|['compiler_generated'] )
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_5> when 'true' -> (primop 'match_fail' ({'function_clause',_5})-|[{'function_name',{'family_to_digraph',1}}] )-|['compiler_generated'] ) end
'family_to_digraph'/2 = fun (_0,_1) -> case <_0,_1> of <F = {'Set',_15,_16},Type> when ('true'-|['compiler_generated'] ) -> (case F of (<({'Set',_17,_rec173}-|['compiler_generated'] )> when 'true' -> do case _rec173 of <{_19,[_20|[]]}> when 'true' -> 'ok'
<'_'> when 'true' -> 'ok'
<_X_Else> when 'true' -> call 'erlang':'error' ('badarg') end try call 'digraph':'new' (Type) of <_5> -> let <_6> = catch apply 'fam2digraph'/2 (F,_5) in case _6 of <{'error',Reason}> when 'true' -> case call 'digraph':'delete' (_5) of <'true'> when 'true' -> call 'erlang':'error' (Reason)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<_21> when 'true' -> _5 end catch <_12,_11,_10> -> case <_12,_11,_10> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_22> when 'true' -> call 'erlang':'error' ('badarg')
(<_24,_25,_26> when 'true' -> primop 'raise' (_26,_25)-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_18> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'family_to_digraph',2}}] )-|['compiler_generated'] ) end
'digraph_to_family'/1 = fun (_0) -> try apply 'digraph_family'/1 (_0) of <_1> -> {'Set',_1,{'atom',['atom']}} catch <_5,_4,_3> -> call 'erlang':'error' ('badarg')
'digraph_to_family'/2 = fun (_0,_1) -> let <_2> = apply 'is_type'/1 (_1) in case <_2,_1> of <('true'-|['compiler_generated'] ),([Type = ({_11,([_12|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when 'true' -> try apply 'digraph_family'/1 (_0) of <_3> -> {'Set',_3,Type} catch <_7,_6,_5> -> call 'erlang':'error' ('badarg')
<(_17-|['compiler_generated'] ),(_18-|['compiler_generated'] )> when 'true' -> call 'erlang':'error' ('badarg') end
'is_types'/2 = fun (_0,_1) -> case <_0,_1> of <0,_X_T> when 'true' -> 'true'
<I,T> when 'true' -> let <_2> = call 'erlang':'element' (I,T) in case apply 'is_type'/1 (_2) of <'true'> when 'true' -> let <_3> = call 'erlang':'-' (I,1) in apply 'is_types'/2 (_3,T)
<'false'> when 'true' -> 'false'
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end end
'is_element_type'/1 = fun (_0) -> case _0 of <'_'> when 'true' -> 'true'
<T> when 'true' -> apply 'is_type'/1 (T) end
'set_of_sets'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[S = {'Set',_17,_18}|Ss],L,T0> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_19,_rec174}-|['compiler_generated'] )> when 'true' -> let <_30> = [_rec174|([]-|['compiler_generated'] )] in case (case <_30,T0> of (<T,_32> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_32,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> {'error','type_mismatch'}
<Type> when 'true' -> (case S of (<({'Set',_rec175,_21}-|['compiler_generated'] )> when 'true' -> apply 'set_of_sets'/3 (Ss,[_rec175|L],Type)-|['compiler_generated'] )
(<_22> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_20> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[S = {'OrdSet',_23,_24}|Ss],L,T0> when ('true'-|['compiler_generated'] ) -> (case S of (<({'OrdSet',_25,_rec176}-|['compiler_generated'] )> when 'true' -> case (case <_rec176,T0> of (<T,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,T)-|['compiler_generated'] ) -> T-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> {'error','type_mismatch'}
<Type> when 'true' -> (case S of (<({'OrdSet',_rec177,_27}-|['compiler_generated'] )> when 'true' -> apply 'set_of_sets'/3 (Ss,[_rec177|L],Type)-|['compiler_generated'] )
(<_28> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_26> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[],L,T> when 'true' -> let <_13> = call 'lists':'usort' (L) in {'Set',_13,T}
<_29,_X_L,_X_T> when 'true' -> {'error','badarg'} end
'ordset_of_sets'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[S = {'Set',_18,_19}|Ss],L,T> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_rec178,_20}-|['compiler_generated'] )> when 'true' -> (case S of (<({'Set',_22,_rec179}-|['compiler_generated'] )> when 'true' -> apply 'ordset_of_sets'/3 (Ss,[_rec178|L],[[_rec179|[]]|T])-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[S = {'OrdSet',_24,_25}|Ss],L,T> when ('true'-|['compiler_generated'] ) -> (case S of (<({'OrdSet',_rec180,_26}-|['compiler_generated'] )> when 'true' -> (case S of (<({'OrdSet',_28,_rec181}-|['compiler_generated'] )> when 'true' -> apply 'ordset_of_sets'/3 (Ss,[_rec180|L],[_rec181|T])-|['compiler_generated'] )
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[],L,T> when 'true' -> let <_13> = call 'lists':'reverse' (L) in let <_14> = call 'erlang':'list_to_tuple' (_13) in let <_11> = call 'lists':'reverse' (T) in let <_12> = call 'erlang':'list_to_tuple' (_11) in {'OrdSet',_14,_12}
<_30,_X_L,_X_T> when 'true' -> 'error' end
'rel'/2 = fun (_0,_1) -> case <_0,_1> of <Ts,[Type|[]]> when 'true' -> let <_3> = apply 'is_type'/1 (Type) in let <_2> = apply 'atoms_only'/2 (Type,1) in case call 'erlang':'and' (_3,_2) of <'true'> when 'true' -> let <_4> = call 'erlang':'tuple_size' (Type) in apply 'rel'/3 (Ts,_4,Type)
<'false'> when 'true' -> apply 'rel_type'/3 (Ts,[],Type) end
<Ts,Sz> when 'true' -> let <_6> = call 'erlang':'make_tuple' (Sz,'atom') in apply 'rel'/3 (Ts,Sz,_6) end
'atoms_only'/2 = fun (_0,_1) -> case <_0,_1> of <Type,I> when try let <_2> = call 'erlang':'element' (I,Type) in call 'erlang':'is_atom' (_2) of <Try> -> Try catch <T,R> -> 'false' -> let <_3> = call 'erlang':'+' (I,1) in apply 'atoms_only'/2 (Type,_3)
<Type,I> when try let <_4> = call 'erlang':'tuple_size' (Type) in let <_5> = call 'erlang':'>' (I,_4) in let <_6> = call 'erlang':'is_tuple' (Type) in call 'erlang':'and' (_5,_6) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<_X_Type,_X_I> when 'true' -> 'false' end
'rel'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Ts,Sz,Type> when call 'erlang':'>=' (Sz,1) -> let <SL> = call 'lists':'usort' (Ts) in apply 'rel'/4 (SL,SL,Sz,Type)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'rel',3}}] )-|['compiler_generated'] ) end
'rel'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[T|Ts],L,Sz,Type> when try let <_4> = call 'erlang':'tuple_size' (T) in call 'erlang':'=:=' (_4,Sz) of <Try> -> Try catch <T,R> -> 'false' -> apply 'rel'/4 (Ts,L,Sz,Type)
<[],L,_X_Sz,Type> when 'true' -> {'Set',L,Type}
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'rel',4}}] )-|['compiler_generated'] ) end
'rel_type'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Ts],L,Type> when 'true' -> case apply 'make_element'/3 (E,Type,Type) of <{NType,NE}> when 'true' -> apply 'rel_type'/3 (Ts,[NE|L],NType)
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<[],[],'_'> when 'true' -> apply 'empty_set'/0 ()
<[],SL,Type> when call 'erlang':'is_tuple' (Type) -> let <_4> = call 'lists':'usort' (SL) in {'Set',_4,Type}
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'rel_type',3}}] )-|['compiler_generated'] ) end
'a_func'/2 = fun (_0,_1) -> let <_2> = apply 'is_type'/1 (_1) in case <_1,_2> of <([Type = ({DT,RT}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when let <_3> = call 'erlang':'is_atom' (DT) in let <_4> = call 'erlang':'is_atom' (RT) in call 'erlang':'and' (_3,_4) -> apply 'func'/2 (_0,Type)
<([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when 'true' -> let <_7> = fun (_5) -> case _5 of <{_11,_12}> when 'true' -> 'true'
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'-a_func/2-fun-0-',1}}] )-|['compiler_generated'] ) end in apply 'func_type'/4 (_0,[],Type,_7)
(<(_13-|['compiler_generated'] ),(_14-|['compiler_generated'] )> when 'true' -> let <_8> = {(_13-|['compiler_generated'] ),(_14-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
'func'/2 = fun (_0,_1) -> let <L> = call 'lists':'usort' (_0) in apply 'func'/4 (L,L,L,_1)
'func'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{X,_8}|Ts],X0,L,Type> when call 'erlang':'/=' (X,X0) -> apply 'func'/4 (Ts,X,L,Type)
<[{X,_9}|_X_Ts],X0,_X_L,_X_Type> when call 'erlang':'==' (X,X0) -> 'bad_function'
<[],_X_X0,L,Type> when 'true' -> {'Set',L,Type}
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'func',4}}] )-|['compiler_generated'] ) end
'fam'/2 = fun (_0,_1) -> let <_2> = apply 'is_type'/1 (_1) in case <_1,_2> of <([Type = ({DT,([RT|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when let <_3> = call 'erlang':'is_atom' (DT) in let <_4> = call 'erlang':'is_atom' (RT) in call 'erlang':'and' (_3,_4) -> apply 'fam2'/2 (_0,Type)
<([Type|([]-|['compiler_generated'] )]-|['compiler_generated'] ),('true'-|['compiler_generated'] )> when 'true' -> let <_7> = fun (_5) -> case _5 of <{_11,[_12|[]]}> when 'true' -> 'true'
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'-fam/2-fun-0-',1}}] )-|['compiler_generated'] ) end in apply 'func_type'/4 (_0,[],Type,_7)
(<(_13-|['compiler_generated'] ),(_14-|['compiler_generated'] )> when 'true' -> let <_8> = {(_13-|['compiler_generated'] ),(_14-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
'fam2'/2 = fun (_0,_1) -> case <_0,_1> of <[],Type> when 'true' -> {'Set',[],Type}
<Ts,Type> when 'true' -> let <_2> = call 'lists':'sort' (Ts) in apply 'fam2'/4 (_2,Ts,[],Type) end
'fam2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{I,L}|T],I0,SL,Type> when call 'erlang':'/=' (I,I0) -> let <_4> = call 'lists':'usort' (L) in apply 'fam2'/4 (T,I,[{I,_4}|SL],Type)
<[{I,L}|T],I0,SL,Type> when call 'erlang':'==' (I,I0) -> let <_5> = call 'lists':'usort' (L) in case <_5,SL> of <NL,([({_X_I,NL1}-|['compiler_generated'] )|_12]-|['compiler_generated'] )> when call 'erlang':'==' (NL,NL1) -> apply 'fam2'/4 (T,I0,SL,Type)
<(_14-|['compiler_generated'] ),(_15-|['compiler_generated'] )> when 'true' -> 'bad_function' end
<[],_X_I0,SL,Type> when 'true' -> let <_7> = call 'lists':'reverse' (SL) in {'Set',_7,Type}
(<_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8})-|[{'function_name',{'fam2',4}}] )-|['compiler_generated'] ) end
'func_type'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E|T],SL,Type,F> when 'true' -> case apply 'make_element'/3 (E,Type,Type) of <{NType,NE}> when 'true' -> apply 'func_type'/4 (T,[NE|SL],NType,F)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[],[],'_',_X_F> when 'true' -> apply 'empty_set'/0 ()
<[],SL,Type,F> when 'true' -> case apply F (Type) of <'true'> when 'true' -> let <NL> = call 'lists':'usort' (SL) in apply 'check_function'/2 (NL,{'Set',NL,Type})
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7})-|[{'function_name',{'func_type',4}}] )-|['compiler_generated'] ) end
'setify'/2 = fun (_0,_1) -> case <_0,_1> of <L,[Atom|[]]> when let <_2> = call 'erlang':'is_atom' (Atom) in let <_3> = call 'erlang':'=/=' (Atom,'_') in call 'erlang':'and' (_2,_3) -> let <_4> = call 'lists':'usort' (L) in {'Set',_4,Atom}
<L,[Type0|[]]> when 'true' -> try apply 'is_no_lists'/1 (Type0) of <_5> -> case _5 of <N> when call 'erlang':'is_integer' (_5) -> apply 'rel'/3 (L,N,Type0)
<Sizes> when 'true' -> apply 'make_oset'/4 (L,Sizes,L,Type0) end catch <_9,_8,_7> -> case apply 'create'/4 (L,Type0,Type0,[]) of <{[Type|[]],Set}> when 'true' -> {'Set',Set,Type}
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<E,Type0> when 'true' -> case apply 'make_element'/3 (E,Type0,Type0) of <{Type,OrdSet}> when 'true' -> {'OrdSet',OrdSet,Type}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end end
'is_no_lists'/1 = fun (_0) -> case _0 of <T> when call 'erlang':'is_tuple' (_0) -> let <Sz> = call 'erlang':'tuple_size' (T) in apply 'is_no_lists'/4 (T,Sz,Sz,[])
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'is_no_lists',1}}] )-|['compiler_generated'] ) end
'is_no_lists'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_T,0,Sz,[]> when 'true' -> Sz
<_X_T,0,Sz,L> when 'true' -> {Sz,L}
<T,I,Sz,L> when try let <_4> = call 'erlang':'element' (I,T) in call 'erlang':'is_atom' (_4) of <Try> -> Try catch <T,R> -> 'false' -> let <_5> = call 'erlang':'-' (I,1) in apply 'is_no_lists'/4 (T,_5,Sz,L)
<T,I,Sz,L> when 'true' -> let <_8> = call 'erlang':'-' (I,1) in let <_6> = call 'erlang':'element' (I,T) in let <_7> = apply 'is_no_lists'/1 (_6) in apply 'is_no_lists'/4 (T,_8,Sz,[{I,_7}|L]) end
'create'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E|Es],T,T0,L> when 'true' -> case apply 'make_element'/3 (E,T,T0) of <{NT,S}> when 'true' -> apply 'create'/4 (Es,NT,T0,[S|L])
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[],T,_X_T0,L> when 'true' -> let <_5> = call 'lists':'usort' (L) in {[T|[]],_5}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'create',4}}] )-|['compiler_generated'] ) end
'make_element'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <C,'_',_X_T0> when 'true' -> apply 'make_element'/1 (C)
<C,Atom,'_'> when try let <_3> = call 'erlang':'is_atom' (Atom) in let <_4> = call 'erlang':'is_list' (C) in let <_5> = call 'erlang':'not' (_4) in let <_6> = call 'erlang':'is_tuple' (C) in let <_7> = call 'erlang':'not' (_6) in let <_8> = call 'erlang':'and' (_5,_7) in call 'erlang':'and' (_3,_8) of <Try> -> Try catch <T,R> -> 'false' -> {Atom,C}
<C,Atom,_21> when let <_22> = call 'erlang':'=:=' (_21,Atom) in let <_23> = call 'erlang':'is_atom' (Atom) in call 'erlang':'and' (_22,_23) -> {Atom,C}
<T,TT,'_'> when try let <_10> = call 'erlang':'tuple_size' (T) in let <_9> = call 'erlang':'tuple_size' (TT) in call 'erlang':'=:=' (_10,_9) of <Try> -> Try catch <T,R> -> 'false' -> let <_12> = call 'erlang':'tuple_to_list' (T) in let <_11> = call 'erlang':'tuple_to_list' (TT) in apply 'make_tuple'/5 (_12,_11,[],[],'_')
<T,TT,T0> when try let <_14> = call 'erlang':'tuple_size' (T) in let <_13> = call 'erlang':'tuple_size' (TT) in call 'erlang':'=:=' (_14,_13) of <Try> -> Try catch <T,R> -> 'false' -> let <_17> = call 'erlang':'tuple_to_list' (T) in let <_16> = call 'erlang':'tuple_to_list' (TT) in let <_15> = call 'erlang':'tuple_to_list' (T0) in apply 'make_tuple'/5 (_17,_16,[],[],_15)
<L,[LT|[]],'_'> when call 'erlang':'is_list' (L) -> apply 'create'/4 (L,LT,'_',[])
<L,[LT|[]],[T0|[]]> when call 'erlang':'is_list' (L) -> apply 'create'/4 (L,LT,T0,[])
(<_20,_19,_18> when 'true' -> (primop 'match_fail' ({'function_clause',_20,_19,_18})-|[{'function_name',{'make_element',3}}] )-|['compiler_generated'] ) end
'make_tuple'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[E|Es],[T|Ts],NT,L,T0> when call 'erlang':'=:=' (T0,'_') -> case apply 'make_element'/3 (E,T,T0) of <{ET,ES}> when 'true' -> apply 'make_tuple'/5 (Es,Ts,[ET|NT],[ES|L],T0)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<[E|Es],[T|Ts],NT,L,[T0|T0s]> when 'true' -> case apply 'make_element'/3 (E,T,T0) of <{ET,ES}> when 'true' -> apply 'make_tuple'/5 (Es,Ts,[ET|NT],[ES|L],T0s)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<[],[],NT,L,_X_T0s> when call 'erlang':'=/=' (NT,[]) -> let <_9> = call 'lists':'reverse' (NT) in let <_10> = call 'erlang':'list_to_tuple' (_9) in let <_7> = call 'lists':'reverse' (L) in let <_8> = call 'erlang':'list_to_tuple' (_7) in {_10,_8}
(<_15,_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12,_11})-|[{'function_name',{'make_tuple',5}}] )-|['compiler_generated'] ) end
'make_element'/1 = fun (_0) -> case _0 of <C> when try let <_1> = call 'erlang':'is_list' (_0) in let <_2> = call 'erlang':'not' (_1) in let <_3> = call 'erlang':'is_tuple' (_0) in let <_4> = call 'erlang':'not' (_3) in call 'erlang':'and' (_2,_4) of <Try> -> Try catch <T,R> -> 'false' -> {'atom',C}
<T> when call 'erlang':'is_tuple' (_0) -> let <_5> = call 'erlang':'tuple_to_list' (T) in apply 'make_tuple'/3 (_5,[],[])
<L> when call 'erlang':'is_list' (_0) -> apply 'create'/4 (L,'_','_',[])
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'make_element',1}}] )-|['compiler_generated'] ) end
'make_tuple'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Es],T,L> when 'true' -> case apply 'make_element'/1 (E) of <{ET,ES}> when 'true' -> apply 'make_tuple'/3 (Es,[ET|T],[ES|L])
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<[],T,L> when call 'erlang':'=/=' (T,[]) -> let <_6> = call 'lists':'reverse' (T) in let <_7> = call 'erlang':'list_to_tuple' (_6) in let <_4> = call 'lists':'reverse' (L) in let <_5> = call 'erlang':'list_to_tuple' (_4) in {_7,_5}
(<_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8})-|[{'function_name',{'make_tuple',3}}] )-|['compiler_generated'] ) end
'make_oset'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[T|Ts],Szs,L,Type> when 'true' -> case apply 'test_oset'/3 (Szs,T,T) of <'true'> when 'true' -> apply 'make_oset'/4 (Ts,Szs,L,Type)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[],_X_Szs,L,Type> when 'true' -> let <_5> = call 'lists':'usort' (L) in {'Set',_5,Type}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'make_oset',4}}] )-|['compiler_generated'] ) end
'test_oset'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{Sz,Args},T,T0> when try let <_3> = call 'erlang':'tuple_size' (T) in call 'erlang':'=:=' (_3,Sz) of <Try> -> Try catch <T,R> -> 'false' -> apply 'test_oset_args'/3 (Args,T,T0)
<Sz,T,_X_T0> when try let <_4> = call 'erlang':'tuple_size' (T) in call 'erlang':'=:=' (_4,Sz) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'test_oset',3}}] )-|['compiler_generated'] ) end
'test_oset_args'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{Arg,Szs}|Ss],T,T0> when 'true' -> let <_3> = call 'erlang':'element' (Arg,T) in case apply 'test_oset'/3 (Szs,_3,T0) of <'true'> when 'true' -> apply 'test_oset_args'/3 (Ss,T,T0)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[],_X_T,_X_T0> when 'true' -> 'true'
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'test_oset_args',3}}] )-|['compiler_generated'] ) end
'list_of_sets'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[S|Ss],Type,L> when 'true' -> apply 'list_of_sets'/3 (Ss,Type,[{'Set',S,Type}|L])
<[],_X_Type,L> when 'true' -> call 'lists':'reverse' (L)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'list_of_sets',3}}] )-|['compiler_generated'] ) end
'list_of_ordsets'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[S|Ss],Type,L> when 'true' -> apply 'list_of_ordsets'/3 (Ss,Type,[{'OrdSet',S,Type}|L])
<[],_X_Type,L> when 'true' -> call 'lists':'reverse' (L)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'list_of_ordsets',3}}] )-|['compiler_generated'] ) end
'tuple_of_sets'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[S|Ss],[[Type|[]]|Types],L> when 'true' -> apply 'tuple_of_sets'/3 (Ss,Types,[{'Set',S,Type}|L])
<[S|Ss],[Type|Types],L> when 'true' -> apply 'tuple_of_sets'/3 (Ss,Types,[{'OrdSet',S,Type}|L])
<[],[],L> when 'true' -> let <_3> = call 'lists':'reverse' (L) in call 'erlang':'list_to_tuple' (_3)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'tuple_of_sets',3}}] )-|['compiler_generated'] ) end
'spec'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E|Es],Fun,Type,L> when 'true' -> let <_4> = case <E,Type> of (<_13,_14> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (_13)-|['compiler_generated'] ) -> ({('Set'-|['compiler_generated'] ),_13,_14}-|['compiler_generated'] )-|['compiler_generated'] )
(<T,_15> when ('true'-|['compiler_generated'] ) -> ({('OrdSet'-|['compiler_generated'] ),T,_15}-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply Fun (_4) of <'true'> when 'true' -> apply 'spec'/4 (Es,Fun,Type,[E|L])
<'false'> when 'true' -> apply 'spec'/4 (Es,Fun,Type,L)
<_10> when 'true' -> 'badarg' end
<[],_X_Fun,_X_Type,L> when 'true' -> call 'lists':'reverse' (L)
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'spec',4}}] )-|['compiler_generated'] ) end
'specification'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Es],Fun,L> when 'true' -> case apply Fun (E) of <'true'> when 'true' -> apply 'specification'/3 (Es,Fun,[E|L])
<'false'> when 'true' -> apply 'specification'/3 (Es,Fun,L)
<_7> when 'true' -> 'badarg' end
<[],_X_Fun,L> when 'true' -> call 'lists':'reverse' (L)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'specification',3}}] )-|['compiler_generated'] ) end
'intersection'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[H1|T1],[H2|T2],L> when call 'erlang':'<' (H1,H2) -> apply 'intersection1'/4 (T1,T2,L,H2)
<[H1|T1],[H2|T2],L> when call 'erlang':'==' (H1,H2) -> apply 'intersection'/3 (T1,T2,[H1|L])
<[H1|T1],[_X_H2|T2],L> when 'true' -> apply 'intersection2'/4 (T1,T2,L,H1)
<_6,_7,L> when 'true' -> call 'lists':'reverse' (L) end
'intersection1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[H1|T1],T2,L,H2> when call 'erlang':'<' (H1,H2) -> apply 'intersection1'/4 (T1,T2,L,H2)
<[H1|T1],T2,L,H2> when call 'erlang':'==' (H1,H2) -> apply 'intersection'/3 (T1,T2,[H1|L])
<[H1|T1],T2,L,_X_H2> when 'true' -> apply 'intersection2'/4 (T1,T2,L,H1)
<_8,_9,L,_10> when 'true' -> call 'lists':'reverse' (L) end
'intersection2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <T1,[H2|T2],L,H1> when call 'erlang':'>' (H1,H2) -> apply 'intersection2'/4 (T1,T2,L,H1)
<T1,[H2|T2],L,H1> when call 'erlang':'==' (H1,H2) -> apply 'intersection'/3 (T1,T2,[H1|L])
<T1,[H2|T2],L,_X_H1> when 'true' -> apply 'intersection1'/4 (T1,T2,L,H2)
<_8,_9,L,_10> when 'true' -> call 'lists':'reverse' (L) end
'difference'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[H1|T1],[H2|T2],L> when call 'erlang':'<' (H1,H2) -> apply 'diff'/4 (T1,T2,[H1|L],H2)
<[H1|T1],[H2|T2],L> when call 'erlang':'==' (H1,H2) -> apply 'difference'/3 (T1,T2,L)
<[H1|T1],[_X_H2|T2],L> when 'true' -> apply 'diff2'/4 (T1,T2,L,H1)
<L1,_6,L> when 'true' -> call 'lists':'reverse' (L,L1) end
'diff'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[H1|T1],T2,L,H2> when call 'erlang':'<' (H1,H2) -> apply 'diff'/4 (T1,T2,[H1|L],H2)
<[H1|T1],T2,L,H2> when call 'erlang':'==' (H1,H2) -> apply 'difference'/3 (T1,T2,L)
<[H1|T1],T2,L,_X_H2> when 'true' -> apply 'diff2'/4 (T1,T2,L,H1)
<_8,_9,L,_10> when 'true' -> call 'lists':'reverse' (L) end
'diff2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <T1,[H2|T2],L,H1> when call 'erlang':'>' (H1,H2) -> apply 'diff2'/4 (T1,T2,L,H1)
<T1,[H2|T2],L,H1> when call 'erlang':'==' (H1,H2) -> apply 'difference'/3 (T1,T2,L)
<T1,[H2|T2],L,H1> when 'true' -> apply 'diff'/4 (T1,T2,[H1|L],H2)
<T1,_8,L,H1> when 'true' -> call 'lists':'reverse' (L,[H1|T1]) end
'symdiff'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[H1|T1],T2,L> when 'true' -> apply 'symdiff2'/4 (T1,T2,L,H1)
<_6,T2,L> when 'true' -> call 'lists':'reverse' (L,T2) end
'symdiff1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[H1|T1],T2,L,H2> when call 'erlang':'<' (H1,H2) -> apply 'symdiff1'/4 (T1,T2,[H1|L],H2)
<[H1|T1],T2,L,H2> when call 'erlang':'==' (H1,H2) -> (case <T1,T2,L> of (<([_12|_13]-|['compiler_generated'] ),_14,_15> when ('true'-|['compiler_generated'] ) -> (apply 'symdiff2'/4 (_13,_14,_15,_12)-|['compiler_generated'] )-|['compiler_generated'] )
(<_6,_16,_17> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (_17,_16)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[H1|T1],T2,L,H2> when 'true' -> apply 'symdiff2'/4 (T1,T2,[H2|L],H1)
<_8,T2,L,H2> when 'true' -> call 'lists':'reverse' (L,[H2|T2]) end
'symdiff2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <T1,[H2|T2],L,H1> when call 'erlang':'>' (H1,H2) -> apply 'symdiff2'/4 (T1,T2,[H2|L],H1)
<T1,[H2|T2],L,H1> when call 'erlang':'==' (H1,H2) -> (case <T1,T2,L> of (<([_12|_13]-|['compiler_generated'] ),_14,_15> when ('true'-|['compiler_generated'] ) -> (apply 'symdiff2'/4 (_13,_14,_15,_12)-|['compiler_generated'] )-|['compiler_generated'] )
(<_6,_16,_17> when ('true'-|['compiler_generated'] ) -> (call ('lists'-|['compiler_generated'] ):('reverse'-|['compiler_generated'] ) (_17,_16)-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<T1,[H2|T2],L,H1> when 'true' -> apply 'symdiff1'/4 (T1,T2,[H1|L],H2)
<T1,_8,L,H1> when 'true' -> call 'lists':'reverse' (L,[H1|T1]) end
'sympart'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[H1|T1],[H2|T2],L1,L12,L2,T> when call 'erlang':'<' (H1,H2) -> apply 'sympart1'/7 (T1,T2,[H1|L1],L12,L2,T,H2)
<[H1|T1],[H2|T2],L1,L12,L2,T> when call 'erlang':'==' (H1,H2) -> apply 'sympart'/6 (T1,T2,L1,[H1|L12],L2,T)
<[H1|T1],[H2|T2],L1,L12,L2,T> when 'true' -> apply 'sympart2'/7 (T1,T2,L1,L12,[H2|L2],T,H1)
<S1,[],L1,L12,L2,T> when 'true' -> let <_8> = call 'lists':'reverse' (L1,S1) in let <_7> = call 'lists':'reverse' (L12) in let <_6> = call 'lists':'reverse' (L2) in {{'Set',_8,T},{'Set',_7,T},{'Set',_6,T}}
<_18,S2,L1,L12,L2,T> when 'true' -> let <_11> = call 'lists':'reverse' (L1) in let <_10> = call 'lists':'reverse' (L12) in let <_9> = call 'lists':'reverse' (L2,S2) in {{'Set',_11,T},{'Set',_10,T},{'Set',_9,T}} end
'sympart1'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[H1|T1],T2,L1,L12,L2,T,H2> when call 'erlang':'<' (H1,H2) -> apply 'sympart1'/7 (T1,T2,[H1|L1],L12,L2,T,H2)
<[H1|T1],T2,L1,L12,L2,T,H2> when call 'erlang':'==' (H1,H2) -> apply 'sympart'/6 (T1,T2,L1,[H1|L12],L2,T)
<[H1|T1],T2,L1,L12,L2,T,H2> when 'true' -> apply 'sympart2'/7 (T1,T2,L1,L12,[H2|L2],T,H1)
<_17,T2,L1,L12,L2,T,H2> when 'true' -> let <_9> = call 'lists':'reverse' (L1) in let <_8> = call 'lists':'reverse' (L12) in let <_7> = call 'lists':'reverse' (L2,[H2|T2]) in {{'Set',_9,T},{'Set',_8,T},{'Set',_7,T}} end
'sympart2'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <T1,[H2|T2],L1,L12,L2,T,H1> when call 'erlang':'>' (H1,H2) -> apply 'sympart2'/7 (T1,T2,L1,L12,[H2|L2],T,H1)
<T1,[H2|T2],L1,L12,L2,T,H1> when call 'erlang':'==' (H1,H2) -> apply 'sympart'/6 (T1,T2,L1,[H1|L12],L2,T)
<T1,[H2|T2],L1,L12,L2,T,H1> when 'true' -> apply 'sympart1'/7 (T1,T2,[H1|L1],L12,L2,T,H2)
<T1,_17,L1,L12,L2,T,H1> when 'true' -> let <_9> = call 'lists':'reverse' (L1,[H1|T1]) in let <_8> = call 'lists':'reverse' (L12) in let <_7> = call 'lists':'reverse' (L2) in {{'Set',_9,T},{'Set',_8,T},{'Set',_7,T}} end
'prod'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[[E|Es]|Xs],T,L> when 'true' -> let <_3> = apply 'prod'/3 (Xs,[E|T],L) in apply 'prod'/4 (Es,Xs,T,_3)
<[],T,L> when 'true' -> let <_4> = call 'lists':'reverse' (T) in let <_5> = call 'erlang':'list_to_tuple' (_4) in [_5|L]
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'prod',3}}] )-|['compiler_generated'] ) end
'prod'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E|Es],Xs,T,L> when 'true' -> let <_4> = apply 'prod'/3 (Xs,[E|T],L) in apply 'prod'/4 (Es,Xs,T,_4)
<[],_X_Xs,_X_E,L> when 'true' -> L
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'prod',4}}] )-|['compiler_generated'] ) end
'constant_function'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Es],X,L> when 'true' -> apply 'constant_function'/3 (Es,X,[{E,X}|L])
<[],_X_X,L> when 'true' -> call 'lists':'reverse' (L)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'constant_function',3}}] )-|['compiler_generated'] ) end
'subset'/2 = fun (_0,_1) -> case <_0,_1> of <[H1|T1],[H2|T2]> when call 'erlang':'>' (H1,H2) -> apply 'subset'/3 (T1,T2,H1)
<[H1|T1],[H2|T2]> when call 'erlang':'==' (H1,H2) -> apply 'subset'/2 (T1,T2)
<L1,_4> when 'true' -> call 'erlang':'=:=' (L1,[]) end
'subset'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <T1,[H2|T2],H1> when call 'erlang':'>' (H1,H2) -> apply 'subset'/3 (T1,T2,H1)
<T1,[H2|T2],H1> when call 'erlang':'==' (H1,H2) -> apply 'subset'/2 (T1,T2)
<_6,_7,_8> when 'true' -> 'false' end
'disjoint'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[B|Bs],A,As> when call 'erlang':'<' (A,B) -> apply 'disjoint'/3 (As,B,Bs)
<[B|_X_Bs],A,_X_As> when call 'erlang':'==' (A,B) -> 'false'
<[_X_B|Bs],A,As> when 'true' -> apply 'disjoint'/3 (Bs,A,As)
<_X_Bs,_X_A,_X_As> when 'true' -> 'true' end
'lunion'/1 = fun (_0) -> case _0 of <[S = [_4|[]]|[]]> when 'true' -> S
<[[]|Ls]> when 'true' -> apply 'lunion'/1 (Ls)
<[S|Ss]> when 'true' -> let <_1> = call 'lists':'last' (S) in let <_2> = apply 'lunion'/4 (Ss,_1,[S|[]],[]) in call 'lists':'umerge' (_2)
<[]> when 'true' -> []
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'lunion',1}}] )-|['compiler_generated'] ) end
'lunion'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[S = [E|[]]|Ss],Last,SL,Ls> when call 'erlang':'>' (E,Last) -> apply 'lunion'/4 (Ss,E,[S|SL],Ls)
<[S|Ss],Last,SL,Ls> when try let <_4> = call 'erlang':'hd' (S) in call 'erlang':'>' (_4,Last) of <Try> -> Try catch <T,R> -> 'false' -> let <_5> = call 'lists':'last' (S) in apply 'lunion'/4 (Ss,_5,[S|SL],Ls)
<[S|Ss],_X_Last,SL,Ls> when 'true' -> let <_8> = call 'lists':'last' (S) in let <_6> = call 'lists':'reverse' (SL) in let <_7> = call 'lists':'append' (_6) in apply 'lunion'/4 (Ss,_8,[S|[]],[_7|Ls])
<[],_X_Last,SL,Ls> when 'true' -> let <_9> = call 'lists':'reverse' (SL) in let <_10> = call 'lists':'append' (_9) in [_10|Ls]
(<_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11})-|[{'function_name',{'lunion',4}}] )-|['compiler_generated'] ) end
'lintersection'/2 = fun (_0,_1) -> case <_0,_1> of <_5,[]> when 'true' -> []
<[S|Ss],S0> when 'true' -> let <_2> = apply 'intersection'/3 (S,S0,[]) in apply 'lintersection'/2 (Ss,_2)
<[],S> when 'true' -> S
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'lintersection',2}}] )-|['compiler_generated'] ) end
'can_rel'/2 = fun (_0,_1) -> case <_0,_1> of <[S|Ss],L> when 'true' -> apply 'can_rel'/4 (Ss,L,S,S)
<[],L> when 'true' -> call 'lists':'sort' (L)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'can_rel',2}}] )-|['compiler_generated'] ) end
'can_rel'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Ss,L,[E|Es],S> when 'true' -> apply 'can_rel'/4 (Ss,[{E,S}|L],Es,S)
<Ss,L,_8,_X_S> when 'true' -> apply 'can_rel'/2 (Ss,L) end
'rel2family'/1 = fun (_0) -> case _0 of <[{X,Y}|S]> when 'true' -> apply 'rel2fam'/4 (S,X,[Y|[]],[])
<[]> when 'true' -> []
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'rel2family',1}}] )-|['compiler_generated'] ) end
'rel2fam'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{X,Y}|S],X0,YL,L> when call 'erlang':'==' (X0,X) -> apply 'rel2fam'/4 (S,X0,[Y|YL],L)
<[{X,Y}|S],X0,[A|[B|YL]],L> when 'true' -> let <_4> = call 'lists':'reverse' (YL,[B|[A|[]]]) in apply 'rel2fam'/4 (S,X,[Y|[]],[{X0,_4}|L])
<[{X,Y}|S],X0,YL,L> when 'true' -> apply 'rel2fam'/4 (S,X,[Y|[]],[{X0,YL}|L])
<[],X,YL,L> when 'true' -> let <_5> = call 'lists':'reverse' (YL) in call 'lists':'reverse' ([{X,_5}|L])
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'rel2fam',4}}] )-|['compiler_generated'] ) end
'dom'/1 = fun (_0) -> case _0 of <[{X,_2}|Es]> when 'true' -> apply 'dom'/3 ([],X,Es)
<L = []> when 'true' -> L
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'dom',1}}] )-|['compiler_generated'] ) end
'dom'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <L,X,[{X1,_6}|Es]> when call 'erlang':'==' (X,X1) -> apply 'dom'/3 (L,X,Es)
<L,X,[{Y,_7}|Es]> when 'true' -> apply 'dom'/3 ([X|L],Y,Es)
<L,X,[]> when 'true' -> call 'lists':'reverse' (L,[X|[]])
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'dom',3}}] )-|['compiler_generated'] ) end
'ran'/2 = fun (_0,_1) -> case <_0,_1> of <[{_4,Y}|Es],L> when 'true' -> apply 'ran'/2 (Es,[Y|L])
<[],L> when 'true' -> call 'lists':'usort' (L)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'ran',2}}] )-|['compiler_generated'] ) end
'relprod'/2 = fun (_0,_1) -> let <_2> = apply 'relprod1'/2 (_0,_1) in call 'lists':'usort' (_2)
'relprod1'/2 = fun (_0,_1) -> case <_0,_1> of <[{Ay,Ax}|A],B> when 'true' -> apply 'relprod1'/5 (B,Ay,Ax,A,[])
<_X_A,_X_B> when 'true' -> [] end
'relprod1'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{Bx,_X_By}|B],Ay,Ax,A,L> when call 'erlang':'>' (Ay,Bx) -> apply 'relprod1'/5 (B,Ay,Ax,A,L)
<[{Bx,By}|B],Ay,Ax,A,L> when call 'erlang':'==' (Ay,Bx) -> apply 'relprod'/8 (B,Bx,By,A,[{Ax,By}|L],Ax,B,Ay)
<[{Bx,By}|B],_X_Ay,_X_Ax,A,L> when 'true' -> apply 'relprod2'/5 (B,Bx,By,A,L)
<_X_B,_X_Ay,_X_Ax,_X_A,L> when 'true' -> L end
'relprod2'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <B,Bx,By,[{Ay,_X_Ax}|A],L> when call 'erlang':'<' (Ay,Bx) -> apply 'relprod2'/5 (B,Bx,By,A,L)
<B,Bx,By,[{Ay,Ax}|A],L> when call 'erlang':'==' (Ay,Bx) -> apply 'relprod'/8 (B,Bx,By,A,[{Ax,By}|L],Ax,B,Ay)
<B,_X_Bx,_X_By,[{Ay,Ax}|A],L> when 'true' -> apply 'relprod1'/5 (B,Ay,Ax,A,L)
<_10,_11,_12,_13,L> when 'true' -> L end
'relprod'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case <_0,_1,_2,_3,_4,_5,_6,_7> of <B0,Bx0,By0,A0,L,Ax,[{Bx,By}|B],Ay> when call 'erlang':'==' (Ay,Bx) -> apply 'relprod'/8 (B0,Bx0,By0,A0,[{Ax,By}|L],Ax,B,Ay)
<B0,Bx0,By0,A0,L,_X_Ax,_X_B,_X_Ay> when 'true' -> apply 'relprod2'/5 (B0,Bx0,By0,A0,L) end
'relprod_n'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],_X_R,_X_EmptyG,_X_IsR> when 'true' -> {'error','badarg'}
<RL,R,EmptyR,IsR> when 'true' -> case apply 'domain_type'/2 (RL,'_') of <Error = {'error',_X_Reason}> when 'true' -> Error
<DType> when 'true' -> let <_4> = 'is_empty_set'/1 in let <_5> = call 'lists':'any' (_4,RL) in let <Empty> = call 'erlang':'or' (_5,EmptyR) in let <RType> = apply 'range_type'/2 (RL,[]) in let <Type> = {DType,RType} in let <_21> = case Empty of <'true'> when let <_9> = call 'erlang':'=:=' (DType,'_') in let <_10> = call 'erlang':'=:=' (RType,'_') in call 'erlang':'or' (_9,_10) -> apply 'empty_set'/0 ()
<'true'> when 'true' -> {'Set',[],Type}
<'false'> when 'true' -> (case apply 'relprod_n'/1 (RL) of (<({'Set',_rec182,_29}-|['compiler_generated'] )> when 'true' -> let <Sz> = call 'erlang':'length' (RL) in let <Fun> = fun (_16) -> case _16 of <{X,A}> when 'true' -> let <_15> = apply 'flat'/3 (Sz,A,[]) in {X,_15}
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'-relprod_n/4-fun-1-',1}}] )-|['compiler_generated'] ) end in let <_19> = call 'lists':'map' (Fun,_rec182) in {'Set',_19,Type}-|['compiler_generated'] )
(<_30> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_20> when 'true' -> primop 'match_fail' ({'case_clause',_20})-|['compiler_generated'] ) end in case IsR of <'true'> when 'true' -> apply 'relative_product'/2 (_21,R)
<'false'> when 'true' -> _21
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end end end
'relprod_n'/1 = fun (_0) -> case _0 of <[R|Rs]> when 'true' -> apply 'relprod_n'/2 (Rs,R)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'relprod_n',1}}] )-|['compiler_generated'] ) end
'relprod_n'/2 = fun (_0,_1) -> case <_0,_1> of <[],R> when 'true' -> R
<[R|Rs],R0> when 'true' -> let <T> = apply 'raise_element'/2 (R0,1) in let <R1> = apply 'relative_product1'/2 (T,R) in let <_6> = fun (_4) -> case _4 of <{{X,A},AS}> when 'true' -> {X,{A,AS}}
(<_5> when 'true' -> (primop 'match_fail' ({'function_clause',_5})-|[{'function_name',{'-relprod_n/2-fun-0-',1}}] )-|['compiler_generated'] ) end in let <NR> = apply 'projection'/2 ({'external',_6},R1) in apply 'relprod_n'/2 (Rs,NR)
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'relprod_n',2}}] )-|['compiler_generated'] ) end
'flat'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <1,A,L> when 'true' -> call 'erlang':'list_to_tuple' ([A|L])
<N,{T,A},L> when 'true' -> let <_3> = call 'erlang':'-' (N,1) in apply 'flat'/3 (_3,T,[A|L])
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'flat',3}}] )-|['compiler_generated'] ) end
'domain_type'/2 = fun (_0,_1) -> case <_0,_1> of <[T = {'Set',_8,_9}|Ts],T0> when ('true'-|['compiler_generated'] ) -> (case T of (<({'Set',_10,_rec183}-|['compiler_generated'] )> when 'true' -> case _rec183 of <{DT,_X_RT}> when 'true' -> case (case <DT,T0> of (<_15,_4> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_4,_15)-|['compiler_generated'] ) -> _15-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> {'error','type_mismatch'}
<T1> when 'true' -> apply 'domain_type'/2 (Ts,T1) end
<'_'> when 'true' -> apply 'domain_type'/2 (Ts,T0)
<_12> when 'true' -> {'error','badarg'} end-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[],T0> when 'true' -> T0
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'domain_type',2}}] )-|['compiler_generated'] ) end
'range_type'/2 = fun (_0,_1) -> case <_0,_1> of <[T|Ts],L> when 'true' -> (case T of (<({'Set',_8,_rec184}-|['compiler_generated'] )> when 'true' -> case _rec184 of <{_X_DT,RT}> when 'true' -> apply 'range_type'/2 (Ts,[RT|L])
<'_'> when 'true' -> '_'
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[],L> when 'true' -> let <_5> = call 'lists':'reverse' (L) in call 'erlang':'list_to_tuple' (_5)
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'range_type',2}}] )-|['compiler_generated'] ) end
'converse'/2 = fun (_0,_1) -> case <_0,_1> of <[{A,B}|X],L> when 'true' -> apply 'converse'/2 (X,[{B,A}|L])
<[],L> when 'true' -> call 'lists':'sort' (L)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'converse',2}}] )-|['compiler_generated'] ) end
'strict'/2 = fun (_0,_1) -> case <_0,_1> of <[{E1,E2}|Es],L> when call 'erlang':'==' (E1,E2) -> apply 'strict'/2 (Es,L)
<[E|Es],L> when 'true' -> apply 'strict'/2 (Es,[E|L])
<[],L> when 'true' -> call 'lists':'reverse' (L)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'strict',2}}] )-|['compiler_generated'] ) end
'weak'/1 = fun (_0) -> let <_1> = apply 'ran'/2 (_0,[]) in apply 'weak'/3 (_0,_1,[])
'weak'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Es = [{X,_6}|_7],[Y|Ys],L> when call 'erlang':'>' (X,Y) -> apply 'weak'/3 (Es,Ys,[{Y,Y}|L])
<Es = [{X,_8}|_9],[Y|Ys],L> when call 'erlang':'==' (X,Y) -> apply 'weak'/3 (Es,Ys,L)
<[E = {X,Y}|Es],Ys,L> when call 'erlang':'>' (X,Y) -> apply 'weak1'/4 (Es,Ys,[E|L],X)
<[E = {X,Y}|Es],Ys,L> when call 'erlang':'==' (X,Y) -> apply 'weak2'/4 (Es,Ys,[E|L],X)
<[E = {X,_X_Y}|Es],Ys,L> when 'true' -> apply 'weak2'/4 (Es,Ys,[E|[{X,X}|L]],X)
<[],[Y|Ys],L> when 'true' -> apply 'weak'/3 ([],Ys,[{Y,Y}|L])
<[],[],L> when 'true' -> call 'lists':'reverse' (L)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'weak',3}}] )-|['compiler_generated'] ) end
'weak1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E = {X,Y}|Es],Ys,L,X0> when let <_4> = call 'erlang':'>' (X,Y) in let <_5> = call 'erlang':'==' (X,X0) in call 'erlang':'and' (_4,_5) -> apply 'weak1'/4 (Es,Ys,[E|L],X)
<[E = {X,Y}|Es],Ys,L,X0> when let <_6> = call 'erlang':'==' (X,Y) in let <_7> = call 'erlang':'==' (X,X0) in call 'erlang':'and' (_6,_7) -> apply 'weak2'/4 (Es,Ys,[E|L],X)
<[E = {X,_X_Y}|Es],Ys,L,X0> when call 'erlang':'==' (X,X0) -> apply 'weak2'/4 (Es,Ys,[E|[{X,X}|L]],X)
<Es,Ys,L,X> when 'true' -> apply 'weak'/3 (Es,Ys,[{X,X}|L]) end
'weak2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E = {X,_X_Y}|Es],Ys,L,X0> when call 'erlang':'==' (X,X0) -> apply 'weak2'/4 (Es,Ys,[E|L],X)
<Es,Ys,L,_X_X> when 'true' -> apply 'weak'/3 (Es,Ys,L) end
'extc'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L,[D|Ds],C,Ts> when 'true' -> apply 'extc'/5 (L,Ds,C,Ts,D)
<L,[],_X_C,_X_Ts> when 'true' -> L
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'extc',4}}] )-|['compiler_generated'] ) end
'extc'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <L,Ds,C,[{X,_X_Y}|Ts],D> when call 'erlang':'<' (X,D) -> apply 'extc'/5 (L,Ds,C,Ts,D)
<L,Ds,C,[{X,_X_Y}|Ts],D> when call 'erlang':'==' (X,D) -> apply 'extc'/4 (L,Ds,C,Ts)
<L,Ds,C,[{X,_X_Y}|Ts],D> when 'true' -> apply 'extc2'/5 ([{D,C}|L],Ds,C,Ts,X)
<L,Ds,C,[],D> when 'true' -> apply 'extc_tail'/3 ([{D,C}|L],Ds,C)
(<_9,_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6,_5})-|[{'function_name',{'extc',5}}] )-|['compiler_generated'] ) end
'extc2'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <L,[D|Ds],C,Ts,X> when call 'erlang':'>' (X,D) -> apply 'extc2'/5 ([{D,C}|L],Ds,C,Ts,X)
<L,[D|Ds],C,Ts,X> when call 'erlang':'==' (X,D) -> apply 'extc'/4 (L,Ds,C,Ts)
<L,[D|Ds],C,Ts,_X_X> when 'true' -> apply 'extc'/5 (L,Ds,C,Ts,D)
<L,[],_X_C,_X_Ts,_X_X> when 'true' -> L
(<_9,_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6,_5})-|[{'function_name',{'extc2',5}}] )-|['compiler_generated'] ) end
'extc_tail'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <L,[D|Ds],C> when 'true' -> apply 'extc_tail'/3 ([{D,C}|L],Ds,C)
<L,[],_X_C> when 'true' -> L
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'extc_tail',3}}] )-|['compiler_generated'] ) end
'is_a_func'/2 = fun (_0,_1) -> case <_0,_1> of <[{E,_4}|Es],E0> when call 'erlang':'/=' (E,E0) -> apply 'is_a_func'/2 (Es,E)
<L,_X_E> when 'true' -> call 'erlang':'=:=' (L,[]) end
'restrict_n'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <I,[T|Ts],Key,Keys,L> when 'true' -> case call 'erlang':'element' (I,T) of <K> when call 'erlang':'<' (K,Key) -> apply 'restrict_n'/5 (I,Ts,Key,Keys,L)
<K> when call 'erlang':'==' (K,Key) -> apply 'restrict_n'/5 (I,Ts,Key,Keys,[T|L])
<K> when 'true' -> apply 'restrict_n'/6 (I,K,Ts,Keys,L,T) end
<_X_I,_X_Ts,_X_Key,_X_Keys,L> when 'true' -> L end
'restrict_n'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <I,K,Ts,[Key|Keys],L,E> when call 'erlang':'>' (K,Key) -> apply 'restrict_n'/6 (I,K,Ts,Keys,L,E)
<I,K,Ts,[Key|Keys],L,E> when call 'erlang':'==' (K,Key) -> apply 'restrict_n'/5 (I,Ts,Key,Keys,[E|L])
<I,_X_K,Ts,[Key|Keys],L,_X_E> when 'true' -> apply 'restrict_n'/5 (I,Ts,Key,Keys,L)
<_X_I,_X_K,_X_Ts,_X_Keys,L,_X_E> when 'true' -> L end
'restrict'/2 = fun (_0,_1) -> case <_0,_1> of <[Key|Keys],Tuples> when 'true' -> apply 'restrict'/4 (Tuples,Key,Keys,[])
<_X_Keys,_X_Tuples> when 'true' -> [] end
'restrict'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{K,_X_E}|Ts],Key,Keys,L> when call 'erlang':'<' (K,Key) -> apply 'restrict'/4 (Ts,Key,Keys,L)
<[{K,E}|Ts],Key,Keys,L> when call 'erlang':'==' (K,Key) -> apply 'restrict'/4 (Ts,Key,Keys,[E|L])
<[{K,E}|Ts],_X_Key,Keys,L> when 'true' -> apply 'restrict'/5 (Ts,K,Keys,L,E)
<_X_Ts,_X_Key,_X_Keys,L> when 'true' -> L end
'restrict'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Ts,K,[Key|Keys],L,E> when call 'erlang':'>' (K,Key) -> apply 'restrict'/5 (Ts,K,Keys,L,E)
<Ts,K,[Key|Keys],L,E> when call 'erlang':'==' (K,Key) -> apply 'restrict'/4 (Ts,Key,Keys,[E|L])
<Ts,_X_K,[Key|Keys],L,_X_E> when 'true' -> apply 'restrict'/4 (Ts,Key,Keys,L)
<_X_Ts,_X_K,_X_Keys,L,_X_E> when 'true' -> L end
'diff_restrict_n'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <I,[T|Ts],Key,Keys,L> when 'true' -> case call 'erlang':'element' (I,T) of <K> when call 'erlang':'<' (K,Key) -> apply 'diff_restrict_n'/5 (I,Ts,Key,Keys,[T|L])
<K> when call 'erlang':'==' (K,Key) -> apply 'diff_restrict_n'/5 (I,Ts,Key,Keys,L)
<K> when 'true' -> apply 'diff_restrict_n'/6 (I,K,Ts,Keys,L,T) end
<I,_X_Ts,_X_Key,_X_Keys,L> when call 'erlang':'=:=' (I,1) -> call 'lists':'reverse' (L)
<_X_I,_X_Ts,_X_Key,_X_Keys,L> when 'true' -> call 'lists':'sort' (L) end
'diff_restrict_n'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <I,K,Ts,[Key|Keys],L,T> when call 'erlang':'>' (K,Key) -> apply 'diff_restrict_n'/6 (I,K,Ts,Keys,L,T)
<I,K,Ts,[Key|Keys],L,_X_T> when call 'erlang':'==' (K,Key) -> apply 'diff_restrict_n'/5 (I,Ts,Key,Keys,L)
<I,_X_K,Ts,[Key|Keys],L,T> when 'true' -> apply 'diff_restrict_n'/5 (I,Ts,Key,Keys,[T|L])
<I,_X_K,Ts,_X_Keys,L,T> when call 'erlang':'=:=' (I,1) -> call 'lists':'reverse' (L,[T|Ts])
<_X_I,_X_K,Ts,_X_Keys,L,T> when 'true' -> let <_6> = call 'erlang':'++' (Ts,L) in call 'lists':'sort' ([T|_6]) end
'diff_restrict'/2 = fun (_0,_1) -> case <_0,_1> of <[Key|Keys],Tuples> when 'true' -> apply 'diff_restrict'/4 (Tuples,Key,Keys,[])
<_X_Keys,Tuples> when 'true' -> apply 'diff_restrict_tail'/2 (Tuples,[]) end
'diff_restrict'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{K,E}|Ts],Key,Keys,L> when call 'erlang':'<' (K,Key) -> apply 'diff_restrict'/4 (Ts,Key,Keys,[E|L])
<[{K,_X_E}|Ts],Key,Keys,L> when call 'erlang':'==' (K,Key) -> apply 'diff_restrict'/4 (Ts,Key,Keys,L)
<[{K,E}|Ts],_X_Key,Keys,L> when 'true' -> apply 'diff_restrict'/5 (Ts,K,Keys,L,E)
<_X_Ts,_X_Key,_X_Keys,L> when 'true' -> L end
'diff_restrict'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Ts,K,[Key|Keys],L,E> when call 'erlang':'>' (K,Key) -> apply 'diff_restrict'/5 (Ts,K,Keys,L,E)
<Ts,K,[Key|Keys],L,_X_E> when call 'erlang':'==' (K,Key) -> apply 'diff_restrict'/4 (Ts,Key,Keys,L)
<Ts,_X_K,[Key|Keys],L,E> when 'true' -> apply 'diff_restrict'/4 (Ts,Key,Keys,[E|L])
<Ts,_X_K,_X_Keys,L,E> when 'true' -> apply 'diff_restrict_tail'/2 (Ts,[E|L]) end
'diff_restrict_tail'/2 = fun (_0,_1) -> case <_0,_1> of <[{_X_K,E}|Ts],L> when 'true' -> apply 'diff_restrict_tail'/2 (Ts,[E|L])
<_X_Ts,L> when 'true' -> L end
'comp'/2 = fun (_0,_1) -> case <_0,_1> of <[],B> when 'true' -> apply 'check_function'/2 (B,[])
<_X_A,[]> when 'true' -> 'bad_function'
<A0,[{Bx,By}|B]> when 'true' -> let <A> = apply 'converse'/2 (A0,[]) in let <_3> = apply 'comp1'/5 (A,B,[],Bx,By) in apply 'check_function'/2 (A0,_3)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'comp',2}}] )-|['compiler_generated'] ) end
'comp1'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{Ay,Ax}|A],B,L,Bx,By> when call 'erlang':'==' (Ay,Bx) -> apply 'comp1'/5 (A,B,[{Ax,By}|L],Bx,By)
<[{Ay,Ax}|A],B,L,Bx,_X_By> when call 'erlang':'>' (Ay,Bx) -> apply 'comp2'/6 (A,B,L,Bx,Ay,Ax)
<[{Ay,_X_Ax}|_X_A],_X_B,_X_L,Bx,_X_By> when call 'erlang':'<' (Ay,Bx) -> 'bad_function'
<[],B,L,Bx,_X_By> when 'true' -> apply 'check_function'/3 (Bx,B,L)
(<_9,_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6,_5})-|[{'function_name',{'comp1',5}}] )-|['compiler_generated'] ) end
'comp2'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <A,[{Bx,_X_By}|B],L,Bx0,Ay,Ax> when let <_6> = call 'erlang':'>' (Ay,Bx) in let <_7> = call 'erlang':'/=' (Bx,Bx0) in call 'erlang':'and' (_6,_7) -> apply 'comp2'/6 (A,B,L,Bx,Ay,Ax)
<A,[{Bx,By}|B],L,_X_Bx0,Ay,Ax> when call 'erlang':'==' (Ay,Bx) -> apply 'comp1'/5 (A,B,[{Ax,By}|L],Bx,By)
<_X_A,_X_B,_X_L,_X_Bx0,_X_Ay,_X_Ax> when 'true' -> 'bad_function' end
'inverse1'/1 = fun (_0) -> case _0 of <[{A,B}|X]> when 'true' -> apply 'inverse'/3 (X,A,[{B,A}|[]])
<[]> when 'true' -> []
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'inverse1',1}}] )-|['compiler_generated'] ) end
'inverse'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{A,B}|X],A0,L> when call 'erlang':'/=' (A0,A) -> apply 'inverse'/3 (X,A,[{B,A}|L])
<[{A,_X_B}|_X_X],A0,_X_L> when call 'erlang':'==' (A0,A) -> 'bad_function'
<[],_X_A0,L> when 'true' -> case call 'lists':'sort' (L) of <SL = [{V,_8}|Es]> when 'true' -> case apply 'is_a_func'/2 (Es,V) of <'true'> when 'true' -> SL
<'false'> when 'true' -> 'bad_function'
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'inverse',3}}] )-|['compiler_generated'] ) end
'external_fun'/1 = fun (_0) -> case _0 of <{'external',Function}> when call 'erlang':'is_atom' (Function) -> 'false'
<{'external',Fun}> when 'true' -> Fun
<_2> when 'true' -> 'false' end
'element_type'/1 = fun (_0) -> case _0 of <[Type|[]]> when 'true' -> Type
<Type> when 'true' -> Type end
'subst'/3 = fun (_0,_1,_2) -> apply 'subst'/5 (_0,_1,_2,'_',[])
'subst'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[T|Ts],Fun,Type,NType,L> when 'true' -> case apply 'setfun'/4 (T,Fun,Type,NType) of <{SD,ST}> when 'true' -> apply 'subst'/5 (Ts,Fun,Type,ST,[{T,SD}|L])
<Bad> when 'true' -> Bad end
<[],_X_Fun,_X_Type,NType,L> when 'true' -> {L,NType}
(<_10,_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7,_6})-|[{'function_name',{'subst',5}}] )-|['compiler_generated'] ) end
'projection1'/1 = fun (_0) -> case _0 of <[E|Es]> when 'true' -> let <_1> = call 'erlang':'element' (1,E) in apply 'projection1'/3 ([],_1,Es)
<L = []> when 'true' -> L
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'projection1',1}}] )-|['compiler_generated'] ) end
'projection1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <L,X,[E|Es]> when 'true' -> case call 'erlang':'element' (1,E) of <X1> when call 'erlang':'==' (X,X1) -> apply 'projection1'/3 (L,X,Es)
<X1> when 'true' -> apply 'projection1'/3 ([X|L],X1,Es) end
<L,X,[]> when 'true' -> call 'lists':'reverse' (L,[X|[]])
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'projection1',3}}] )-|['compiler_generated'] ) end
'projection_n'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Es],I,L> when 'true' -> let <_3> = call 'erlang':'element' (I,E) in apply 'projection_n'/3 (Es,I,[_3|L])
<[],_X_I,L> when 'true' -> call 'lists':'usort' (L)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'projection_n',3}}] )-|['compiler_generated'] ) end
'substitute_element'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[T|Ts],I,L> when 'true' -> let <_3> = call 'erlang':'element' (I,T) in apply 'substitute_element'/3 (Ts,I,[{T,_3}|L])
<_7,_X_I,L> when 'true' -> call 'lists':'reverse' (L) end
'substitute'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[T|Ts],Fun,L> when 'true' -> let <_3> = apply Fun (T) in apply 'substitute'/3 (Ts,Fun,[{T,_3}|L])
<_7,_X_Fun,L> when 'true' -> call 'lists':'reverse' (L) end
'partition_n'/2 = fun (_0,_1) -> case <_0,_1> of <I,[E|Ts]> when 'true' -> let <_2> = call 'erlang':'element' (I,E) in apply 'partition_n'/5 (I,Ts,_2,[E|[]],[])
<_X_I,[]> when 'true' -> []
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'partition_n',2}}] )-|['compiler_generated'] ) end
'partition_n'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <I,[E|Ts],K,Es,P> when 'true' -> let <_5> = call 'erlang':'element' (I,E) in case <_5,Es> of <K1,_15> when call 'erlang':'==' (K,K1) -> apply 'partition_n'/5 (I,Ts,K,[E|Es],P)
<K1,([_16|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when 'true' -> apply 'partition_n'/5 (I,Ts,K1,[E|[]],[Es|P])
<K1,_17> when 'true' -> let <_6> = call 'lists':'reverse' (Es) in apply 'partition_n'/5 (I,Ts,K1,[E|[]],[_6|P]) end
<I,[],_X_K,Es,P> when call 'erlang':'>' (I,1) -> let <_8> = call 'lists':'reverse' (Es) in call 'lists':'sort' ([_8|P])
<_X_I,[],_X_K,Es = [_18|[]],P> when 'true' -> call 'lists':'reverse' (P,[Es|[]])
<_X_I,[],_X_K,Es,P> when 'true' -> let <_9> = call 'lists':'reverse' (Es) in call 'lists':'reverse' (P,[_9|[]])
(<_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11,_10})-|[{'function_name',{'partition_n',5}}] )-|['compiler_generated'] ) end
'partition3_n'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <I,[T|Ts],Key,Keys,L1,L2> when 'true' -> case call 'erlang':'element' (I,T) of <K> when call 'erlang':'<' (K,Key) -> apply 'partition3_n'/6 (I,Ts,Key,Keys,L1,[T|L2])
<K> when call 'erlang':'==' (K,Key) -> apply 'partition3_n'/6 (I,Ts,Key,Keys,[T|L1],L2)
<K> when 'true' -> apply 'partition3_n'/7 (I,K,Ts,Keys,L1,L2,T) end
<I,_X_Ts,_X_Key,_X_Keys,L1,L2> when call 'erlang':'=:=' (I,1) -> let <_7> = call 'lists':'reverse' (L1) in let <_8> = call 'lists':'reverse' (L2) in [_7|_8]
<_X_I,_X_Ts,_X_Key,_X_Keys,L1,L2> when 'true' -> let <_9> = call 'lists':'sort' (L1) in let <_10> = call 'lists':'sort' (L2) in [_9|_10] end
'partition3_n'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <I,K,Ts,[Key|Keys],L1,L2,T> when call 'erlang':'>' (K,Key) -> apply 'partition3_n'/7 (I,K,Ts,Keys,L1,L2,T)
<I,K,Ts,[Key|Keys],L1,L2,T> when call 'erlang':'==' (K,Key) -> apply 'partition3_n'/6 (I,Ts,Key,Keys,[T|L1],L2)
<I,_X_K,Ts,[Key|Keys],L1,L2,T> when 'true' -> apply 'partition3_n'/6 (I,Ts,Key,Keys,L1,[T|L2])
<I,_X_K,Ts,_X_Keys,L1,L2,T> when call 'erlang':'=:=' (I,1) -> let <_7> = call 'lists':'reverse' (L1) in let <_8> = call 'lists':'reverse' (L2,[T|Ts]) in [_7|_8]
<_X_I,_X_K,Ts,_X_Keys,L1,L2,T> when 'true' -> let <_9> = call 'lists':'sort' (L1) in let <_10> = call 'erlang':'++' (Ts,L2) in let <_11> = call 'lists':'sort' ([T|_10]) in [_9|_11] end
'partition3'/2 = fun (_0,_1) -> case <_0,_1> of <[Key|Keys],Tuples> when 'true' -> apply 'partition3'/5 (Tuples,Key,Keys,[],[])
<_X_Keys,Tuples> when 'true' -> apply 'partition3_tail'/3 (Tuples,[],[]) end
'partition3'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{K,E}|Ts],Key,Keys,L1,L2> when call 'erlang':'<' (K,Key) -> apply 'partition3'/5 (Ts,Key,Keys,L1,[E|L2])
<[{K,E}|Ts],Key,Keys,L1,L2> when call 'erlang':'==' (K,Key) -> apply 'partition3'/5 (Ts,Key,Keys,[E|L1],L2)
<[{K,E}|Ts],_X_Key,Keys,L1,L2> when 'true' -> apply 'partition3'/6 (Ts,K,Keys,L1,L2,E)
<_X_Ts,_X_Key,_X_Keys,L1,L2> when 'true' -> [L1|L2] end
'partition3'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Ts,K,[Key|Keys],L1,L2,E> when call 'erlang':'>' (K,Key) -> apply 'partition3'/6 (Ts,K,Keys,L1,L2,E)
<Ts,K,[Key|Keys],L1,L2,E> when call 'erlang':'==' (K,Key) -> apply 'partition3'/5 (Ts,Key,Keys,[E|L1],L2)
<Ts,_X_K,[Key|Keys],L1,L2,E> when 'true' -> apply 'partition3'/5 (Ts,Key,Keys,L1,[E|L2])
<Ts,_X_K,_X_Keys,L1,L2,E> when 'true' -> apply 'partition3_tail'/3 (Ts,L1,[E|L2]) end
'partition3_tail'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{_X_K,E}|Ts],L1,L2> when 'true' -> apply 'partition3_tail'/3 (Ts,L1,[E|L2])
<_X_Ts,L1,L2> when 'true' -> [L1|L2] end
'replace'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Es],F,L> when 'true' -> let <_3> = apply F (E) in apply 'replace'/3 (Es,F,[_3|L])
<_7,_X_F,L> when 'true' -> call 'lists':'sort' (L) end
'mul_relprod'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[T = {'Set',_10,_11}|Ts],I,R> when ('true'-|['compiler_generated'] ) -> let <P> = apply 'raise_element'/2 (R,I) in let <F> = apply 'relative_product1'/2 (P,T) in let <_5> = call 'erlang':'+' (I,1) in let <_6> = apply 'mul_relprod'/3 (Ts,_5,R) in [F|_6]
<[],_X_I,_X_R> when 'true' -> []
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'mul_relprod',3}}] )-|['compiler_generated'] ) end
'raise_element'/2 = fun (_0,_1) -> let <_5> = call 'erlang':'=/=' (_1,1) in (case _0 of (<({'Set',_rec185,_13}-|['compiler_generated'] )> when 'true' -> let <_4> = apply 'rearr'/3 (_rec185,_1,[]) in let <L> = apply 'sort'/2 (_5,_4) in (case _0 of (<({'Set',_15,_rec186}-|['compiler_generated'] )> when 'true' -> let <_10> = call 'erlang':'element' (_1,_rec186) in {'Set',L,{_10,_rec186}}-|['compiler_generated'] )
(<_16> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'rearr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Es],I,L> when 'true' -> let <_3> = call 'erlang':'element' (I,E) in apply 'rearr'/3 (Es,I,[{_3,E}|L])
<[],_X_I,L> when 'true' -> L
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'rearr',3}}] )-|['compiler_generated'] ) end
'join_element'/2 = fun (_0,_1) -> case call 'erlang':'tuple_to_list' (_1) of <[_7|L2]> when 'true' -> let <_3> = call 'erlang':'tuple_to_list' (_0) in let <_4> = call 'erlang':'++' (_3,L2) in call 'erlang':'list_to_tuple' (_4)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'join_element'/3 = fun (_0,_1,_2) -> let <_5> = call 'erlang':'tuple_to_list' (_0) in let <_3> = call 'erlang':'tuple_to_list' (_1) in let <_4> = apply 'join_element2'/3 (_3,1,_2) in call 'erlang':'++' (_5,_4)
'join_element2'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[B|Bs],C,I2> when call 'erlang':'=/=' (C,I2) -> let <_3> = call 'erlang':'+' (C,1) in let <_4> = apply 'join_element2'/3 (Bs,_3,I2) in [B|_4]
<[_8|Bs],_X_C,_X_I2> when 'true' -> Bs
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'join_element2',3}}] )-|['compiler_generated'] ) end
'family2rel'/2 = fun (_0,_1) -> case <_0,_1> of <[{X,S}|F],L> when 'true' -> apply 'fam2rel'/4 (F,L,X,S)
<[],L> when 'true' -> call 'lists':'reverse' (L)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'family2rel',2}}] )-|['compiler_generated'] ) end
'fam2rel'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <F,L,X,[Y|Ys]> when 'true' -> apply 'fam2rel'/4 (F,[{X,Y}|L],X,Ys)
<F,L,_X_X,_8> when 'true' -> apply 'family2rel'/2 (F,L) end
'fam_spec'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[E = {_9,S}|F],Fun,Type,L> when 'true' -> case apply Fun ({'Set',S,Type}) of <'true'> when 'true' -> apply 'fam_spec'/4 (F,Fun,Type,[E|L])
<'false'> when 'true' -> apply 'fam_spec'/4 (F,Fun,Type,L)
<_10> when 'true' -> 'badarg' end
<[],_X_Fun,_X_Type,L> when 'true' -> call 'lists':'reverse' (L)
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'fam_spec',4}}] )-|['compiler_generated'] ) end
'fam_specification'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E = {_7,S}|F],Fun,L> when 'true' -> case apply Fun (S) of <'true'> when 'true' -> apply 'fam_specification'/3 (F,Fun,[E|L])
<'false'> when 'true' -> apply 'fam_specification'/3 (F,Fun,L)
<_8> when 'true' -> 'badarg' end
<[],_X_Fun,L> when 'true' -> call 'lists':'reverse' (L)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'fam_specification',3}}] )-|['compiler_generated'] ) end
'un_of_fam'/2 = fun (_0,_1) -> case <_0,_1> of <[{_X_X,S}|F],L> when 'true' -> apply 'un_of_fam'/2 (F,[S|L])
<[],L> when 'true' -> let <_2> = call 'lists':'sort' (L) in apply 'lunion'/1 (_2)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'un_of_fam',2}}] )-|['compiler_generated'] ) end
'int_of_fam'/1 = fun (_0) -> case _0 of <[{_2,S}|F]> when 'true' -> apply 'int_of_fam'/2 (F,[S|[]])
<[]> when 'true' -> 'badarg'
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'int_of_fam',1}}] )-|['compiler_generated'] ) end
'int_of_fam'/2 = fun (_0,_1) -> case <_0,_1> of <[{_4,S}|F],L> when 'true' -> apply 'int_of_fam'/2 (F,[S|L])
<[],[L|Ls]> when 'true' -> apply 'lintersection'/2 (Ls,L)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'int_of_fam',2}}] )-|['compiler_generated'] ) end
'fam_un'/2 = fun (_0,_1) -> case <_0,_1> of <[{X,S}|F],L> when 'true' -> let <_2> = apply 'lunion'/1 (S) in apply 'fam_un'/2 (F,[{X,_2}|L])
<[],L> when 'true' -> call 'lists':'reverse' (L)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'fam_un',2}}] )-|['compiler_generated'] ) end
'fam_int'/2 = fun (_0,_1) -> case <_0,_1> of <[{X,[S|Ss]}|F],L> when 'true' -> let <_2> = apply 'lintersection'/2 (Ss,S) in apply 'fam_int'/2 (F,[{X,_2}|L])
<[{_X_X,[]}|_X_F],_X_L> when 'true' -> 'badarg'
<[],L> when 'true' -> call 'lists':'reverse' (L)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'fam_int',2}}] )-|['compiler_generated'] ) end
'fam_dom'/2 = fun (_0,_1) -> case <_0,_1> of <[{X,S}|F],L> when 'true' -> let <_2> = apply 'dom'/1 (S) in apply 'fam_dom'/2 (F,[{X,_2}|L])
<[],L> when 'true' -> call 'lists':'reverse' (L)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'fam_dom',2}}] )-|['compiler_generated'] ) end
'fam_ran'/2 = fun (_0,_1) -> case <_0,_1> of <[{X,S}|F],L> when 'true' -> let <_2> = apply 'ran'/2 (S,[]) in apply 'fam_ran'/2 (F,[{X,_2}|L])
<[],L> when 'true' -> call 'lists':'reverse' (L)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'fam_ran',2}}] )-|['compiler_generated'] ) end
'fam_union'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F1 = [{A,_X_AS}|_X_AL],[B1 = {B,_X_BS}|BL],L> when call 'erlang':'>' (A,B) -> apply 'fam_union'/3 (F1,BL,[B1|L])
<[{A,AS}|AL],[{B,BS}|BL],L> when call 'erlang':'==' (A,B) -> let <_3> = call 'lists':'umerge' (AS,BS) in apply 'fam_union'/3 (AL,BL,[{A,_3}|L])
<[A1|AL],F2,L> when 'true' -> apply 'fam_union'/3 (AL,F2,[A1|L])
<_7,F2,L> when 'true' -> call 'lists':'reverse' (L,F2) end
'fam_intersect'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F1 = [{A,_X_AS}|_X_AL],[{B,_X_BS}|BL],L> when call 'erlang':'>' (A,B) -> apply 'fam_intersect'/3 (F1,BL,L)
<[{A,AS}|AL],[{B,BS}|BL],L> when call 'erlang':'==' (A,B) -> let <_3> = apply 'intersection'/3 (AS,BS,[]) in apply 'fam_intersect'/3 (AL,BL,[{A,_3}|L])
<[_X_A1|AL],F2,L> when 'true' -> apply 'fam_intersect'/3 (AL,F2,L)
<_7,_8,L> when 'true' -> call 'lists':'reverse' (L) end
'fam_difference'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F1 = [{A,_X_AS}|_X_AL],[{B,_X_BS}|BL],L> when call 'erlang':'>' (A,B) -> apply 'fam_difference'/3 (F1,BL,L)
<[{A,AS}|AL],[{B,BS}|BL],L> when call 'erlang':'==' (A,B) -> let <_3> = apply 'difference'/3 (AS,BS,[]) in apply 'fam_difference'/3 (AL,BL,[{A,_3}|L])
<[A1|AL],F2,L> when 'true' -> apply 'fam_difference'/3 (AL,F2,[A1|L])
<F1,_7,L> when 'true' -> call 'lists':'reverse' (L,F1) end
'check_function'/2 = fun (_0,_1) -> case <_0,_1> of <[{X,_4}|XL],R> when 'true' -> apply 'check_function'/3 (X,XL,R)
<[],R> when 'true' -> R
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'check_function',2}}] )-|['compiler_generated'] ) end
'check_function'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <X0,[{X,_6}|XL],R> when call 'erlang':'/=' (X0,X) -> apply 'check_function'/3 (X,XL,R)
<X0,[{X,_7}|_X_XL],_X_R> when call 'erlang':'==' (X0,X) -> 'bad_function'
<_X_X0,[],R> when 'true' -> R
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'check_function',3}}] )-|['compiler_generated'] ) end
'fam_partition_n'/2 = fun (_0,_1) -> case <_0,_1> of <I,[E|Ts]> when 'true' -> let <_2> = call 'erlang':'element' (I,E) in apply 'fam_partition_n'/5 (I,Ts,_2,[E|[]],[])
<_X_I,[]> when 'true' -> []
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'fam_partition_n',2}}] )-|['compiler_generated'] ) end
'fam_partition_n'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <I,[E|Ts],K,Es,P> when 'true' -> let <_5> = call 'erlang':'element' (I,E) in case <_5,Es> of <K1,_14> when call 'erlang':'==' (K,K1) -> apply 'fam_partition_n'/5 (I,Ts,K,[E|Es],P)
<K1,([_15|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when 'true' -> apply 'fam_partition_n'/5 (I,Ts,K1,[E|[]],[{K,Es}|P])
<K1,_16> when 'true' -> let <_6> = call 'lists':'reverse' (Es) in apply 'fam_partition_n'/5 (I,Ts,K1,[E|[]],[{K,_6}|P]) end
<_X_I,[],K,Es = [_17|[]],P> when 'true' -> call 'lists':'reverse' (P,[{K,Es}|[]])
<_X_I,[],K,Es,P> when 'true' -> let <_8> = call 'lists':'reverse' (Es) in call 'lists':'reverse' (P,[{K,_8}|[]])
(<_13,_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10,_9})-|[{'function_name',{'fam_partition_n',5}}] )-|['compiler_generated'] ) end
'fam_partition'/2 = fun (_0,_1) -> case <_0,_1> of <[{K,Vs}|Ts],Sort> when 'true' -> apply 'fam_partition'/5 (Ts,K,[Vs|[]],[],Sort)
<[],_X_Sort> when 'true' -> []
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'fam_partition',2}}] )-|['compiler_generated'] ) end
'fam_partition'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{K1,V}|Ts],K,Vs,P,S> when call 'erlang':'==' (K1,K) -> apply 'fam_partition'/5 (Ts,K,[V|Vs],P,S)
<[{K1,V}|Ts],K,Vs = [_12|[]],P,S> when 'true' -> apply 'fam_partition'/5 (Ts,K1,[V|[]],[{K,Vs}|P],S)
<[{K1,V}|Ts],K,Vs,P,S> when 'true' -> let <_5> = apply 'sort'/2 (S,Vs) in apply 'fam_partition'/5 (Ts,K1,[V|[]],[{K,_5}|P],S)
<[],K,Vs = [_13|[]],P,_X_S> when 'true' -> [{K,Vs}|P]
<[],K,Vs,P,S> when 'true' -> let <_6> = apply 'sort'/2 (S,Vs) in [{K,_6}|P]
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'fam_partition',5}}] )-|['compiler_generated'] ) end
'fam_proj'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{X,S}|F],Fun,Type,NType,L> when 'true' -> case apply 'setfun'/4 (S,Fun,Type,NType) of <{SD,ST}> when 'true' -> apply 'fam_proj'/5 (F,Fun,Type,ST,[{X,SD}|L])
<Bad> when 'true' -> Bad end
<[],_X_Fun,_X_Type,NType,L> when 'true' -> let <_6> = call 'lists':'reverse' (L) in {_6,NType}
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'fam_proj',5}}] )-|['compiler_generated'] ) end
'setfun'/4 = fun (_0,_1,_2,_3) -> let <_4> = case <_0,_2> of (<L,_37> when (call ('erlang'-|['compiler_generated'] ):('is_list'-|['compiler_generated'] ) (L)-|['compiler_generated'] ) -> ({('Set'-|['compiler_generated'] ),L,_37}-|['compiler_generated'] )-|['compiler_generated'] )
(<_38,_39> when ('true'-|['compiler_generated'] ) -> ({('OrdSet'-|['compiler_generated'] ),_38,_39}-|['compiler_generated'] )-|['compiler_generated'] ) end in case apply _1 (_4) of <NS = {'Set',_21,_22}> when ('true'-|['compiler_generated'] ) -> (case NS of (<({'Set',_23,_rec187}-|['compiler_generated'] )> when 'true' -> let <_41> = [_rec187|([]-|['compiler_generated'] )] in case (case <_3,_41> of (<_42,_43> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_43,_42)-|['compiler_generated'] ) -> _42-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> 'type_mismatch'
<NT> when 'true' -> (case NS of (<({'Set',_rec188,_25}-|['compiler_generated'] )> when 'true' -> {_rec188,NT}-|['compiler_generated'] )
(<_26> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_24> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<NS = {'OrdSet',_27,_28}> when ('true'-|['compiler_generated'] ) -> (case NS of (<({'OrdSet',_29,_rec189}-|['compiler_generated'] )> when 'true' -> case (case <_3,_rec189> of (<_46,_47> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (_47,_46)-|['compiler_generated'] ) -> _46-|['compiler_generated'] )
(<Type1,Type2> when ('true'-|['compiler_generated'] ) -> (catch (apply 'unify_types1'/2 (Type1,Type2)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) of <[]> when 'true' -> 'type_mismatch'
<_31> when call 'erlang':'=:=' (_31,_rec189) -> (case NS of (<({'OrdSet',_rec190,_32}-|['compiler_generated'] )> when 'true' -> {_rec190,_rec189}-|['compiler_generated'] )
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_30> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','OrdSet'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_34> when 'true' -> 'badarg' end
'term2set'/2 = fun (_0,_1) -> case <_0,_1> of <L,Type> when call 'erlang':'is_list' (L) -> {'Set',L,Type}
<T,Type> when 'true' -> {'OrdSet',T,Type} end
'fam2digraph'/2 = fun (_0,_1) -> let <Fun> = fun (_6) -> case _6 of <{From,ToL}> when 'true' -> do call 'digraph':'add_vertex' (_1,From) let <Fun2> = fun (_3) -> do call 'digraph':'add_vertex' (_1,_3) case call 'digraph':'add_edge' (_1,From,_3) of <{'error',{'bad_edge',_12}}> when 'true' -> call 'erlang':'throw' ({'error','cyclic'})
<_13> when 'true' -> 'true' end in call 'lists':'foreach' (Fun2,ToL)
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'-fam2digraph/2-fun-1-',1}}] )-|['compiler_generated'] ) end in let <_9> = apply 'to_external'/1 (_0) in do call 'lists':'foreach' (Fun,_9) _1
'digraph_family'/1 = fun (_0) -> let <_1> = call 'digraph':'vertices' (_0) in let <Vs> = call 'lists':'sort' (_1) in apply 'digraph_fam'/4 (Vs,Vs,_0,[])
'digraph_fam'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[V|Vs],V0,G,L> when call 'erlang':'/=' (V,V0) -> let <_4> = call 'digraph':'out_neighbours' (G,V) in let <Ns> = call 'lists':'sort' (_4) in apply 'digraph_fam'/4 (Vs,V,G,[{V,Ns}|L])
<[],_X_V0,_X_G,L> when 'true' -> call 'lists':'reverse' (L)
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'digraph_fam',4}}] )-|['compiler_generated'] ) end
'check_fun'/3 = fun (_0,_1,_2) -> case apply 'is_type'/1 (_2) of <'true'> when 'true' -> case apply 'number_tuples'/2 (_0,1) of <{NT,_X_MaxI}> when 'true' -> let <_5> = apply _1 (NT) in let <_6> = apply 'tuple2list'/1 (_5) in let <L> = call 'lists':'flatten' (_6) in apply 'has_hole'/2 (L,1)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'number_tuples'/2 = fun (_0,_1) -> case <_0,_1> of <T,N> when call 'erlang':'is_tuple' (T) -> let <_3> = 'number_tuples'/2 in let <_2> = call 'erlang':'tuple_to_list' (T) in case call 'lists':'mapfoldl' (_3,N,_2) of <{L,NN}> when 'true' -> let <_5> = call 'erlang':'list_to_tuple' (L) in {_5,NN}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<_9,N> when 'true' -> let <_6> = call 'erlang':'+' (N,1) in {N,_6} end
'tuple2list'/1 = fun (_0) -> case _0 of <T> when call 'erlang':'is_tuple' (_0) -> let <_2> = 'tuple2list'/1 in let <_1> = call 'erlang':'tuple_to_list' (T) in call 'lists':'map' (_2,_1)
<C> when 'true' -> [C|[]] end
'has_hole'/2 = fun (_0,_1) -> case <_0,_1> of <[I|Is],I0> when call 'erlang':'=<' (I,I0) -> let <_2> = call 'erlang':'+' (I,1) in let <_3> = call 'erlang':'max' (_2,I0) in apply 'has_hole'/2 (Is,_3)
<Is,_X_I> when 'true' -> call 'erlang':'=/=' (Is,[]) end
'check_for_sort'/2 = fun (_0,_1) -> case <_0,_1> of <T,_X_I> when call 'erlang':'=:=' (T,'_') -> 'empty'
<T,I> when try let <_2> = call 'erlang':'is_tuple' (T) in let <_3> = call 'erlang':'tuple_size' (T) in let <_4> = call 'erlang':'=<' (I,_3) in let <_5> = call 'erlang':'>=' (I,1) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_2,_6) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'>' (I,1)
<_X_T,_X_I> when 'true' -> 'error' end
'inverse_substitution'/3 = fun (_0,_1,_2) -> let <_3> = apply 'fun_rearr'/3 (_0,_1,[]) in apply 'sort'/2 (_2,_3)
'fun_rearr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[E|Es],Fun,L> when 'true' -> let <_3> = apply Fun (E) in apply 'fun_rearr'/3 (Es,Fun,[{_3,E}|L])
<[],_X_Fun,L> when 'true' -> L
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'fun_rearr',3}}] )-|['compiler_generated'] ) end
'sets_to_list'/1 = fun (_0) -> let <_4> = fun (_2) -> case _2 of <S = {'Set',_6,_7}> when ('true'-|['compiler_generated'] ) -> (case S of (<({'Set',_rec191,_8}-|['compiler_generated'] )> when 'true' -> _rec191-|['compiler_generated'] )
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'-sets_to_list/1-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'map' (_4,_0)
'types'/2 = fun (_0,_1) -> case <_0,_1> of <[],L> when 'true' -> let <_2> = call 'lists':'reverse' (L) in call 'erlang':'list_to_tuple' (_2)
<[S = {'Set',_13,_14}|_X_Ss],_X_L> when (try let <_7> = call 'erlang':'element' (3,S) in call 'erlang':'=:=' (_7,'_') of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> '_'
<[S|Ss],L> when 'true' -> (case S of (<({'Set',_15,_rec192}-|['compiler_generated'] )> when 'true' -> apply 'types'/2 (Ss,[_rec192|L])-|['compiler_generated'] )
(<_16> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','Set'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'types',2}}] )-|['compiler_generated'] ) end
'unify_types'/2 = fun (_0,_1) -> case <_0,_1> of <T,_4> when call 'erlang':'=:=' (_4,T) -> T
<Type1,Type2> when 'true' -> catch apply 'unify_types1'/2 (Type1,Type2) end
'unify_types1'/2 = fun (_0,_1) -> case <_0,_1> of <Atom,_8> when let <_9> = call 'erlang':'=:=' (_8,Atom) in let <_10> = call 'erlang':'is_atom' (Atom) in call 'erlang':'and' (_9,_10) -> Atom
<'_',Type> when 'true' -> Type
<Type,'_'> when 'true' -> Type
<[Type1|[]],[Type2|[]]> when 'true' -> let <_2> = apply 'unify_types1'/2 (Type1,Type2) in [_2|[]]
<T1,T2> when try let <_4> = call 'erlang':'tuple_size' (T1) in let <_3> = call 'erlang':'tuple_size' (T2) in call 'erlang':'=:=' (_4,_3) of <Try> -> Try catch <T,R> -> 'false' -> let <_5> = call 'erlang':'tuple_size' (T1) in apply 'unify_typesl'/4 (_5,T1,T2,[])
<_X_T1,_X_T2> when 'true' -> call 'erlang':'throw' ([]) end
'unify_typesl'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <0,_X_T1,_X_T2,L> when 'true' -> call 'erlang':'list_to_tuple' (L)
<N,T1,T2,L> when 'true' -> let <_5> = call 'erlang':'element' (N,T1) in let <_4> = call 'erlang':'element' (N,T2) in let <T> = apply 'unify_types1'/2 (_5,_4) in let <_7> = call 'erlang':'-' (N,1) in apply 'unify_typesl'/4 (_7,T1,T2,[T|L]) end
'match_types'/2 = fun (_0,_1) -> case <_0,_1> of <T,_4> when call 'erlang':'=:=' (_4,T) -> 'true'
<Type1,Type2> when 'true' -> apply 'match_types1'/2 (Type1,Type2) end
'match_types1'/2 = fun (_0,_1) -> case <_0,_1> of <Atom,_7> when let <_8> = call 'erlang':'=:=' (_7,Atom) in let <_9> = call 'erlang':'is_atom' (Atom) in call 'erlang':'and' (_8,_9) -> 'true'
<'_',_10> when 'true' -> 'true'
<_11,'_'> when 'true' -> 'true'
<[Type1|[]],[Type2|[]]> when 'true' -> apply 'match_types1'/2 (Type1,Type2)
<T1,T2> when try let <_3> = call 'erlang':'tuple_size' (T1) in let <_2> = call 'erlang':'tuple_size' (T2) in call 'erlang':'=:=' (_3,_2) of <Try> -> Try catch <T,R> -> 'false' -> let <_4> = call 'erlang':'tuple_size' (T1) in apply 'match_typesl'/3 (_4,T1,T2)
<_X_T1,_X_T2> when 'true' -> 'false' end
'match_typesl'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <0,_X_T1,_X_T2> when 'true' -> 'true'
<N,T1,T2> when 'true' -> let <_4> = call 'erlang':'element' (N,T1) in let <_3> = call 'erlang':'element' (N,T2) in case apply 'match_types1'/2 (_4,_3) of <'true'> when 'true' -> let <_5> = call 'erlang':'-' (N,1) in apply 'match_typesl'/3 (_5,T1,T2)
<'false'> when 'true' -> 'false'
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end end
'sort'/2 = fun (_0,_1) -> case <_0,_1> of <'true',L> when 'true' -> call 'lists':'sort' (L)
<'false',L> when 'true' -> call 'lists':'reverse' (L)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'sort',2}}] )-|['compiler_generated'] ) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('sofs')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('sofs',_0) end