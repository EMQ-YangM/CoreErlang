module 'qlc_pt' ['module_info'/0,'module_info'/1,'parse_transform'/2,'transform_expression'/2,'transform_from_evaluator'/2] attributes [ 'file' = [{[115|[114|[99|[47|[113|[108|[99|[95|[112|[116|[46|[101|[114|[108]]]]]]]]]]]]]],1}]
, 'file' = [{[47|[117|[115|[114|[47|[108|[111|[99|[97|[108|[47|[67|[101|[108|[108|[97|[114|[47|[101|[114|[108|[97|[110|[103|[47|[50|[50|[46|[50|[47|[108|[105|[98|[47|[101|[114|[108|[97|[110|[103|[47|[108|[105|[98|[47|[115|[116|[100|[108|[105|[98|[45|[51|[46|[49|[49|[47|[105|[110|[99|[108|[117|[100|[101|[47|[109|[115|[95|[116|[114|[97|[110|[115|[102|[111|[114|[109|[46|[104|[114|[108]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],1}]
, 'file' = [{[115|[114|[99|[47|[113|[108|[99|[95|[112|[116|[46|[101|[114|[108]]]]]]]]]]]]]],28}]
, 'record' = [{'qlc_lc',[{'record_field',39,{'atom',39,'lc'}}|[{'record_field',40,{'atom',40,'opt'}}]]}]
, 'record' = [{'state',[{'record_field',43,{'atom',43,'imp'}}|[{'record_field',44,{'atom',44,'overridden'}}|[{'record_field',45,{'atom',45,'maxargs'}}|[{'record_field',46,{'atom',46,'records'}}|[{'record_field',47,{'atom',47,'xwarnings'},{'nil',47}}|[{'record_field',48,{'atom',48,'intro_vars'}}|[{'record_field',49,{'atom',49,'node_info'}}]]]]]]]}]
, 'spec' = [{{'parse_transform',2},[{'type',70,'bounded_fun',[{'type',70,'fun',[{'type',70,'product',[{'var',70,'Forms'}|[{'var',70,'Options'}]]}|[{'var',70,'Forms2'}]]}|[[{'type',71,'constraint',[{'atom',71,'is_subtype'}|[[{'var',71,'Forms'}|[{'type',71,'list',[{'type',71,'union',[{'remote_type',71,[{'atom',71,'erl_parse'}|[{'atom',71,'abstract_form'}|[[]]]]}|[{'remote_type',71,[{'atom',71,'erl_parse'}|[{'atom',71,'form_info'}|[[]]]]}]]}]}]]]]}|[{'type',72,'constraint',[{'atom',72,'is_subtype'}|[[{'var',72,'Forms2'}|[{'type',72,'list',[{'type',72,'union',[{'remote_type',72,[{'atom',72,'erl_parse'}|[{'atom',72,'abstract_form'}|[[]]]]}|[{'remote_type',72,[{'atom',72,'erl_parse'}|[{'atom',72,'form_info'}|[[]]]]}]]}]}]]]]}|[{'type',73,'constraint',[{'atom',73,'is_subtype'}|[[{'var',73,'Options'}|[{'type',73,'list',[{'var',73,'Option'}]}]]]]}|[{'type',74,'constraint',[{'atom',74,'is_subtype'}|[[{'var',74,'Option'}|[{'type',74,'union',[{'atom',74,'type_checker'}|[{'remote_type',74,[{'atom',74,'compile'}|[{'atom',74,'option'}|[[]]]]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'transform_from_evaluator',2},[{'type',121,'bounded_fun',[{'type',121,'fun',[{'type',121,'product',[{'var',121,'LC'}|[{'var',121,'Bs'}]]}|[{'var',121,'Return'}]]}|[[{'type',122,'constraint',[{'atom',122,'is_subtype'}|[[{'var',122,'LC'}|[{'remote_type',122,[{'atom',122,'erl_parse'}|[{'atom',122,'abstract_expr'}|[[]]]]}]]]]}|[{'type',123,'constraint',[{'atom',123,'is_subtype'}|[[{'var',123,'Bs'}|[{'remote_type',123,[{'atom',123,'erl_eval'}|[{'atom',123,'binding_struct'}|[[]]]]}]]]]}|[{'type',124,'constraint',[{'atom',124,'is_subtype'}|[[{'var',124,'Return'}|[{'type',124,'union',[{'type',124,'tuple',[{'atom',124,'ok'}|[{'remote_type',124,[{'atom',124,'erl_parse'}|[{'atom',124,'abstract_expr'}|[[]]]]}]]}|[{'type',125,'tuple',[{'atom',125,'not_ok'}|[{'type',125,'tuple',[{'atom',125,'error'}|[{'type',125,'module',[]}|[{'ann_type',125,[{'var',125,'Reason'}|[{'type',125,'term',[]}]]}]]]}]]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'transform_expression',2},[{'type',131,'bounded_fun',[{'type',131,'fun',[{'type',131,'product',[{'var',131,'LC'}|[{'var',131,'Bs'}]]}|[{'var',131,'Return'}]]}|[[{'type',132,'constraint',[{'atom',132,'is_subtype'}|[[{'var',132,'LC'}|[{'remote_type',132,[{'atom',132,'erl_parse'}|[{'atom',132,'abstract_expr'}|[[]]]]}]]]]}|[{'type',133,'constraint',[{'atom',133,'is_subtype'}|[[{'var',133,'Bs'}|[{'remote_type',133,[{'atom',133,'erl_eval'}|[{'atom',133,'binding_struct'}|[[]]]]}]]]]}|[{'type',134,'constraint',[{'atom',134,'is_subtype'}|[[{'var',134,'Return'}|[{'type',134,'union',[{'type',134,'tuple',[{'atom',134,'ok'}|[{'remote_type',134,[{'atom',134,'erl_parse'}|[{'atom',134,'abstract_expr'}|[[]]]]}]]}|[{'type',135,'tuple',[{'atom',135,'not_ok'}|[{'type',135,'list',[{'type',135,'tuple',[{'atom',135,'error'}|[{'ann_type',135,[{'var',135,'Reason'}|[{'type',135,'term',[]}]]}]]}]}]]}]]}]]]]}]]]]]}]}]
, 'record' = [{'qid',[{'record_field',230,{'atom',230,'lcid'}}|[{'record_field',230,{'atom',230,'no'}}]]}]
, 'record' = [{'fstate',[{'record_field',1659,{'atom',1659,'state'}}|[{'record_field',1659,{'atom',1659,'bind_fun'}}|[{'record_field',1659,{'atom',1659,'imported'}}]]]}]
, 'record' = [{'bind',[{'record_field',1982,{'atom',1982,'var'}}|[{'record_field',1982,{'atom',1982,'value'}}|[{'record_field',1982,{'atom',1982,'op'}}]]]}] ] 'parse_transform'/2 = fun (_0,_1) -> let <Imported> = apply 'is_qlc_q_imported'/1 (_0) in case apply 'initiate'/2 (_0,Imported) of <{Forms,FormsNoShadows,State}> when 'true' -> (case State of (<({'state',_38,_39,_40,_41,_42,_43,_rec0}-|['compiler_generated'] )> when 'true' -> letrec 'after$^1'/0 = fun () -> let <_45> = call 'ets':'delete' (_rec0) in case _45 of <'true'> when 'true' -> (_45-|['compiler_generated'] )
(<_31> when 'true' -> primop 'match_fail' ({'badmatch',_31})-|['compiler_generated'] ) end in try case apply 'called_from_type_checker'/1 (_1) of <'true'> when 'true' -> let <L> = apply 'anno0'/0 () in case apply 'abstr'/2 ({'qlc_lc','undefined','undefined'},L) of <{'tuple',_46,Fs0}> when 'true' -> let <F> = fun (_13,_12,_11) -> let <Init> = apply 'simple'/4 (L,'V',_12,L) in let <_10> = apply 'set_field'/3 (2,Fs0,Init) in {{'tuple',L,_10},_11} in case apply 'qlc_mapfold'/4 (F,'ok',Forms,State) of <{Forms1,'ok'}> when 'true' -> Forms1
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<'false'> when 'true' -> case apply 'compile_messages'/4 (Forms,FormsNoShadows,_1,State) of <{[],Warnings}> when 'true' -> case apply 'transform'/2 (FormsNoShadows,State) of <{NewForms,State1}> when 'true' -> (case State1 of (<({'state',_47,_48,_49,_50,_rec1,_51,_52}-|['compiler_generated'] )> when 'true' -> case apply 'no_duplicates'/5 (NewForms,[],Warnings,_rec1,_1) of <{[],WForms}> when 'true' -> let <_25> = apply 'restore_locations'/2 (WForms,State) in let <_24> = apply 'restore_anno'/2 (NewForms,_rec0) in call 'erlang':'++' (_25,_24)
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_53> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<{Errors,Warnings}> when 'true' -> case apply 'no_duplicates'/5 (FormsNoShadows,Errors,Warnings,[],_1) of <{EForms,WForms}> when 'true' -> let <_27> = call 'erlang':'++' (EForms,WForms) in let <_28> = apply 'restore_locations'/2 (_27,State) in call 'erlang':'++' (_28,_0)
(<_26> when 'true' -> primop 'match_fail' ({'badmatch',_26})-|['compiler_generated'] ) end
(<_29> when 'true' -> primop 'match_fail' ({'case_clause',_29})-|['compiler_generated'] ) end
(<_30> when 'true' -> primop 'match_fail' ({'case_clause',_30})-|['compiler_generated'] ) end of <_32> -> do (apply 'after$^1'/0 ()-|['compiler_generated'] ) _32 catch <_35,_34,_33> -> do (apply 'after$^1'/0 ()-|['compiler_generated'] ) primop 'raise' (_33,_34)-|['compiler_generated'] )
(<_44> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'transform_from_evaluator'/2 = fun (_0,_1) -> apply 'transform_expression'/3 (_0,_1,'false')
'transform_expression'/2 = fun (_0,_1) -> apply 'transform_expression'/3 (_0,_1,'true')
'called_from_type_checker'/1 = fun (_0) -> call 'lists':'member' ('type_checker',_0)
'transform_expression'/3 = fun (_0,_1,_2) -> let <L> = apply 'anno1'/0 () in let <_8> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{V,_X_Val}|_5]> when 'true' -> let <_7> = apply 'lc$^0'/1 (_5) in ([{'var',L,V}|_7]-|['compiler_generated'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_56> when 'true' -> (primop 'match_fail' ({'function_clause',_56})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1) in let <Ar> = call 'erlang':'length' (_8) in let <F> = {'function',L,'bar',Ar,[{'clause',L,_8,[],[{'call',L,{'remote',L,{'atom',L,'qlc'},{'atom',L,'q'}},[_0|[]]}|[]]}|[]]} in let <Forms0> = [{'attribute',L,'file',{[102|[111|[111]]],L}}|[{'attribute',L,'module','foo'}|[F|[]]]] in case apply 'initiate'/2 (Forms0,'false') of <{Forms,FormsNoShadows,State}> when 'true' -> (case State of (<({'state',_37,_38,_39,_40,_41,_42,_rec2}-|['compiler_generated'] )> when 'true' -> letrec 'after$^1'/0 = fun () -> let <_44> = call 'ets':'delete' (_rec2) in case _44 of <'true'> when 'true' -> (_44-|['compiler_generated'] )
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end in try try apply 'compile_messages'/4 (Forms,FormsNoShadows,[],State) of <_18> -> case _18 of <{Errors0,_X_Warnings}> when 'true' -> case apply 'restore_locations'/2 (Errors0,State) of <[]> when 'true' -> case apply 'transform'/2 (FormsNoShadows,State) of <{NewForms,_X_State1}> when 'true' -> let <NewForms1> = apply 'restore_anno'/2 (NewForms,_rec2) in case call 'lists':'last' (NewForms1) of <{'function',_45,'bar',_46,[{'clause',_47,_48,[],[NF|[]]}|[]]}> when let <_53> = call 'erlang':'=:=' (_45,L) in let <_51> = call 'erlang':'=:=' (_46,Ar) in let <_49> = call 'erlang':'=:=' (_47,L) in let <_50> = call 'erlang':'=:=' (_48,_8) in let <_52> = call 'erlang':'and' (_49,_50) in let <_54> = call 'erlang':'and' (_51,_52) in call 'erlang':'and' (_53,_54) -> {'ok',NF}
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<Errors> when (call 'erlang':'=:=' (_2,'true')-|['compiler_generated'] ) -> let <_22> = apply 'mforms'/2 ('error',Errors) in {'not_ok',_22}
<Errors> when 'true' -> case apply 'mforms'/2 ('error',Errors) of <[{'error',Reason}|_55]> when 'true' -> {'not_ok',{'error','qlc',Reason}}
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end end
(<_25> when 'true' -> primop 'match_fail' ({'try_clause',_25})-|['compiler_generated'] ) end catch <_28,_27,_26> -> primop 'raise' (_26,_27) of <_30> -> do (apply 'after$^1'/0 ()-|['compiler_generated'] ) _30 catch <_33,_32,_31> -> do (apply 'after$^1'/0 ()-|['compiler_generated'] ) primop 'raise' (_31,_32)-|['compiler_generated'] )
(<_43> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
'initiate'/2 = fun (_0,_1) -> let <NodeInfo> = call 'ets':'new' ('qlc',[]) in case call 'ets':'insert' (NodeInfo,{'var_n',0}) of <'true'> when 'true' -> do apply 'exclude_integers_from_unique_line_numbers'/2 (_0,NodeInfo) let <IsOverridden> = apply 'set_up_overridden'/1 (_0) in let <_5> = apply 'record_attributes'/1 (_0) in let <State0> = {'state',_1,IsOverridden,20,_5,[],'undefined',NodeInfo} in let <Forms> = apply 'save_anno'/2 (_0,NodeInfo) in let <FormsNoShadows> = apply 'no_shadows'/2 (Forms,State0) in let <IntroVars> = apply 'intro_variables'/2 (FormsNoShadows,State0) in let <_12> = call 'erlang':'setelement' (7,State0,IntroVars) in {Forms,FormsNoShadows,_12}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'exclude_integers_from_unique_line_numbers'/2 = fun (_0,_1) -> let <Integers> = apply 'find_integers'/1 (_0) in let <_5> = fun (_3) -> call 'ets':'insert' (_1,{_3}) in call 'lists':'foreach' (_5,Integers)
'find_integers'/1 = fun (_0) -> let <F> = fun (_6) -> let <_3> = fun (_1) -> _6 in let <Fs1> = apply 'map_anno'/2 (_3,_0) in let <_5> = apply 'integers'/2 (Fs1,[]) in call 'ordsets':'from_list' (_5) in let <_11> = apply 'anno0'/0 () in let <_12> = apply F (_11) in let <_9> = apply 'anno1'/0 () in let <_10> = apply F (_9) in let <_13> = call 'ordsets':'intersection' (_12,_10) in call 'ordsets':'to_list' (_13)
'integers'/2 = fun (_0,_1) -> case <_0,_1> of <[E|Es],L> when 'true' -> let <_2> = apply 'integers'/2 (E,L) in apply 'integers'/2 (Es,_2)
<T,L> when call 'erlang':'is_tuple' (T) -> let <_3> = call 'erlang':'tuple_to_list' (T) in apply 'integers'/2 (_3,L)
<I,L> when let <_4> = call 'erlang':'is_integer' (I) in let <_5> = call 'erlang':'>' (I,0) in call 'erlang':'and' (_4,_5) -> [I|L]
<_8,L> when 'true' -> L end
'mforms'/2 = fun (_0,_1) -> let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{_X_File,Ms}|_3]> when 'true' -> (letrec 'lc$^1'/1 = fun (_7) -> case _7 of <[M|_5]> when 'true' -> let <_8> = apply 'lc$^1'/1 (_5) in ([{_0,M}|_8]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_3)
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Ms)-|['list_comprehension'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_13> when 'true' -> (primop 'match_fail' ({'function_clause',_13})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1) in call 'lists':'sort' (_9)
'no_duplicates'/5 = fun (_0,_1,_2,_3,_4) -> let <_11> = letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[W = {_X_File,[{_43,'qlc',Tag}|[]]}|_6]> when 'true' -> (case call 'lists':'member' (Tag,['nomatch_pattern'|['nomatch_filter']]) of <'false'> when 'true' -> let <_9> = apply 'lc$^0'/1 (_6) in ([W|_9]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_44> when 'true' -> (primop 'match_fail' ({'function_clause',_44})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_3) in let <_26> = apply 'mforms'/1 (_2) in let <_18> = letrec 'lc$^1'/1 = fun (_16) -> case _16 of <[{File,[{L,'qlc',M}|[]]}|_14]> when call 'erlang':'=:=' (M,'nomatch_filter') -> let <_17> = apply 'lc$^1'/1 (_14) in ([{File,[{L,'sys_core_fold','nomatch_guard'}|[]]}|_17]-|['compiler_generated'] )
(<[_13|_14]> when 'true' -> apply 'lc$^1'/1 (_14)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_45> when 'true' -> (primop 'match_fail' ({'function_clause',_45})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_15> = apply 'mforms'/1 (_11) in apply 'lc$^1'/1 (_15) in let <_25> = letrec 'lc$^2'/1 = fun (_22) -> case _22 of <[{File,[{L,'qlc',M}|[]]}|_20]> when 'true' -> (case call 'lists':'member' (M,['nomatch_pattern'|['nomatch_filter']]) of <'true'> when 'true' -> let <_23> = apply 'lc$^2'/1 (_20) in ([{File,[{L,'v3_core','nomatch'}|[]]}|_23]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^2'/1 (_20)-|['compiler_generated'] )
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_19|_20]> when 'true' -> apply 'lc$^2'/1 (_20)-|['compiler_generated'] )
<[]> when 'true' -> _18
(<_46> when 'true' -> (primop 'match_fail' ({'function_clause',_46})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in let <_21> = apply 'mforms'/1 (_11) in apply 'lc$^2'/1 (_21) in let <Warnings1> = call 'erlang':'--' (_26,_25) in let <Warnings> = call 'erlang':'++' (Warnings1,_11) in case apply 'compile_forms'/2 (_0,_4) of <{Es1,Ws1}> when 'true' -> let <_31> = apply 'mforms'/1 (_1) in let <_30> = apply 'mforms'/1 (Es1) in let <Es> = call 'erlang':'--' (_31,_30) in let <_34> = apply 'mforms'/1 (Warnings) in let <_33> = apply 'mforms'/1 (Ws1) in let <Ws> = call 'erlang':'--' (_34,_33) in let <_37> = apply 'mforms2'/2 ('error',Es) in let <_36> = apply 'mforms2'/2 ('warning',Ws) in {_37,_36}
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end
'mforms'/1 = fun (_0) -> let <_8> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[{File,Ms}|_2]> when 'true' -> (letrec 'lc$^1'/1 = fun (_6) -> case _6 of <[M|_4]> when 'true' -> let <_7> = apply 'lc$^1'/1 (_4) in ([{File,[M|[]]}|_7]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_2)
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Ms)-|['list_comprehension'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in call 'lists':'sort' (_8)
'mforms2'/2 = fun (_0,_1) -> let <Line> = apply 'anno0'/0 () in let <_10> = fun (_8) -> case _8 of <{File,Ms}> when 'true' -> (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[M|_5]> when 'true' -> let <_7> = apply 'lc$^0'/1 (_5) in ([[{'attribute',Line,'file',{File,0}}|[{_0,M}|[]]]|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Ms)-|['list_comprehension'] )
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'-mforms2/2-fun-1-',1}}] )-|['compiler_generated'] ) end in let <_3> = call 'lists':'sort' (_1) in let <ML> = call 'lists':'flatmap' (_10,_3) in let <_12> = call 'lists':'sort' (ML) in call 'lists':'flatten' (_12)
'restore_locations'/2 = fun (_0,_1) -> case <_0,_1> of <[T|Ts],State> when 'true' -> let <_2> = apply 'restore_locations'/2 (T,State) in let <_3> = apply 'restore_locations'/2 (Ts,State) in [_2|_3]
<T,State> when call 'erlang':'is_tuple' (T) -> let <_4> = call 'erlang':'tuple_to_list' (T) in let <_5> = apply 'restore_locations'/2 (_4,State) in call 'erlang':'list_to_tuple' (_5)
<I,State> when call 'erlang':'>' (I,0) -> apply 'restore_loc'/2 (I,State)
<T,_X_State> when 'true' -> T end
'is_qlc_q_imported'/1 = fun (_0) -> let <_8> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[{'attribute',_10,'import',{'qlc',FAs}}|_2]> when 'true' -> (letrec 'lc$^1'/1 = fun (_6) -> case _6 of <[{'q',1}|_4]> when 'true' -> let <_7> = apply 'lc$^1'/1 (_4) in ([[]|_7]-|['compiler_generated'] )
(<[_3|_4]> when 'true' -> apply 'lc$^1'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_2)
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (FAs)-|['list_comprehension'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in call 'erlang':'=/=' (_8,[])
'record_attributes'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[A = {'attribute',_6,'record',_X_D}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([A|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'compile_messages'/4 = fun (_0,_1,_2,_3) -> let <BGenF> = fun (_10,_9,_8,_7) -> case <_10,_9,_8,_7> of <_X_QId,BGen = {'b_generate',Line,_X_P,_X_LE},GA,A> when 'true' -> let <_4> = apply 'loc'/1 (Line) in let <M> = {_4,'qlc','binary_generator'} in let <_6> = call 'erlang':'get' ('qlc_current_file') in {BGen,[{_6,[M|[]]}|GA],A}
<_X_QId,Q,GA,A> when 'true' -> {Q,GA,A} end in case apply 'qual_fold'/5 (BGenF,[],[],_0,_3) of <{_44,BGens}> when 'true' -> let <GenForm> = apply 'used_genvar_check'/2 (_1,_3) in case apply 'compile_forms'/2 ([GenForm|[]],_2) of <{GEs,_45}> when 'true' -> let <UsedGenVarMsgs> = apply 'used_genvar_messages'/2 (GEs,_3) in (case _3 of (<({'state',_46,_47,_48,_49,_50,_51,_rec4}-|['compiler_generated'] )> when 'true' -> let <WarnFun> = fun (_26,_25,_24) -> let <_23> = apply 'lc_nodes'/2 (_25,_rec4) in {_23,_24} in case apply 'qlc_mapfold'/4 (WarnFun,'ok',_0,_3) of <{WForms,'ok'}> when 'true' -> case apply 'compile_forms'/2 (WForms,_2) of <{Es,Ws}> when 'true' -> let <LcEs> = apply 'lc_messages'/2 (Es,_rec4) in let <LcWs> = apply 'lc_messages'/2 (Ws,_rec4) in let <_37> = apply 'badarg'/2 (_0,_3) in let <_35> = call 'erlang':'++' (LcEs,BGens) in let <_36> = call 'erlang':'++' (UsedGenVarMsgs,_35) in let <Errors> = call 'erlang':'++' (_37,_36) in {Errors,LcWs}
(<_32> when 'true' -> primop 'match_fail' ({'badmatch',_32})-|['compiler_generated'] ) end
(<_31> when 'true' -> primop 'match_fail' ({'badmatch',_31})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_52> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
'badarg'/2 = fun (_0,_1) -> let <F> = fun (_7,_6,_5) -> case <_7,_6,_5> of <_X_Id,LC = {'lc',_X_L,_X_E,_X_Qs},Es> when 'true' -> {LC,Es}
<Id,A,Es> when 'true' -> let <_2> = apply 'get_lcid_line'/1 (Id) in let <E> = {_2,'qlc','not_a_query_list_comprehension'} in let <_4> = call 'erlang':'get' ('qlc_current_file') in {A,[{_4,[E|[]]}|Es]} end in case apply 'qlc_mapfold'/4 (F,[],_0,_1) of <{_15,E0}> when 'true' -> E0
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
'lc_nodes'/2 = fun (_0,_1) -> let <_9> = fun (_7) -> let <N> = call 'erl_anno':'line' (_7) in case call 'ets':'lookup' (_1,N) of <[{_12,Data}|[]]> when call 'erlang':'=:=' (_12,N) -> case <> of (<> when call 'erlang':'is_map' (Data) -> let <_4> = ~{'inside_lc'=>'true'|Data}~ in case call 'ets':'insert' (_1,{N,_4}) of <'true'> when 'true' -> _7
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Data})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end in apply 'map_anno'/2 (_9,_0)
'used_genvar_messages'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[{_15,Ms}|_3]> when 'true' -> (letrec 'lc$^1'/1 = fun (_10) -> case _10 of <[{XLoc,'erl_lint',{'unbound_var',_16}}|_5]> when 'true' -> (letrec 'lc$^2'/1 = fun (_11) -> case _11 of <[{Loc,File,V}|_7]> when 'true' -> let <_12> = apply 'lc$^2'/1 (_7) in ([{File,[{Loc,'qlc',{'used_generator_variable',V}}|[]]}|_12]-|['compiler_generated'] )
(<[_6|_7]> when 'true' -> apply 'lc$^2'/1 (_7)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^1'/1 (_5)
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in let <_8> = apply 'genvar_pos'/2 (XLoc,_1) in apply 'lc$^2'/1 ([_8|[]])-|['list_comprehension'] )
(<[_4|_5]> when 'true' -> apply 'lc$^1'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_3)
(<_18> when 'true' -> (primop 'match_fail' ({'function_clause',_18})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Ms)-|['list_comprehension'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_19> when 'true' -> (primop 'match_fail' ({'function_clause',_19})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'lc_messages'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{File,Ms}|_3]> when 'true' -> let <_10> = letrec 'lc$^1'/1 = fun (_7) -> case _7 of <[_@r0 = {Loc,Mod,T}|_6]> when 'true' -> (case apply 'lc_loc'/2 (Loc,_1) of <'true'> when 'true' -> let <_8> = apply 'lc$^1'/1 (_6) in ([_@r0|_8]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^1'/1 (_6)-|['compiler_generated'] )
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_5|_6]> when 'true' -> apply 'lc$^1'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_14> when 'true' -> (primop 'match_fail' ({'function_clause',_14})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Ms) in let <_11> = apply 'lc$^0'/1 (_3) in ([{File,_10}|_11]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'lc_loc'/2 = fun (_0,_1) -> case call 'ets':'lookup' (_1,_0) of <[{_5,~{'inside_lc':='true'}~}|[]]> when call 'erlang':'=:=' (_5,_0) -> 'true'
<[{_6,_7}|[]]> when call 'erlang':'=:=' (_6,_0) -> 'false'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'genvar_pos'/2 = fun (_0,_1) -> (case _1 of (<({'state',_7,_8,_9,_10,_11,_12,_rec5}-|['compiler_generated'] )> when 'true' -> case call 'ets':'lookup' (_rec5,_0) of <[{_14,~{'genvar_pos':=Pos}~}|[]]> when call 'erlang':'=:=' (_14,_0) -> Pos
<[]> when 'true' -> _0
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'intro_variables'/2 = fun (_0,_1) -> (case _1 of (<({'state',_76,_77,_78,_79,_80,_81,_rec6}-|['compiler_generated'] )> when 'true' -> let <Fun> = fun (_29,_28,_27,_26) -> case <_29,_28,_27,_26> of <QId,Q = {T,_X_L,P0,_X_E0},{GVs,QIds},Foo> when let <_5> = call 'erlang':'=:=' (T,'b_generate') in let <_6> = call 'erlang':'=:=' (T,'generate') in call 'erlang':'or' (_5,_6) -> let <_9> = fun (_7) -> case _7 of <{'var',_83,V}> when 'true' -> {QId,V}
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'-intro_variables/2-fun-0-',1}}] )-|['compiler_generated'] ) end in let <PVs> = call 'qlc':'var_ufold' (_9,P0) in let <_11> = call 'ordsets':'to_list' (PVs) in let <_12> = call 'erlang':'++' (_11,GVs) in {Q,{_12,[{QId,[]}|QIds]},Foo}
<QId,Filter0,{GVs,QIds},Foo> when 'true' -> let <_13> = call 'qlc':'vars' (Filter0) in let <Vs> = call 'ordsets':'to_list' (_13) in let <AnyLine> = apply 'anno0'/0 () in let <_20> = letrec 'lc$^1'/1 = fun (_18) -> case _18 of <[V|_17]> when 'true' -> let <_19> = apply 'lc$^1'/1 (_17) in ([{'var',AnyLine,V}|_19]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_84> when 'true' -> (primop 'match_fail' ({'function_clause',_84})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Vs) in let <LC> = apply 'embed_vars'/2 (_20,AnyLine) in let <LC1> = apply 'intro_anno'/4 (LC,'before',QId,_rec6) in let <LC2> = apply 'intro_anno'/4 (LC,'after',QId,_rec6) in let <Filter> = {'block',AnyLine,[LC1|[Filter0|[LC2|[]]]]} in {Filter,{GVs,[{QId,[]}|QIds]},Foo}
(<_33,_32,_31,_30> when 'true' -> (primop 'match_fail' ({'function_clause',_33,_32,_31,_30})-|[{'function_name',{'-intro_variables/2-fun-2-',4}}] )-|['compiler_generated'] ) end in case apply 'qual_fold'/5 (Fun,{[],[]},[],_0,_1) of <{FForms,{GenVars,QIds}}> when 'true' -> let <Es0> = apply 'compile_errors'/1 (FForms) in let <_46> = letrec 'lc$^3'/1 = fun (_43) -> case _43 of <[{L,'erl_lint',{'unbound_var',V}}|_39]> when 'true' -> (letrec 'lc$^4'/1 = fun (_44) -> case _44 of <[{_X_L,{QId,'before'}}|_41]> when 'true' -> let <_45> = apply 'lc$^4'/1 (_41) in ([{QId,V}|_45]-|['compiler_generated'] )
(<[_40|_41]> when 'true' -> apply 'lc$^4'/1 (_41)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^3'/1 (_39)
(<_85> when 'true' -> (primop 'match_fail' ({'function_clause',_85})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in let <_42> = call 'ets':'lookup' (_rec6,L) in apply 'lc$^4'/1 (_42)-|['list_comprehension'] )
(<[_38|_39]> when 'true' -> apply 'lc$^3'/1 (_39)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_86> when 'true' -> (primop 'match_fail' ({'function_clause',_86})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (Es0) in let <_56> = letrec 'lc$^5'/1 = fun (_53) -> case _53 of <[{L,'erl_lint',{'unbound_var',V}}|_49]> when 'true' -> (letrec 'lc$^6'/1 = fun (_54) -> case _54 of <[{_X_L,{QId,'after'}}|_51]> when 'true' -> let <_55> = apply 'lc$^6'/1 (_51) in ([{QId,V}|_55]-|['compiler_generated'] )
(<[_50|_51]> when 'true' -> apply 'lc$^6'/1 (_51)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^5'/1 (_49)
(<_87> when 'true' -> (primop 'match_fail' ({'function_clause',_87})-|[{'function_name',{'lc$^6',1}}] )-|['compiler_generated'] ) end in let <_52> = call 'ets':'lookup' (_rec6,L) in apply 'lc$^6'/1 (_52)-|['list_comprehension'] )
(<[_48|_49]> when 'true' -> apply 'lc$^5'/1 (_49)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_88> when 'true' -> (primop 'match_fail' ({'function_clause',_88})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in apply 'lc$^5'/1 (Es0) in let <_66> = letrec 'lc$^7'/1 = fun (_63) -> case _63 of <[{L,'erl_lint',{'unsafe_var',V,_X_Where}}|_59]> when 'true' -> (letrec 'lc$^8'/1 = fun (_64) -> case _64 of <[{_X_L,{QId,'after'}}|_61]> when 'true' -> let <_65> = apply 'lc$^8'/1 (_61) in ([{QId,V}|_65]-|['compiler_generated'] )
(<[_60|_61]> when 'true' -> apply 'lc$^8'/1 (_61)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^7'/1 (_59)
(<_89> when 'true' -> (primop 'match_fail' ({'function_clause',_89})-|[{'function_name',{'lc$^8',1}}] )-|['compiler_generated'] ) end in let <_62> = call 'ets':'lookup' (_rec6,L) in apply 'lc$^8'/1 (_62)-|['list_comprehension'] )
(<[_58|_59]> when 'true' -> apply 'lc$^7'/1 (_59)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_90> when 'true' -> (primop 'match_fail' ({'function_clause',_90})-|[{'function_name',{'lc$^7',1}}] )-|['compiler_generated'] ) end in apply 'lc$^7'/1 (Es0) in let <_68> = call 'erlang':'--' (_46,_56) in let <IV> = call 'erlang':'--' (_68,_66) in let <_70> = call 'erlang':'++' (IV,GenVars) in let <I1> = apply 'family'/1 (_70) in let <_72> = call 'sofs':'family' (QIds) in let <_73> = call 'sofs':'family_union' (_72,I1) in call 'sofs':'to_external' (_73)
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_82> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'intro_anno'/4 = fun (_0,_1,_2,_3) -> let <Data> = {_2,_1} in let <Fun> = fun (_7) -> let <Location> = call 'erl_anno':'location' (_7) in case call 'ets':'insert' (_3,{Location,Data}) of <'true'> when 'true' -> _7
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end in let <_10> = apply 'save_anno'/2 (_0,_3) in apply 'map_anno'/2 (Fun,_10)
'compile_errors'/1 = fun (_0) -> case apply 'compile_forms'/2 (_0,[]) of <{[],_X_Warnings}> when 'true' -> []
<{Errors,_X_Warnings}> when 'true' -> let <_3> = fun (_1) -> case _1 of <{_X_File,Es}> when 'true' -> Es
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-compile_errors/1-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'flatmap' (_3,Errors)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'compile_forms'/2 = fun (_0,_1) -> let <Exclude> = fun (_2) -> case _2 of <'eof'> when 'true' -> 'true'
<'warning'> when 'true' -> 'true'
<'error'> when 'true' -> 'true'
<_24> when 'true' -> 'false' end in let <_12> = letrec 'lc$^1'/1 = fun (_9) -> case _9 of <[F|_6]> when 'true' -> let <_7> = call 'erlang':'element' (1,F) in (case apply Exclude (_7) of <'false'> when 'true' -> let <_10> = apply 'lc$^1'/1 (_6) in ([F|_10]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^1'/1 (_6)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
<[]> when 'true' -> [{'eof',0}]
(<_28> when 'true' -> (primop 'match_fail' ({'function_clause',_28})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_0) in try let <_14> = apply 'compile_options'/1 (_1) in case call 'compile':'noenv_forms' (_12,_14) of <{'ok',_X_ModName,Ws0}> when 'true' -> {[],Ws0}
<{'error',Es0,Ws0}> when 'true' -> {Es0,Ws0}
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end of <_16> -> _16 catch <_19,_18,_17> -> let <_20> = apply 'lint_options'/1 (_1) in case call 'erl_lint':'module' (_12,_20) of <{'ok',Warnings}> when 'true' -> {[],Warnings}
<{'error',Errors,Warnings}> when 'true' -> {Errors,Warnings}
(<_21> when 'true' -> primop 'match_fail' ({'case_clause',_21})-|['compiler_generated'] ) end
'compile_options'/1 = fun (_0) -> let <_1> = apply 'bitstr_options'/0 () in let <No> = ['report'|['report_errors'|['report_warnings'|['P'|['E'|_1]]]]] in let <_3> = apply 'skip_options'/2 (No,_0) in ['strong_validation'|['return'|_3]]
'lint_options'/1 = fun (_0) -> let <_1> = apply 'bitstr_options'/0 () in apply 'skip_options'/2 (_1,_0)
'skip_options'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[O|_3]> when 'true' -> (case call 'lists':'member' (O,_0) of <'false'> when 'true' -> let <_6> = apply 'lc$^0'/1 (_3) in ([O|_6]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1)-|['list_comprehension'] )
'bitstr_options'/0 = fun () -> ['binary_comprehension'|['bitlevel_binaries']]
'used_genvar_check'/2 = fun (_0,_1) -> (case _1 of (<({'state',_60,_61,_62,_63,_64,_65,_rec7}-|['compiler_generated'] )> when 'true' -> let <F> = fun (_37,_36,_35,_34) -> case <_37,_36,_35,_34> of <QId,Q = {T,Ln,_X_P,LE},{QsIVs0,Exprs0},IVsSoFar0> when let <_5> = call 'erlang':'=:=' (T,'b_generate') in let <_6> = call 'erlang':'=:=' (T,'generate') in call 'erlang':'or' (_5,_6) -> let <F> = fun (_17) -> case apply 'undo_no_shadows'/2 (_17,_1) of <{'var',Anno0,OrigVar}> when 'true' -> case apply 'save_anno'/2 (_17,_rec7) of <NewVar = {'var',Anno,_67}> when 'true' -> let <Location0> = call 'erl_anno':'location' (Anno0) in let <Location> = call 'erl_anno':'location' (Anno) in case call 'ets':'lookup' (_rec7,Location) of <[{_68,Data}|[]]> when call 'erlang':'=:=' (_68,Location) -> let <_12> = call 'erlang':'get' ('qlc_current_file') in let <Pos> = {Location0,_12,OrigVar} in case <> of (<> when call 'erlang':'is_map' (Data) -> let <_14> = ~{'genvar_pos'=>Pos|Data}~ in case call 'ets':'insert' (_rec7,{Location,_14}) of <'true'> when 'true' -> NewVar
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Data})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end in let <_26> = letrec 'lc$^1'/1 = fun (_23) -> case _23 of <[Var = {'var',_69,V}|_21]> when 'true' -> (case call 'lists':'member' (V,IVsSoFar0) of <'true'> when 'true' -> let <_24> = apply 'lc$^1'/1 (_21) in ([Var|_24]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^1'/1 (_21)-|['compiler_generated'] )
(<_25> when 'true' -> primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_20|_21]> when 'true' -> apply 'lc$^1'/1 (_21)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_83> when 'true' -> (primop 'match_fail' ({'function_clause',_83})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_22> = call 'qlc':'var_fold' (F,[],LE) in apply 'lc$^1'/1 (_22) in let <_30> = case _26 of <[]> when 'true' -> Exprs0
<_70> when 'true' -> let <_28> = apply 'embed_vars'/2 (_26,Ln) in [_28|Exprs0] end in case apply 'q_intro_vars'/3 (QId,QsIVs0,IVsSoFar0) of <{QsIVs,IVsSoFar}> when 'true' -> {Q,{QsIVs,_30},IVsSoFar}
(<_32> when 'true' -> primop 'match_fail' ({'badmatch',_32})-|['compiler_generated'] ) end
<QId,Filter,{QsIVs0,Exprs},IVsSoFar0> when 'true' -> case apply 'q_intro_vars'/3 (QId,QsIVs0,IVsSoFar0) of <{QsIVs,IVsSoFar}> when 'true' -> {Filter,{QsIVs,Exprs},IVsSoFar}
(<_33> when 'true' -> primop 'match_fail' ({'badmatch',_33})-|['compiler_generated'] ) end
(<_41,_40,_39,_38> when 'true' -> (primop 'match_fail' ({'function_clause',_41,_40,_39,_38})-|[{'function_name',{'-used_genvar_check/2-fun-2-',4}}] )-|['compiler_generated'] ) end in (case _1 of (<({'state',_71,_72,_73,_74,_75,_rec8,_76}-|['compiler_generated'] )> when 'true' -> let <_43> = apply 'anno0'/0 () in let <Acc0> = {_rec8,[{'atom',_43,'true'}|[]]} in case apply 'qual_fold'/5 (F,Acc0,[],_0,_1) of <{_78,{[],Exprs}}> when 'true' -> let <_52> = letrec 'lc$^3'/1 = fun (_50) -> case _50 of <[{'function',_79,Name,_80,_81}|_49]> when 'true' -> let <_51> = apply 'lc$^3'/1 (_49) in ([Name|_51]-|['compiler_generated'] )
(<[_48|_49]> when 'true' -> apply 'lc$^3'/1 (_49)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_84> when 'true' -> (primop 'match_fail' ({'function_clause',_84})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (_0) in let <_54> = call 'gb_sets':'from_list' (_52) in let <UniqueFName> = call 'qlc':'aux_name' ('used_genvar',1,_54) in let <A> = apply 'anno0'/0 () in let <_57> = call 'lists':'reverse' (Exprs) in {'function',A,UniqueFName,0,[{'clause',A,[],[],_57}|[]]}
(<_47> when 'true' -> primop 'match_fail' ({'badmatch',_47})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_77> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_66> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'q_intro_vars'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <QId,[{_7,IVs}|QsIVs],IVsSoFar> when call 'erlang':'=:=' (_7,QId) -> let <_3> = call 'erlang':'++' (IVs,IVsSoFar) in {QsIVs,_3}
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'q_intro_vars',3}}] )-|['compiler_generated'] ) end
'transform'/2 = fun (_0,_1) -> do (call ('erlang'-|['result_not_wanted'] ):('system_flag'-|['result_not_wanted'] ) (('backtrace_depth'-|['result_not_wanted'] ),(500-|['result_not_wanted'] ))-|['result_not_wanted'] ) (case _1 of (<({'state',_113,_114,_115,_116,_117,_rec9,_118}-|['compiler_generated'] )> when 'true' -> let <_6> = call 'qlc':'vars' (_0) in let <_7> = call 'ordsets':'to_list' (_6) in let <AllVars> = call 'gb_sets':'from_list' (_7) in let <F1> = fun (_16,_15,_14,_13) -> case <_16,_15,_14,_13> of <QId,{'generate',_120,P,LE},Foo,{GoI,SI}> when 'true' -> let <_10> = call 'erlang':'+' (GoI,3) in let <_9> = call 'erlang':'+' (SI,2) in {{QId,GoI,SI,{'gen',P,LE}},Foo,{_10,_9}}
<QId,F,Foo,{GoI,SI}> when 'true' -> let <_12> = call 'erlang':'+' (GoI,2) in let <_11> = call 'erlang':'+' (SI,1) in {{QId,GoI,SI,{'fil',F}},Foo,{_12,_11}}
(<_20,_19,_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_20,_19,_18,_17})-|[{'function_name',{'-transform/2-fun-0-',4}}] )-|['compiler_generated'] ) end in let <TemplS> = call 'qlc':'template_state' () in let <_24> = call 'erlang':'+' (TemplS,1) in let <_23> = call 'erlang':'+' (TemplS,1) in let <GoState> = {_24,_23} in case apply 'qual_fold'/5 (F1,[],GoState,_0,_1) of <{ModifiedForms1,_121}> when 'true' -> let <_37> = fun (_32,_31,_30,_29) -> case <_32,_31,_30,_29> of <_X_QId,Q = {'generate',_122,_X_P,_X_E},Dict,Foo> when 'true' -> {Q,Dict,Foo}
<QId,F,Dict,Foo> when 'true' -> let <_28> = call 'maps':'put' (QId,F,Dict) in {F,_28,Foo} end in let <_27> = call 'maps':'new' () in case apply 'qual_fold'/5 (_37,_27,[],_0,_1) of <{_123,Source0}> when 'true' -> let <_46> = fun (_42,_41,_40) -> case <_42,_41,_40> of <Id,LC = {'lc',_X_L,E,_X_Qs},Dict> when 'true' -> let <_39> = call 'maps':'put' (Id,E,Dict) in {LC,_39}
(<_45,_44,_43> when 'true' -> (primop 'match_fail' ({'function_clause',_45,_44,_43})-|[{'function_name',{'-transform/2-fun-2-',3}}] )-|['compiler_generated'] ) end in case apply 'qlc_mapfold'/4 (_46,Source0,_0,_1) of <{_124,Source}> when 'true' -> let <F2> = fun (_102,_101,_100) -> case <_102,_101,_100> of <Id,{'lc',_X_L,E,Qs},{IntroVs0,XWarn0}> when 'true' -> let <LcNo> = apply 'get_lcid_no'/1 (Id) in let <LcL> = apply 'get_lcid_line'/1 (Id) in case apply 'aux_vars'/3 (['RL'|['Fun'|['Go'|['C'|['S0'|['RL0'|['Go0'|['AT'|['E']]]]]]]]],LcNo,AllVars) of <[RL|[Fun|[Go|[NGV|[S0|[RL0|[Go0|[AT|[Err|[]]]]]]]]]]> when 'true' -> let <_51> = call 'erlang':'length' (Qs) in case call 'lists':'split' (_51,IntroVs0) of <{IntroVs,RestIntroVs}> when 'true' -> let <IntroVs_Qs> = call 'lists':'zip' (IntroVs,Qs) in let <F> = fun (_61,_60) -> case <_61,_60> of <{{QId,IVs},{_125,GoI,SI,{'gen',P,LE}}},AllIVs0> when call 'erlang':'=:=' (_125,QId) -> (case QId of (<({'qid',_126,_rec10}-|['compiler_generated'] )> when 'true' -> let <GV> = apply 'aux_var'/5 ('C',LcNo,_rec10,1,AllVars) in let <GenIVs> = [GV|IVs] in let <_58> = call 'erlang':'++' (GenIVs,AllIVs0) in {{QId,{GenIVs,{{'gen',P,LE,GV},GoI,SI}}},_58}-|['compiler_generated'] )
(<_127> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<{{QId,IVs},{_128,GoI,SI,_@r0 = {'fil',F}}},AllIVs0> when call 'erlang':'=:=' (_128,QId) -> let <_59> = call 'erlang':'++' (IVs,AllIVs0) in {{QId,{IVs,{_@r0,GoI,SI}}},_59}
(<_63,_62> when 'true' -> (primop 'match_fail' ({'function_clause',_63,_62})-|[{'function_name',{'-transform/2-fun-3-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'mapfoldl' (F,[],IntroVs_Qs) of <{QCs,AllIVs}> when 'true' -> let <Dependencies> = apply 'qualifier_dependencies'/2 (Qs,IntroVs) in let <L> = apply 'no_compiler_warning'/1 (LcL) in case apply 'constants_and_sizes'/5 (Qs,E,Dependencies,AllIVs,_1) of <{EqColumnConstants,EqualColumnConstants,ExtraConsts,SizeInfo}> when 'true' -> case apply 'join_kind'/5 (Qs,LcL,AllIVs,Dependencies,_1) of <{JoinInfo,XWarn}> when 'true' -> let <FWarn> = apply 'warn_failing_qualifiers'/4 (Qs,AllIVs,Dependencies,_1) in let <JQs> = apply 'join_quals'/6 (JoinInfo,QCs,L,LcNo,ExtraConsts,AllVars) in let <XQCs> = call 'erlang':'++' (QCs,JQs) in let <Cs0> = apply 'clauses'/8 (XQCs,RL,Fun,Go,NGV,Err,AllIVs,_1) in let <Template> = apply 'template'/8 (E,RL,Fun,Go,AT,L,AllIVs,_1) in let <Fin> = apply 'final'/4 (RL,AllIVs,L,_1) in let <_76> = call 'erlang':'++' (Template,Cs0) in let <_77> = call 'erlang':'++' (Fin,_76) in let <FunC> = {'fun',L,{'clauses',_77}} in let <_79> = apply 'replace'/3 (AllIVs,AllIVs,'nil') in let <_80> = apply 'abst_vars'/2 ([S0|[RL0|[Fun|[Go0|_79]]]],L) in let <As0> = apply 'pack_args'/3 (_80,L,_1) in let <AsW> = apply 'abst_vars'/2 ([S0|[RL0|[Go0|[]]]],L) in let <FunW> = {'fun',L,{'clauses',[{'clause',L,AsW,[],[{'match',L,{'var',L,Fun},FunC}|[{'call',L,{'var',L,Fun},As0}|[]]]}|[]]}} in let <OrigE0> = call 'erlang':'map_get' (Id,Source) in let <OrigE> = apply 'undo_no_shadows'/2 (OrigE0,_1) in let <QCode> = apply 'qcode'/5 (OrigE,XQCs,Source,L,_1) in let <Qdata> = apply 'qdata'/2 (XQCs,L) in let <TemplateInfo> = apply 'template_columns'/5 (Qs,E,AllIVs,Dependencies,_1) in let <MSQs> = apply 'match_spec_quals'/4 (E,Dependencies,Qs,_1) in let <Opt> = apply 'opt_info'/7 (TemplateInfo,SizeInfo,JoinInfo,MSQs,L,EqColumnConstants,EqualColumnConstants) in let <_93> = case apply 'qlc_kind'/3 (OrigE,Qs,_1) of <'qlc'> when 'true' -> {'tuple',L,[{'atom',L,'qlc_v1'}|[FunW|[QCode|[Qdata|[Opt|[]]]]]]}
<{'simple',PL,LE,V}> when 'true' -> let <Init> = apply 'closure'/2 (LE,L) in apply 'simple'/4 (L,V,Init,PL)
(<_92> when 'true' -> primop 'match_fail' ({'case_clause',_92})-|['compiler_generated'] ) end in let <LCFun> = {'fun',L,{'clauses',[{'clause',L,[],[],[_93|[]]}|[]]}} in case apply 'abstr'/2 ({'qlc_lc','undefined','undefined'},L) of <{'tuple',_129,Fs0}> when 'true' -> let <Fs> = apply 'set_field'/3 (2,Fs0,LCFun) in let <_98> = call 'erlang':'++' (XWarn,XWarn0) in let <_99> = call 'erlang':'++' (FWarn,_98) in {{'tuple',L,Fs},{RestIntroVs,_99}}
(<_96> when 'true' -> primop 'match_fail' ({'badmatch',_96})-|['compiler_generated'] ) end
(<_69> when 'true' -> primop 'match_fail' ({'badmatch',_69})-|['compiler_generated'] ) end
(<_68> when 'true' -> primop 'match_fail' ({'badmatch',_68})-|['compiler_generated'] ) end
(<_65> when 'true' -> primop 'match_fail' ({'badmatch',_65})-|['compiler_generated'] ) end
(<_52> when 'true' -> primop 'match_fail' ({'badmatch',_52})-|['compiler_generated'] ) end
(<_50> when 'true' -> primop 'match_fail' ({'badmatch',_50})-|['compiler_generated'] ) end
(<_105,_104,_103> when 'true' -> (primop 'match_fail' ({'function_clause',_105,_104,_103})-|[{'function_name',{'-transform/2-fun-4-',3}}] )-|['compiler_generated'] ) end in case apply 'qlc_mapfold'/4 (F2,{_rec9,[]},ModifiedForms1,_1) of <{NForms,{[],XW}}> when 'true' -> do apply 'display_forms'/1 (NForms) case _1 of <{'state',_130,_131,_132,_133,_134,_135,_136}> when 'true' -> let <_110> = call 'erlang':'setelement' (6,_1,XW) in {NForms,_110}
(<_137> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_107> when 'true' -> primop 'match_fail' ({'badmatch',_107})-|['compiler_generated'] ) end
(<_47> when 'true' -> primop 'match_fail' ({'badmatch',_47})-|['compiler_generated'] ) end
(<_38> when 'true' -> primop 'match_fail' ({'badmatch',_38})-|['compiler_generated'] ) end
(<_26> when 'true' -> primop 'match_fail' ({'badmatch',_26})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_119> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'join_kind'/5 = fun (_0,_1,_2,_3,_4) -> case apply 'equal_columns'/4 (_0,_2,_3,_4) of <{EqualCols2,EqualColsN}> when 'true' -> case apply 'eq_columns'/4 (_0,_2,_3,_4) of <{MatchCols2,MatchColsN}> when 'true' -> let <_14> = letrec 'lc$^0'/1 = fun (_11) -> case _11 of <[{C,_X_Skip}|_8]> when 'true' -> (letrec 'lc$^1'/1 = fun (_12) -> case _12 of <[T|_10]> when call 'erlang':'is_integer' (T) -> let <_13> = apply 'lc$^1'/1 (_10) in ([T|_13]-|['compiler_generated'] )
(<[T|_10]> when 'true' -> apply 'lc$^1'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_8)
(<_37> when 'true' -> (primop 'match_fail' ({'function_clause',_37})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (C)-|['list_comprehension'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_38> when 'true' -> (primop 'match_fail' ({'function_clause',_38})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (EqualCols2) in let <_22> = letrec 'lc$^2'/1 = fun (_19) -> case _19 of <[{C,_X_Skip}|_16]> when 'true' -> (letrec 'lc$^3'/1 = fun (_20) -> case _20 of <[{T,_36}|_18]> when 'true' -> let <_21> = apply 'lc$^3'/1 (_18) in ([T|_21]-|['compiler_generated'] )
(<[_17|_18]> when 'true' -> apply 'lc$^3'/1 (_18)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^2'/1 (_16)
(<_39> when 'true' -> (primop 'match_fail' ({'function_clause',_39})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (C)-|['list_comprehension'] )
(<[_15|_16]> when 'true' -> apply 'lc$^2'/1 (_16)-|['compiler_generated'] )
<[]> when 'true' -> _14
(<_40> when 'true' -> (primop 'match_fail' ({'function_clause',_40})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (EqualCols2) in let <Tables> = call 'lists':'usort' (_22) in case <> of <> when let <_24> = call 'erlang':'=/=' (EqualColsN,[]) in let <_25> = call 'erlang':'=/=' (MatchColsN,[]) in call 'erlang':'or' (_24,_25) -> let <_26> = call 'erlang':'get' ('qlc_current_file') in {[],[{_26,[{_1,'qlc','too_complex_join'}|[]]}|[]]}
<> when let <_27> = call 'erlang':'=:=' (EqualCols2,[]) in let <_28> = call 'erlang':'=:=' (MatchCols2,[]) in call 'erlang':'and' (_27,_28) -> {[],[]}
<> when try let <_29> = call 'erlang':'length' (Tables) in call 'erlang':'>' (_29,2) of <Try> -> Try catch <T,R> -> 'false' -> let <_30> = call 'erlang':'get' ('qlc_current_file') in {[],[{_30,[{_1,'qlc','too_many_joins'}|[]]}|[]]}
<> when call 'erlang':'=:=' (EqualCols2,MatchCols2) -> {EqualCols2,[]}
<> when 'true' -> {{EqualCols2,MatchCols2},[]} end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'qlc_kind'/3 = fun (_0,_1,_2) -> let <_3> = apply 'undo_no_shadows'/2 (_1,_2) in case apply 'qual_data'/1 (_3) of <{OrigFilterData,OrigGeneratorData}> when 'true' -> let <OrigAllFilters> = apply 'filters_as_one'/1 (OrigFilterData) in case apply 'qual_data'/1 (_1) of <{_X_FilterData,GeneratorData}> when 'true' -> case <_0,OrigAllFilters,OrigGeneratorData> of <({('var'-|['compiler_generated'] ),_12,V}-|['compiler_generated'] ),({('atom'-|['compiler_generated'] ),_13,('true'-|['compiler_generated'] )}-|['compiler_generated'] ),([({_14,({('gen'-|['compiler_generated'] ),({('var'-|['compiler_generated'] ),PatternL,_15}-|['compiler_generated'] ),_X_LE}-|['compiler_generated'] )}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when call 'erlang':'=:=' (_15,V) -> case GeneratorData of <[{_16,{'gen',_17,LE}}|[]]> when 'true' -> {'simple',PatternL,LE,V}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<(_19-|['compiler_generated'] ),(_20-|['compiler_generated'] ),(_21-|['compiler_generated'] )> when 'true' -> 'qlc' end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'warn_failing_qualifiers'/4 = fun (_0,_1,_2,_3) -> case apply 'qual_data'/1 (_0) of <{FilterData,GeneratorData}> when 'true' -> let <BindFun> = fun (_7,_6) -> apply 'is_bindable'/1 (_6) in case apply 'pattern_frame'/4 (GeneratorData,BindFun,1,_3) of <{PFrame,_X_PatternVars}> when 'true' -> case apply 'filter_info'/4 (FilterData,_1,_2,_3) of <{_34,_35,Imported}> when 'true' -> let <PFrames> = apply 'frame2frames'/1 (PFrame) in let <_28> = fun (_25,_24) -> case <_25,_24> of <{_X_QId,{'fil',_X_Filter}},_@r0 = {Frames = [],Warnings}> when 'true' -> _@r0
<{_X_QId,{'fil',Filter}},{Frames,Warnings}> when 'true' -> let <_15> = apply 'reset_anno'/1 (Filter) in case apply 'filter'/5 (_15,Frames,BindFun,_3,Imported) of <[]> when 'true' -> let <_18> = call 'erlang':'get' ('qlc_current_file') in let <_16> = call 'erlang':'element' (2,Filter) in let <_17> = apply 'loc'/1 (_16) in {[],[{_18,[{_17,'qlc','nomatch_filter'}|[]]}|Warnings]}
<Frames1> when 'true' -> {Frames1,Warnings} end
<{_X_QId,{'gen',Pattern,_36}},_@r1 = {Frames,Warnings}> when 'true' -> case apply 'pattern'/5 (Pattern,1,[],BindFun,_3) of <{'failed',_37,_38}> when 'true' -> let <_22> = call 'erlang':'get' ('qlc_current_file') in let <_20> = call 'erlang':'element' (2,Pattern) in let <_21> = apply 'loc'/1 (_20) in {Frames,[{_22,[{_21,'qlc','nomatch_pattern'}|[]]}|Warnings]}
<_39> when 'true' -> _@r1 end
(<_27,_26> when 'true' -> (primop 'match_fail' ({'function_clause',_27,_26})-|[{'function_name',{'-warn_failing_qualifiers/4-fun-1-',2}}] )-|['compiler_generated'] ) end in let <_14> = call 'erlang':'++' (FilterData,GeneratorData) in case call 'lists':'foldl' (_28,{PFrames,[]},_14) of <{_40,Warnings}> when 'true' -> Warnings
(<_29> when 'true' -> primop 'match_fail' ({'badmatch',_29})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'opt_info'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <_12> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[{C,Sz}|_8]> when 'true' -> let <_11> = apply 'lc$^0'/1 (_8) in ([{'clause',_4,[{'integer',_4,C}|[]],[],[{'integer',_4,Sz}|[]]}|_11]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> [{'clause',_4,[{'var',_4,'_'}|[]],[],[{'atom',_4,'undefined'}|[]]}|[]]
(<_106> when 'true' -> (primop 'match_fail' ({'function_clause',_106})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_9> = call 'lists':'sort' (_1) in apply 'lc$^0'/1 (_9) in let <S> = [{'size',{'fun',_4,{'clauses',_12}}}|[]] in let <_17> = case _2 of <[]> when 'true' -> []
<_104> when 'true' -> let <_15> = apply 'abstr'/2 (_2,_4) in [{'join',_15}|[]] end in let <_30> = letrec 'lc$^1'/1 = fun (_21) -> case _21 of <[{EqType,TemplateColumns}|_20]> when 'true' -> let <_28> = letrec 'lc$^2'/1 = fun (_24) -> case _24 of <[{Col,TemplCols}|_23]> when 'true' -> let <_26> = apply 'abstr'/2 (Col,_4) in let <_25> = apply 'abstr'/2 (TemplCols,_4) in let <_27> = apply 'lc$^2'/1 (_23) in ([{'clause',_4,[_26|[EqType|[]]],[],[_25|[]]}|_27]-|['compiler_generated'] )
(<[_22|_23]> when 'true' -> apply 'lc$^2'/1 (_23)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_107> when 'true' -> (primop 'match_fail' ({'function_clause',_107})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (TemplateColumns) in let <_29> = apply 'lc$^1'/1 (_20) in ([_28|_29]-|['compiler_generated'] )
(<[_19|_20]> when 'true' -> apply 'lc$^1'/1 (_20)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_108> when 'true' -> (primop 'match_fail' ({'function_clause',_108})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_0) in let <TCls0> = call 'lists':'append' (_30) in let <_32> = call 'lists':'sort' (TCls0) in let <TCls> = call 'erlang':'++' (_32,[{'clause',_4,[{'var',_4,'_'}|[{'var',_4,'_'}|[]]],[],[{'nil',_4}|[]]}|[]]) in let <T> = [{'template',{'fun',_4,{'clauses',TCls}}}|[]] in let <EqColumnConstants> = apply 'opt_column_constants'/1 (_5) in let <CCs> = apply 'opt_constants'/2 (_4,EqColumnConstants) in let <EqC> = {'constants',{'fun',_4,{'clauses',CCs}}} in let <EqualColumnConstants> = apply 'opt_column_constants'/1 (_6) in let <ECCs> = apply 'opt_constants'/2 (_4,EqualColumnConstants) in let <EqualC> = {'equal_constants',{'fun',_4,{'clauses',ECCs}}} in let <_46> = letrec 'lc$^3'/1 = fun (_44) -> case _44 of <['true'|_42]> when 'true' -> let <_45> = apply 'lc$^3'/1 (_42) in ([EqualC|_45]-|['compiler_generated'] )
(<[_41|_42]> when 'true' -> apply 'lc$^3'/1 (_42)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_109> when 'true' -> (primop 'match_fail' ({'function_clause',_109})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_43> = call 'erlang':'=/=' (CCs,ECCs) in apply 'lc$^3'/1 ([_43|[]]) in let <C> = [EqC|_46] in let <_52> = letrec 'lc$^4'/1 = fun (_50) -> case _50 of <[{_@r0 = {IdNo,Col},[_105|[]],_X_FilNs}|_49]> when 'true' -> let <_51> = apply 'lc$^4'/1 (_49) in ([_@r0|_51]-|['compiler_generated'] )
(<[_48|_49]> when 'true' -> apply 'lc$^4'/1 (_49)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_110> when 'true' -> (primop 'match_fail' ({'function_clause',_110})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in apply 'lc$^4'/1 (EqualColumnConstants) in let <ConstColsFamily> = apply 'family_list'/1 (_52) in let <_64> = letrec 'lc$^5'/1 = fun (_57) -> case _57 of <[{IdNo,Cols}|_56]> when 'true' -> let <_58> = call 'erlang':'length' (Cols) in let <_59> = call 'erlang':'+' (_58,1) in let <_60> = call 'lists':'seq' (1,_59) in let <_61> = call 'erlang':'--' (_60,Cols) in let <_62> = call 'erlang':'hd' (_61) in let <_63> = apply 'lc$^5'/1 (_56) in ([{IdNo,_62}|_63]-|['compiler_generated'] )
(<[_55|_56]> when 'true' -> apply 'lc$^5'/1 (_56)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_111> when 'true' -> (primop 'match_fail' ({'function_clause',_111})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in apply 'lc$^5'/1 (ConstColsFamily) in let <_71> = letrec 'lc$^6'/1 = fun (_68) -> case _68 of <[{IdNo,N}|_67]> when call 'erlang':'>' (N,0) -> let <_69> = call 'erlang':'-' (N,1) in let <_70> = apply 'lc$^6'/1 (_67) in ([{'clause',_4,[{'integer',_4,IdNo}|[]],[],[{'integer',_4,_69}|[]]}|_70]-|['compiler_generated'] )
(<[_66|_67]> when 'true' -> apply 'lc$^6'/1 (_67)-|['compiler_generated'] )
<[]> when 'true' -> [{'clause',_4,[{'var',_4,'_'}|[]],[],[{'integer',_4,0}|[]]}|[]]
(<_112> when 'true' -> (primop 'match_fail' ({'function_clause',_112})-|[{'function_name',{'lc$^6',1}}] )-|['compiler_generated'] ) end in apply 'lc$^6'/1 (_64) in let <N> = [{'n_leading_constant_columns',{'fun',_4,{'clauses',_71}}}|[]] in let <_79> = letrec 'lc$^7'/1 = fun (_76) -> case _76 of <[{IdNo,Cols}|_75]> when 'true' -> let <_77> = apply 'abstr'/2 (Cols,_4) in let <_78> = apply 'lc$^7'/1 (_75) in ([{'clause',_4,[{'integer',_4,IdNo}|[]],[],[_77|[]]}|_78]-|['compiler_generated'] )
(<[_74|_75]> when 'true' -> apply 'lc$^7'/1 (_75)-|['compiler_generated'] )
<[]> when 'true' -> [{'clause',_4,[{'var',_4,'_'}|[]],[],[{'nil',_4}|[]]}|[]]
(<_113> when 'true' -> (primop 'match_fail' ({'function_clause',_113})-|[{'function_name',{'lc$^7',1}}] )-|['compiler_generated'] ) end in apply 'lc$^7'/1 (ConstColsFamily) in let <CC> = [{'constant_columns',{'fun',_4,{'clauses',_79}}}|[]] in let <_87> = letrec 'lc$^8'/1 = fun (_84) -> case _84 of <[{G,MS,Fs}|_83]> when 'true' -> let <_85> = apply 'abstr'/2 (Fs,_4) in let <_86> = apply 'lc$^8'/1 (_83) in ([{'clause',_4,[{'integer',_4,G}|[]],[],[{'tuple',_4,[MS|[_85|[]]]}|[]]}|_86]-|['compiler_generated'] )
(<[_82|_83]> when 'true' -> apply 'lc$^8'/1 (_83)-|['compiler_generated'] )
<[]> when 'true' -> [{'clause',_4,[{'var',_4,'_'}|[]],[],[{'atom',_4,'undefined'}|[]]}|[]]
(<_114> when 'true' -> (primop 'match_fail' ({'function_clause',_114})-|[{'function_name',{'lc$^8',1}}] )-|['compiler_generated'] ) end in apply 'lc$^8'/1 (_3) in let <MS> = [{'match_specs',{'fun',_4,{'clauses',_87}}}|[]] in let <_95> = letrec 'lc$^9'/1 = fun (_93) -> case _93 of <[{Tag,V}|_91]> when 'true' -> let <_94> = apply 'lc$^9'/1 (_91) in ([{'clause',_4,[{'atom',_4,Tag}|[]],[],[V|[]]}|_94]-|['compiler_generated'] )
(<[_90|_91]> when 'true' -> apply 'lc$^9'/1 (_91)-|['compiler_generated'] )
<[]> when 'true' -> [{'clause',_4,[{'var',_4,'_'}|[]],[],[{'atom',_4,'undefined'}|[]]}|[]]
(<_115> when 'true' -> (primop 'match_fail' ({'function_clause',_115})-|[{'function_name',{'lc$^9',1}}] )-|['compiler_generated'] ) end in let <_92> = call 'lists':'append' ([_17|[S|[T|[C|[N|[CC|[MS|[]]]]]]]]) in apply 'lc$^9'/1 (_92) in {'fun',_4,{'clauses',_95}}
'opt_column_constants'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[CC = {{IdNo,_X_Col},Const,_X_FilNs}|_2]> when try let <_3> = call 'erlang':'=/=' (IdNo,0) in let <_4> = call 'erlang':'length' (Const) in let <_5> = call 'erlang':'=:=' (_4,1) in call 'erlang':'or' (_3,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = apply 'lc$^0'/1 (_2) in ([CC|_7]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'opt_constants'/2 = fun (_0,_1) -> let <_6> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{{IdNo,_X_Col},_X_Const,_X_FilNs}|_3]> when 'true' -> let <_5> = apply 'lc$^0'/1 (_3) in ([IdNo|_5]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1) in let <Ns> = call 'lists':'usort' (_6) in (letrec 'lc$^1'/1 = fun (_10) -> case _10 of <[IdNo|_9]> when 'true' -> let <_11> = apply 'column_fun'/3 (_1,IdNo,_0) in let <_12> = apply 'lc$^1'/1 (_9) in ([{'clause',_0,[{'integer',_0,IdNo}|[]],[],[_11|[]]}|_12]-|['compiler_generated'] )
<[]> when 'true' -> [{'clause',_0,[{'var',_0,'_'}|[]],[],[{'atom',_0,'no_column_fun'}|[]]}|[]]
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Ns)-|['list_comprehension'] )
'abstr'/2 = fun (_0,_1) -> let <_2> = apply 'loc'/1 (_1) in call 'erl_parse':'abstract' (_0,_2)
'join_quals'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <_14> = fun (_11,_10) -> case <_11,_10> of <{_X_QId,{_X_QIVs,{{'fil',_111},GoI,SI}}},{GoI0,_X_SI0}> when call 'erlang':'>=' (GoI,GoI0) -> let <_7> = call 'erlang':'+' (GoI,2) in let <_6> = call 'erlang':'+' (SI,1) in {_7,_6}
<{_X_QId,{_X_QIVs,{{'gen',_112,_113,_114},GoI,SI}}},{GoI0,_X_SI0}> when call 'erlang':'>=' (GoI,GoI0) -> let <_9> = call 'erlang':'+' (GoI,3) in let <_8> = call 'erlang':'+' (SI,2) in {_9,_8}
<_115,A> when 'true' -> A end in case call 'lists':'foldl' (_14,{0,0},_1) of <{LastGoI,LastSI}> when 'true' -> let <_20> = letrec 'lc$^1'/1 = fun (_18) -> case _18 of <[{QId,{_X_QIVs,{_X_Q,_X_GoI,_X_SI}}}|_17]> when 'true' -> let <_19> = apply 'lc$^1'/1 (_17) in ([QId|_19]-|['compiler_generated'] )
(<[_16|_17]> when 'true' -> apply 'lc$^1'/1 (_17)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_130> when 'true' -> (primop 'match_fail' ({'function_clause',_130})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_1) in let <LastQId> = call 'lists':'max' (_20) in let <_40> = case _0 of <{EqualCols,MatchCols}> when 'true' -> let <EQs> = apply 'join_qnums'/1 (EqualCols) in let <MQs> = apply 'join_qnums'/1 (MatchCols) in let <_29> = letrec 'lc$^2'/1 = fun (_27) -> case _27 of <[{Q1,Q2}|_25]> when 'true' -> let <_28> = apply 'lc$^2'/1 (_25) in ([{Q1,Q2,'=='}|_28]-|['compiler_generated'] )
(<[_24|_25]> when 'true' -> apply 'lc$^2'/1 (_25)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_131> when 'true' -> (primop 'match_fail' ({'function_clause',_131})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in let <_26> = call 'erlang':'--' (EQs,MQs) in apply 'lc$^2'/1 (_26) in (letrec 'lc$^3'/1 = fun (_32) -> case _32 of <[{Q1,Q2}|_31]> when 'true' -> let <_33> = apply 'lc$^3'/1 (_31) in ([{Q1,Q2,'=:='}|_33]-|['compiler_generated'] )
(<[_30|_31]> when 'true' -> apply 'lc$^3'/1 (_31)-|['compiler_generated'] )
<[]> when 'true' -> _29
(<_132> when 'true' -> (primop 'match_fail' ({'function_clause',_132})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (MQs)-|['list_comprehension'] )
<EqualCols> when 'true' -> (letrec 'lc$^4'/1 = fun (_37) -> case _37 of <[{Q1,Q2}|_35]> when 'true' -> let <_38> = apply 'lc$^4'/1 (_35) in ([{Q1,Q2,'=='}|_38]-|['compiler_generated'] )
(<[_34|_35]> when 'true' -> apply 'lc$^4'/1 (_35)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_133> when 'true' -> (primop 'match_fail' ({'function_clause',_133})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in let <_36> = apply 'join_qnums'/1 (EqualCols) in apply 'lc$^4'/1 (_36)-|['list_comprehension'] ) end in let <_73> = letrec 'lc$^5'/1 = fun (_45) -> case _45 of <[{Q1,Q2,Op}|_43]> when 'true' -> let <_56> = letrec 'lc$^6'/1 = fun (_54) -> case _54 of <[{QId,{QIVs,{{'gen',P,_116,GV},_X_GoI,_X_SI}}}|_47]> when (try (let <_50> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (QId,('qid'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_48-|['compiler_generated'] )> when 'true' -> (_48-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_51> = call 'erlang':'=:=' ((_50-|['compiler_generated'] ),'true') in let <_52> = call 'erlang':'element' (3,QId) in let <_53> = call 'erlang':'=:=' (_52,Q1) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_51,_53)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> let <_55> = apply 'lc$^6'/1 (_47) in ([{QId,P,GV,QIVs}|_55]-|['compiler_generated'] )
(<[_46|_47]> when 'true' -> apply 'lc$^6'/1 (_47)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_134> when 'true' -> (primop 'match_fail' ({'function_clause',_134})-|[{'function_name',{'lc$^6',1}}] )-|['compiler_generated'] ) end in apply 'lc$^6'/1 (_1) in case _56 of <[{QId1,P1,GV1,QIVs1}|[]]> when 'true' -> let <_69> = letrec 'lc$^7'/1 = fun (_66) -> case _66 of <[{QId,{QIVs,{{'gen',P,_117,GV},_118,_119}}}|_59]> when (try (let <_62> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (QId,('qid'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_60-|['compiler_generated'] )> when 'true' -> (_60-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_63> = call 'erlang':'=:=' ((_62-|['compiler_generated'] ),'true') in let <_64> = call 'erlang':'element' (3,QId) in let <_65> = call 'erlang':'=:=' (_64,Q2) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_63,_65)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> let <_67> = call 'erlang':'--' (QIVs,[GV|[]]) in let <_68> = apply 'lc$^7'/1 (_59) in ([{QId,P,_67}|_68]-|['compiler_generated'] )
(<[_58|_59]> when 'true' -> apply 'lc$^7'/1 (_59)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_135> when 'true' -> (primop 'match_fail' ({'function_clause',_135})-|[{'function_name',{'lc$^7',1}}] )-|['compiler_generated'] ) end in apply 'lc$^7'/1 (_1) in case _69 of <[{QId2,P2,QIVs2}|[]]> when 'true' -> let <_71> = call 'erlang':'++' (QIVs1,QIVs2) in let <_72> = apply 'lc$^5'/1 (_43) in ([{QId1,Op,P1,GV1,_71,QId2,P2}|_72]-|['compiler_generated'] )
(<_70> when 'true' -> primop 'match_fail' ({'badmatch',_70})-|['compiler_generated'] ) end
(<_57> when 'true' -> primop 'match_fail' ({'badmatch',_57})-|['compiler_generated'] ) end
(<[_42|_43]> when 'true' -> apply 'lc$^5'/1 (_43)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_136> when 'true' -> (primop 'match_fail' ({'function_clause',_136})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in let <_44> = call 'lists':'usort' (_40) in apply 'lc$^5'/1 (_44) in let <_75> = apply 'aux_vars'/3 (['F'|['H'|['O'|['C']]]],_3,_5) in let <Aux> = apply 'abst_vars'/2 (_75,_2) in let <F> = fun (_100,_99) -> case <_100,_99> of <{QId1,Op,P1,GV1,QIVs,QId2,P2},{QId,GoI,SI}> when 'true' -> let <AP1> = apply 'anon_pattern'/1 (P1) in let <AP2> = apply 'anon_pattern'/1 (P2) in let <Cs1> = apply 'join_handle_constants'/2 (QId1,_4) in let <Cs2> = apply 'join_handle_constants'/2 (QId2,_4) in let <H1> = apply 'join_handle'/4 (AP1,_2,Aux,Cs1) in let <H2> = apply 'join_handle'/4 (AP2,_2,Aux,Cs2) in (case QId1 of (<({'qid',_120,_rec12}-|['compiler_generated'] )> when 'true' -> (case QId2 of (<({'qid',_122,_rec13}-|['compiler_generated'] )> when 'true' -> let <Join> = {'join',Op,_rec12,_rec13,H1,H2,Cs1,Cs2} in (case QId of (<({'qid',_124,_rec16}-|['compiler_generated'] )> when 'true' -> let <_rec14> = call 'erlang':'+' (_rec16,1) in case QId of <{'qid',_126,_127}> when 'true' -> let <_93> = call 'erlang':'setelement' (3,QId,_rec14) in let <G> = {_93,{QIVs,{{'gen',{'cons',_2,P1,P2},Join,GV1},GoI,SI}}} in let <_97> = call 'erlang':'+' (GoI,3) in let <_96> = call 'erlang':'+' (SI,2) in let <A> = {_93,_97,_96} in {G,A}
(<_128> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_125> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_123> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_121> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_102,_101> when 'true' -> (primop 'match_fail' ({'function_clause',_102,_101})-|[{'function_name',{'-join_quals/6-fun-8-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'mapfoldl' (F,{LastQId,LastGoI,LastSI},_73) of <{Qs,_129}> when 'true' -> Qs
(<_104> when 'true' -> primop 'match_fail' ({'badmatch',_104})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
'join_qnums'/1 = fun (_0) -> let <_5> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{[{Q1,_X_C1}|[{Q2,_X_C2}|[]]],_X_Skip}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([{Q1,Q2}|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in call 'lists':'usort' (_5)
'anon_pattern'/1 = fun (_0) -> let <_2> = apply 'occ_vars'/1 (_0) in let <_1> = call 'qlc':'vars' (_0) in let <_3> = call 'erlang':'--' (_2,_1) in let <MoreThanOnce> = call 'lists':'usort' (_3) in let <_10> = fun (_7,_6) -> case <_7,_6> of <_@r0 = {'var',L,V},A> when 'true' -> case call 'lists':'member' (V,MoreThanOnce) of <'true'> when 'true' -> {_@r0,A}
<'false'> when 'true' -> {{'var',L,'_'},A}
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'-anon_pattern/1-fun-0-',2}}] )-|['compiler_generated'] ) end in case apply 'var_mapfold'/3 (_10,'foo',_0) of <{AP,'foo'}> when 'true' -> AP
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
'join_handle'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <AP,L,[F|[H|[O|_@r0 = [C|[]]]]],Constants> when 'true' -> case <AP,Constants> of <({('var'-|['compiler_generated'] ),_32,_33}-|['compiler_generated'] ),([]-|['compiler_generated'] )> when 'true' -> {'fun',L,{'clauses',[{'clause',L,[H|[]],[],[H|[]]}|[]]}}
<(_35-|['compiler_generated'] ),(_36-|['compiler_generated'] )> when 'true' -> let <A> = apply 'anno0'/0 () in let <_16> = letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[{Col,Cs}|_6]> when 'true' -> let <Call> = {'call',A,{'atom',A,'element'},[{'integer',A,Col}|[O|[]]]} in let <_13> = letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[{Con,Op}|_10]> when 'true' -> let <_12> = apply 'lc$^1'/1 (_10) in ([{'op',A,Op,Con,Call}|_12]-|['compiler_generated'] )
(<[_9|_10]> when 'true' -> apply 'lc$^1'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_39> when 'true' -> (primop 'match_fail' ({'function_clause',_39})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Cs) in let <_14> = apply 'list2op'/2 (_13,'or') in let <_15> = apply 'lc$^0'/1 (_6) in ([_14|_15]-|['compiler_generated'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_40> when 'true' -> (primop 'match_fail' ({'function_clause',_40})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Constants) in let <_18> = case <> of <> when call 'erlang':'=:=' (_16,[]) -> _16
<> when 'true' -> [_16|[]] end in let <_20> = apply 'closure'/2 ({'call',L,F,[F|_@r0]},L) in let <CC1> = {'clause',L,[AP|[]],_18,[{'cons',L,O,_20}|[]]} in let <CC2> = {'clause',L,[{'var',L,'_'}|[]],[],[{'call',L,F,[F|_@r0]}|[]]} in let <Case> = {'case',L,O,[CC1|[CC2|[]]]} in let <Cls> = [{'clause',L,[{'var',L,'_'}|[{'nil',L}|[]]],[],[{'nil',L}|[]]}|[{'clause',L,[F|[{'cons',L,O,C}|[]]],[],[Case|[]]}|[{'clause',L,[F|_@r0],[[{'call',L,{'atom',L,'is_function'},_@r0}|[]]|[]],[{'call',L,F,[F|[{'call',L,C,[]}|[]]]}|[]]}|[{'clause',L,[{'var',L,'_'}|_@r0],[],_@r0}|[]]]]] in let <Fun> = {'fun',L,{'clauses',Cls}} in let <_26> = apply 'closure'/2 ({'call',L,F,[F|[H|[]]]},L) in {'fun',L,{'clauses',[{'clause',L,[H|[]],[],[{'match',L,F,Fun}|[_26|[]]]}|[]]}} end
(<_31,_30,_29,_28> when 'true' -> (primop 'match_fail' ({'function_clause',_31,_30,_29,_28})-|[{'function_name',{'join_handle',4}}] )-|['compiler_generated'] ) end
'join_handle_constants'/2 = fun (_0,_1) -> (case _0 of (<({'qid',_8,_rec17}-|['compiler_generated'] )> when 'true' -> case call 'lists':'keyfind' (_rec17,1,_1) of <{_10,ConstOps}> when call 'erlang':'=:=' (_10,_rec17) -> ConstOps
<'false'> when 'true' -> []
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'column_fun'/3 = fun (_0,_1,_2) -> let <A> = apply 'anno0'/0 () in let <_27> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{{CIdNo,Col},Vs0,{FTag,Fils}}|_5]> when call 'erlang':'=:=' (CIdNo,_1) -> case call 'erlang':'=/=' (Vs0,[]) of <'true'> when 'true' -> let <Vs1> = apply 'list2cons'/1 (Vs0) in let <_13> = fun (_10,_9) -> {'cons',A,{'integer',A,_10},_9} in let <_14> = call 'lists':'foldr' (_13,{'nil',A},Fils) in let <Fils1> = {'tuple',A,[{'atom',A,FTag}|[_14|[]]]} in let <_16> = call 'qlc':'vars' (Vs1) in let <_22> = case call 'ordsets':'to_list' (_16) of <Imp> when try let <_17> = call 'erlang':'length' (Imp) in let <_18> = call 'erlang':'>' (_17,0) in let <_19> = call 'erlang':'length' (Vs0) in let <_20> = call 'erlang':'>' (_19,1) in call 'erlang':'and' (_18,_20) of <Try> -> Try catch <T,R> -> 'false' -> 'usort_needed'
<_33> when 'true' -> 'values' end in let <Vs> = {'tuple',A,[{'atom',A,_22}|[Vs1|[Fils1|[]]]]} in let <_25> = call 'erl_parse':'abstract' (Col) in let <_26> = apply 'lc$^0'/1 (_5) in ([{'clause',A,[_25|[]],[],[Vs|[]]}|_26]-|['compiler_generated'] )
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> [{'clause',A,[{'var',A,'_'}|[]],[],[{'atom',A,'false'}|[]]}|[]]
(<_36> when 'true' -> (primop 'match_fail' ({'function_clause',_36})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <ColCls> = apply 'set_anno'/2 (_27,_2) in {'fun',_2,{'clauses',ColCls}}
'template_columns'/5 = fun (_0,_1,_2,_3,_4) -> let <_5> = apply 'pre_expand'/1 (_1) in let <E> = apply 'expand_expr_records'/2 (_5,_4) in let <TemplateAsPattern> = apply 'template_as_pattern'/1 (E) in let <Qs> = [TemplateAsPattern|_0] in let <EqualColumns> = apply 'equal_columns2'/4 (Qs,_2,_3,_4) in let <MatchColumns> = apply 'eq_columns2'/4 (Qs,_2,_3,_4) in let <Equal> = apply 'template_cols'/1 (EqualColumns) in let <Match> = apply 'template_cols'/1 (MatchColumns) in let <L> = apply 'anno0'/0 () in case <> of <> when call 'erlang':'=:=' (Match,Equal) -> [{{'var',L,'_'},Match}|[]]
<> when 'true' -> [{{'atom',L,'=='},Equal}|[{{'atom',L,'=:='},Match}|[]]] end
'equal_columns2'/4 = fun (_0,_1,_2,_3) -> case apply 'join_info'/5 (_0,_1,_2,_3,('=='-|['compiler_generated'] )) of <{JI,_X_Skip}> when 'true' -> JI
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'eq_columns2'/4 = fun (_0,_1,_2,_3) -> case apply 'join_info'/5 (_0,_1,_2,_3,('=:='-|['compiler_generated'] )) of <{JI,_X_SKip}> when 'true' -> JI
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'template_cols'/1 = fun (_0) -> let <_16> = letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[Class|_2]> when 'true' -> (letrec 'lc$^2'/1 = fun (_12) -> case _12 of <[_@r0 = {IdNo,Col}|_4]> when call 'erlang':'=/=' (IdNo,0) -> let <_9> = letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[{0,C}|_6]> when 'true' -> let <_8> = apply 'lc$^0'/1 (_6) in ([C|_8]-|['compiler_generated'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_18> when 'true' -> (primop 'match_fail' ({'function_clause',_18})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Class) in (case <> of <> when call 'erlang':'=/=' ([],_9) -> let <_13> = call 'lists':'usort' (_9) in let <_14> = apply 'lc$^2'/1 (_4) in ([{_@r0,_13}|_14]-|['compiler_generated'] )
(<> when 'true' -> apply 'lc$^2'/1 (_4)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_3|_4]> when 'true' -> apply 'lc$^2'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^1'/1 (_2)
(<_19> when 'true' -> (primop 'match_fail' ({'function_clause',_19})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (Class)-|['list_comprehension'] )
<[]> when 'true' -> []
(<_20> when 'true' -> (primop 'match_fail' ({'function_clause',_20})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_0) in call 'lists':'sort' (_16)
'template_as_pattern'/1 = fun (_0) -> let <P> = apply 'simple_template'/1 (_0) in let <_2> = apply 'anno0'/0 () in {{'qid','template',0},'foo','foo',{'gen',P,{'nil',_2}}}
'simple_template'/1 = fun (_0) -> case _0 of <{'call',L,Call = {'remote',_13,{'atom',_14,'erlang'},{'atom',_15,'element'}},[A1 = {'integer',_16,I}|[A2|[]]]}> when call 'erlang':'>' (I,0) -> let <_1> = apply 'simple_template'/1 (A2) in {'call',L,Call,[A1|[_1|[]]]}
<E = {'var',_17,_18}> when 'true' -> E
<{'tuple',L,Es}> when 'true' -> let <_7> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[E|_3]> when 'true' -> let <_5> = apply 'simple_template'/1 (E) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_21> when 'true' -> (primop 'match_fail' ({'function_clause',_21})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Es) in {'tuple',L,_7}
<{'cons',L,H,T}> when 'true' -> let <_9> = apply 'simple_template'/1 (H) in let <_8> = apply 'simple_template'/1 (T) in {'cons',L,_9,_8}
<E> when 'true' -> let <_10> = catch call 'erl_parse':'normalise' (E) in case _10 of <{'EXIT',_19}> when 'true' -> apply 'unique_var'/0 ()
<_20> when 'true' -> E end end
'qualifier_dependencies'/2 = fun (_0,_1) -> let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{QId,IVs}|_3]> when 'true' -> (letrec 'lc$^1'/1 = fun (_7) -> case _7 of <[IV|_5]> when 'true' -> let <_8> = apply 'lc$^1'/1 (_5) in ([{IV,QId}|_8]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_3)
(<_45> when 'true' -> (primop 'match_fail' ({'function_clause',_45})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (IVs)-|['list_comprehension'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_46> when 'true' -> (primop 'match_fail' ({'function_clause',_46})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1) in let <Intro> = call 'sofs':'relation' (_9) in case apply 'qual_data'/1 (_0) of <{FilterData,_44}> when 'true' -> let <_20> = letrec 'lc$^2'/1 = fun (_17) -> case _17 of <[{QId,{'fil',F}}|_13]> when 'true' -> (letrec 'lc$^3'/1 = fun (_18) -> case _18 of <[UV|_15]> when 'true' -> let <_19> = apply 'lc$^3'/1 (_15) in ([{QId,UV}|_19]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^2'/1 (_13)
(<_47> when 'true' -> (primop 'match_fail' ({'function_clause',_47})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_16> = call 'qlc':'vars' (F) in apply 'lc$^3'/1 (_16)-|['list_comprehension'] )
(<[_12|_13]> when 'true' -> apply 'lc$^2'/1 (_13)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_48> when 'true' -> (primop 'match_fail' ({'function_clause',_48})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (FilterData) in let <Used> = call 'sofs':'relation' (_20) in let <_22> = call 'sofs':'relative_product' (Used,Intro) in let <Depend> = call 'sofs':'strict_relation' (_22) in let <_24> = call 'sofs':'relation_to_family' (Depend) in let <G> = call 'sofs':'family_to_digraph' (_24) in let <_32> = letrec 'lc$^4'/1 = fun (_29) -> case _29 of <[V|_27]> when 'true' -> let <_30> = call 'digraph_utils':'reachable_neighbours' ([V|[]],G) in let <_31> = apply 'lc$^4'/1 (_27) in ([{V,_30}|_31]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_49> when 'true' -> (primop 'match_fail' ({'function_clause',_49})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in let <_28> = call 'digraph':'vertices' (G) in apply 'lc$^4'/1 (_28) in case call 'digraph':'delete' (G) of <'true'> when 'true' -> let <_35> = apply 'filter_ids'/1 (_0) in let <FilterIds> = call 'sofs':'set' (_35) in let <_37> = call 'sofs':'family' (_32) in let <Dep1> = call 'sofs':'restriction' (_37,FilterIds) in let <_39> = call 'sofs':'empty_set' () in let <NoDep> = call 'sofs':'constant_function' (FilterIds,_39) in let <_41> = call 'sofs':'family_union' (Dep1,NoDep) in call 'sofs':'to_external' (_41)
(<_34> when 'true' -> primop 'match_fail' ({'badmatch',_34})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
'filter_ids'/1 = fun (_0) -> case apply 'qual_data'/1 (_0) of <{FilterData,_7}> when 'true' -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{QId,_8}|_3]> when 'true' -> let <_5> = apply 'lc$^0'/1 (_3) in ([QId|_5]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (FilterData)-|['list_comprehension'] )
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'match_spec_quals'/4 = fun (_0,_1,_2,_3) -> case apply 'qual_data'/1 (_2) of <{FilterData,GeneratorData}> when 'true' -> let <_13> = letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[{GId,_74}|_10]> when 'true' -> let <_12> = apply 'lc$^1'/1 (_10) in ([GId|_12]-|['compiler_generated'] )
(<[_9|_10]> when 'true' -> apply 'lc$^1'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_87> when 'true' -> (primop 'match_fail' ({'function_clause',_87})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (GeneratorData) in let <_7> = fun (_5) -> case _5 of <{_75,GIds}> when 'true' -> GIds
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'-match_spec_quals/4-fun-0-',1}}] )-|['compiler_generated'] ) end in let <_8> = call 'lists':'flatmap' (_7,_1) in let <NoFilterGIds> = call 'erlang':'--' (_13,_8) in let <Filters> = apply 'filter_list'/3 (FilterData,_1,_3) in let <_24> = letrec 'lc$^2'/1 = fun (_18) -> case _18 of <[{GId,{'gen',Pattern,_76}}|_17]> when 'true' -> (case call 'lists':'member' (GId,NoFilterGIds) of <'true'> when 'true' -> (case GId of (<({'qid',_77,_rec19}-|['compiler_generated'] )> when 'true' -> let <_19> = apply 'anno0'/0 () in let <_22> = apply 'lc$^2'/1 (_17) in ([{_rec19,Pattern,[],{'atom',_19,'true'}}|_22]-|['compiler_generated'] )-|['compiler_generated'] )
(<_78> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^2'/1 (_17)-|['compiler_generated'] )
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_16|_17]> when 'true' -> apply 'lc$^2'/1 (_17)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_88> when 'true' -> (primop 'match_fail' ({'function_clause',_88})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (GeneratorData) in let <_37> = letrec 'lc$^3'/1 = fun (_31) -> case _31 of <[{QId,[QId2|[]]}|_26]> when 'true' -> (letrec 'lc$^4'/1 = fun (_32) -> case _32 of <[{GQId,{'gen',Pattern,_79}}|_28]> when call 'erlang':'=:=' (GQId,QId2) -> (letrec 'lc$^5'/1 = fun (_33) -> case _33 of <[Filter = {FQId,{'fil',F}}|_30]> when call 'erlang':'=:=' (FQId,QId) -> (case QId2 of (<({'qid',_80,_rec18}-|['compiler_generated'] )> when 'true' -> let <_36> = apply 'lc$^5'/1 (_30) in ([{_rec18,Pattern,[Filter|[]],F}|_36]-|['compiler_generated'] )-|['compiler_generated'] )
(<_81> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<[_29|_30]> when 'true' -> apply 'lc$^5'/1 (_30)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^4'/1 (_28)
(<_89> when 'true' -> (primop 'match_fail' ({'function_clause',_89})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in apply 'lc$^5'/1 (Filters)-|['list_comprehension'] )
(<[_27|_28]> when 'true' -> apply 'lc$^4'/1 (_28)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^3'/1 (_26)
(<_90> when 'true' -> (primop 'match_fail' ({'function_clause',_90})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in apply 'lc$^4'/1 (GeneratorData)-|['list_comprehension'] )
(<[_25|_26]> when 'true' -> apply 'lc$^3'/1 (_26)-|['compiler_generated'] )
<[]> when 'true' -> _24
(<_91> when 'true' -> (primop 'match_fail' ({'function_clause',_91})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (_1) in let <_39> = apply 'anno0'/0 () in let <E> = {'nil',_39} in let <_47> = letrec 'lc$^6'/1 = fun (_44) -> case _44 of <[{GNum,Pattern,Filter,F}|_42]> when 'true' -> let <_43> = apply 'try_ms'/4 (E,Pattern,F,_3) in (case <> of <> when call 'erlang':'=/=' ('no',_43) -> let <_45> = apply 'lc$^6'/1 (_42) in ([{{GNum,Pattern},Filter}|_45]-|['compiler_generated'] )
(<> when 'true' -> apply 'lc$^6'/1 (_42)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_41|_42]> when 'true' -> apply 'lc$^6'/1 (_42)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_92> when 'true' -> (primop 'match_fail' ({'function_clause',_92})-|[{'function_name',{'lc$^6',1}}] )-|['compiler_generated'] ) end in apply 'lc$^6'/1 (_37) in let <_49> = call 'sofs':'relation' (_47,[{'gnum_pattern',['filter']}]) in let <GFF> = call 'sofs':'relation_to_family' (_49) in let <_51> = call 'sofs':'family_union' (GFF) in let <GFFL> = call 'sofs':'to_external' (_51) in try case GFFL of <[{{GNum,Pattern},GFilterData}|[]]> when 'true' -> let <_55> = call 'erlang':'length' (GFilterData) in let <_54> = call 'erlang':'length' (FilterData) in case call 'erlang':'=:=' (_55,_54) of <'true'> when 'true' -> case GeneratorData of <[_82|[]]> when 'true' -> let <AbstrMS> = apply 'gen_ms'/4 (_0,Pattern,GFilterData,_3) in [{GNum,AbstrMS,'all'}|[]]
(<_57> when 'true' -> primop 'match_fail' ({'badmatch',_57})-|['compiler_generated'] ) end
(<_56> when 'true' -> primop 'match_fail' ({'badmatch',_56})-|['compiler_generated'] ) end
(<_53> when 'true' -> primop 'match_fail' ({'badmatch',_53})-|['compiler_generated'] ) end of <_59> -> _59 catch <_62,_61,_60> -> let <_63> = apply 'anno0'/0 () in case apply 'anon_var'/2 ({'var',_63,'_'},0) of <{TemplVar,_86}> when 'true' -> (letrec 'lc$^7'/1 = fun (_67) -> case _67 of <[{{GNum,Pattern},GFilterData}|_66]> when 'true' -> let <_68> = apply 'one_gen_match_spec'/5 (GNum,Pattern,GFilterData,_3,TemplVar) in let <_69> = apply 'lc$^7'/1 (_66) in ([_68|_69]-|['compiler_generated'] )
(<[_65|_66]> when 'true' -> apply 'lc$^7'/1 (_66)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_93> when 'true' -> (primop 'match_fail' ({'function_clause',_93})-|[{'function_name',{'lc$^7',1}}] )-|['compiler_generated'] ) end in apply 'lc$^7'/1 (GFFL)-|['list_comprehension'] )
(<_64> when 'true' -> primop 'match_fail' ({'badmatch',_64})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'one_gen_match_spec'/5 = fun (_0,_1,_2,_3,_4) -> case apply 'pattern_as_template'/2 (_1,_4) of <{E,Pattern}> when 'true' -> let <AbstrMS> = apply 'gen_ms'/4 (E,Pattern,_2,_3) in let <_13> = letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[{FId,_19}|_8]> when 'true' -> (case FId of (<({'qid',_20,_rec20}-|['compiler_generated'] )> when 'true' -> let <_12> = apply 'lc$^0'/1 (_8) in ([_rec20|_12]-|['compiler_generated'] )-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_22> when 'true' -> (primop 'match_fail' ({'function_clause',_22})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_2) in {_0,AbstrMS,_13}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'gen_ms'/4 = fun (_0,_1,_2,_3) -> let <_4> = apply 'filters_as_one'/1 (_2) in case apply 'try_ms'/4 (_0,_1,_4,_3) of <{'ok',MS,AMS}> when 'true' -> case MS of <[{'$1',['true'],['$1']}]> when 'true' -> let <_6> = apply 'anno0'/0 () in {'atom',_6,'no_match_spec'}
<_12> when 'true' -> AMS end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'pattern_as_template'/2 = fun (_0,_1) -> case <_0,_1> of <{'var',_5,'_'},TemplVar> when 'true' -> {TemplVar,TemplVar}
<V = {'var',_6,_7},_X_TemplVar> when 'true' -> {V,V}
<{'match',L,E,{'var',_8,'_'}},TemplVar> when 'true' -> {TemplVar,{'match',L,E,TemplVar}}
<{'match',L,{'var',_9,'_'},E},TemplVar> when 'true' -> {TemplVar,{'match',L,E,TemplVar}}
<P = {'match',_10,_X_E,V = {'var',_11,_12}},_X_TemplVar> when 'true' -> {V,P}
<P = {'match',_13,V = {'var',_14,_15},_X_E},_X_TemplVar> when 'true' -> {V,P}
<E,TemplVar> when 'true' -> let <L> = apply 'anno0'/0 () in {TemplVar,{'match',L,E,TemplVar}} end
'constants_and_sizes'/5 = fun (_0,_1,_2,_3,_4) -> let <TemplateAsPattern> = apply 'template_as_pattern'/1 (_1) in let <Qualifiers> = [TemplateAsPattern|_0] in case apply 'qual_data'/1 (Qualifiers) of <{FilterData,GeneratorData}> when 'true' -> case apply 'filter_info'/4 (FilterData,_3,_2,_4) of <{Filter,Anon1,Imported}> when 'true' -> let <PatBindFun> = fun (_10,_9) -> apply 'is_bindable'/1 (_9) in case apply 'pattern_frame'/4 (GeneratorData,PatBindFun,Anon1,_4) of <{PatternFrame,PatternVars}> when 'true' -> let <PatternFrames> = apply 'frame2frames'/1 (PatternFrame) in let <FilterFun> = fun (_16) -> apply 'filter'/5 (Filter,PatternFrames,_16,_4,Imported) in let <SzFs> = apply FilterFun (PatBindFun) in let <SizeInfo> = apply 'pattern_sizes'/2 (PatternVars,SzFs) in let <SelectorFun> = apply 'const_selector'/1 (Imported) in let <_22> = apply 'deref_pattern'/1 (Imported) in let <_23> = apply 'frames_to_columns'/6 (PatternFrames,PatternVars,_22,SelectorFun,Imported,'=:=') in let <PatternConstants> = call 'lists':'flatten' (_23) in case apply 'constants'/9 (FilterFun,PatternVars,PatternConstants,PatternFrame,FilterData,_2,('=:='-|['compiler_generated'] ),Imported,_4) of <{EqColumnConstants,_X_EqExtraConsts}> when 'true' -> case apply 'constants'/9 (FilterFun,PatternVars,PatternConstants,PatternFrame,FilterData,_2,('=='-|['compiler_generated'] ),Imported,_4) of <{EqualColumnConstants,EqualExtraConsts}> when 'true' -> let <_38> = letrec 'lc$^2'/1 = fun (_35) -> case _35 of <[{Consts,Op}|_32]> when 'true' -> (letrec 'lc$^3'/1 = fun (_36) -> case _36 of <[{_@r0 = {GId,Col},Val}|_34]> when 'true' -> let <_37> = apply 'lc$^3'/1 (_34) in ([{_@r0,{Val,Op}}|_37]-|['compiler_generated'] )
(<[_33|_34]> when 'true' -> apply 'lc$^3'/1 (_34)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^2'/1 (_32)
(<_55> when 'true' -> (primop 'match_fail' ({'function_clause',_55})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (Consts)-|['list_comprehension'] )
(<[_31|_32]> when 'true' -> apply 'lc$^2'/1 (_32)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_56> when 'true' -> (primop 'match_fail' ({'function_clause',_56})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 ([{EqualExtraConsts,'=='}|[]]) in let <_45> = letrec 'lc$^4'/1 = fun (_43) -> case _43 of <[{{GId,Col},ValOps}|_41]> when 'true' -> let <_44> = apply 'lc$^4'/1 (_41) in ([{GId,{Col,ValOps}}|_44]-|['compiler_generated'] )
(<[_40|_41]> when 'true' -> apply 'lc$^4'/1 (_41)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_57> when 'true' -> (primop 'match_fail' ({'function_clause',_57})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in let <_42> = apply 'family_list'/1 (_38) in apply 'lc$^4'/1 (_42) in let <ExtraConstants> = apply 'family_list'/1 (_45) in {EqColumnConstants,EqualColumnConstants,ExtraConstants,SizeInfo}
(<_30> when 'true' -> primop 'match_fail' ({'badmatch',_30})-|['compiler_generated'] ) end
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
'constants'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> let <BindFun> = fun (_10,_9) -> apply 'is_bindable'/1 (_9) in let <Fs> = apply _0 (BindFun) in let <SelectorFun> = apply 'const_selector'/1 (_7) in let <_16> = apply 'deref_lookup'/2 (_7,_6) in let <ColumnConstants0> = apply 'frames_to_columns'/6 (Fs,_1,_16,SelectorFun,_7,_6) in let <ColumnConstants1> = call 'lists':'flatten' (ColumnConstants0) in let <_27> = letrec 'lc$^1'/1 = fun (_24) -> case _24 of <[{_@r0 = {GId,Col},Vals}|_20]> when call 'erlang':'=/=' (GId,0) -> (letrec 'lc$^2'/1 = fun (_25) -> case _25 of <[Val|_23]> when 'true' -> let <_26> = apply 'lc$^2'/1 (_23) in ([{_@r0,Val}|_26]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^1'/1 (_20)
(<_41> when 'true' -> (primop 'match_fail' ({'function_clause',_41})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (Vals)-|['list_comprehension'] )
(<[_19|_20]> when 'true' -> apply 'lc$^1'/1 (_20)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_42> when 'true' -> (primop 'match_fail' ({'function_clause',_42})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_21> = call 'erlang':'--' (ColumnConstants1,_2) in apply 'lc$^1'/1 (_21) in let <ColumnConstants> = apply 'lu_skip'/8 (ColumnConstants1,_4,_3,_1,_5,_8,_7,_6) in {ColumnConstants,_27}
'deref_lookup'/2 = fun (_0,_1) -> case <_0,_1> of <Imported,'=='> when 'true' -> (fun (_3,_2) -> apply 'deref_values'/3 (_3,_2,Imported)-|[{'id',{0,0,'-deref_lookup/2-fun-0-'}}] )
<Imported,'=:='> when 'true' -> let <BFun> = fun (_9,_8) -> (case <> of (<> when call 'erlang':'=:=' (_8,'=:=') -> 'true'-|['compiler_generated'] )
(<> when 'true' -> apply 'free_of_integers'/2 (_9,Imported)-|['compiler_generated'] ) end-|['compiler_generated'] ) in (fun (_14,_13) -> apply 'deref_values'/4 (_14,_13,BFun,Imported)-|[{'id',{0,0,'-deref_lookup/2-fun-2-'}}] )
(<_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17})-|[{'function_name',{'deref_lookup',2}}] )-|['compiler_generated'] ) end
'lu_skip'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> let <FailSelector> = fun (_10) -> (fun (_8) -> {'yes',_8}-|[{'id',{0,0,'-lu_skip/8-fun-0-'}}] ) in let <PatternFrames> = apply 'frame2frames'/1 (_2) in let <_14> = apply 'deref_pattern'/1 (_6) in let <_15> = apply 'frames_to_columns'/6 (PatternFrames,_3,_14,FailSelector,_6,_7) in let <PatternColumns> = call 'lists':'flatten' (_15) in let <BindFun> = fun (_18,_17) -> apply 'is_bindable'/1 (_17) in let <_66> = letrec 'lc$^4'/1 = fun (_56) -> case _56 of <[{FId,{'fil',Fil}}|_23]> when 'true' -> let <_25> = apply 'reset_anno'/1 (Fil) in let <_27> = apply 'safe_filter'/5 (_25,PatternFrames,BindFun,_5,_6) in (case <> of <> when call 'erlang':'=/=' ([],_27) -> (letrec 'lc$^5'/1 = fun (_57) -> case _57 of <[_@r0 = {GId,PV}|_29]> when 'true' -> let <_31> = apply 'deref_lu_skip'/2 (_7,_6) in let <_30> = apply 'const_selector'/1 (_6) in let <_32> = apply 'frames_to_columns'/6 (_27,[_@r0|[]],_31,_30,_6,_7) in let <_34> = call 'erlang':'hd' (_32) in (case <> of <> when call 'erlang':'=/=' ([],_34) -> let <_36> = call 'erlang':'--' (_34,PatternColumns) in let <_37> = call 'erlang':'length' (_36) in (case <> of <> when call 'erlang':'=:=' (_37,1) -> (letrec 'lc$^6'/1 = fun (_58) -> case _58 of <[{Column = {_82,Col},Constants}|_39]> when 'true' -> let <_55> = fun (_53) -> case apply 'unify_column'/5 (_53,PV,Col,BindFun,_6) of <{VarI,FrameI}> when 'true' -> let <VarValues> = apply 'deref_skip'/4 (VarI,FrameI,_7,_6) in case apply 'unify_column'/5 (_2,PV,Col,BindFun,_6) of <{NV,F1}> when 'true' -> let <F2> = apply 'unify_var_bindings'/7 (VarValues,'=:=',NV,F1,BindFun,_6,'false') in let <_45> = case call 'lists':'keyfind' (Column,1,_0) of <'false'> when 'true' -> []
<{_83,LUCs}> when call 'erlang':'=:=' (_83,Column) -> LUCs
(<_44> when 'true' -> primop 'match_fail' ({'case_clause',_44})-|['compiler_generated'] ) end in let <_48> = call 'erlang':'length' (VarValues) in (case <> of (<> when call 'erlang':'=<' (_48,1) -> let <_50> = call 'erlang':'--' (Constants,_45) in (case <> of (<> when call 'erlang':'=:=' (_50,[]) -> apply 'bindings_is_subset'/3 (_53,F2,_6)-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_42> when 'true' -> primop 'match_fail' ({'badmatch',_42})-|['compiler_generated'] ) end
(<_40> when 'true' -> primop 'match_fail' ({'badmatch',_40})-|['compiler_generated'] ) end in (case call 'lists':'all' (_55,_27) of <'true'> when 'true' -> (case FId of (<({'qid',_84,_rec21}-|['compiler_generated'] )> when 'true' -> let <_61> = apply 'lc$^6'/1 (_39) in ([{Column,_rec21}|_61]-|['compiler_generated'] )-|['compiler_generated'] )
(<_85> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^6'/1 (_39)-|['compiler_generated'] )
(<_62> when 'true' -> primop 'match_fail' ({'case_clause',_62})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_38|_39]> when 'true' -> apply 'lc$^6'/1 (_39)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^5'/1 (_29)
(<_91> when 'true' -> (primop 'match_fail' ({'function_clause',_91})-|[{'function_name',{'lc$^6',1}}] )-|['compiler_generated'] ) end in apply 'lc$^6'/1 (_36)-|['list_comprehension'] )
(<> when 'true' -> apply 'lc$^5'/1 (_29)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<> when 'true' -> apply 'lc$^5'/1 (_29)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_28|_29]> when 'true' -> apply 'lc$^5'/1 (_29)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^4'/1 (_23)
(<_92> when 'true' -> (primop 'match_fail' ({'function_clause',_92})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in apply 'lc$^5'/1 (_3)-|['list_comprehension'] )
(<> when 'true' -> apply 'lc$^4'/1 (_23)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_22|_23]> when 'true' -> apply 'lc$^4'/1 (_23)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_93> when 'true' -> (primop 'match_fail' ({'function_clause',_93})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in let <_24> = apply 'filter_list'/3 (_1,_4,_5) in apply 'lc$^4'/1 (_24) in let <ColFils> = apply 'family_list'/1 (_66) in (letrec 'lc$^7'/1 = fun (_71) -> case _71 of <[{Col,Constants}|_70]> when 'true' -> let <_72> = apply 'skip_tag'/3 (Col,ColFils,_1) in let <_73> = apply 'lc$^7'/1 (_70) in ([{Col,Constants,_72}|_73]-|['compiler_generated'] )
(<[_69|_70]> when 'true' -> apply 'lc$^7'/1 (_70)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_94> when 'true' -> (primop 'match_fail' ({'function_clause',_94})-|[{'function_name',{'lc$^7',1}}] )-|['compiler_generated'] ) end in apply 'lc$^7'/1 (_0)-|['list_comprehension'] )
'deref_skip'/4 = fun (_0,_1,_2,_3) -> apply 'deref'/3 (_0,_1,_3)
'deref_lu_skip'/2 = fun (_0,_1) -> case <_0,_1> of <'==',Imported> when 'true' -> let <BFun> = fun (_5,_4) -> (case <> of (<> when call 'erlang':'=:=' (_4,'==') -> 'true'-|['compiler_generated'] )
(<> when 'true' -> apply 'free_of_integers'/2 (_5,Imported)-|['compiler_generated'] ) end-|['compiler_generated'] ) in (fun (_10,_9) -> apply 'deref_values'/4 (_10,_9,BFun,Imported)-|[{'id',{0,0,'-deref_lu_skip/2-fun-1-'}}] )
<'=:=',Imported> when 'true' -> (fun (_14,_13) -> apply 'deref_values'/3 (_14,_13,Imported)-|[{'id',{0,0,'-deref_lu_skip/2-fun-2-'}}] )
(<_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17})-|[{'function_name',{'deref_lu_skip',2}}] )-|['compiler_generated'] ) end
'equal_columns'/4 = fun (_0,_1,_2,_3) -> case apply 'join_info'/5 (_0,_1,_2,_3,('=='-|['compiler_generated'] )) of <{Cs,Skip}> when 'true' -> apply 'join_gens'/3 (Cs,_0,Skip)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'eq_columns'/4 = fun (_0,_1,_2,_3) -> case apply 'join_info'/5 (_0,_1,_2,_3,('=:='-|['compiler_generated'] )) of <{Cs,Skip}> when 'true' -> apply 'join_gens'/3 (Cs,_0,Skip)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
'join_gens'/3 = fun (_0,_1,_2) -> let <_8> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[C|_4]> when 'true' -> let <_6> = apply 'family_list'/1 (C) in let <_7> = apply 'lc$^0'/1 (_4) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_26> when 'true' -> (primop 'match_fail' ({'function_clause',_26})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in case apply 'qual_data'/1 (_1) of <{FD,_X_GeneratorData}> when 'true' -> let <_20> = fun (_18) -> let <_17> = call 'erlang':'length' (_18) in call 'erlang':'=:=' (_17,2) in let <_21> = call 'lists':'filter' (_20,_8) in let <_22> = apply 'join_gens2'/3 (_21,FD,_2) in let <_14> = fun (_12) -> let <_11> = call 'erlang':'length' (_12) in call 'erlang':'>' (_11,2) in let <_15> = call 'lists':'filter' (_14,_8) in let <_16> = apply 'join_gens2'/3 (_15,FD,_2) in {_22,_16}
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
'join_gens2'/3 = fun (_0,_1,_2) -> (letrec 'lc$^1'/1 = fun (_12) -> case _12 of <[J|_4]> when 'true' -> let <_14> = case call 'lists':'keyfind' (J,1,_2) of <{_20,FilL}> when call 'erlang':'=:=' (_20,J) -> FilL
<'false'> when 'true' -> []
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end in let <_15> = apply 'skip_tag'/2 (_14,_1) in let <_16> = apply 'lc$^1'/1 (_4) in ([{J,_15}|_16]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_21> when 'true' -> (primop 'match_fail' ({'function_clause',_21})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_10> = letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[C|_6]> when 'true' -> let <_8> = call 'qlc':'all_selections' (C) in let <_9> = apply 'lc$^0'/1 (_6) in ([_8|_9]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_22> when 'true' -> (primop 'match_fail' ({'function_clause',_22})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <_11> = call 'lists':'append' (_10) in apply 'lc$^1'/1 (_11)-|['list_comprehension'] )
'skip_tag'/2 = fun (_0,_1) -> let <_4> = case <> of <> when try let <_3> = call 'erlang':'length' (_1) in let <_2> = call 'erlang':'length' (_0) in call 'erlang':'=:=' (_3,_2) of <Try> -> Try catch <T,R> -> 'false' -> 'all'
<> when 'true' -> 'some' end in {_4,_0}
'skip_tag'/3 = fun (_0,_1,_2) -> case call 'lists':'keyfind' (_0,1,_1) of <{_11,FilL}> when call 'erlang':'=:=' (_11,_0) -> let <_5> = case <> of <> when try let <_4> = call 'erlang':'length' (_2) in let <_3> = call 'erlang':'length' (FilL) in call 'erlang':'=:=' (_4,_3) of <Try> -> Try catch <T,R> -> 'false' -> 'all'
<> when 'true' -> 'some' end in {_5,FilL}
<'false'> when 'true' -> {'some',[]}
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
'join_info'/5 = fun (_0,_1,_2,_3,_4) -> case apply 'qual_data'/1 (_0) of <{FilterData,GeneratorData}> when 'true' -> case apply 'filter_info'/4 (FilterData,_1,_2,_3) of <{Filter,Anon1,Imported}> when 'true' -> let <BindFun> = fun (_8,_7) -> apply 'bind_no_const'/2 (_7,Imported) in case apply 'pattern_frame'/4 (GeneratorData,BindFun,Anon1,_3) of <{PatternFrame,PatternVars}> when 'true' -> let <PatternFrames> = apply 'frame2frames'/1 (PatternFrame) in let <Fs> = apply 'filter'/5 (Filter,PatternFrames,BindFun,_3,Imported) in let <SelectorFun> = apply 'no_const_selector'/1 (Imported) in let <_20> = fun (_17,_16) -> apply 'deref_join'/3 (_17,_16,_4) in let <Cols> = apply 'frames_to_columns'/6 (Fs,PatternVars,_20,SelectorFun,Imported,'=:=') in let <JC> = apply 'join_classes'/1 (Cols) in let <Skip> = apply 'join_skip'/8 (JC,FilterData,PatternFrame,PatternVars,_2,_3,Imported,_4) in {JC,Skip}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'deref_join'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <E,Frame,'=='> when 'true' -> apply 'deref_values'/3 (E,Frame,([]-|['compiler_generated'] ))
<E,Frame,'=:='> when 'true' -> let <_9> = fun (_6,_5) -> call 'erlang':'=:=' (_5,'=:=') in apply 'deref_values'/4 (E,Frame,_9,'all')
(<_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10})-|[{'function_name',{'deref_join',3}}] )-|['compiler_generated'] ) end
'join_classes'/1 = fun (_0) -> let <_1> = call 'lists':'append' (_0) in let <ColVar> = call 'sofs':'relation' (_1) in let <Cols> = call 'sofs':'partition' (2,ColVar) in (letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[Cs|_5]> when try let <_6> = call 'erlang':'length' (Cs) in call 'erlang':'>' (_6,1) of <Try> -> Try catch <T,R> -> 'false' -> let <_13> = letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[{C,_16}|_10]> when 'true' -> let <_12> = apply 'lc$^1'/1 (_10) in ([C|_12]-|['compiler_generated'] )
(<[_9|_10]> when 'true' -> apply 'lc$^1'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Cs) in let <_14> = apply 'lc$^0'/1 (_5) in ([_13|_14]-|['compiler_generated'] )
(<[Cs|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_18> when 'true' -> (primop 'match_fail' ({'function_clause',_18})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_7> = call 'sofs':'to_external' (Cols) in apply 'lc$^0'/1 (_7)-|['list_comprehension'] )
'join_skip'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> let <PatternFrames> = apply 'frame2frames'/1 (_2) in let <_61> = letrec 'lc$^2'/1 = fun (_51) -> case _51 of <[JoinClass = [{Q1,C1}|[{Q2,C2}|[]]]|_10]> when 'true' -> (letrec 'lc$^3'/1 = fun (_52) -> case _52 of <[{GId1,PV1}|_12]> when (try (let <_15> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (GId1,('qid'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_13-|['compiler_generated'] )> when 'true' -> (_13-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_16> = call 'erlang':'=:=' ((_15-|['compiler_generated'] ),'true') in let <_17> = call 'erlang':'element' (3,GId1) in let <_18> = call 'erlang':'=:=' (_17,Q1) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_16,_18)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (letrec 'lc$^4'/1 = fun (_53) -> case _53 of <[{GId2,PV2}|_20]> when (try (let <_23> = case (call ('erlang'-|['compiler_generated'] ):('is_record'-|['compiler_generated'] ) (GId2,('qid'-|['compiler_generated'] ),(3-|['compiler_generated'] ))-|['compiler_generated'] ) of (<('true'-|['compiler_generated'] )> when 'true' -> ('true'-|['compiler_generated'] )-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> ('fail'-|['compiler_generated'] )-|['compiler_generated'] )
(<(_21-|['compiler_generated'] )> when 'true' -> (_21-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_24> = call 'erlang':'=:=' ((_23-|['compiler_generated'] ),'true') in let <_25> = call 'erlang':'element' (3,GId2) in let <_26> = call 'erlang':'=:=' (_25,Q2) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (_24,_26)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (letrec 'lc$^5'/1 = fun (_54) -> case _54 of <[{FId,{'fil',Fil}}|_28]> when 'true' -> (letrec 'lc$^6'/1 = fun (_55) -> case _55 of <[{'value',{_71,GIds}}|_31]> when 'true' -> let <_33> = call 'lists':'sort' ([GId1|[GId2|[]]]) in (case <> of <> when call 'erlang':'=:=' (GIds,_33) -> let <BindFun> = fun (_35,_34) -> apply 'is_bindable'/1 (_34) in case apply 'unify_column'/5 (_2,PV1,C1,BindFun,_6) of <{V1,JF1}> when 'true' -> case apply 'unify_column'/5 (JF1,PV2,C2,BindFun,_6) of <{V2,JF2}> when 'true' -> let <JF> = apply 'unify'/6 (_7,V1,V2,JF2,BindFun,_6) in let <_42> = apply 'reset_anno'/1 (Fil) in let <SFs> = apply 'safe_filter'/5 (_42,PatternFrames,BindFun,_5,_6) in let <JImp> = call 'qlc':'vars' ([SFs|[JF|[]]]) in let <_48> = fun (_46) -> apply 'bindings_is_subset'/3 (_46,JF,JImp) in let <_50> = case call 'lists':'all' (_48,SFs) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'=/=' (SFs,[])-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_45> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_45}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in (case _50 of <'true'> when 'true' -> (case FId of (<({'qid',_72,_rec22}-|['compiler_generated'] )> when 'true' -> let <_58> = apply 'lc$^6'/1 (_31) in ([{JoinClass,_rec22}|_58]-|['compiler_generated'] )-|['compiler_generated'] )
(<_73> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^6'/1 (_31)-|['compiler_generated'] )
(<_59> when 'true' -> primop 'match_fail' ({'case_clause',_59})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<_40> when 'true' -> primop 'match_fail' ({'badmatch',_40})-|['compiler_generated'] ) end
(<_39> when 'true' -> primop 'match_fail' ({'badmatch',_39})-|['compiler_generated'] ) end
(<> when 'true' -> apply 'lc$^6'/1 (_31)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_30|_31]> when 'true' -> apply 'lc$^6'/1 (_31)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^5'/1 (_28)
(<_77> when 'true' -> (primop 'match_fail' ({'function_clause',_77})-|[{'function_name',{'lc$^6',1}}] )-|['compiler_generated'] ) end in let <_32> = call 'lists':'keysearch' (FId,1,_4) in apply 'lc$^6'/1 ([_32|[]])-|['list_comprehension'] )
(<[_27|_28]> when 'true' -> apply 'lc$^5'/1 (_28)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^4'/1 (_20)
(<_78> when 'true' -> (primop 'match_fail' ({'function_clause',_78})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in let <_29> = apply 'filter_list'/3 (_1,_4,_5) in apply 'lc$^5'/1 (_29)-|['list_comprehension'] )
(<[_19|_20]> when 'true' -> apply 'lc$^4'/1 (_20)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^3'/1 (_12)
(<_79> when 'true' -> (primop 'match_fail' ({'function_clause',_79})-|[{'function_name',{'lc$^4',1}}] )-|['compiler_generated'] ) end in apply 'lc$^4'/1 (_3)-|['list_comprehension'] )
(<[_11|_12]> when 'true' -> apply 'lc$^3'/1 (_12)-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^2'/1 (_10)
(<_80> when 'true' -> (primop 'match_fail' ({'function_clause',_80})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in apply 'lc$^3'/1 (_3)-|['list_comprehension'] )
(<[_9|_10]> when 'true' -> apply 'lc$^2'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_81> when 'true' -> (primop 'match_fail' ({'function_clause',_81})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (_0) in apply 'family_list'/1 (_61)
'filter_info'/4 = fun (_0,_1,_2,_3) -> let <FilterList> = apply 'filter_list'/3 (_0,_2,_3) in let <_5> = apply 'filters_as_one'/1 (FilterList) in let <Filter0> = apply 'reset_anno'/1 (_5) in case apply 'anon_var'/2 (Filter0,0) of <{Filter,Anon1}> when 'true' -> let <_10> = call 'qlc':'vars' (Filter) in let <_9> = call 'ordsets':'from_list' (_1) in let <Imported> = call 'ordsets':'subtract' (_10,_9) in {Filter,Anon1,Imported}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
'filter_list'/3 = fun (_0,_1,_2) -> apply 'sel_gf'/6 (_0,1,_1,_2,[],[])
'sel_gf'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[],_X_N,_X_Deps,_X_RDs,_X_Gens,_X_Gens1> when 'true' -> []
<[Fil = {Id = {'qid',_26,N},{'fil',F}}|FData],_27,Deps,State,Gens,Gens1> when call 'erlang':'=:=' (_27,N) -> case apply 'is_guard_test'/2 (F,State) of <'true'> when 'true' -> case call 'lists':'keyfind' (Id,1,Deps) of <{_28,GIds}> when call 'erlang':'=:=' (_28,Id) -> let <_7> = call 'erlang':'length' (GIds) in case <> of <> when call 'erlang':'=<' (_7,1) -> case apply 'generators_in_scope'/2 (GIds,Gens1) of <'true'> when 'true' -> let <_8> = call 'erlang':'+' (N,1) in let <_9> = apply 'sel_gf'/6 (FData,_8,Deps,State,Gens,Gens1) in [Fil|_9]
<'false'> when 'true' -> let <_10> = call 'erlang':'+' (N,1) in apply 'sel_gf'/6 (FData,_10,Deps,State,[],[])
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
<> when 'true' -> case apply 'generators_in_scope'/2 (GIds,Gens) of <'true'> when 'true' -> let <_12> = call 'erlang':'+' (N,1) in let <_13> = apply 'sel_gf'/6 (FData,_12,Deps,State,Gens,[]) in [Fil|_13]
<'false'> when 'true' -> let <_14> = call 'erlang':'+' (N,1) in apply 'sel_gf'/6 (FData,_14,Deps,State,[],[])
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_17> = call 'erlang':'+' (N,1) in apply 'sel_gf'/6 (FData,_17,Deps,State,[],[])
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end
<FData,N,Deps,State,Gens,Gens1> when 'true' -> let <_19> = call 'erlang':'+' (N,1) in apply 'sel_gf'/6 (FData,_19,Deps,State,[N|Gens],[N|Gens1]) end
'generators_in_scope'/2 = fun (_0,_1) -> let <_4> = fun (_2) -> case _2 of <{'qid',_7,N}> when 'true' -> call 'lists':'member' (N,_1)
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'-generators_in_scope/2-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'all' (_4,_0)
'pattern_frame'/4 = fun (_0,_1,_2,_3) -> let <_10> = fun (_7,_6) -> case <_7,_6> of <{QId,{'gen',Pattern,_16}},{F0,An0,PVs}> when 'true' -> case apply 'pattern'/5 (Pattern,An0,F0,_1,_3) of <{F1,An1,PV}> when 'true' -> {F1,An1,[{QId,PV}|PVs]}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'-pattern_frame/4-fun-0-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'foldl' (_10,{[],_2,[]},_0) of <{PatternFrame,_X_Anon2,PatternVars}> when 'true' -> {PatternFrame,PatternVars}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
'const_selector'/1 = fun (_0) -> let <_1> = 'is_const'/2 in apply 'selector'/2 (_0,_1)
'no_const_selector'/1 = fun (_0) -> let <_6> = fun (_3,_2) -> let <_1> = apply 'is_const'/2 (_3,_2) in call 'erlang':'not' (_1) in apply 'selector'/2 (_0,_6)
'selector'/2 = fun (_0,_1) -> (fun (_5) -> (fun (_3) -> case apply _1 (_3,_0) of <'true'> when 'true' -> {'yes',_3}
<'false'> when 'true' -> 'no'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end-|[{'id',{0,0,'-selector/2-fun-0-'}}] )-|[{'id',{0,0,'-selector/2-fun-1-'}}] )
'bind_no_const'/2 = fun (_0,_1) -> case apply 'is_const'/2 (_0,_1) of <'true'> when 'true' -> 'false'
<'false'> when 'true' -> apply 'is_bindable'/1 (_0)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'is_const'/2 = fun (_0,_1) -> let <_2> = call 'qlc':'vars' (_0) in let <_3> = call 'ordsets':'subtract' (_2,_1) in let <_4> = call 'ordsets':'to_list' (_3) in call 'erlang':'=:=' ([],_4)
'is_bindable'/1 = fun (_0) -> case apply 'normalise'/1 (_0) of <{'ok',_X_C}> when 'true' -> 'true'
<'not_ok'> when 'true' -> 'false'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'pattern'/5 = fun (_0,_1,_2,_3,_4) -> let <_9> = try apply 'expand_pattern_records'/2 (_0,_4) of <_5> -> _5 catch <_8,_7,_6> -> _0 in let <P2> = apply 'reset_anno'/1 (_9) in case apply 'anon_var'/2 (P2,_1) of <{P3,AnonN}> when 'true' -> let <_13> = apply 'tuple2cons'/1 (P3) in case apply 'match_in_pattern'/3 (_13,_2,_3) of <{P4,F1}> when 'true' -> case apply 'element_calls'/4 (P4,F1,_3,([]-|['compiler_generated'] )) of <{P,F2}> when 'true' -> case apply 'unique_var'/0 () of <UniqueVar = {'var',_30,PatternVar}> when 'true' -> let <F> = apply 'unify'/6 ('=:=',UniqueVar,P,F2,_3,([]-|['compiler_generated'] )) in {F,AnonN,PatternVar}
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
'frame2frames'/1 = fun (_0) -> case _0 of <'failed'> when 'true' -> []
<F> when 'true' -> [F|[]] end
'match_in_pattern'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'match',_19,E10,E20},F0,BF> when 'true' -> case apply 'match_in_pattern'/3 (E10,F0,BF) of <{E1,F1}> when 'true' -> case apply 'match_in_pattern'/3 (E20,F1,BF) of <{E2,F}> when 'true' -> let <_6> = case apply BF ('=:=',E1) of <'true'> when 'true' -> E1
<'false'> when 'true' -> E2
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end in let <_10> = apply 'unify'/6 ('=:=',E1,E2,F,BF,([]-|['compiler_generated'] )) in {_6,_10}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<T,F0,BF> when call 'erlang':'is_tuple' (T) -> let <_11> = call 'erlang':'tuple_to_list' (T) in case apply 'match_in_pattern'/3 (_11,F0,BF) of <{L,F}> when 'true' -> let <_13> = call 'erlang':'list_to_tuple' (L) in {_13,F}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<[E0|Es0],F0,BF> when 'true' -> case apply 'match_in_pattern'/3 (E0,F0,BF) of <{E,F1}> when 'true' -> case apply 'match_in_pattern'/3 (Es0,F1,BF) of <{Es,F}> when 'true' -> {[E|Es],F}
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<E,F,_X_BF> when 'true' -> {E,F} end
'anon_var'/2 = fun (_0,_1) -> let <_7> = fun (_4,_3) -> case <_4,_3> of <{'var',L,'_'},N> when 'true' -> let <_2> = call 'erlang':'+' (N,1) in {{'var',L,N},_2}
<Var,N> when 'true' -> {Var,N} end in apply 'var_mapfold'/3 (_7,_1,_0)
'reset_anno'/1 = fun (_0) -> let <_1> = apply 'anno0'/0 () in apply 'set_anno'/2 (_0,_1)
'set_anno'/2 = fun (_0,_1) -> let <_4> = fun (_2) -> _1 in apply 'map_anno'/2 (_4,_0)
'filter'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_X_E,Frames0 = [],_X_BF,_X_State,_X_Imported> when 'true' -> Frames0
<E0,Frames0,BF,State,Imported> when 'true' -> let <E> = apply 'pre_expand'/1 (E0) in let <FState> = {'fstate',State,BF,Imported} in apply 'filter1'/3 (E,Frames0,FState) end
'filter1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'op',_24,Op,L0,R0},Fs,FS> when let <_3> = call 'erlang':'=:=' (Op,'=:=') in let <_4> = call 'erlang':'=:=' (Op,'==') in call 'erlang':'or' (_3,_4) -> case FS of <{'fstate',S,BF,Imported}> when 'true' -> let <_11> = fun (_9) -> case apply 'prep_expr'/5 (L0,_9,S,BF,Imported) of <{L,F1}> when 'true' -> case apply 'prep_expr'/5 (R0,F1,S,BF,Imported) of <{R,F2}> when 'true' -> case apply 'unify'/6 (Op,L,R,F2,BF,Imported) of <'failed'> when 'true' -> []
<F> when 'true' -> [F|[]] end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end in call 'lists':'flatmap' (_11,Fs)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{'op',_25,Op,L,R},Fs,FS> when let <_12> = call 'erlang':'=:=' (Op,'and') in let <_13> = call 'erlang':'=:=' (Op,'andalso') in call 'erlang':'or' (_12,_13) -> let <_14> = apply 'filter1'/3 (L,Fs,FS) in apply 'filter1'/3 (R,_14,FS)
<{'op',_26,Op,L,R},Fs,FS> when let <_15> = call 'erlang':'=:=' (Op,'or') in let <_16> = call 'erlang':'=:=' (Op,'orelse') in let <_17> = call 'erlang':'=:=' (Op,'xor') in let <_18> = call 'erlang':'or' (_16,_17) in call 'erlang':'or' (_15,_18) -> let <_20> = apply 'filter1'/3 (L,Fs,FS) in let <_19> = apply 'filter1'/3 (R,Fs,FS) in call 'erlang':'++' (_20,_19)
<{'atom',_27,Atom},_X_Fs,_X_FS> when call 'erlang':'=/=' (Atom,'true') -> []
<{'call',L,{'remote',_28,{'atom',_29,'erlang'},{'atom',_30,'is_record'}},[T|[R|[]]]},Fs,FS> when 'true' -> apply 'filter1'/3 ({'op',L,'=:=',{'call',L,{'remote',L,{'atom',L,'erlang'},{'atom',L,'element'}},[{'integer',L,1}|[T|[]]]},R},Fs,FS)
<{'call',L,_@r0 = {'remote',L1,M = {'atom',_31,'erlang'},{'atom',L2,'is_record'}},[T|[R|[_X_Sz|[]]]]},Fs,FS> when 'true' -> apply 'filter1'/3 ({'call',L,_@r0,[T|[R|[]]]},Fs,FS)
<_X_E,Fs,_X_FS> when 'true' -> Fs end
'safe_filter'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_X_E,Frames0 = [],_X_BF,_X_State,_X_Imported> when 'true' -> Frames0
<E0,Frames0,BF,State,Imported> when 'true' -> let <E> = apply 'pre_expand'/1 (E0) in let <FState> = {'fstate',State,BF,Imported} in apply 'safe_filter1'/3 (E,Frames0,FState) end
'safe_filter1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'op',_22,Op,L0,R0},Fs,FS> when let <_3> = call 'erlang':'=:=' (Op,'=:=') in let <_4> = call 'erlang':'=:=' (Op,'==') in call 'erlang':'or' (_3,_4) -> case FS of <{'fstate',S,BF,Imported}> when 'true' -> let <_11> = fun (_9) -> case apply 'prep_expr'/5 (L0,_9,S,BF,Imported) of <{L,F1}> when 'true' -> case apply 'prep_expr'/5 (R0,F1,S,BF,Imported) of <{R,F2}> when 'true' -> case apply 'safe_unify'/6 (Op,L,R,F2,BF,Imported) of <'failed'> when 'true' -> []
<F> when 'true' -> [F|[]] end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end in call 'lists':'flatmap' (_11,Fs)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{'op',_23,Op,L,R},Fs,FS> when let <_12> = call 'erlang':'=:=' (Op,'and') in let <_13> = call 'erlang':'=:=' (Op,'andalso') in call 'erlang':'or' (_12,_13) -> let <_14> = apply 'safe_filter1'/3 (L,Fs,FS) in apply 'safe_filter1'/3 (R,_14,FS)
<{'op',_24,Op,L,R},Fs,FS> when let <_15> = call 'erlang':'=:=' (Op,'or') in let <_16> = call 'erlang':'=:=' (Op,'orelse') in call 'erlang':'or' (_15,_16) -> let <_18> = apply 'safe_filter1'/3 (L,Fs,FS) in let <_17> = apply 'safe_filter1'/3 (R,Fs,FS) in call 'erlang':'++' (_18,_17)
<{'atom',_25,'true'},Fs,_X_FS> when 'true' -> Fs
<_X_E,_X_Fs,_X_FS> when 'true' -> [] end
'pre_expand'/1 = fun (_0) -> case _0 of <{'call',L1,{'atom',L2,'record'},As}> when 'true' -> apply 'pre_expand'/1 ({'call',L1,{'atom',L2,'is_record'},As})
<{'call',L,F = {'atom',_6,_7},As}> when 'true' -> apply 'pre_expand'/1 ({'call',L,{'remote',L,{'atom',L,'erlang'},F},As})
<{'call',L,{'tuple',_8,[M|[F|[]]]},As}> when 'true' -> apply 'pre_expand'/1 ({'call',L,{'remote',L,M,F},As})
<T> when call 'erlang':'is_tuple' (_0) -> let <_1> = call 'erlang':'tuple_to_list' (T) in let <_2> = apply 'pre_expand'/1 (_1) in call 'erlang':'list_to_tuple' (_2)
<[E|Es]> when 'true' -> let <_3> = apply 'pre_expand'/1 (E) in let <_4> = apply 'pre_expand'/1 (Es) in [_3|_4]
<T> when 'true' -> T end
'frames_to_columns'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[],_X_PatternVars,_X_DerefFun,_X_SelectorFun,_X_Imp,_X_CompOp> when 'true' -> []
<Fs,PatternVars,DerefFun,SelectorFun,Imp,CompOp> when 'true' -> let <_24> = letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[{PatternId,PV}|_7]> when 'true' -> let <_9> = apply 'anno0'/0 () in let <PatVar> = {'var',_9,PV} in let <_16> = letrec 'lc$^1'/1 = fun (_13) -> case _13 of <[F|_12]> when 'true' -> let <_14> = apply 'pattern_size'/3 ([F|[]],PatVar,'false') in let <_15> = apply 'lc$^1'/1 (_12) in ([_14|_15]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_57> when 'true' -> (primop 'match_fail' ({'function_clause',_57})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Fs) in let <_18> = call 'erlang':'--' (_16,['undefined']) in let <MaxPZ> = call 'lists':'max' ([0|_18]) in let <Vars> = apply 'pat_vars'/1 (MaxPZ) in (case PatternId of (<({'qid',_55,_rec23}-|['compiler_generated'] )> when 'true' -> let <_23> = apply 'lc$^0'/1 (_7) in ([{_rec23,PatVar,_16,Vars}|_23]-|['compiler_generated'] )-|['compiler_generated'] )
(<_56> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<[_6|_7]> when 'true' -> apply 'lc$^0'/1 (_7)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_58> when 'true' -> (primop 'match_fail' ({'function_clause',_58})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (PatternVars) in let <BF> = fun (_27,_26) -> apply 'is_bindable'/1 (_26) in let <Fun> = fun (_39,_38) -> case <_39,_38> of <{_X_PatN,PatVar,PatSizes,Vars},Frames> when 'true' -> (letrec 'lc$^3'/1 = fun (_34) -> case _34 of <[{Sz,Frame}|_32]> when 'true' -> let <_35> = apply 'pat_tuple'/2 (Sz,Vars) in let <_36> = apply 'unify'/6 ('=:=',_35,PatVar,Frame,BF,Imp) in let <_37> = apply 'lc$^3'/1 (_32) in ([_36|_37]-|['compiler_generated'] )
(<[_31|_32]> when 'true' -> apply 'lc$^3'/1 (_32)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_61> when 'true' -> (primop 'match_fail' ({'function_clause',_61})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_33> = call 'lists':'zip' (PatSizes,Frames) in apply 'lc$^3'/1 (_33)-|['list_comprehension'] )
(<_41,_40> when 'true' -> (primop 'match_fail' ({'function_clause',_41,_40})-|[{'function_name',{'-frames_to_columns/6-fun-4-',2}}] )-|['compiler_generated'] ) end in let <NFs> = call 'lists':'foldl' (Fun,Fs,_24) in (letrec 'lc$^5'/1 = fun (_46) -> case _46 of <[{PatN,_X_PatVar,PatSizes,Vars}|_45]> when 'true' -> let <_47> = apply 'frames2cols'/7 (NFs,PatN,PatSizes,Vars,DerefFun,SelectorFun,CompOp) in let <_48> = apply 'lc$^5'/1 (_45) in ([_47|_48]-|['compiler_generated'] )
(<[_44|_45]> when 'true' -> apply 'lc$^5'/1 (_45)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_62> when 'true' -> (primop 'match_fail' ({'function_clause',_62})-|[{'function_name',{'lc$^5',1}}] )-|['compiler_generated'] ) end in apply 'lc$^5'/1 (_24)-|['list_comprehension'] ) end
'frames2cols'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <_33> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[{F,PatSz}|_8]> when 'true' -> let <_29> = letrec 'lc$^1'/1 = fun (_23) -> case _23 of <[{V,Col}|_12]> when 'true' -> let <_17> = apply _4 (V,F) in let <_18> = call 'erlang':'tl' (_17) in (case <> of <> when call 'erlang':'=:=' (_18,[]) -> let <_19> = apply _5 (F) in let <_20> = call 'erlang':'hd' (_17) in let <_22> = apply _19 (_20) in (case <> of <> when call 'erlang':'=/=' (_22,'no') -> let <_24> = call 'erlang':'element' (2,_22) in let <_25> = apply 'cons2tuple'/1 (_24) in let <_26> = apply 'lc$^1'/1 (_12) in ([{{_1,Col},_25}|_26]-|['compiler_generated'] )
(<> when 'true' -> apply 'lc$^1'/1 (_12)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<> when 'true' -> apply 'lc$^1'/1 (_12)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_11|_12]> when 'true' -> apply 'lc$^1'/1 (_12)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_59> when 'true' -> (primop 'match_fail' ({'function_clause',_59})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_14> = call 'lists':'sublist' (_3,PatSz) in let <_13> = call 'lists':'seq' (1,PatSz) in let <_15> = call 'lists':'zip' (_14,_13) in apply 'lc$^1'/1 (_15) in let <_31> = call 'sofs':'relation' (_29) in let <_32> = apply 'lc$^0'/1 (_8) in ([_31|_32]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_60> when 'true' -> (primop 'match_fail' ({'function_clause',_60})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_9> = call 'lists':'zip' (_0,_2) in apply 'lc$^0'/1 (_9) in let <Ss> = call 'sofs':'from_sets' (_33) in let <_38> = fun (_36) -> call 'sofs':'projection' (1,_36) in let <_39> = call 'sofs':'projection' (_38,Ss) in let <D> = call 'sofs':'intersection' (_39) in let <_41> = call 'sofs':'union' (Ss) in let <_42> = call 'sofs':'relation_to_family' (_41) in let <Cs> = call 'sofs':'restriction' (_42,D) in (letrec 'lc$^3'/1 = fun (_48) -> case _48 of <[C = {_58,Vs}|_45]> when 'true' -> (case apply 'col_ignore'/2 (Vs,_6) of <'false'> when 'true' -> let <_49> = apply 'lc$^3'/1 (_45) in ([C|_49]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^3'/1 (_45)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_44|_45]> when 'true' -> apply 'lc$^3'/1 (_45)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_62> when 'true' -> (primop 'match_fail' ({'function_clause',_62})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_46> = call 'sofs':'to_external' (Cs) in apply 'lc$^3'/1 (_46)-|['list_comprehension'] )
'pat_vars'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[_8|_2]> when 'true' -> let <_5> = apply 'unique_var'/0 () in let <_6> = apply 'lc$^0'/1 (_2) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_3> = call 'lists':'seq' (1,_0) in apply 'lc$^0'/1 (_3)-|['list_comprehension'] )
'pat_tuple'/2 = fun (_0,_1) -> case <_0,_1> of <Sz,Vars> when let <_2> = call 'erlang':'is_integer' (Sz) in let <_3> = call 'erlang':'>' (Sz,0) in call 'erlang':'and' (_2,_3) -> let <TupleTail> = apply 'unique_var'/0 () in let <_5> = call 'lists':'sublist' (Vars,Sz) in let <_6> = call 'erlang':'++' (_5,TupleTail) in let <_7> = apply 'list2cons'/1 (_6) in {'cons_tuple',_7}
<_10,_X_Vars> when 'true' -> apply 'unique_var'/0 () end
'col_ignore'/2 = fun (_0,_1) -> case <_0,_1> of <_X_Vs,'=:='> when 'true' -> 'false'
<Vs,'=='> when 'true' -> let <_11> = call 'erlang':'length' (Vs) in let <_8> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[V|_3]> when 'true' -> let <_5> = apply 'normalise'/1 (V) in let <_6> = call 'erlang':'element' (2,_5) in let <_7> = apply 'lc$^0'/1 (_3) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_14> when 'true' -> (primop 'match_fail' ({'function_clause',_14})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Vs) in let <_9> = call 'lists':'usort' (_8) in let <_10> = call 'erlang':'length' (_9) in call 'erlang':'=/=' (_11,_10)
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'col_ignore',2}}] )-|['compiler_generated'] ) end
'pattern_sizes'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[{QId,PV}|_3]> when 'true' -> let <_4> = apply 'anno0'/0 () in let <_6> = apply 'pattern_size'/3 (_1,{'var',_4,PV},'true') in (case <> of <> when call 'erlang':'=/=' ('undefined',_6) -> (case QId of (<({'qid',_14,_rec24}-|['compiler_generated'] )> when 'true' -> let <_10> = apply 'lc$^0'/1 (_3) in ([{_rec24,_6}|_10]-|['compiler_generated'] )-|['compiler_generated'] )
(<_15> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'pattern_size'/3 = fun (_0,_1,_2) -> let <Fun> = fun (_6) -> let <_5> = apply 'deref_pattern'/1 (([]-|['compiler_generated'] )) in apply _5 (_1,_6) in let <Derefs> = call 'lists':'flatmap' (Fun,_0) in let <_15> = letrec 'lc$^1'/1 = fun (_12) -> case _12 of <[{'cons_tuple',Cs}|_11]> when 'true' -> let <_13> = apply 'pattern_sz'/3 (Cs,0,_2) in let <_14> = apply 'lc$^1'/1 (_11) in ([_13|_14]-|['compiler_generated'] )
(<[_10|_11]> when 'true' -> apply 'lc$^1'/1 (_11)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_26> when 'true' -> (primop 'match_fail' ({'function_clause',_26})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Derefs) in case call 'lists':'usort' (_15) of <[Sz|[]]> when let <_17> = call 'erlang':'is_integer' (Sz) in let <_18> = call 'erlang':'>=' (Sz,0) in call 'erlang':'and' (_17,_18) -> Sz
<[]> when (call 'erlang':'=:=' (_2,'false')-|['compiler_generated'] ) -> 0
<_24> when 'true' -> 'undefined' end
'pattern_sz'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'cons',_7,_X_C,E},Col,Exact> when 'true' -> let <_3> = call 'erlang':'+' (Col,1) in apply 'pattern_sz'/3 (E,_3,Exact)
<{'nil',_8},Sz,_X_Exact> when 'true' -> Sz
<_9,_X_Sz,'true'> when 'true' -> 'undefined'
<_10,Sz,'false'> when 'true' -> Sz
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'pattern_sz',3}}] )-|['compiler_generated'] ) end
'deref_pattern'/1 = fun (_0) -> (fun (_2,_1) -> apply 'deref_values'/3 (_2,_1,_0)-|[{'id',{0,0,'-deref_pattern/1-fun-0-'}}] )
'prep_expr'/5 = fun (_0,_1,_2,_3,_4) -> let <_5> = apply 'expand_expr_records'/2 (_0,_2) in let <_6> = apply 'tuple2cons'/1 (_5) in apply 'element_calls'/4 (_6,_1,_3,_4)
'unify_column'/5 = fun (_0,_1,_2,_3,_4) -> let <A> = apply 'anno0'/0 () in let <Call> = {'call',A,{'remote',A,{'atom',A,'erlang'},{'atom',A,'element'}},[{'integer',A,_2}|[{'var',A,_1}|[]]]} in apply 'element_calls'/4 (Call,_0,_3,_4)
'element_calls'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <{'call',_28,{'remote',_29,{'atom',_30,'erlang'},{'atom',_31,'element'}},[{'integer',_32,I}|[Term0|[]]]},F0,BF,Imported> when call 'erlang':'>' (I,0) -> let <TupleTail> = apply 'unique_var'/0 () in let <_11> = letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[_33|_6]> when 'true' -> let <_9> = apply 'unique_var'/0 () in let <_10> = apply 'lc$^0'/1 (_6) in ([_9|_10]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_34> when 'true' -> (primop 'match_fail' ({'function_clause',_34})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_7> = call 'lists':'seq' (1,I) in apply 'lc$^0'/1 (_7) in let <Vars> = call 'erlang':'++' (_11,TupleTail) in let <_14> = apply 'list2cons'/1 (Vars) in let <Tuple> = {'cons_tuple',_14} in let <VarI> = call 'lists':'nth' (I,_11) in case apply 'element_calls'/4 (Term0,F0,BF,Imported) of <{Term,F}> when 'true' -> let <_18> = apply 'unify'/6 ('=:=',Tuple,Term,F,BF,Imported) in {VarI,_18}
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<T,F0,BF,Imported> when call 'erlang':'is_tuple' (T) -> let <_19> = call 'erlang':'tuple_to_list' (T) in case apply 'element_calls'/4 (_19,F0,BF,Imported) of <{L,F}> when 'true' -> let <_21> = call 'erlang':'list_to_tuple' (L) in {_21,F}
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
<[E0|Es0],F0,BF,Imported> when 'true' -> case apply 'element_calls'/4 (E0,F0,BF,Imported) of <{E,F1}> when 'true' -> case apply 'element_calls'/4 (Es0,F1,BF,Imported) of <{Es,F}> when 'true' -> {[E|Es],F}
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end
(<_22> when 'true' -> primop 'match_fail' ({'badmatch',_22})-|['compiler_generated'] ) end
<E,F,_X_BF,_X_Imported> when 'true' -> {E,F} end
'unique_var'/0 = fun () -> let <_1> = apply 'anno0'/0 () in let <_0> = call 'erlang':'make_ref' () in {'var',_1,_0}
'is_unique_var'/1 = fun (_0) -> case _0 of <{'var',_X_L,V}> when 'true' -> call 'erlang':'is_reference' (V)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'is_unique_var',1}}] )-|['compiler_generated'] ) end
'expand_pattern_records'/2 = fun (_0,_1) -> let <A> = apply 'anno0'/0 () in let <E> = {'case',A,{'atom',A,'true'},[{'clause',A,[_0|[]],[],[{'atom',A,'true'}|[]]}|[]]} in case apply 'expand_expr_records'/2 (E,_1) of <{'case',_7,_8,[{'clause',_9,[NP|[]],_10,_11}|[]]}> when call 'erlang':'=:=' (_9,A) -> NP
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'expand_expr_records'/2 = fun (_0,_1) -> (case _1 of (<({'state',_12,_13,_14,_rec25,_15,_16,_17}-|['compiler_generated'] )> when 'true' -> let <A> = apply 'anno1'/0 () in let <_6> = apply 'pe'/1 (_0) in let <Forms0> = call 'erlang':'++' (_rec25,[{'function',A,'foo',0,[{'clause',A,[],[],[_6|[]]}|[]]}|[]]) in let <Forms> = call 'erl_expand_records':'module' (Forms0,['no_strict_record_tests']) in case call 'lists':'last' (Forms) of <{'function',_19,'foo',0,[{'clause',_20,[],[],[NE|[]]}|[]]}> when 'true' -> NE
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_18> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'pe'/1 = fun (_0) -> case _0 of <{'op',Line,Op,A}> when 'true' -> let <_1> = apply 'pe'/1 (A) in call 'erl_eval':'partial_eval' ({'op',Line,Op,_1})
<{'op',Line,Op,L,R}> when 'true' -> let <_3> = apply 'pe'/1 (L) in let <_2> = apply 'pe'/1 (R) in call 'erl_eval':'partial_eval' ({'op',Line,Op,_3,_2})
<T> when call 'erlang':'is_tuple' (_0) -> let <_4> = call 'erlang':'tuple_to_list' (T) in let <_5> = apply 'pe'/1 (_4) in call 'erlang':'list_to_tuple' (_5)
<[E|Es]> when 'true' -> let <_6> = apply 'pe'/1 (E) in let <_7> = apply 'pe'/1 (Es) in [_6|_7]
<E> when 'true' -> E end
'unify'/6 = fun (_0,_1,_2,_3,_4,_5) -> apply 'unify'/7 (_0,_1,_2,_3,_4,_5,'false')
'safe_unify'/6 = fun (_0,_1,_2,_3,_4,_5) -> apply 'unify'/7 (_0,_1,_2,_3,_4,_5,'true')
'unify'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <_X_Op,_X_E1,_X_E2,'failed',_X_BF,_X_Imported,_X_Safe> when 'true' -> 'failed'
<_X_Op,E,_26,F,_X_BF,_X_Imported,_X_Safe> when call 'erlang':'=:=' (_26,E) -> F
<Op,Var = {'var',_27,_28},E2,F,BF,Imported,Safe> when 'true' -> apply 'extend_frame'/7 (Op,Var,E2,F,BF,Imported,Safe)
<Op,E1,Var = {'var',_29,_30},F,BF,Imported,Safe> when 'true' -> apply 'extend_frame'/7 (Op,Var,E1,F,BF,Imported,Safe)
<Op,{'cons_tuple',Es1},{'cons_tuple',Es2},F,BF,Imported,Safe> when 'true' -> apply 'unify'/7 (Op,Es1,Es2,F,BF,Imported,Safe)
<Op,{'cons',_31,L1,R1},{'cons',_32,L2,R2},F,BF,Imported,Safe> when 'true' -> let <E> = apply 'unify'/7 (Op,L1,L2,F,BF,Imported,Safe) in apply 'unify'/7 (Op,R1,R2,E,BF,Imported,Safe)
<Op,E1,E2,F,_X_BF,_X_Imported,Safe> when 'true' -> try case apply 'normalise'/1 (E1) of <{'ok',C1}> when 'true' -> case apply 'normalise'/1 (E2) of <{'ok',C2}> when 'true' -> case <> of <> when let <_10> = call 'erlang':'=:=' (Op,'=:=') in let <_11> = call 'erlang':'=:=' (C1,C2) in call 'erlang':'and' (_10,_11) -> F
<> when let <_12> = call 'erlang':'=:=' (Op,'==') in let <_13> = call 'erlang':'==' (C1,C2) in call 'erlang':'and' (_12,_13) -> F
<> when 'true' -> 'failed' end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end of <_14> -> _14 catch <_17,_16,_15> -> case <_17,_16,_15> of <('error'-|['compiler_generated'] ),_33,_34> when (call 'erlang':'=:=' (Safe,'true')-|['compiler_generated'] ) -> 'failed'
<('error'-|['compiler_generated'] ),_35,_36> when (call 'erlang':'=:=' (Safe,'false')-|['compiler_generated'] ) -> F
(<_37,_38,_39> when 'true' -> primop 'raise' (_39,_38)-|['compiler_generated'] ) end end
'extend_frame'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case apply 'var_values'/2 (_1,_3) of <[]> when 'true' -> case _2 of <{'var',_17,_18}> when 'true' -> case apply 'var_values'/2 (_2,_3) of <[]> when 'true' -> apply 'add_binding'/7 (_0,_2,_1,_3,_4,_5,_6)
<ValsOps> when 'true' -> apply 'maybe_add_binding'/8 (ValsOps,_0,_2,_1,_3,_4,_5,_6) end
<_19> when 'true' -> apply 'add_binding'/7 (_0,_1,_2,_3,_4,_5,_6) end
<ValsOps> when 'true' -> apply 'maybe_add_binding'/8 (ValsOps,_0,_1,_2,_3,_4,_5,_6) end
'maybe_add_binding'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case apply 'unify_var_bindings'/7 (_0,_1,_3,_4,_5,_6,_7) of <'failed'> when 'true' -> 'failed'
<F> when 'true' -> case apply 'already_bound'/4 (_1,_2,_3,F) of <'true'> when 'true' -> F
<'false'> when 'true' -> apply 'add_binding'/7 (_1,_2,_3,F,_5,_6,_7)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end end
'already_bound'/4 = fun (_0,_1,_2,_3) -> let <BFun> = fun (_5,_4) -> call 'erlang':'=:=' (_0,_4) in let <DerefValue> = apply 'deref_value'/5 (_2,_0,_3,BFun,'all') in let <DerefVar> = apply 'deref_var'/4 (_1,_3,BFun,'all') in let <_11> = call 'erlang':'--' (DerefValue,DerefVar) in call 'erlang':'=:=' (_11,[])
'unify_var_bindings'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[],_X_Op,_X_Value,F,_X_BF,_X_Imported,_X_Safe> when 'true' -> F
<[{VarValue,Op2}|Bindings],Op1,Value,F0,BF,Imported,Safe> when 'true' -> let <Op> = apply 'deref_op'/2 (Op1,Op2) in case apply 'unify'/7 (Op,VarValue,Value,F0,BF,Imported,Safe) of <'failed'> when 'true' -> 'failed'
<F> when 'true' -> apply 'unify_var_bindings'/7 (Bindings,Op1,Value,F,BF,Imported,Safe) end
(<_15,_14,_13,_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12,_11,_10,_9})-|[{'function_name',{'unify_var_bindings',7}}] )-|['compiler_generated'] ) end
'deref_op'/2 = fun (_0,_1) -> case <_0,_1> of <'=:=','=:='> when 'true' -> '=:='
<_4,_5> when 'true' -> '==' end
'var_values'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[{'bind',_9,Value,Op}|_3]> when 'true' -> let <_6> = apply 'lc$^0'/1 (_3) in ([{Value,Op}|_6]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_4> = apply 'var_bindings'/2 (_0,_1) in apply 'lc$^0'/1 (_4)-|['list_comprehension'] )
'deref_var'/3 = fun (_0,_1,_2) -> let <_7> = fun (_4,_3) -> 'true' in apply 'deref_var'/4 (_0,_1,_7,_2)
'deref_var'/4 = fun (_0,_1,_2,_3) -> let <_13> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[{'bind',_18,Value,Op}|_5]> when 'true' -> (letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[ValOp|_8]> when 'true' -> let <_12> = apply 'lc$^1'/1 (_8) in ([ValOp|_12]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_5)
(<_19> when 'true' -> (primop 'match_fail' ({'function_clause',_19})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_9> = apply 'deref_value'/5 (Value,Op,_1,_2,_3) in apply 'lc$^1'/1 (_9)-|['list_comprehension'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_20> when 'true' -> (primop 'match_fail' ({'function_clause',_20})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_6> = apply 'var_bindings'/2 (_0,_1) in apply 'lc$^0'/1 (_6) in call 'lists':'usort' (_13)
'deref_value'/5 = fun (_0,_1,_2,_3,_4) -> let <_11> = letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[ValOp = {Val,_X_Op}|_6]> when 'true' -> let <_9> = apply 'value_op'/3 (ValOp,_1,_4) in let <_10> = apply 'lc$^0'/1 (_6) in ([{Val,_9}|_10]-|['compiler_generated'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_7> = apply 'deref'/4 (_0,_2,_3,_4) in apply 'lc$^0'/1 (_7) in call 'lists':'usort' (_11)
'add_binding'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case apply 'maybe_swap_var_value'/4 (_1,_2,_3,_5) of <{Var,Value}> when 'true' -> case apply _4 (_0,Value) of <'true'> when 'true' -> apply 'add_binding2'/4 (Var,Value,_0,_3)
<'false'> when (call 'erlang':'=:=' (_6,'true')-|['compiler_generated'] ) -> 'failed'
<'false'> when (call 'erlang':'=:=' (_6,'false')-|['compiler_generated'] ) -> _3
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
'add_binding2'/4 = fun (_0,_1,_2,_3) -> case apply 'occurs'/3 (_0,_1,_3) of <'true'> when 'true' -> 'failed'
<'false'> when 'true' -> [{'bind',_0,_1,_2}|_3]
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'maybe_swap_var_value'/4 = fun (_0,_1,_2,_3) -> case apply 'do_swap_var_value'/4 (_0,_1,_2,_3) of <'true'> when 'true' -> {_1,_0}
<'false'> when 'true' -> {_0,_1}
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'do_swap_var_value'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Var1 = {'var',_13,V1},Var2 = {'var',_14,V2},F,Imported> when 'true' -> case apply 'swap_vv'/3 (Var1,Var2,F) of <[]> when 'true' -> case apply 'swap_vv'/3 (Var2,Var1,F) of <[]> when 'true' -> (case call 'ordsets':'is_element' (V1,Imported) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_5> = call 'ordsets':'is_element' (V2,Imported) in call 'erlang':'not' (_5)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_4> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_4}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_X_Bs> when 'true' -> 'true' end
<_X_Bs> when 'true' -> 'false' end
<_15,_16,_X_F,_X_Imp> when 'true' -> 'false' end
'swap_vv'/3 = fun (_0,_1,_2) -> (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{'bind',_11,V,_12}|_4]> when call 'erlang':'=:=' (V,_1) -> let <_7> = apply 'lc$^0'/1 (_4) in ([V|_7]-|['compiler_generated'] )
(<[_3|_4]> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_13> when 'true' -> (primop 'match_fail' ({'function_clause',_13})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_5> = apply 'var_bindings'/2 (_0,_2) in apply 'lc$^0'/1 (_5)-|['list_comprehension'] )
'normalise'/1 = fun (_0) -> let <_3> = catch let <_1> = apply 'cons2tuple'/1 (_0) in let <_2> = apply 'var2const'/1 (_1) in call 'erl_parse':'normalise' (_2) in case _3 of <{'EXIT',_6}> when 'true' -> 'not_ok'
<C> when 'true' -> {'ok',C} end
'occurs'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <V,_18,_X_F> when call 'erlang':'=:=' (_18,V) -> 'true'
<V,Var = {'var',_19,_20},F> when 'true' -> let <_8> = fun (_6) -> (case _6 of (<({'bind',_21,_rec26,_22}-|['compiler_generated'] )> when 'true' -> apply 'occurs'/3 (V,_rec26,F)-|['compiler_generated'] )
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bind'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) in let <_3> = apply 'var_bindings'/2 (Var,F) in call 'lists':'any' (_8,_3)
<V,T,F> when call 'erlang':'is_tuple' (T) -> let <_12> = fun (_10) -> apply 'occurs'/3 (V,_10,F) in let <_9> = call 'erlang':'tuple_to_list' (T) in call 'lists':'any' (_12,_9)
<V,[E|Es],F> when 'true' -> (case apply 'occurs'/3 (V,E,F) of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'occurs'/3 (V,Es,F)-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_13}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_X_V,_X_E,_X_F> when 'true' -> 'false' end
'deref_values'/3 = fun (_0,_1,_2) -> let <_7> = fun (_4,_3) -> 'true' in apply 'deref_values'/4 (_0,_1,_7,_2)
'deref_values'/4 = fun (_0,_1,_2,_3) -> let <_10> = letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[{V,Op}|_5]> when 'true' -> (case apply _2 (V,Op) of <'true'> when 'true' -> let <_8> = apply 'lc$^0'/1 (_5) in ([V|_8]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_6> = apply 'deref'/4 (_0,_1,_2,_3) in apply 'lc$^0'/1 (_6) in call 'lists':'usort' (_10)
'deref'/3 = fun (_0,_1,_2) -> let <BFun> = fun (_4,_3) -> 'true' in apply 'deref'/4 (_0,_1,BFun,_2)
'deref'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <V = {'var',_35,_36},F,BFun,Imp> when 'true' -> let <_7> = fun (_5) -> apply 'deref_binding'/4 (_5,F,BFun,Imp) in let <_4> = apply 'var_bindings'/2 (V,F) in let <DBs> = call 'lists':'flatmap' (_7,_4) in case DBs of <[]> when 'true' -> [{V,'=:='}|[]]
<_37> when 'true' -> call 'lists':'usort' (DBs) end
<T,F,BFun,Imp> when call 'erlang':'is_tuple' (T) -> (letrec 'lc$^1'/1 = fun (_14) -> case _14 of <[{DL,Op}|_11]> when 'true' -> let <_15> = call 'erlang':'list_to_tuple' (DL) in let <_16> = apply 'lc$^1'/1 (_11) in ([{_15,Op}|_16]-|['compiler_generated'] )
(<[_10|_11]> when 'true' -> apply 'lc$^1'/1 (_11)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_39> when 'true' -> (primop 'match_fail' ({'function_clause',_39})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_12> = call 'erlang':'tuple_to_list' (T) in let <_13> = apply 'deref'/4 (_12,F,BFun,Imp) in apply 'lc$^1'/1 (_13)-|['list_comprehension'] )
<Es,F,BFun,Imp> when call 'erlang':'is_list' (Es) -> let <_22> = letrec 'lc$^2'/1 = fun (_19) -> case _19 of <[C|_18]> when 'true' -> let <_20> = apply 'deref'/4 (C,F,BFun,Imp) in let <_21> = apply 'lc$^2'/1 (_18) in ([_20|_21]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_40> when 'true' -> (primop 'match_fail' ({'function_clause',_40})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (Es) in let <_30> = letrec 'lc$^3'/1 = fun (_27) -> case _27 of <[S|_25]> when 'true' -> let <_28> = apply 'deref_list'/1 (S) in let <_29> = apply 'lc$^3'/1 (_25) in ([_28|_29]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_41> when 'true' -> (primop 'match_fail' ({'function_clause',_41})-|[{'function_name',{'lc$^3',1}}] )-|['compiler_generated'] ) end in let <_26> = apply 'all_comb'/1 (_22) in apply 'lc$^3'/1 (_26) in call 'lists':'usort' (_30)
<E,_X_F,_X_BFun,_X_Imp> when 'true' -> [{E,'=:='}|[]] end
'var_bindings'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[B = {'bind',V,_8,_9}|_3]> when call 'erlang':'=:=' (V,_0) -> let <_5> = apply 'lc$^0'/1 (_3) in ([B|_5]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1)-|['list_comprehension'] )
'deref_binding'/4 = fun (_0,_1,_2,_3) -> case _0 of <{'bind',_17,Value,Op0}> when 'true' -> (letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[ValOp = {Val,_X_Op}|_6]> when 'true' -> let <_9> = apply 'value_op'/3 (ValOp,Op0,_3) in (case apply _2 (Val,_9) of <'true'> when 'true' -> let <_11> = apply 'lc$^0'/1 (_6) in ([{Val,_9}|_11]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_18> when 'true' -> (primop 'match_fail' ({'function_clause',_18})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_7> = apply 'deref'/4 (Value,_1,_2,_3) in apply 'lc$^0'/1 (_7)-|['list_comprehension'] )
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'deref_list'/1 = fun (_0) -> let <_5> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{_X_Val,Op}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([Op|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <_7> = case call 'lists':'usort' (_5) of <['=:=']> when 'true' -> '=:='
<_15> when 'true' -> '==' end in let <_13> = letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[{V,_X_Op}|_10]> when 'true' -> let <_12> = apply 'lc$^1'/1 (_10) in ([V|_12]-|['compiler_generated'] )
(<[_9|_10]> when 'true' -> apply 'lc$^1'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_0) in {_13,_7}
'value_op'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{_X_V,'=='},_X_BindOp,_X_Imp> when 'true' -> '=='
<{_X_V,'=:='},_X_BindOp = '=:=',_X_Imp> when 'true' -> '=:='
<{V,'=:='},_X_BindOp = '==',Imp> when 'true' -> case apply 'free_of_integers'/2 (V,Imp) of <'true'> when 'true' -> '=:='
<'false'> when 'true' -> '=='
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'value_op',3}}] )-|['compiler_generated'] ) end
'all_comb'/1 = fun (_0) -> case _0 of <[]> when 'true' -> [[]]
<[Cs|ICs]> when 'true' -> (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[C|_2]> when 'true' -> (letrec 'lc$^1'/1 = fun (_7) -> case _7 of <[L|_4]> when 'true' -> let <_8> = apply 'lc$^1'/1 (_4) in ([[C|L]|_8]-|['compiler_generated'] )
<[]> when 'true' -> apply 'lc$^0'/1 (_2)
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in let <_5> = apply 'all_comb'/1 (ICs) in apply 'lc$^1'/1 (_5)-|['list_comprehension'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Cs)-|['list_comprehension'] )
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'all_comb',1}}] )-|['compiler_generated'] ) end
'free_of_integers'/2 = fun (_0,_1) -> (case apply 'has_integer'/1 (_0) of (<'false'> when 'true' -> let <_4> = apply 'has_imported_vars'/2 (_0,_1) in call 'erlang':'not' (_4)-|['compiler_generated'] )
(<'true'> when 'true' -> 'false'-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['compiler_generated'] )
'has_imported_vars'/2 = fun (_0,_1) -> case <_0,_1> of <Value,'all'> when 'true' -> let <_2> = call 'qlc':'vars' (Value) in call 'erlang':'=/=' (_2,[])
<Value,Imported> when 'true' -> let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[Var|_4]> when 'true' -> (case call 'lists':'member' (Var,Imported) of <'true'> when 'true' -> let <_7> = apply 'lc$^0'/1 (_4) in ([Var|_7]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end-|['list_comprehension'] )
<[]> when 'true' -> []
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_5> = call 'qlc':'vars' (Value) in apply 'lc$^0'/1 (_5) in call 'erlang':'=/=' (_9,[]) end
'has_integer'/1 = fun (_0) -> try apply 'has_int'/1 (_0) of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('throw'-|['compiler_generated'] ),('true'-|['compiler_generated'] ),_6> when 'true' -> 'true'
(<_7,_8,_9> when 'true' -> primop 'raise' (_9,_8)-|['compiler_generated'] ) end
'has_int'/1 = fun (_0) -> case _0 of <{'integer',_5,I}> when try let <_1> = call 'erlang':'float' (I) in call 'erlang':'==' (_1,I) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'throw' ('true')
<{'float',_6,F}> when try let <_2> = call 'erlang':'round' (F) in call 'erlang':'==' (_2,F) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'throw' ('true')
<T> when call 'erlang':'is_tuple' (_0) -> let <_3> = call 'erlang':'tuple_to_list' (T) in apply 'has_int'/1 (_3)
<[E|Es]> when 'true' -> do apply 'has_int'/1 (E) apply 'has_int'/1 (Es)
<_7> when 'true' -> 'false' end
'tuple2cons'/1 = fun (_0) -> case _0 of <{'tuple',_8,Es}> when 'true' -> let <_1> = apply 'tuple2cons'/1 (Es) in let <_2> = apply 'list2cons'/1 (_1) in {'cons_tuple',_2}
<T> when call 'erlang':'is_tuple' (_0) -> let <_3> = call 'erlang':'tuple_to_list' (T) in let <_4> = apply 'tuple2cons'/1 (_3) in call 'erlang':'list_to_tuple' (_4)
<[E|Es]> when 'true' -> let <_5> = apply 'tuple2cons'/1 (E) in let <_6> = apply 'tuple2cons'/1 (Es) in [_5|_6]
<E> when 'true' -> E end
'list2cons'/1 = fun (_0) -> case _0 of <[E|Es]> when 'true' -> let <_2> = apply 'anno0'/0 () in let <_1> = apply 'list2cons'/1 (Es) in {'cons',_2,E,_1}
<[]> when 'true' -> let <_3> = apply 'anno0'/0 () in {'nil',_3}
<E> when 'true' -> E end
'cons2tuple'/1 = fun (_0) -> case _0 of <{'cons_tuple',Es}> when 'true' -> let <_2> = apply 'anno0'/0 () in let <_1> = apply 'cons2list'/1 (Es) in {'tuple',_2,_1}
<T> when call 'erlang':'is_tuple' (_0) -> let <_3> = call 'erlang':'tuple_to_list' (T) in let <_4> = apply 'cons2tuple'/1 (_3) in call 'erlang':'list_to_tuple' (_4)
<[E|Es]> when 'true' -> let <_5> = apply 'cons2tuple'/1 (E) in let <_6> = apply 'cons2tuple'/1 (Es) in [_5|_6]
<E> when 'true' -> E end
'cons2list'/1 = fun (_0) -> case _0 of <{'cons',_5,L,R}> when 'true' -> let <_1> = apply 'cons2tuple'/1 (L) in let <_2> = apply 'cons2list'/1 (R) in [_1|_2]
<{'nil',_6}> when 'true' -> []
<E> when 'true' -> let <_3> = apply 'cons2tuple'/1 (E) in [_3|[]] end
'bindings_is_subset'/3 = fun (_0,_1,_2) -> let <BF> = fun (_4,_3) -> 'true' in let <_12> = fun (_9,_8) -> case <_9,_8> of <{'bind',V,Value,Op},Frame> when 'true' -> apply 'unify'/6 (Op,V,Value,Frame,BF,_2)
(<_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10})-|[{'function_name',{'-bindings_is_subset/3-fun-1-',2}}] )-|['compiler_generated'] ) end in let <F> = call 'lists':'foldl' (_12,_1,_0) in (case apply 'bindings_subset'/3 (F,_1,_2) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'bindings_subset'/3 (_1,F,_2)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_14> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_14}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'bindings_subset'/3 = fun (_0,_1,_2) -> let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{'bind',V,_19,_20}|_4]> when 'true' -> (case apply 'is_unique_var'/1 (V) of <'false'> when 'true' -> let <_7> = apply 'lc$^0'/1 (_4) in ([V|_7]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_3|_4]> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_21> when 'true' -> (primop 'match_fail' ({'function_clause',_21})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <Vars> = call 'lists':'usort' (_9) in let <_15> = fun (_13) -> let <_12> = apply 'deref_var'/3 (_13,_0,_2) in let <_11> = apply 'deref_var'/3 (_13,_1,_2) in call 'erlang':'=:=' (_12,_11) in call 'lists':'all' (_15,Vars)
'try_ms'/4 = fun (_0,_1,_2,_3) -> let <L> = apply 'anno1'/0 () in let <Fun> = {'fun',L,{'clauses',[{'clause',L,[_1|[]],[[_2|[]]|[]],[_0|[]]}|[]]}} in let <Expr> = {'call',L,{'remote',L,{'atom',L,'ets'},{'atom',L,'fun2ms'}},[Fun|[]]} in let <Form> = {'function',L,'foo',0,[{'clause',L,[],[],[Expr|[]]}|[]]} in (case _3 of (<({'state',_23,_24,_25,_rec27,_26,_27,_28}-|['compiler_generated'] )> when 'true' -> let <_10> = call 'erlang':'++' (_rec27,[Form|[]]) in let <X> = call 'ms_transform':'parse_transform' (_10,[]) in let <_17> = catch case call 'lists':'last' (X) of <{'function',_30,'foo',0,[{'clause',_31,[],[],[MS0|[]]}|[]]}> when let <_32> = call 'erlang':'=:=' (_30,L) in let <_33> = call 'erlang':'=:=' (_31,L) in call 'erlang':'and' (_32,_33) -> let <_13> = apply 'var2const'/1 (MS0) in let <MS> = call 'erl_parse':'normalise' (_13) in let <XMS> = call 'ets':'match_spec_compile' (MS) in case call 'ets':'is_compiled_ms' (XMS) of <'true'> when 'true' -> {'ok',MS,MS0}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end in case _17 of <{'EXIT',_X_Reason}> when 'true' -> 'no'
<Reply> when 'true' -> Reply end-|['compiler_generated'] )
(<_29> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'filters_as_one'/1 = fun (_0) -> case _0 of <[]> when 'true' -> let <_1> = apply 'anno0'/0 () in {'atom',_1,'true'}
<FilterData> when 'true' -> case call 'lists':'reverse' (FilterData) of <[{_10,{'fil',Filter1}}|Filters]> when 'true' -> let <_8> = fun (_5,_4) -> case <_5,_4> of <{_X_QId,{'fil',Filter}},AbstF> when 'true' -> let <_3> = apply 'anno0'/0 () in {'op',_3,'andalso',Filter,AbstF}
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'-filters_as_one/1-fun-0-',2}}] )-|['compiler_generated'] ) end in call 'lists':'foldr' (_8,Filter1,Filters)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end end
'qual_data'/1 = fun (_0) -> let <F> = fun (_6) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{QId,_12,_13,Q}|_2]> when try let <_3> = call 'erlang':'element' (1,Q) in call 'erlang':'=:=' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <_5> = apply 'lc$^0'/1 (_2) in ([{QId,Q}|_5]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_14> when 'true' -> (primop 'match_fail' ({'function_clause',_14})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] ) in let <_10> = apply F ('fil') in let <_9> = apply F ('gen') in {_10,_9}
'set_field'/3 = fun (_0,_1,_2) -> let <_5> = call 'erlang':'-' (_0,1) in let <_6> = call 'lists':'sublist' (_1,_5) in let <_3> = call 'lists':'nthtail' (_0,_1) in let <_4> = [_2|_3] in call 'erlang':'++' (_6,_4)
'qdata'/2 = fun (_0,_1) -> case <_0,_1> of <[{{'qid',_13,QIdNo},{_X_QIVs,{{'gen',_X_P,LE,_X_GV},GoI,SI}}}|QCs],L> when 'true' -> let <_7> = case LE of <{'join',Op,Q1,Q2,H1,H2,Cs1_0,Cs2_0}> when 'true' -> let <Cs1> = apply 'qcon'/1 (Cs1_0) in let <Cs2> = apply 'qcon'/1 (Cs2_0) in let <Compat> = {'atom',L,'v1'} in let <CF> = apply 'closure'/2 ({'tuple',L,[Cs1|[Cs2|[Compat|[]]]]},L) in {'tuple',L,[{'atom',L,'join'}|[{'atom',L,Op}|[{'integer',L,Q1}|[{'integer',L,Q2}|[H1|[H2|[CF|[]]]]]]]]}
<_14> when 'true' -> apply 'closure'/2 (LE,L) end in let <_9> = apply 'qdata'/2 (QCs,L) in {'cons',L,{'tuple',L,[{'integer',L,QIdNo}|[{'integer',L,GoI}|[{'integer',L,SI}|[{'tuple',L,[{'atom',L,'gen'}|[_7|[]]]}|[]]]]]},_9}
<[{{'qid',_15,QIdNo},{_X_QIVs,{{'fil',_X_F},GoI,SI}}}|QCs],L> when 'true' -> let <_10> = apply 'qdata'/2 (QCs,L) in {'cons',L,{'tuple',L,[{'integer',L,QIdNo}|[{'integer',L,GoI}|[{'integer',L,SI}|[{'atom',L,'fil'}|[]]]]]},_10}
<[],L> when 'true' -> {'nil',L}
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'qdata',2}}] )-|['compiler_generated'] ) end
'qcon'/1 = fun (_0) -> let <A> = apply 'anno0'/0 () in let <_8> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{Col,ConstOps}|_3]> when 'true' -> let <_5> = apply 'qcon1'/1 (ConstOps) in let <_6> = apply 'list2cons'/1 (_5) in let <_7> = apply 'lc$^0'/1 (_3) in ([{'tuple',A,[{'integer',A,Col}|[_6|[]]]}|_7]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in apply 'list2cons'/1 (_8)
'qcon1'/1 = fun (_0) -> let <A> = apply 'anno0'/0 () in (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{Const,Op}|_3]> when 'true' -> let <_5> = apply 'abstr'/2 (Op,A) in let <_6> = apply 'lc$^0'/1 (_3) in ([{'tuple',A,[Const|[_5|[]]]}|_6]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'qcode'/5 = fun (_0,_1,_2,_3,_4) -> let <_14> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[{_21,C}|_6]> when 'true' -> let <Bin> = call 'erlang':'term_to_binary' (C,['compressed']) in let <_12> = call 'erlang':'binary_to_list' (Bin) in let <_13> = apply 'lc$^0'/1 (_6) in ([{'bin',_3,[{'bin_element',_3,{'string',_3,_12},'default','default'}|[]]}|_13]-|['compiler_generated'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_22> when 'true' -> (primop 'match_fail' ({'function_clause',_22})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_7> = call 'qlc':'template_state' () in let <_8> = apply 'qcode'/3 (_1,_2,_4) in let <_9> = call 'lists':'keysort' (1,[{_7,_0}|_8]) in apply 'lc$^0'/1 (_9) in {'fun',_3,{'clauses',[{'clause',_3,[],[],[{'tuple',_3,_14}|[]]}|[]]}}
'qcode'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{_X_QId,{_X_QIvs,{{'gen',P,_X_LE,_X_GV},GoI,_X_SI}}}|QCs],Source,State> when 'true' -> let <_3> = apply 'undo_no_shadows'/2 (P,State) in let <_4> = apply 'qcode'/3 (QCs,Source,State) in [{GoI,_3}|_4]
<[{QId,{_X_QIVs,{{'fil',_X_F},GoI,_X_SI}}}|QCs],Source,State> when 'true' -> let <OrigF> = call 'erlang':'map_get' (QId,Source) in let <_6> = apply 'undo_no_shadows'/2 (OrigF,State) in let <_7> = apply 'qcode'/3 (QCs,Source,State) in [{GoI,_6}|_7]
<[],_X_Source,_X_State> when 'true' -> []
(<_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8})-|[{'function_name',{'qcode',3}}] )-|['compiler_generated'] ) end
'closure'/2 = fun (_0,_1) -> {'fun',_1,{'clauses',[{'clause',_1,[],[],[_0|[]]}|[]]}}
'simple'/4 = fun (_0,_1,_2,_3) -> let <_4> = apply 'loc'/1 (_3) in let <_5> = apply 'abstr'/2 (_4,_3) in {'tuple',_0,[{'atom',_0,'simple_v1'}|[{'atom',_0,_1}|[_2|[_5|[]]]]]}
'clauses'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case <_0,_1,_2,_3,_4,_5,_6,_7> of <[{QId,{QIVs,{QualData,GoI,S}}}|QCs],RL,Fun,Go,NGV,E,IVs,St> when 'true' -> (case QId of (<({'qid',_rec28,_24}-|['compiler_generated'] )> when 'true' -> let <_10> = apply 'get_lcid_line'/1 (_rec28) in let <L> = apply 'no_compiler_warning'/1 (_10) in let <_13> = case QualData of <{'gen',P,_X_LE,GV}> when 'true' -> apply 'generator'/13 (S,QIVs,P,GV,NGV,E,IVs,RL,Fun,Go,GoI,L,St)
<{'fil',F}> when 'true' -> apply 'filter'/10 (F,L,QIVs,S,RL,Fun,Go,GoI,IVs,St)
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end in let <_15> = apply 'clauses'/8 (QCs,RL,Fun,Go,NGV,E,IVs,St) in call 'erlang':'++' (_13,_15)-|['compiler_generated'] )
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','qid'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<[],_X_RL,_X_Fun,_X_Go,_X_NGV,_X_IVs,_X_E,_X_St> when 'true' -> []
(<_23,_22,_21,_20,_19,_18,_17,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21,_20,_19,_18,_17,_16})-|[{'function_name',{'clauses',8}}] )-|['compiler_generated'] ) end
'final'/4 = fun (_0,_1,_2,_3) -> let <IAs> = apply 'replace'/3 (_1,_1,'_') in let <_5> = [_0|['_'|['_'|IAs]]] in let <_6> = apply 'abst_vars'/2 (_5,_2) in let <AsL> = apply 'pack_args'/3 ([{'integer',_2,0}|_6],_2,_3) in let <_8> = apply 'is_list_c'/2 (_0,_2) in let <Grd> = [_8|[]] in let <Rev> = {'call',_2,{'remote',_2,{'atom',_2,'lists'},{'atom',_2,'reverse'}},[{'var',_2,_0}|[]]} in let <CL> = {'clause',_2,AsL,[Grd|[]],[Rev|[]]} in let <_12> = ['_'|['_'|['_'|IAs]]] in let <_13> = apply 'abst_vars'/2 (_12,_2) in let <AsF> = apply 'pack_args'/3 ([{'integer',_2,0}|_13],_2,_3) in let <CF> = {'clause',_2,AsF,[],[{'nil',_2}|[]]} in [CL|[CF|[]]]
'template'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> let <I> = call 'qlc':'template_state' () in let <GoI> = call 'qlc':'template_state' () in let <_10> = apply 'abst_vars'/2 (_1,_5) in let <ARL> = {'cons',_5,_0,_10} in let <Next> = apply 'next'/3 (_3,GoI,_5) in let <_13> = [_1|[_2|[_3|_6]]] in let <As0> = apply 'abst_vars'/2 (_13,_5) in let <As> = apply 'pack_args'/3 ([{'integer',_5,I}|As0],_5,_7) in let <_16> = [_2|[_3|_6]] in let <_17> = apply 'abst_vars'/2 (_16,_5) in let <_18> = [Next|[ARL|_17]] in let <NAs> = apply 'pack_args'/3 (_18,_5,_7) in let <_20> = apply 'is_list_c'/2 (_1,_5) in let <Grd> = [_20|[]] in let <CL> = {'clause',_5,As,[Grd|[]],[{'call',_5,{'var',_5,_2},NAs}|[]]} in let <_26> = case apply 'split_args'/3 ([Next|As0],_5,_7) of <{ArgsL,ArgsT}> when 'true' -> let <_23> = call 'erlang':'++' (ArgsL,[{'var',_5,_4}|[]]) in let <Call> = {'call',_5,{'var',_5,_2},_23} in {'block',_5,[{'match',_5,{'var',_5,_4},ArgsT}|[{'fun',_5,{'clauses',[{'clause',_5,[],[],[Call|[]]}|[]]}}|[]]]}
<FNAs> when 'true' -> {'fun',_5,{'clauses',[{'clause',_5,[],[],[{'call',_5,{'var',_5,_2},FNAs}|[]]}|[]]}} end in let <CF> = {'clause',_5,As,[],[{'cons',_5,_0,_26}|[]]} in [CL|[CF|[]]]
'generator'/13 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12) -> let <ComAs> = apply 'abst_vars'/2 ([_7|[_8|[_9|[]]]],_11) in let <InitC> = apply 'generator_init'/9 (_0,_11,_3,_7,_8,_9,_10,_6,_12) in let <_15> = call 'erlang':'+' (_0,1) in let <_16> = call 'erlang':'--' (_1,[_3|[]]) in let <_17> = apply 'replace'/3 (_16,_6,'_') in let <_18> = apply 'abst_vars'/2 (_17,_11) in let <_19> = call 'erlang':'++' (ComAs,_18) in let <As> = [{'integer',_11,_15}|_19] in let <_21> = call 'erlang':'+' (_10,1) in let <MatchS> = apply 'next'/3 (_9,_21,_11) in let <_23> = apply 'replace'/3 ([_3|[]],_6,_4) in let <_24> = apply 'abst_vars'/2 (_23,_11) in let <_25> = call 'erlang':'++' (ComAs,_24) in let <AsM0> = [MatchS|_25] in let <AsM> = apply 'pack_args'/3 (AsM0,_11,_12) in let <_28> = call 'erlang':'+' (_0,1) in let <ContS> = {'integer',_11,_28} in let <QIVs__GV> = call 'erlang':'--' (_1,[_3|[]]) in let <_31> = apply 'replace'/3 (QIVs__GV,_6,'nil') in let <Tmp> = apply 'replace'/3 ([_3|[]],_31,_4) in let <_33> = apply 'abst_vars'/2 (Tmp,_11) in let <_34> = call 'erlang':'++' (ComAs,_33) in let <AsC> = apply 'pack_args'/3 ([ContS|_34],_11,_12) in let <DoneS> = apply 'next'/3 (_9,_10,_11) in let <_37> = apply 'replace'/3 (_1,_6,'nil') in let <_38> = apply 'abst_vars'/2 (_37,_11) in let <_39> = call 'erlang':'++' (ComAs,_38) in let <AsD0> = [DoneS|_39] in let <AsD> = apply 'pack_args'/3 (AsD0,_11,_12) in let <CsL> = apply 'generator_list'/10 (_2,_3,_4,As,AsM,AsC,AsD,_8,_11,_12) in let <CsF> = apply 'generator_cont'/11 (_2,_3,_4,_5,As,AsM,AsC,AsD,_8,_11,_12) in let <_44> = call 'erlang':'++' (CsL,CsF) in [InitC|_44]
'generator_init'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> let <_9> = apply 'replace'/3 ([_2|[]],_7,'_') in let <_10> = [_3|[_4|[_5|_9]]] in let <As0> = apply 'abst_vars'/2 (_10,_1) in let <As> = apply 'pack_args'/3 ([{'integer',_1,_0}|As0],_1,_8) in let <_13> = call 'erlang':'+' (_6,2) in let <Next> = apply 'next'/3 (_5,_13,_1) in let <_15> = call 'erlang':'+' (_0,1) in let <_16> = apply 'replace'/3 ([{'var',_1,'_'}|[]],As0,Next) in let <NAs> = apply 'pack_args'/3 ([{'integer',_1,_15}|_16],_1,_8) in {'clause',_1,As,[],[{'call',_1,{'var',_1,_4},NAs}|[]]}
'generator_list'/10 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8,_9) -> let <_10> = apply 'replace'/3 ([{'var',_8,_1}|[]],_3,{'cons',_8,_0,{'var',_8,_2}}) in let <As1> = apply 'pack_args'/3 (_10,_8,_9) in let <_12> = apply 'replace'/3 ([{'var',_8,_1}|[]],_3,{'cons',_8,{'var',_8,'_'},{'var',_8,_2}}) in let <As2> = apply 'pack_args'/3 (_12,_8,_9) in let <_14> = apply 'replace'/3 ([{'var',_8,_1}|[]],_3,{'nil',_8}) in let <As3> = apply 'pack_args'/3 (_14,_8,_9) in let <CM> = {'clause',_8,As1,[],[{'call',_8,{'var',_8,_7},_4}|[]]} in let <CC> = {'clause',_8,As2,[],[{'call',_8,{'var',_8,_7},_5}|[]]} in let <CD> = {'clause',_8,As3,[],[{'call',_8,{'var',_8,_7},_6}|[]]} in [CM|[CC|[CD|[]]]]
'generator_cont'/11 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10) -> let <As> = apply 'pack_args'/3 (_4,_9,_10) in let <CF1> = {'cons',_9,_0,{'var',_9,_2}} in let <CF2> = {'cons',_9,{'var',_9,'_'},{'var',_9,_2}} in let <CF3> = {'nil',_9} in let <CF4> = {'var',_9,_3} in let <CM> = {'clause',_9,[CF1|[]],[],[{'call',_9,{'var',_9,_8},_5}|[]]} in let <CC> = {'clause',_9,[CF2|[]],[],[{'call',_9,{'var',_9,_8},_6}|[]]} in let <CD> = {'clause',_9,[CF3|[]],[],[{'call',_9,{'var',_9,_8},_7}|[]]} in let <CE> = {'clause',_9,[CF4|[]],[],[CF4|[]]} in let <Cls> = [CM|[CC|[CD|[CE|[]]]]] in let <B> = {'case',_9,{'call',_9,{'var',_9,_1},[]},Cls} in [{'clause',_9,As,[],[B|[]]}|[]]
'filter'/10 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8,_9) -> let <IAs> = apply 'replace'/3 (_2,_8,'_') in let <_11> = [_4|[_5|[_6|IAs]]] in let <_12> = apply 'abst_vars'/2 (_11,_1) in let <As> = apply 'pack_args'/3 ([{'integer',_1,_3}|_12],_1,_9) in let <_14> = [_4|[_5|[_6|_8]]] in let <NAs> = apply 'abst_vars'/2 (_14,_1) in let <_16> = call 'erlang':'+' (_7,1) in let <TNext> = apply 'next'/3 (_6,_16,_1) in let <FNext> = apply 'next'/3 (_6,_7,_1) in let <NAsT> = apply 'pack_args'/3 ([TNext|NAs],_1,_9) in let <NAsF> = apply 'pack_args'/3 ([FNext|NAs],_1,_9) in let <_26> = case apply 'is_guard_test'/2 (_0,_9) of <'true'> when 'true' -> let <CT> = {'clause',_1,[],[[_0|[]]|[]],[{'call',_1,{'var',_1,_5},NAsT}|[]]} in let <CF> = {'clause',_1,[],[[{'atom',_1,'true'}|[]]|[]],[{'call',_1,{'var',_1,_5},NAsF}|[]]} in [{'if',_1,[CT|[CF|[]]]}|[]]
<'false'> when 'true' -> let <CT> = {'clause',_1,[{'atom',_1,'true'}|[]],[],[{'call',_1,{'var',_1,_5},NAsT}|[]]} in let <CF> = {'clause',_1,[{'atom',_1,'false'}|[]],[],[{'call',_1,{'var',_1,_5},NAsF}|[]]} in [{'case',_1,_0,[CT|[CF|[]]]}|[]]
(<_25> when 'true' -> primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end in [{'clause',_1,As,[],_26}|[]]
'pack_args'/3 = fun (_0,_1,_2) -> case apply 'split_args'/3 (_0,_1,_2) of <{ArgsL,ArgsT}> when 'true' -> call 'erlang':'++' (ArgsL,[ArgsT|[]])
<_7> when 'true' -> _0 end
'split_args'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Args,L,State = {'state',_21,_22,_23,_24,_25,_26,_27}> when (try let <_8> = call 'erlang':'length' (Args) in let <_7> = call 'erlang':'element' (4,State) in call 'erlang':'>' (_8,_7) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case State of (<({'state',_28,_29,_rec29,_30,_31,_32,_33}-|['compiler_generated'] )> when 'true' -> let <_16> = call 'erlang':'-' (_rec29,1) in let <_17> = call 'lists':'sublist' (Args,_16) in (case State of (<({'state',_35,_36,_rec30,_37,_38,_39,_40}-|['compiler_generated'] )> when 'true' -> let <_12> = call 'erlang':'-' (_rec30,1) in let <_13> = call 'lists':'nthtail' (_12,Args) in {_17,{'tuple',L,_13}}-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_34> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Args,_X_L,_X_State> when 'true' -> Args end
'replace'/3 = fun (_0,_1,_2) -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[E|_4]> when 'true' -> let <_7> = case call 'lists':'member' (E,_0) of <'true'> when 'true' -> _2
<'false'> when 'true' -> E
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end in let <_8> = apply 'lc$^0'/1 (_4) in ([_7|_8]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1)-|['list_comprehension'] )
'is_list_c'/2 = fun (_0,_1) -> {'call',_1,{'atom',_1,'is_list'},[{'var',_1,_0}|[]]}
'next'/3 = fun (_0,_1,_2) -> {'call',_2,{'atom',_2,'element'},[{'integer',_2,_1}|[{'var',_2,_0}|[]]]}
'aux_vars'/3 = fun (_0,_1,_2) -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[Name|_4]> when 'true' -> let <_6> = apply 'aux_var'/5 (Name,_1,0,1,_2) in let <_7> = apply 'lc$^0'/1 (_4) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> (primop 'match_fail' ({'function_clause',_11})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'aux_var'/5 = fun (_0,_1,_2,_3,_4) -> let <_5> = call 'lists':'concat' ([_0|[_1|['_'|[_2|['_']]]]]) in call 'qlc':'aux_name' (_5,_3,_4)
'no_compiler_warning'/1 = fun (_0) -> let <Anno> = call 'erl_anno':'new' (_0) in call 'erl_anno':'set_generated' ('true',Anno)
'loc'/1 = fun (_0) -> call 'erl_anno':'location' (_0)
'list2op'/2 = fun (_0,_1) -> case <_0,_1> of <[E|[]],_X_Op> when 'true' -> E
<[E|Es],Op> when 'true' -> let <_3> = apply 'anno0'/0 () in let <_2> = apply 'list2op'/2 (Es,Op) in {'op',_3,Op,E,_2}
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'list2op',2}}] )-|['compiler_generated'] ) end
'anno0'/0 = fun () -> call 'erl_anno':'new' (0)
'anno1'/0 = fun () -> call 'erl_anno':'new' (1)
'qual_fold'/5 = fun (_0,_1,_2,_3,_4) -> let <F> = fun (_8,_7,_6) -> case <_8,_7,_6> of <Id,{'lc',L,E,Qs0},GA0> when 'true' -> case apply 'qual_fold'/7 (Qs0,_0,GA0,_2,Id,1,[]) of <{Qs,GA,_X_NA}> when 'true' -> {{'lc',L,E,Qs},GA}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<_X_Id,Expr,GA> when 'true' -> {Expr,GA} end in apply 'qlc_mapfold'/4 (F,_1,_3,_4)
'qual_fold'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[Q0|Qs],F,GA0,A0,Id,No,NQs> when 'true' -> let <QId> = apply 'qid'/2 (Id,No) in case apply F (QId,Q0,GA0,A0) of <{Q,GA,A}> when 'true' -> let <_9> = call 'erlang':'+' (No,1) in apply 'qual_fold'/7 (Qs,F,GA,A,Id,_9,[Q|NQs])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<[],_X_F,GA,A,_X_Id,_X_No,NQs> when 'true' -> let <_10> = call 'lists':'reverse' (NQs) in {_10,GA,A}
(<_17,_16,_15,_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_17,_16,_15,_14,_13,_12,_11})-|[{'function_name',{'qual_fold',7}}] )-|['compiler_generated'] ) end
'qlc_mapfold'/4 = fun (_0,_1,_2,_3) -> (case _3 of (<({'state',_rec31,_11,_12,_13,_14,_15,_16}-|['compiler_generated'] )> when 'true' -> case apply 'qlcmf'/5 (_2,_0,_rec31,_1,1) of <{Forms,A,_X_NNo}> when 'true' -> do call 'erlang':'erase' ('qlc_current_file') {Forms,A}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_17> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'qlcmf'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[E0|Es0],F,Imp,A0,No0> when 'true' -> case apply 'qlcmf'/5 (E0,F,Imp,A0,No0) of <{E,A1,No1}> when 'true' -> case apply 'qlcmf'/5 (Es0,F,Imp,A1,No1) of <{Es,A,No}> when 'true' -> {[E|Es],A,No}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{'call',L1,_@r0 = {'remote',L2,{'atom',L3,'qlc'},{'atom',L4,'q'}},[LC0|Os0]},F,Imp,A0,No0> when try let <_7> = call 'erlang':'length' (Os0) in call 'erlang':'<' (_7,2) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'qlcmf'/5 (Os0,F,Imp,A0,No0) of <{Os,A1,No1}> when 'true' -> case apply 'qlcmf'/5 (LC0,F,Imp,A1,No1) of <{LC,A2,No}> when 'true' -> let <NL> = apply 'make_lcid'/2 (L1,No) in case apply F (NL,LC,A2) of <{T,A}> when 'true' -> let <_12> = call 'erlang':'+' (No,1) in {{'call',L1,_@r0,[T|Os]},A,_12}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<{'call',L,_@r1 = {'atom',L2,'q'},[LC0|Os0]},F,Imp = 'true',A0,No0> when try let <_13> = call 'erlang':'length' (Os0) in call 'erlang':'<' (_13,2) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'qlcmf'/5 (Os0,F,Imp,A0,No0) of <{Os,A1,No1}> when 'true' -> case apply 'qlcmf'/5 (LC0,F,Imp,A1,No1) of <{LC,A2,No}> when 'true' -> let <NL> = apply 'make_lcid'/2 (L,No) in case apply F (NL,LC,A2) of <{T,A}> when 'true' -> let <_18> = call 'erlang':'+' (No,1) in {{'call',L,_@r1,[T|Os]},A,_18}
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<Attr = {'attribute',_X_L,'file',{File,_X_Line}},_X_F,_X_Imp,A,No> when 'true' -> do call 'erlang':'put' ('qlc_current_file',File) {Attr,A,No}
<T,F,Imp,A0,No0> when call 'erlang':'is_tuple' (T) -> let <_19> = call 'erlang':'tuple_to_list' (T) in case apply 'qlcmf'/5 (_19,F,Imp,A0,No0) of <{TL,A,No}> when 'true' -> let <_21> = call 'erlang':'list_to_tuple' (TL) in {_21,A,No}
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
<T,_X_F,_X_Imp,A,No> when 'true' -> {T,A,No} end
'occ_vars'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'var',_X_L,V}> when 'true' -> V
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-occ_vars/1-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'qlc':'var_fold' (_3,[],_0)
'save_anno'/2 = fun (_0,_1) -> let <F> = fun (_7) -> let <N> = apply 'next_slot'/1 (_1) in let <Location> = call 'erl_anno':'location' (_7) in let <_4> = ~{'location'=>Location}~ in let <Data> = {N,_4} in case call 'ets':'insert' (_1,Data) of <'true'> when 'true' -> call 'erl_anno':'new' (N)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end in apply 'map_anno'/2 (F,_0)
'next_slot'/1 = fun (_0) -> let <I> = call 'ets':'update_counter' (_0,'var_n',1) in case call 'ets':'lookup' (_0,I) of <[]> when 'true' -> I
<_4> when 'true' -> apply 'next_slot'/1 (_0) end
'restore_anno'/2 = fun (_0,_1) -> let <F> = fun (_5) -> let <Location> = call 'erl_anno':'location' (_5) in case call 'ets':'lookup' (_1,Location) of <[{_10,Data}|[]]> when call 'erlang':'=:=' (_10,Location) -> let <OrigLocation> = call 'maps':'get' ('location',Data) in call 'erl_anno':'set_location' (OrigLocation,_5)
<[{_11}|[]]> when call 'erlang':'=:=' (_11,Location) -> _5
<[]> when 'true' -> _5
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in apply 'map_anno'/2 (F,_0)
'restore_loc'/2 = fun (_0,_1) -> case <_0,_1> of <Location,{'state',_5,_6,_7,_8,_9,_10,NodeInfo}> when 'true' -> case call 'ets':'lookup' (NodeInfo,Location) of <[{_11,~{'location':=OrigLocation}~}|[]]> when call 'erlang':'=:=' (_11,Location) -> OrigLocation
<[{_12}|[]]> when call 'erlang':'=:=' (_12,Location) -> Location
<[]> when 'true' -> Location
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'restore_loc',2}}] )-|['compiler_generated'] ) end
'no_shadows'/2 = fun (_0,_1) -> let <_2> = call 'qlc':'vars' (_0) in let <_3> = call 'ordsets':'to_list' (_2) in let <AllVars> = call 'gb_sets':'from_list' (_3) in let <VFun> = fun (_7,_6,_5) -> apply 'nos'/2 (_6,_5) in let <LI> = call 'ets':'new' ('qlc',[]) in let <UV> = call 'ets':'new' ('qlc',[]) in let <D0> = call 'maps':'new' () in let <S1> = {LI,D0,UV,AllVars,[],_1} in do apply 'qlc_mapfold'/4 (VFun,S1,_0,_1) let <Singletons> = call 'ets':'select' (UV,[{{'$1',0},[],['$1']}]) in case call 'ets':'delete_all_objects' (LI) of <'true'> when 'true' -> case call 'ets':'delete_all_objects' (UV) of <'true'> when 'true' -> let <S2> = {LI,D0,UV,AllVars,Singletons,_1} in case apply 'qlc_mapfold'/4 (VFun,S2,_0,_1) of <{Forms,_26}> when 'true' -> case call 'ets':'delete' (LI) of <'true'> when 'true' -> case call 'ets':'delete' (UV) of <'true'> when 'true' -> Forms
(<_23> when 'true' -> primop 'match_fail' ({'badmatch',_23})-|['compiler_generated'] ) end
(<_22> when 'true' -> primop 'match_fail' ({'badmatch',_22})-|['compiler_generated'] ) end
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
'nos'/2 = fun (_0,_1) -> case <_0,_1> of <[E0|Es0],S0> when 'true' -> case apply 'nos'/2 (E0,S0) of <{E,S1}> when 'true' -> case apply 'nos'/2 (Es0,S1) of <{Es,S}> when 'true' -> {[E|Es],S}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{'fun',L,{'clauses',Cs}},S> when 'true' -> let <_10> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{'clause',Ln,H0,G0,B0}|_5]> when 'true' -> case apply 'nos_pattern'/2 (H0,S) of <{H,S1}> when 'true' -> case apply 'nos'/2 ([G0|[B0|[]]],S1) of <{[G|[B|[]]],_40}> when 'true' -> let <_9> = apply 'lc$^0'/1 (_5) in ([{'clause',Ln,H,G,B}|_9]-|['compiler_generated'] )
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_45> when 'true' -> (primop 'match_fail' ({'function_clause',_45})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Cs) in {{'fun',L,{'clauses',_10}},S}
<{'named_fun',Loc,Name,Cs},S> when 'true' -> let <_13> = case Name of <'_'> when 'true' -> S
<_41> when 'true' -> apply 'nos_pattern'/2 ({'var',Loc,Name},S) end in case _13 of <{{'var',NLoc,NName},S1}> when 'true' -> let <_21> = letrec 'lc$^1'/1 = fun (_17) -> case _17 of <[{'clause',CLoc,H0,G0,B0}|_16]> when 'true' -> case apply 'nos_pattern'/2 (H0,S1) of <{H,S2}> when 'true' -> case apply 'nos'/2 ([G0|[B0|[]]],S2) of <{[G|[B|[]]],_42}> when 'true' -> let <_20> = apply 'lc$^1'/1 (_16) in ([{'clause',CLoc,H,G,B}|_20]-|['compiler_generated'] )
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
(<[_15|_16]> when 'true' -> apply 'lc$^1'/1 (_16)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_46> when 'true' -> (primop 'match_fail' ({'function_clause',_46})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Cs) in {{'named_fun',NLoc,NName,_21},S}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<{'lc',L,E0,Qs0},S> when 'true' -> let <F> = fun (_28,_27) -> case <_28,_27> of <{T,Ln,P0,LE0},QS0> when let <_23> = call 'erlang':'=:=' (T,'b_generate') in let <_24> = call 'erlang':'=:=' (T,'generate') in call 'erlang':'or' (_23,_24) -> case apply 'nos'/2 (LE0,QS0) of <{LE,_43}> when 'true' -> case apply 'nos_pattern'/2 (P0,QS0) of <{P,QS}> when 'true' -> {{T,Ln,P,LE},QS}
(<_26> when 'true' -> primop 'match_fail' ({'badmatch',_26})-|['compiler_generated'] ) end
(<_25> when 'true' -> primop 'match_fail' ({'badmatch',_25})-|['compiler_generated'] ) end
<Filter,QS> when 'true' -> apply 'nos'/2 (Filter,QS) end in case call 'lists':'mapfoldl' (F,S,Qs0) of <{Qs,S1}> when 'true' -> case apply 'nos'/2 (E0,S1) of <{E,_44}> when 'true' -> {{'lc',L,E,Qs},S}
(<_33> when 'true' -> primop 'match_fail' ({'badmatch',_33})-|['compiler_generated'] ) end
(<_32> when 'true' -> primop 'match_fail' ({'badmatch',_32})-|['compiler_generated'] ) end
<Var = {'var',L,V},S = {_X_LI,Vs,UV,_X_A,_X_Sg,State}> when call 'erlang':'=/=' (V,'_') -> case apply 'used_var'/3 (V,Vs,UV) of <{'true',VN}> when 'true' -> do apply 'nos_var'/3 (L,V,State) {{'var',L,VN},S}
<'false'> when 'true' -> {Var,S}
(<_34> when 'true' -> primop 'match_fail' ({'case_clause',_34})-|['compiler_generated'] ) end
<T,S0> when call 'erlang':'is_tuple' (T) -> let <_35> = call 'erlang':'tuple_to_list' (T) in case apply 'nos'/2 (_35,S0) of <{TL,S}> when 'true' -> let <_37> = call 'erlang':'list_to_tuple' (TL) in {_37,S}
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end
<T,S> when 'true' -> {T,S} end
'nos_pattern'/2 = fun (_0,_1) -> case apply 'nos_pattern'/3 (_0,_1,[]) of <{T,NS,_5}> when 'true' -> {T,NS}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'nos_pattern'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[P0|Ps0],S0,PVs0> when 'true' -> case apply 'nos_pattern'/3 (P0,S0,PVs0) of <{P,S1,PVs1}> when 'true' -> case apply 'nos_pattern'/3 (Ps0,S1,PVs1) of <{Ps,S,PVs}> when 'true' -> {[P|Ps],S,PVs}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<{'var',L,V},{LI,Vs0,UV,A,Sg,State},PVs0> when call 'erlang':'=/=' (V,'_') -> let <_20,_21,_22> = case call 'lists':'keyfind' (V,1,PVs0) of <{_19,VN}> when call 'erlang':'=:=' (_19,V) -> do apply 'used_var'/3 (V,Vs0,UV) <VN,Vs0,PVs0>
<'false'> when 'true' -> case apply 'next_var'/5 (V,Vs0,A,LI,UV) of <{VN,Vs1}> when 'true' -> let <_8> = case call 'lists':'member' (VN,Sg) of <'true'> when 'true' -> '_'
<'false'> when 'true' -> VN
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end in <_8,Vs1,[{V,VN}|PVs0]>
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end in do apply 'nos_var'/3 (L,V,State) {{'var',L,(_20-|['compiler_generated'] )},{LI,(_21-|['compiler_generated'] ),UV,A,Sg,State},(_22-|['compiler_generated'] )}
<T,S0,PVs0> when call 'erlang':'is_tuple' (T) -> let <_13> = call 'erlang':'tuple_to_list' (T) in case apply 'nos_pattern'/3 (_13,S0,PVs0) of <{TL,S,PVs}> when 'true' -> let <_15> = call 'erlang':'list_to_tuple' (TL) in {_15,S,PVs}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<T,S,PVs> when 'true' -> {T,S,PVs} end
'nos_var'/3 = fun (_0,_1,_2) -> (case _2 of (<({'state',_13,_14,_15,_16,_17,_18,_rec32}-|['compiler_generated'] )> when 'true' -> let <Location> = call 'erl_anno':'location' (_0) in case call 'ets':'lookup' (_rec32,Location) of <[{_20,~{'name':=_21}~}|[]]> when call 'erlang':'=:=' (_20,Location) -> 'true'
<[{_22,Data}|[]]> when call 'erlang':'=:=' (_22,Location) -> case <> of (<> when call 'erlang':'is_map' (Data) -> let <_7> = ~{'name'=>_1|Data}~ in let <_23> = call 'ets':'insert' (_rec32,{Location,_7}) in case _23 of <'true'> when 'true' -> (_23-|['compiler_generated'] )
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Data})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<[]> when 'true' -> 'true'
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'used_var'/3 = fun (_0,_1,_2) -> case call 'maps':'find' (_0,_1) of <{'ok',Value}> when 'true' -> let <VN> = call 'qlc':'name_suffix' (_0,Value) in do (call ('ets'-|['result_not_wanted'] ):('update_counter'-|['result_not_wanted'] ) (_2,VN,(1-|['result_not_wanted'] ))-|['result_not_wanted'] ) {'true',VN}
<'error'> when 'true' -> 'false'
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'next_var'/5 = fun (_0,_1,_2,_3,_4) -> let <_6> = case call 'ets':'lookup' (_3,_0) of <[{_18,Value}|[]]> when call 'erlang':'=:=' (_18,_0) -> call 'erlang':'+' (Value,1)
<[]> when 'true' -> 1
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end in case call 'ets':'insert' (_3,{_0,_6}) of <'true'> when 'true' -> let <VN> = call 'qlc':'name_suffix' (_0,_6) in case call 'gb_sets':'is_member' (VN,_2) of <'true'> when 'true' -> apply 'next_var'/5 (_0,_1,_2,_3,_4)
<'false'> when 'true' -> case call 'ets':'insert' (_4,{VN,0}) of <'true'> when 'true' -> let <NVs> = call 'maps':'put' (_0,_6,_1) in {VN,NVs}
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
'undo_no_shadows'/2 = fun (_0,_1) -> let <_4> = fun (_2) -> apply 'undo_no_shadows1'/2 (_2,_1) in apply 'var_map'/2 (_4,_0)
'undo_no_shadows1'/2 = fun (_0,_1) -> case <_0,_1> of <Var = {'var',Anno,_9},State> when 'true' -> let <Location> = call 'erl_anno':'location' (Anno) in (case State of (<({'state',_10,_11,_12,_13,_14,_15,_rec33}-|['compiler_generated'] )> when 'true' -> case call 'ets':'lookup' (_rec33,Location) of <[{_17,~{'name':=Name}~}|[]]> when call 'erlang':'=:=' (_17,Location) -> {'var',Anno,Name}
<_18> when 'true' -> Var end-|['compiler_generated'] )
(<_16> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'undo_no_shadows1',2}}] )-|['compiler_generated'] ) end
'make_lcid'/2 = fun (_0,_1) -> case <_0,_1> of <Anno,No> when let <_2> = call 'erlang':'is_integer' (No) in let <_3> = call 'erlang':'>' (No,0) in call 'erlang':'and' (_2,_3) -> let <_4> = call 'erl_anno':'line' (Anno) in {No,_4}
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'make_lcid',2}}] )-|['compiler_generated'] ) end
'get_lcid_no'/1 = fun (_0) -> case _0 of <{No,_X_Line}> when 'true' -> No
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'get_lcid_no',1}}] )-|['compiler_generated'] ) end
'get_lcid_line'/1 = fun (_0) -> case _0 of <{_X_No,Line}> when 'true' -> Line
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'get_lcid_line',1}}] )-|['compiler_generated'] ) end
'qid'/2 = fun (_0,_1) -> {'qid',_0,_1}
'abst_vars'/2 = fun (_0,_1) -> case <_0,_1> of <[V|Vs],L> when 'true' -> let <_2> = apply 'abst_vars'/2 (V,L) in let <_3> = apply 'abst_vars'/2 (Vs,L) in [_2|_3]
<[],_X_L> when 'true' -> []
<'nil',L> when 'true' -> {'nil',L}
<V,L> when 'true' -> {'var',L,V} end
'embed_vars'/2 = fun (_0,_1) -> apply 'embed_expr'/2 ({'tuple',_1,_0},_1)
'embed_expr'/2 = fun (_0,_1) -> {'lc',_1,_0,[{'generate',_1,{'var',_1,'_'},{'nil',_1}}|[]]}
'var2const'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'var',L,V}> when 'true' -> {'atom',L,V}
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-var2const/1-fun-0-',1}}] )-|['compiler_generated'] ) end in apply 'var_map'/2 (_3,_0)
'var_map'/2 = fun (_0,_1) -> case <_0,_1> of <F,V = {'var',_10,_11}> when 'true' -> apply F (V)
<F,{'named_fun',NLoc,NName,Cs}> when 'true' -> case apply F ({'var',NLoc,NName}) of <{'var',Loc,Name}> when 'true' -> let <_3> = apply 'var_map'/2 (F,Cs) in {'named_fun',Loc,Name,_3}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<F,T> when call 'erlang':'is_tuple' (T) -> let <_4> = call 'erlang':'tuple_to_list' (T) in let <_5> = apply 'var_map'/2 (F,_4) in call 'erlang':'list_to_tuple' (_5)
<F,[E|Es]> when 'true' -> let <_6> = apply 'var_map'/2 (F,E) in let <_7> = apply 'var_map'/2 (F,Es) in [_6|_7]
<_X_F,E> when 'true' -> E end
'var_mapfold'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <F,A,V = {'var',_11,_12}> when 'true' -> apply F (V,A)
<F,A0,T> when call 'erlang':'is_tuple' (T) -> let <_3> = call 'erlang':'tuple_to_list' (T) in case apply 'var_mapfold'/3 (F,A0,_3) of <{L,A}> when 'true' -> let <_5> = call 'erlang':'list_to_tuple' (L) in {_5,A}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<F,A0,[E0|Es0]> when 'true' -> case apply 'var_mapfold'/3 (F,A0,E0) of <{E,A1}> when 'true' -> case apply 'var_mapfold'/3 (F,A1,Es0) of <{Es,A}> when 'true' -> {[E|Es],A}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<_X_F,A,E> when 'true' -> {E,A} end
'map_anno'/2 = fun (_0,_1) -> case <_0,_1> of <F,AbstrList> when call 'erlang':'is_list' (AbstrList) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[Abstr|_3]> when 'true' -> let <_5> = apply 'map_anno1'/2 (F,Abstr) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (AbstrList)-|['list_comprehension'] )
<F,Abstr> when 'true' -> apply 'map_anno1'/2 (F,Abstr) end
'map_anno1'/2 = fun (_0,_1) -> call 'erl_parse':'map_anno' (_0,_1)
'family_list'/1 = fun (_0) -> let <_1> = apply 'family'/1 (_0) in call 'sofs':'to_external' (_1)
'family'/1 = fun (_0) -> let <_1> = call 'sofs':'relation' (_0) in call 'sofs':'relation_to_family' (_1)
'is_guard_test'/2 = fun (_0,_1) -> case <_0,_1> of <E,{'state',_4,IsOverridden,_5,RDs,_6,_7,_8}> when 'true' -> call 'erl_lint':'is_guard_test' (E,RDs,IsOverridden)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'is_guard_test',2}}] )-|['compiler_generated'] ) end
'set_up_overridden'/1 = fun (_0) -> let <_5> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{'function',_26,Name,Arity,_27}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([{Name,Arity}|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_30> when 'true' -> (primop 'match_fail' ({'function_clause',_30})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <_11> = letrec 'lc$^1'/1 = fun (_9) -> case _9 of <[{'attribute',_28,'import',Fs}|_8]> when 'true' -> let <_10> = apply 'lc$^1'/1 (_8) in ([Fs|_10]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^1'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_31> when 'true' -> (primop 'match_fail' ({'function_clause',_31})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_0) in let <Imports1> = call 'lists':'flatten' (_11) in let <_18> = letrec 'lc$^2'/1 = fun (_16) -> case _16 of <[{_29,Fs}|_15]> when 'true' -> let <_17> = apply 'lc$^2'/1 (_15) in ([Fs|_17]-|['compiler_generated'] )
(<[_14|_15]> when 'true' -> apply 'lc$^2'/1 (_15)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_32> when 'true' -> (primop 'match_fail' ({'function_clause',_32})-|[{'function_name',{'lc$^2',1}}] )-|['compiler_generated'] ) end in apply 'lc$^2'/1 (Imports1) in let <Imports> = call 'lists':'flatten' (_18) in let <_21> = call 'erlang':'++' (Imports,_5) in let <Overridden> = call 'gb_sets':'from_list' (_21) in (fun (_23) -> call 'gb_sets':'is_element' (_23,Overridden)-|[{'id',{0,0,'-set_up_overridden/1-fun-3-'}}] )
'display_forms'/1 = fun (_0) -> 'ok'
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('qlc_pt')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('qlc_pt',_0) end