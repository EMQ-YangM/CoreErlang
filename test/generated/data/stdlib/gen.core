module 'gen' ['call'/3,'call'/4,'check_response'/2,'debug_options'/2,'format_status_header'/2,'get_parent'/0,'get_proc_name'/1,'hibernate_after'/1,'init_it'/6,'init_it'/7,'module_info'/0,'module_info'/1,'name'/1,'reply'/2,'send_request'/3,'start'/5,'start'/6,'stop'/1,'stop'/3,'unregister_name'/1,'wait_response'/2] attributes [ 'file' = [{[115|[114|[99|[47|[103|[101|[110|[46|[101|[114|[108]]]]]]]]]]],1}]
, 'compile' = [{'inline',[{'get_node',1}]}]
, 'type' = [{'linkage',{'type',43,'union',[{'atom',43,'monitor'}|[{'atom',43,'link'}|[{'atom',43,'nolink'}]]]},[]}]
, 'type' = [{'emgr_name',{'type',44,'union',[{'type',44,'tuple',[{'atom',44,'local'}|[{'type',44,'atom',[]}]]}|[{'type',45,'tuple',[{'atom',45,'global'}|[{'type',45,'term',[]}]]}|[{'type',46,'tuple',[{'atom',46,'via'}|[{'ann_type',46,[{'var',46,'Module'}|[{'type',46,'module',[]}]]}|[{'ann_type',46,[{'var',46,'Name'}|[{'type',46,'term',[]}]]}]]]}]]]},[]}]
, 'type' = [{'start_ret',{'type',48,'union',[{'type',48,'tuple',[{'atom',48,'ok'}|[{'type',48,'pid',[]}]]}|[{'atom',48,'ignore'}|[{'type',48,'tuple',[{'atom',48,'error'}|[{'type',48,'term',[]}]]}]]]},[]}]
, 'type' = [{'debug_flag',{'type',50,'union',[{'atom',50,'trace'}|[{'atom',50,'log'}|[{'atom',50,'statistics'}|[{'atom',50,'debug'}|[{'type',51,'tuple',[{'atom',51,'logfile'}|[{'type',51,'string',[]}]]}]]]]]},[]}]
, 'type' = [{'option',{'type',52,'union',[{'type',52,'tuple',[{'atom',52,'timeout'}|[{'type',52,'timeout',[]}]]}|[{'type',53,'tuple',[{'atom',53,'debug'}|[{'type',53,'list',[{'user_type',53,'debug_flag',[]}]}]]}|[{'type',54,'tuple',[{'atom',54,'hibernate_after'}|[{'type',54,'timeout',[]}]]}|[{'type',55,'tuple',[{'atom',55,'spawn_opt'}|[{'type',55,'list',[{'remote_type',55,[{'atom',55,'proc_lib'}|[{'atom',55,'spawn_option'}|[[]]]]}]}]]}]]]]},[]}]
, 'type' = [{'options',{'type',56,'list',[{'user_type',56,'option',[]}]},[]}]
, 'type' = [{'server_ref',{'type',58,'union',[{'type',58,'pid',[]}|[{'type',58,'atom',[]}|[{'type',58,'tuple',[{'type',58,'atom',[]}|[{'type',58,'node',[]}]]}|[{'type',59,'tuple',[{'atom',59,'global'}|[{'type',59,'term',[]}]]}|[{'type',59,'tuple',[{'atom',59,'via'}|[{'type',59,'module',[]}|[{'type',59,'term',[]}]]]}]]]]]},[]}]
, 'type' = [{'request_id',{'type',61,'term',[]},[]}]
, 'spec' = [{{'start',6},[{'type',79,'fun',[{'type',79,'product',[{'type',79,'module',[]}|[{'user_type',79,'linkage',[]}|[{'user_type',79,'emgr_name',[]}|[{'type',79,'module',[]}|[{'type',79,'term',[]}|[{'user_type',79,'options',[]}]]]]]]}|[{'user_type',80,'start_ret',[]}]]}]}]
, 'spec' = [{{'start',5},[{'type',90,'fun',[{'type',90,'product',[{'type',90,'module',[]}|[{'user_type',90,'linkage',[]}|[{'type',90,'module',[]}|[{'type',90,'term',[]}|[{'user_type',90,'options',[]}]]]]]}|[{'user_type',90,'start_ret',[]}]]}]}]
, 'spec' = [{{'send_request',3},[{'type',236,'fun',[{'type',236,'product',[{'ann_type',236,[{'var',236,'Name'}|[{'user_type',236,'server_ref',[]}]]}|[{'ann_type',236,[{'var',236,'Label'}|[{'type',236,'term',[]}]]}|[{'ann_type',236,[{'var',236,'Request'}|[{'type',236,'term',[]}]]}]]]}|[{'user_type',236,'request_id',[]}]]}]}]
, 'spec' = [{{'wait_response',2},[{'type',258,'fun',[{'type',258,'product',[{'ann_type',258,[{'var',258,'RequestId'}|[{'user_type',258,'request_id',[]}]]}|[{'type',258,'timeout',[]}]]}|[{'type',259,'union',[{'type',259,'tuple',[{'atom',259,'reply'}|[{'ann_type',259,[{'var',259,'Reply'}|[{'type',259,'term',[]}]]}]]}|[{'atom',259,'timeout'}|[{'type',259,'tuple',[{'atom',259,'error'}|[{'type',259,'tuple',[{'type',259,'term',[]}|[{'user_type',259,'server_ref',[]}]]}]]}]]]}]]}]}]
, 'spec' = [{{'check_response',2},[{'type',272,'fun',[{'type',272,'product',[{'ann_type',272,[{'var',272,'RequestId'}|[{'type',272,'term',[]}]]}|[{'ann_type',272,[{'var',272,'Key'}|[{'user_type',272,'request_id',[]}]]}]]}|[{'type',273,'union',[{'type',273,'tuple',[{'atom',273,'reply'}|[{'ann_type',273,[{'var',273,'Reply'}|[{'type',273,'term',[]}]]}]]}|[{'atom',273,'no_reply'}|[{'type',273,'tuple',[{'atom',273,'error'}|[{'type',273,'tuple',[{'type',273,'term',[]}|[{'user_type',273,'server_ref',[]}]]}]]}]]]}]]}]}] ] 'start'/6 = fun (_0,_1,_2,_3,_4,_5) -> case apply 'where'/1 (_2) of <'undefined'> when 'true' -> apply 'do_spawn'/6 (_0,_1,_2,_3,_4,_5)
<Pid> when 'true' -> {'error',{'already_started',Pid}} end
'start'/5 = fun (_0,_1,_2,_3,_4) -> apply 'do_spawn'/5 (_0,_1,_2,_3,_4)
'do_spawn'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <GenMod,'link',Mod,Args,Options> when 'true' -> let <Time> = apply 'timeout'/1 (Options) in let <_7> = call 'erlang':'self' () in let <_8> = call 'erlang':'self' () in let <_6> = apply 'spawn_opts'/1 (Options) in call 'proc_lib':'start_link' ('gen','init_it',[GenMod|[_7|[_8|[Mod|[Args|[Options|[]]]]]]],Time,_6)
<GenMod,'monitor',Mod,Args,Options> when 'true' -> let <Time> = apply 'timeout'/1 (Options) in let <_11> = call 'erlang':'self' () in let <_12> = call 'erlang':'self' () in let <_10> = apply 'spawn_opts'/1 (Options) in let <Ret> = call 'proc_lib':'start_monitor' ('gen','init_it',[GenMod|[_11|[_12|[Mod|[Args|[Options|[]]]]]]],Time,_10) in apply 'monitor_return'/1 (Ret)
<GenMod,_22,Mod,Args,Options> when 'true' -> let <Time> = apply 'timeout'/1 (Options) in let <_16> = call 'erlang':'self' () in let <_15> = apply 'spawn_opts'/1 (Options) in call 'proc_lib':'start' ('gen','init_it',[GenMod|[_16|['self'|[Mod|[Args|[Options|[]]]]]]],Time,_15) end
'do_spawn'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <GenMod,'link',Name,Mod,Args,Options> when 'true' -> let <Time> = apply 'timeout'/1 (Options) in let <_8> = call 'erlang':'self' () in let <_9> = call 'erlang':'self' () in let <_7> = apply 'spawn_opts'/1 (Options) in call 'proc_lib':'start_link' ('gen','init_it',[GenMod|[_8|[_9|[Name|[Mod|[Args|[Options|[]]]]]]]],Time,_7)
<GenMod,'monitor',Name,Mod,Args,Options> when 'true' -> let <Time> = apply 'timeout'/1 (Options) in let <_12> = call 'erlang':'self' () in let <_13> = call 'erlang':'self' () in let <_11> = apply 'spawn_opts'/1 (Options) in let <Ret> = call 'proc_lib':'start_monitor' ('gen','init_it',[GenMod|[_12|[_13|[Name|[Mod|[Args|[Options|[]]]]]]]],Time,_11) in apply 'monitor_return'/1 (Ret)
<GenMod,_24,Name,Mod,Args,Options> when 'true' -> let <Time> = apply 'timeout'/1 (Options) in let <_17> = call 'erlang':'self' () in let <_16> = apply 'spawn_opts'/1 (Options) in call 'proc_lib':'start' ('gen','init_it',[GenMod|[_17|['self'|[Name|[Mod|[Args|[Options|[]]]]]]]],Time,_16) end
'monitor_return'/1 = fun (_0) -> case _0 of <{{'ok',Pid},Mon}> when let <_1> = call 'erlang':'is_pid' (Pid) in let <_2> = call 'erlang':'is_reference' (Mon) in call 'erlang':'and' (_1,_2) -> {'ok',{Pid,Mon}}
<{Error,Mon}> when call 'erlang':'is_reference' (Mon) -> do receive <{'DOWN',_4,'process',_X_Pid,_X_Reason}> when call 'erlang':'=:=' (_4,Mon) -> 'ok' after 'infinity' -> 'ok' Error
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'monitor_return',1}}] )-|['compiler_generated'] ) end
'init_it'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <_6> = call 'erlang':'self' () in apply 'init_it2'/7 (_0,_1,_2,_6,_3,_4,_5)
'init_it'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case apply 'register_name'/1 (_3) of <'true'> when 'true' -> apply 'init_it2'/7 (_0,_1,_2,_3,_4,_5,_6)
<{'false',Pid}> when 'true' -> call 'proc_lib':'init_ack' (_1,{'error',{'already_started',Pid}})
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
'init_it2'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> call _0:'init_it' (_1,_2,_3,_4,_5,_6)
'call'/3 = fun (_0,_1,_2) -> apply 'call'/4 (_0,_1,_2,5000)
'call'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Process,Label,Request,Timeout> when try let <_4> = call 'erlang':'is_pid' (Process) in (let <_9> = case call 'erlang':'=:=' (Timeout,'infinity') of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> (case call 'erlang':'is_integer' (Timeout) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Timeout,0)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_6> when 'true' -> _6-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_10> = call 'erlang':'=:=' ((_9-|['compiler_generated'] ),'true') in call 'erlang':'and' (_4,_10)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> apply 'do_call'/4 (Process,Label,Request,Timeout)
<Process,Label,Request,Timeout> when let <_11> = call 'erlang':'=:=' (Timeout,'infinity') in let <_12> = call 'erlang':'is_integer' (Timeout) in let <_13> = call 'erlang':'>=' (Timeout,0) in let <_14> = call 'erlang':'and' (_12,_13) in call 'erlang':'or' (_11,_14) -> let <Fun> = fun (_15) -> apply 'do_call'/4 (_15,Label,Request,Timeout) in apply 'do_for_proc'/2 (Process,Fun)
(<_21,_20,_19,_18> when 'true' -> (primop 'match_fail' ({'function_clause',_21,_20,_19,_18})-|[{'function_name',{'call',4}}] )-|['compiler_generated'] ) end
'do_call'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Process,Label,Request,Timeout> when let <_4> = call 'erlang':'is_atom' (Process) in call 'erlang':'=:=' (_4,'false') -> let <Mref> = call 'erlang':'monitor' ('process',Process) in let <_6> = call 'erlang':'self' () in do call 'erlang':'send' (Process,{Label,{_6,Mref},Request},['noconnect']) receive <{_12,Reply}> when call 'erlang':'=:=' (_12,Mref) -> do call 'erlang':'demonitor' (Mref,['flush']) {'ok',Reply}
<{'DOWN',_13,_14,_15,'noconnection'}> when call 'erlang':'=:=' (_13,Mref) -> let <Node> = case Process of (<({_X_S,N}-|['compiler_generated'] )> when (call ('erlang'-|['compiler_generated'] ):('is_atom'-|['compiler_generated'] ) (N)-|['compiler_generated'] ) -> N-|['compiler_generated'] )
(<_21> when (call ('erlang'-|['compiler_generated'] ):('is_pid'-|['compiler_generated'] ) (Process)-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('node'-|['compiler_generated'] ) (Process)-|['compiler_generated'] )-|['compiler_generated'] )
(<_22> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_22}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in call 'erlang':'exit' ({'nodedown',Node})
<{'DOWN',_16,_17,_18,Reason}> when call 'erlang':'=:=' (_16,Mref) -> call 'erlang':'exit' (Reason) after Timeout -> do call 'erlang':'demonitor' (Mref,['flush']) call 'erlang':'exit' ('timeout')
(<_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8})-|[{'function_name',{'do_call',4}}] )-|['compiler_generated'] ) end
'get_node'/1 = fun (_0) -> case _0 of <{_X_S,N}> when call 'erlang':'is_atom' (N) -> N
<_3> when call 'erlang':'is_pid' (_0) -> call 'erlang':'node' (_0)
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'send_request'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Process,Label,Request> when call 'erlang':'is_pid' (Process) -> apply 'do_send_request'/3 (Process,Label,Request)
<Process,Label,Request> when 'true' -> let <Fun> = fun (_3) -> apply 'do_send_request'/3 (_3,Label,Request) in try apply 'do_for_proc'/2 (Process,Fun) of <_6> -> _6 catch <_9,_8,_7> -> case <_9,_8,_7> of <('exit'-|['compiler_generated'] ),Reason,_15> when 'true' -> let <Mref> = call 'erlang':'make_ref' () in let <_11> = call 'erlang':'self' () in do call 'erlang':'!' (_11,{'DOWN',Mref,'process',Process,Reason}) Mref
(<_17,_18,_19> when 'true' -> primop 'raise' (_19,_18)-|['compiler_generated'] ) end end
'do_send_request'/3 = fun (_0,_1,_2) -> let <Mref> = call 'erlang':'monitor' ('process',_0) in let <_4> = call 'erlang':'self' () in do call 'erlang':'send' (_0,{_1,{_4,{'$gen_request_id',Mref}},_2},['noconnect']) Mref
'wait_response'/2 = fun (_0,_1) -> case <_0,_1> of <Mref,Timeout> when call 'erlang':'is_reference' (Mref) -> receive <{{'$gen_request_id',_4},Reply}> when call 'erlang':'=:=' (_4,Mref) -> do call 'erlang':'demonitor' (Mref,['flush']) {'reply',Reply}
<{'DOWN',_5,_6,Object,Reason}> when call 'erlang':'=:=' (_5,Mref) -> {'error',{Reason,Object}} after Timeout -> 'timeout'
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'wait_response',2}}] )-|['compiler_generated'] ) end
'check_response'/2 = fun (_0,_1) -> case <_0,_1> of <Msg,Mref> when call 'erlang':'is_reference' (Mref) -> case Msg of <{{'$gen_request_id',_5},Reply}> when call 'erlang':'=:=' (_5,Mref) -> do call 'erlang':'demonitor' (Mref,['flush']) {'reply',Reply}
<{'DOWN',_6,_7,Object,Reason}> when call 'erlang':'=:=' (_6,Mref) -> {'error',{Reason,Object}}
<_8> when 'true' -> 'no_reply' end
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'check_response',2}}] )-|['compiler_generated'] ) end
'reply'/2 = fun (_0,_1) -> case <_0,_1> of <{To,Tag},Reply> when 'true' -> let <Msg> = {Tag,Reply} in try call 'erlang':'!' (To,Msg) of <_3> -> _3 catch <_6,_5,_4> -> Msg
(<_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7})-|[{'function_name',{'reply',2}}] )-|['compiler_generated'] ) end
'stop'/1 = fun (_0) -> apply 'stop'/3 (_0,'normal','infinity')
'stop'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Process,Reason,Timeout> when let <_3> = call 'erlang':'=:=' (Timeout,'infinity') in let <_4> = call 'erlang':'is_integer' (Timeout) in let <_5> = call 'erlang':'>=' (Timeout,0) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'or' (_3,_6) -> let <Fun> = fun (_7) -> call 'proc_lib':'stop' (_7,Reason,Timeout) in apply 'do_for_proc'/2 (Process,Fun)
(<_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10})-|[{'function_name',{'stop',3}}] )-|['compiler_generated'] ) end
'do_for_proc'/2 = fun (_0,_1) -> case <_0,_1> of <Pid,Fun> when call 'erlang':'is_pid' (Pid) -> apply Fun (Pid)
<Name,Fun> when call 'erlang':'is_atom' (Name) -> case call 'erlang':'whereis' (Name) of <Pid> when call 'erlang':'is_pid' (Pid) -> apply Fun (Pid)
<'undefined'> when 'true' -> call 'erlang':'exit' ('noproc')
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<Process,Fun> when try let <_5> = call 'erlang':'tuple_size' (Process) in let <_8> = case call 'erlang':'=:=' (_5,2) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_6> = call 'erlang':'element' (1,Process) in call 'erlang':'=:=' (_6,'global')-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_4> when 'true' -> _4-|['compiler_generated'] ) end in (let <_14> = case _8 of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> let <_10> = call 'erlang':'tuple_size' (Process) in (case call 'erlang':'=:=' (_10,3) of (<('true'-|['compiler_generated'] )> when 'true' -> let <_11> = call 'erlang':'element' (1,Process) in call 'erlang':'=:=' (_11,'via')-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_9> when 'true' -> _9-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when 'true' -> _3-|['compiler_generated'] ) end in (call 'erlang':'=:=' ((_14-|['compiler_generated'] ),'true')-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'where'/1 (Process) of <Pid> when call 'erlang':'is_pid' (Pid) -> let <Node> = call 'erlang':'node' (Pid) in try apply Fun (Pid) of <_16> -> _16 catch <_19,_18,_17> -> case <_19,_18,_17> of <('exit'-|['compiler_generated'] ),({('nodedown'-|['compiler_generated'] ),_25}-|['compiler_generated'] ),_26> when call 'erlang':'=:=' (_25,Node) -> call 'erlang':'exit' ('noproc')
(<_27,_28,_29> when 'true' -> primop 'raise' (_29,_28)-|['compiler_generated'] ) end
<'undefined'> when 'true' -> call 'erlang':'exit' ('noproc')
(<_20> when 'true' -> primop 'match_fail' ({'case_clause',_20})-|['compiler_generated'] ) end
<{Name,Node},Fun> when try let <_21> = call 'erlang':'node' () in call 'erlang':'=:=' (Node,_21) of <Try> -> Try catch <T,R> -> 'false' -> apply 'do_for_proc'/2 (Name,Fun)
<Process = {_X_Name,Node},Fun> when call 'erlang':'is_atom' (Node) -> case <> of <> when try let <_22> = call 'erlang':'node' () in call 'erlang':'=:=' (_22,'nonode@nohost') of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'exit' ({'nodedown',Node})
<> when 'true' -> apply Fun (Process) end
(<_24,_23> when 'true' -> (primop 'match_fail' ({'function_clause',_24,_23})-|[{'function_name',{'do_for_proc',2}}] )-|['compiler_generated'] ) end
'where'/1 = fun (_0) -> case _0 of <{'global',Name}> when 'true' -> call 'global':'whereis_name' (Name)
<{'via',Module,Name}> when 'true' -> call Module:'whereis_name' (Name)
<{'local',Name}> when 'true' -> call 'erlang':'whereis' (Name)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'where',1}}] )-|['compiler_generated'] ) end
'register_name'/1 = fun (_0) -> case _0 of <LN = {'local',Name}> when 'true' -> try let <_1> = call 'erlang':'self' () in call 'erlang':'register' (Name,_1) of <_2> -> case _2 of <'true'> when 'true' -> 'true'
(<_3> when 'true' -> primop 'match_fail' ({'try_clause',_3})-|['compiler_generated'] ) end catch <_6,_5,_4> -> case <_6,_5,_4> of <('error'-|['compiler_generated'] ),_15,_16> when 'true' -> let <_7> = apply 'where'/1 (LN) in {'false',_7}
(<_17,_18,_19> when 'true' -> primop 'raise' (_19,_18)-|['compiler_generated'] ) end
<GN = {'global',Name}> when 'true' -> let <_8> = call 'erlang':'self' () in case call 'global':'register_name' (Name,_8) of <'yes'> when 'true' -> 'true'
<'no'> when 'true' -> let <_9> = apply 'where'/1 (GN) in {'false',_9}
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<GN = {'via',Module,Name}> when 'true' -> let <_11> = call 'erlang':'self' () in case call Module:'register_name' (Name,_11) of <'yes'> when 'true' -> 'true'
<'no'> when 'true' -> let <_12> = apply 'where'/1 (GN) in {'false',_12}
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
(<_14> when 'true' -> (primop 'match_fail' ({'function_clause',_14})-|[{'function_name',{'register_name',1}}] )-|['compiler_generated'] ) end
'name'/1 = fun (_0) -> case _0 of <{'local',Name}> when 'true' -> Name
<{'global',Name}> when 'true' -> Name
<{'via',_2,Name}> when 'true' -> Name
<Pid> when call 'erlang':'is_pid' (_0) -> Pid
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'name',1}}] )-|['compiler_generated'] ) end
'unregister_name'/1 = fun (_0) -> case _0 of <{'local',Name}> when 'true' -> try call 'erlang':'unregister' (Name) of <_1> -> 'ok' catch <_5,_4,_3> -> 'ok'
<{'global',Name}> when 'true' -> do (call ('global'-|['result_not_wanted'] ):('unregister_name'-|['result_not_wanted'] ) (Name)-|['result_not_wanted'] ) 'ok'
<{'via',Mod,Name}> when 'true' -> do (call Mod:('unregister_name'-|['result_not_wanted'] ) (Name)-|['result_not_wanted'] ) 'ok'
<Pid> when call 'erlang':'is_pid' (_0) -> 'ok'
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'unregister_name',1}}] )-|['compiler_generated'] ) end
'get_proc_name'/1 = fun (_0) -> case _0 of <Pid> when call 'erlang':'is_pid' (_0) -> Pid
<{'local',Name}> when 'true' -> let <_1> = call 'erlang':'self' () in case call 'erlang':'process_info' (_1,'registered_name') of <{'registered_name',_8}> when call 'erlang':'=:=' (_8,Name) -> Name
<{'registered_name',_X_Name}> when 'true' -> call 'erlang':'exit' ('process_not_registered')
<[]> when 'true' -> call 'erlang':'exit' ('process_not_registered')
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<{'global',Name}> when 'true' -> case call 'global':'whereis_name' (Name) of <'undefined'> when 'true' -> call 'erlang':'exit' ('process_not_registered_globally')
<Pid> when try let <_3> = call 'erlang':'self' () in call 'erlang':'=:=' (Pid,_3) of <Try> -> Try catch <T,R> -> 'false' -> Name
<_X_Pid> when 'true' -> call 'erlang':'exit' ('process_not_registered_globally') end
<{'via',Mod,Name}> when 'true' -> case call Mod:'whereis_name' (Name) of <'undefined'> when 'true' -> call 'erlang':'exit' ({'process_not_registered_via',Mod})
<Pid> when try let <_5> = call 'erlang':'self' () in call 'erlang':'=:=' (Pid,_5) of <Try> -> Try catch <T,R> -> 'false' -> Name
<_X_Pid> when 'true' -> call 'erlang':'exit' ({'process_not_registered_via',Mod}) end
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'get_proc_name',1}}] )-|['compiler_generated'] ) end
'get_parent'/0 = fun () -> case call 'erlang':'get' ('$ancestors') of <[Parent|_1]> when call 'erlang':'is_pid' (Parent) -> Parent
<[Parent|_2]> when call 'erlang':'is_atom' (Parent) -> apply 'name_to_pid'/1 (Parent)
<_3> when 'true' -> call 'erlang':'exit' ('process_was_not_started_by_proc_lib') end
'name_to_pid'/1 = fun (_0) -> case call 'erlang':'whereis' (_0) of <'undefined'> when 'true' -> case call 'global':'whereis_name' (_0) of <'undefined'> when 'true' -> call 'erlang':'exit' ('could_not_find_registered_name')
<Pid> when 'true' -> Pid end
<Pid> when 'true' -> Pid end
'timeout'/1 = fun (_0) -> case call 'lists':'keyfind' ('timeout',1,_0) of <{_3,Time}> when 'true' -> Time
<'false'> when 'true' -> 'infinity'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'spawn_opts'/1 = fun (_0) -> case call 'lists':'keyfind' ('spawn_opt',1,_0) of <{_3,Opts}> when 'true' -> Opts
<'false'> when 'true' -> []
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'hibernate_after'/1 = fun (_0) -> case call 'lists':'keyfind' ('hibernate_after',1,_0) of <{_3,HibernateAfterTimeout}> when 'true' -> HibernateAfterTimeout
<'false'> when 'true' -> 'infinity'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'debug_options'/2 = fun (_0,_1) -> case call 'lists':'keyfind' ('debug',1,_1) of <{_9,Options}> when 'true' -> try call 'sys':'debug_options' (Options) of <_2> -> _2 catch <_5,_4,_3> -> do call 'error_logger':'format' ([126|[116|[112|[58|[32|[105|[103|[110|[111|[114|[105|[110|[103|[32|[101|[114|[114|[111|[110|[101|[111|[117|[115|[32|[100|[101|[98|[117|[103|[32|[111|[112|[116|[105|[111|[110|[115|[32|[45|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_0|[Options|[]]]) []
<'false'> when 'true' -> []
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
'format_status_header'/2 = fun (_0,_1) -> case <_0,_1> of <TagLine,Pid> when call 'erlang':'is_pid' (Pid) -> let <_2> = call 'erlang':'pid_to_list' (Pid) in call 'lists':'concat' ([TagLine|[[32]|[_2|[]]]])
<TagLine,RegName> when call 'erlang':'is_atom' (RegName) -> call 'lists':'concat' ([TagLine|[[32]|[RegName|[]]]])
<TagLine,Name> when 'true' -> {TagLine,Name} end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('gen')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('gen',_0) end