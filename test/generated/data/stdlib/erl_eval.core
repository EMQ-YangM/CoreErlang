module 'erl_eval' ['add_binding'/3,'binding'/2,'bindings'/1,'check_command'/2,'del_binding'/2,'eval_str'/1,'expr'/2,'expr'/3,'expr'/4,'expr'/5,'expr_list'/2,'expr_list'/3,'expr_list'/4,'exprs'/2,'exprs'/3,'exprs'/4,'extended_parse_exprs'/1,'extended_parse_term'/1,'fun_data'/1,'is_constant_expr'/1,'match_clause'/4,'module_info'/0,'module_info'/1,'new_bindings'/0,'partial_eval'/1,'subst_values_for_vars'/2] attributes [ 'file' = [{[115|[114|[99|[47|[101|[114|[108|[95|[101|[118|[97|[108|[46|[101|[114|[108]]]]]]]]]]]]]]]],1}]
, 'compile' = ['no_native']
, 'export_type' = [{'binding_struct',0}]
, 'type' = [{'expression',{'remote_type',44,[{'atom',44,'erl_parse'}|[{'atom',44,'abstract_expr'}|[[]]]]},[]}]
, 'type' = [{'expressions',{'type',45,'list',[{'remote_type',45,[{'atom',45,'erl_parse'}|[{'atom',45,'abstract_expr'}|[[]]]]}]},[]}]
, 'type' = [{'expression_list',{'type',46,'list',[{'user_type',46,'expression',[]}]},[]}]
, 'type' = [{'clauses',{'type',47,'list',[{'remote_type',47,[{'atom',47,'erl_parse'}|[{'atom',47,'abstract_clause'}|[[]]]]}]},[]}]
, 'type' = [{'name',{'type',48,'term',[]},[]}]
, 'type' = [{'value',{'type',49,'term',[]},[]}]
, 'type' = [{'bindings',{'type',50,'list',[{'type',50,'tuple',[{'user_type',50,'name',[]}|[{'user_type',50,'value',[]}]]}]},[]}]
, 'type' = [{'binding_struct',{'remote_type',51,[{'atom',51,'orddict'}|[{'atom',51,'orddict'}|[[]]]]},[]}]
, 'type' = [{'lfun_value_handler',{'type',53,'fun',[{'type',53,'product',[{'ann_type',53,[{'var',53,'Name'}|[{'type',53,'atom',[]}]]}|[{'ann_type',54,[{'var',54,'Arguments'}|[{'type',54,'list',[{'type',54,'term',[]}]}]]}]]}|[{'ann_type',55,[{'var',55,'Value'}|[{'user_type',55,'value',[]}]]}]]},[]}]
, 'type' = [{'lfun_eval_handler',{'type',56,'fun',[{'type',56,'product',[{'ann_type',56,[{'var',56,'Name'}|[{'type',56,'atom',[]}]]}|[{'ann_type',57,[{'var',57,'Arguments'}|[{'user_type',57,'expression_list',[]}]]}|[{'ann_type',58,[{'var',58,'Bindings'}|[{'user_type',58,'binding_struct',[]}]]}]]]}|[{'type',59,'tuple',[{'atom',59,'value'}|[{'ann_type',60,[{'var',60,'Value'}|[{'user_type',60,'value',[]}]]}|[{'ann_type',61,[{'var',61,'NewBindings'}|[{'user_type',61,'binding_struct',[]}]]}]]]}]]},[]}]
, 'type' = [{'local_function_handler',{'type',62,'union',[{'type',62,'tuple',[{'atom',62,'value'}|[{'user_type',62,'lfun_value_handler',[]}]]}|[{'type',63,'tuple',[{'atom',63,'eval'}|[{'user_type',63,'lfun_eval_handler',[]}]]}|[{'atom',64,'none'}]]]},[]}]
, 'type' = [{'func_spec',{'type',66,'union',[{'type',66,'tuple',[{'ann_type',66,[{'var',66,'Module'}|[{'type',66,'module',[]}]]}|[{'ann_type',66,[{'var',66,'Function'}|[{'type',66,'atom',[]}]]}]]}|[{'type',66,'function',[]}]]},[]}]
, 'type' = [{'nlfun_handler',{'type',67,'fun',[{'type',67,'product',[{'ann_type',67,[{'var',67,'FuncSpec'}|[{'user_type',67,'func_spec',[]}]]}|[{'ann_type',68,[{'var',68,'Arguments'}|[{'type',68,'list',[{'type',68,'term',[]}]}]]}]]}|[{'type',69,'term',[]}]]},[]}]
, 'type' = [{'non_local_function_handler',{'type',70,'union',[{'type',70,'tuple',[{'atom',70,'value'}|[{'user_type',70,'nlfun_handler',[]}]]}|[{'atom',71,'none'}]]},[]}]
, 'spec' = [{{'exprs',2},[{'type',87,'bounded_fun',[{'type',87,'fun',[{'type',87,'product',[{'var',87,'Expressions'}|[{'var',87,'Bindings'}]]}|[{'type',87,'tuple',[{'atom',87,'value'}|[{'var',87,'Value'}|[{'var',87,'NewBindings'}]]]}]]}|[[{'type',88,'constraint',[{'atom',88,'is_subtype'}|[[{'var',88,'Expressions'}|[{'user_type',88,'expressions',[]}]]]]}|[{'type',89,'constraint',[{'atom',89,'is_subtype'}|[[{'var',89,'Bindings'}|[{'user_type',89,'binding_struct',[]}]]]]}|[{'type',90,'constraint',[{'atom',90,'is_subtype'}|[[{'var',90,'Value'}|[{'user_type',90,'value',[]}]]]]}|[{'type',91,'constraint',[{'atom',91,'is_subtype'}|[[{'var',91,'NewBindings'}|[{'user_type',91,'binding_struct',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'exprs',3},[{'type',100,'bounded_fun',[{'type',100,'fun',[{'type',100,'product',[{'var',100,'Expressions'}|[{'var',100,'Bindings'}|[{'var',100,'LocalFunctionHandler'}]]]}|[{'type',101,'tuple',[{'atom',101,'value'}|[{'var',101,'Value'}|[{'var',101,'NewBindings'}]]]}]]}|[[{'type',102,'constraint',[{'atom',102,'is_subtype'}|[[{'var',102,'Expressions'}|[{'user_type',102,'expressions',[]}]]]]}|[{'type',103,'constraint',[{'atom',103,'is_subtype'}|[[{'var',103,'Bindings'}|[{'user_type',103,'binding_struct',[]}]]]]}|[{'type',104,'constraint',[{'atom',104,'is_subtype'}|[[{'var',104,'LocalFunctionHandler'}|[{'user_type',104,'local_function_handler',[]}]]]]}|[{'type',105,'constraint',[{'atom',105,'is_subtype'}|[[{'var',105,'Value'}|[{'user_type',105,'value',[]}]]]]}|[{'type',106,'constraint',[{'atom',106,'is_subtype'}|[[{'var',106,'NewBindings'}|[{'user_type',106,'binding_struct',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'exprs',4},[{'type',110,'bounded_fun',[{'type',110,'fun',[{'type',110,'product',[{'var',110,'Expressions'}|[{'var',110,'Bindings'}|[{'var',110,'LocalFunctionHandler'}|[{'var',111,'NonLocalFunctionHandler'}]]]]}|[{'type',112,'tuple',[{'atom',112,'value'}|[{'var',112,'Value'}|[{'var',112,'NewBindings'}]]]}]]}|[[{'type',113,'constraint',[{'atom',113,'is_subtype'}|[[{'var',113,'Expressions'}|[{'user_type',113,'expressions',[]}]]]]}|[{'type',114,'constraint',[{'atom',114,'is_subtype'}|[[{'var',114,'Bindings'}|[{'user_type',114,'binding_struct',[]}]]]]}|[{'type',115,'constraint',[{'atom',115,'is_subtype'}|[[{'var',115,'LocalFunctionHandler'}|[{'user_type',115,'local_function_handler',[]}]]]]}|[{'type',116,'constraint',[{'atom',116,'is_subtype'}|[[{'var',116,'NonLocalFunctionHandler'}|[{'user_type',116,'non_local_function_handler',[]}]]]]}|[{'type',117,'constraint',[{'atom',117,'is_subtype'}|[[{'var',117,'Value'}|[{'user_type',117,'value',[]}]]]]}|[{'type',118,'constraint',[{'atom',118,'is_subtype'}|[[{'var',118,'NewBindings'}|[{'user_type',118,'binding_struct',[]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'expr',2},[{'type',138,'bounded_fun',[{'type',138,'fun',[{'type',138,'product',[{'var',138,'Expression'}|[{'var',138,'Bindings'}]]}|[{'type',138,'tuple',[{'atom',138,'value'}|[{'var',138,'Value'}|[{'var',138,'NewBindings'}]]]}]]}|[[{'type',139,'constraint',[{'atom',139,'is_subtype'}|[[{'var',139,'Expression'}|[{'user_type',139,'expression',[]}]]]]}|[{'type',140,'constraint',[{'atom',140,'is_subtype'}|[[{'var',140,'Bindings'}|[{'user_type',140,'binding_struct',[]}]]]]}|[{'type',141,'constraint',[{'atom',141,'is_subtype'}|[[{'var',141,'Value'}|[{'user_type',141,'value',[]}]]]]}|[{'type',142,'constraint',[{'atom',142,'is_subtype'}|[[{'var',142,'NewBindings'}|[{'user_type',142,'binding_struct',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'expr',3},[{'type',151,'bounded_fun',[{'type',151,'fun',[{'type',151,'product',[{'var',151,'Expression'}|[{'var',151,'Bindings'}|[{'var',151,'LocalFunctionHandler'}]]]}|[{'type',152,'tuple',[{'atom',152,'value'}|[{'var',152,'Value'}|[{'var',152,'NewBindings'}]]]}]]}|[[{'type',153,'constraint',[{'atom',153,'is_subtype'}|[[{'var',153,'Expression'}|[{'user_type',153,'expression',[]}]]]]}|[{'type',154,'constraint',[{'atom',154,'is_subtype'}|[[{'var',154,'Bindings'}|[{'user_type',154,'binding_struct',[]}]]]]}|[{'type',155,'constraint',[{'atom',155,'is_subtype'}|[[{'var',155,'LocalFunctionHandler'}|[{'user_type',155,'local_function_handler',[]}]]]]}|[{'type',156,'constraint',[{'atom',156,'is_subtype'}|[[{'var',156,'Value'}|[{'user_type',156,'value',[]}]]]]}|[{'type',157,'constraint',[{'atom',157,'is_subtype'}|[[{'var',157,'NewBindings'}|[{'user_type',157,'binding_struct',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'expr',4},[{'type',161,'bounded_fun',[{'type',161,'fun',[{'type',161,'product',[{'var',161,'Expression'}|[{'var',161,'Bindings'}|[{'var',161,'LocalFunctionHandler'}|[{'var',162,'NonLocalFunctionHandler'}]]]]}|[{'type',163,'tuple',[{'atom',163,'value'}|[{'var',163,'Value'}|[{'var',163,'NewBindings'}]]]}]]}|[[{'type',164,'constraint',[{'atom',164,'is_subtype'}|[[{'var',164,'Expression'}|[{'user_type',164,'expression',[]}]]]]}|[{'type',165,'constraint',[{'atom',165,'is_subtype'}|[[{'var',165,'Bindings'}|[{'user_type',165,'binding_struct',[]}]]]]}|[{'type',166,'constraint',[{'atom',166,'is_subtype'}|[[{'var',166,'LocalFunctionHandler'}|[{'user_type',166,'local_function_handler',[]}]]]]}|[{'type',167,'constraint',[{'atom',167,'is_subtype'}|[[{'var',167,'NonLocalFunctionHandler'}|[{'user_type',167,'non_local_function_handler',[]}]]]]}|[{'type',168,'constraint',[{'atom',168,'is_subtype'}|[[{'var',168,'Value'}|[{'user_type',168,'value',[]}]]]]}|[{'type',169,'constraint',[{'atom',169,'is_subtype'}|[[{'var',169,'NewBindings'}|[{'user_type',169,'binding_struct',[]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'expr',5},[{'type',202,'bounded_fun',[{'type',202,'fun',[{'type',202,'product',[{'var',202,'Expression'}|[{'var',202,'Bindings'}|[{'var',202,'LocalFunctionHandler'}|[{'var',203,'NonLocalFunctionHandler'}|[{'var',203,'ReturnFormat'}]]]]]}|[{'type',204,'union',[{'type',204,'tuple',[{'atom',204,'value'}|[{'var',204,'Value'}|[{'var',204,'NewBindings'}]]]}|[{'var',204,'Value'}]]}]]}|[[{'type',205,'constraint',[{'atom',205,'is_subtype'}|[[{'var',205,'Expression'}|[{'user_type',205,'expression',[]}]]]]}|[{'type',206,'constraint',[{'atom',206,'is_subtype'}|[[{'var',206,'Bindings'}|[{'user_type',206,'binding_struct',[]}]]]]}|[{'type',207,'constraint',[{'atom',207,'is_subtype'}|[[{'var',207,'LocalFunctionHandler'}|[{'user_type',207,'local_function_handler',[]}]]]]}|[{'type',208,'constraint',[{'atom',208,'is_subtype'}|[[{'var',208,'NonLocalFunctionHandler'}|[{'user_type',208,'non_local_function_handler',[]}]]]]}|[{'type',209,'constraint',[{'atom',209,'is_subtype'}|[[{'var',209,'ReturnFormat'}|[{'type',209,'union',[{'atom',209,'none'}|[{'atom',209,'value'}]]}]]]]}|[{'type',210,'constraint',[{'atom',210,'is_subtype'}|[[{'var',210,'Value'}|[{'user_type',210,'value',[]}]]]]}|[{'type',211,'constraint',[{'atom',211,'is_subtype'}|[[{'var',211,'NewBindings'}|[{'user_type',211,'binding_struct',[]}]]]]}]]]]]]]]]}]}]
, 'spec' = [{{'expr_list',2},[{'type',857,'bounded_fun',[{'type',857,'fun',[{'type',857,'product',[{'var',857,'ExpressionList'}|[{'var',857,'Bindings'}]]}|[{'type',857,'tuple',[{'var',857,'ValueList'}|[{'var',857,'NewBindings'}]]}]]}|[[{'type',858,'constraint',[{'atom',858,'is_subtype'}|[[{'var',858,'ExpressionList'}|[{'user_type',858,'expression_list',[]}]]]]}|[{'type',859,'constraint',[{'atom',859,'is_subtype'}|[[{'var',859,'Bindings'}|[{'user_type',859,'binding_struct',[]}]]]]}|[{'type',860,'constraint',[{'atom',860,'is_subtype'}|[[{'var',860,'ValueList'}|[{'type',860,'list',[{'user_type',860,'value',[]}]}]]]]}|[{'type',861,'constraint',[{'atom',861,'is_subtype'}|[[{'var',861,'NewBindings'}|[{'user_type',861,'binding_struct',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'expr_list',3},[{'type',865,'bounded_fun',[{'type',865,'fun',[{'type',865,'product',[{'var',865,'ExpressionList'}|[{'var',865,'Bindings'}|[{'var',865,'LocalFunctionHandler'}]]]}|[{'type',866,'tuple',[{'var',866,'ValueList'}|[{'var',866,'NewBindings'}]]}]]}|[[{'type',867,'constraint',[{'atom',867,'is_subtype'}|[[{'var',867,'ExpressionList'}|[{'user_type',867,'expression_list',[]}]]]]}|[{'type',868,'constraint',[{'atom',868,'is_subtype'}|[[{'var',868,'Bindings'}|[{'user_type',868,'binding_struct',[]}]]]]}|[{'type',869,'constraint',[{'atom',869,'is_subtype'}|[[{'var',869,'LocalFunctionHandler'}|[{'user_type',869,'local_function_handler',[]}]]]]}|[{'type',870,'constraint',[{'atom',870,'is_subtype'}|[[{'var',870,'ValueList'}|[{'type',870,'list',[{'user_type',870,'value',[]}]}]]]]}|[{'type',871,'constraint',[{'atom',871,'is_subtype'}|[[{'var',871,'NewBindings'}|[{'user_type',871,'binding_struct',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'expr_list',4},[{'type',875,'bounded_fun',[{'type',875,'fun',[{'type',875,'product',[{'var',875,'ExpressionList'}|[{'var',875,'Bindings'}|[{'var',875,'LocalFunctionHandler'}|[{'var',876,'NonLocalFunctionHandler'}]]]]}|[{'type',877,'tuple',[{'var',877,'ValueList'}|[{'var',877,'NewBindings'}]]}]]}|[[{'type',878,'constraint',[{'atom',878,'is_subtype'}|[[{'var',878,'ExpressionList'}|[{'user_type',878,'expression_list',[]}]]]]}|[{'type',879,'constraint',[{'atom',879,'is_subtype'}|[[{'var',879,'Bindings'}|[{'user_type',879,'binding_struct',[]}]]]]}|[{'type',880,'constraint',[{'atom',880,'is_subtype'}|[[{'var',880,'LocalFunctionHandler'}|[{'user_type',880,'local_function_handler',[]}]]]]}|[{'type',881,'constraint',[{'atom',881,'is_subtype'}|[[{'var',881,'NonLocalFunctionHandler'}|[{'user_type',881,'non_local_function_handler',[]}]]]]}|[{'type',882,'constraint',[{'atom',882,'is_subtype'}|[[{'var',882,'ValueList'}|[{'type',882,'list',[{'user_type',882,'value',[]}]}]]]]}|[{'type',883,'constraint',[{'atom',883,'is_subtype'}|[[{'var',883,'NewBindings'}|[{'user_type',883,'binding_struct',[]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'match_clause',4},[{'type',992,'bounded_fun',[{'type',992,'fun',[{'type',992,'product',[{'var',992,'Clauses'}|[{'var',992,'ValueList'}|[{'var',992,'Bindings'}|[{'var',992,'LocalFunctionHandler'}]]]]}|[{'type',993,'union',[{'type',993,'tuple',[{'var',993,'Body'}|[{'var',993,'NewBindings'}]]}|[{'atom',993,'nomatch'}]]}]]}|[[{'type',994,'constraint',[{'atom',994,'is_subtype'}|[[{'var',994,'Clauses'}|[{'user_type',994,'clauses',[]}]]]]}|[{'type',995,'constraint',[{'atom',995,'is_subtype'}|[[{'var',995,'ValueList'}|[{'type',995,'list',[{'user_type',995,'value',[]}]}]]]]}|[{'type',996,'constraint',[{'atom',996,'is_subtype'}|[[{'var',996,'Bindings'}|[{'user_type',996,'binding_struct',[]}]]]]}|[{'type',997,'constraint',[{'atom',997,'is_subtype'}|[[{'var',997,'LocalFunctionHandler'}|[{'user_type',997,'local_function_handler',[]}]]]]}|[{'type',998,'constraint',[{'atom',998,'is_subtype'}|[[{'var',998,'Body'}|[{'user_type',998,'expression_list',[]}]]]]}|[{'type',999,'constraint',[{'atom',999,'is_subtype'}|[[{'var',999,'NewBindings'}|[{'user_type',999,'binding_struct',[]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'new_bindings',0},[{'type',1254,'fun',[{'type',1254,'product',[]}|[{'user_type',1254,'binding_struct',[]}]]}]}]
, 'spec' = [{{'bindings',1},[{'type',1257,'fun',[{'type',1257,'product',[{'ann_type',1257,[{'var',1257,'BindingStruct'}|[{'user_type',1257,'binding_struct',[]}]]}]}|[{'user_type',1257,'bindings',[]}]]}]}]
, 'spec' = [{{'binding',2},[{'type',1260,'bounded_fun',[{'type',1260,'fun',[{'type',1260,'product',[{'var',1260,'Name'}|[{'var',1260,'BindingStruct'}]]}|[{'type',1260,'union',[{'type',1260,'tuple',[{'atom',1260,'value'}|[{'user_type',1260,'value',[]}]]}|[{'atom',1260,'unbound'}]]}]]}|[[{'type',1261,'constraint',[{'atom',1261,'is_subtype'}|[[{'var',1261,'Name'}|[{'user_type',1261,'name',[]}]]]]}|[{'type',1262,'constraint',[{'atom',1262,'is_subtype'}|[[{'var',1262,'BindingStruct'}|[{'user_type',1262,'binding_struct',[]}]]]]}]]]]}]}]
, 'spec' = [{{'add_binding',3},[{'type',1269,'bounded_fun',[{'type',1269,'fun',[{'type',1269,'product',[{'var',1269,'Name'}|[{'var',1269,'Value'}|[{'var',1269,'BindingStruct'}]]]}|[{'user_type',1269,'binding_struct',[]}]]}|[[{'type',1270,'constraint',[{'atom',1270,'is_subtype'}|[[{'var',1270,'Name'}|[{'user_type',1270,'name',[]}]]]]}|[{'type',1271,'constraint',[{'atom',1271,'is_subtype'}|[[{'var',1271,'Value'}|[{'user_type',1271,'value',[]}]]]]}|[{'type',1272,'constraint',[{'atom',1272,'is_subtype'}|[[{'var',1272,'BindingStruct'}|[{'user_type',1272,'binding_struct',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'del_binding',2},[{'type',1275,'bounded_fun',[{'type',1275,'fun',[{'type',1275,'product',[{'var',1275,'Name'}|[{'var',1275,'BindingStruct'}]]}|[{'user_type',1275,'binding_struct',[]}]]}|[[{'type',1276,'constraint',[{'atom',1276,'is_subtype'}|[[{'var',1276,'Name'}|[{'user_type',1276,'name',[]}]]]]}|[{'type',1277,'constraint',[{'atom',1277,'is_subtype'}|[[{'var',1277,'BindingStruct'}|[{'user_type',1277,'binding_struct',[]}]]]]}]]]]}]}]
, 'spec' = [{{'subst_values_for_vars',2},[{'type',1314,'bounded_fun',[{'type',1314,'fun',[{'type',1314,'product',[{'var',1314,'ExprList'}|[{'var',1314,'Bindings'}]]}|[{'type',1314,'list',[{'type',1314,'term',[]}]}]]}|[[{'type',1315,'constraint',[{'atom',1315,'is_subtype'}|[[{'var',1315,'ExprList'}|[{'type',1315,'list',[{'remote_type',1315,[{'atom',1315,'erl_parse'}|[{'atom',1315,'abstract_expr'}|[[]]]]}]}]]]]}|[{'type',1316,'constraint',[{'atom',1316,'is_subtype'}|[[{'var',1316,'Bindings'}|[{'user_type',1316,'binding_struct',[]}]]]]}]]]]}]}]
, 'spec' = [{{'extended_parse_exprs',1},[{'type',1339,'bounded_fun',[{'type',1339,'fun',[{'type',1339,'product',[{'var',1339,'Tokens'}]}|[{'type',1340,'union',[{'type',1340,'tuple',[{'atom',1340,'ok'}|[{'var',1340,'ExprList'}|[{'var',1340,'Bindings'}]]]}|[{'type',1340,'tuple',[{'atom',1340,'error'}|[{'var',1340,'ErrorInfo'}]]}]]}]]}|[[{'type',1341,'constraint',[{'atom',1341,'is_subtype'}|[[{'var',1341,'Tokens'}|[{'type',1341,'list',[{'remote_type',1341,[{'atom',1341,'erl_scan'}|[{'atom',1341,'token'}|[[]]]]}]}]]]]}|[{'type',1342,'constraint',[{'atom',1342,'is_subtype'}|[[{'var',1342,'ExprList'}|[{'type',1342,'list',[{'remote_type',1342,[{'atom',1342,'erl_parse'}|[{'atom',1342,'abstract_expr'}|[[]]]]}]}]]]]}|[{'type',1343,'constraint',[{'atom',1343,'is_subtype'}|[[{'var',1343,'Bindings'}|[{'remote_type',1343,[{'atom',1343,'erl_eval'}|[{'atom',1343,'binding_struct'}|[[]]]]}]]]]}|[{'type',1344,'constraint',[{'atom',1344,'is_subtype'}|[[{'var',1344,'ErrorInfo'}|[{'remote_type',1344,[{'atom',1344,'erl_parse'}|[{'atom',1344,'error_info'}|[[]]]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'extended_parse_term',1},[{'type',1460,'bounded_fun',[{'type',1460,'fun',[{'type',1460,'product',[{'var',1460,'Tokens'}]}|[{'type',1461,'union',[{'type',1461,'tuple',[{'atom',1461,'ok'}|[{'var',1461,'Term'}]]}|[{'type',1461,'tuple',[{'atom',1461,'error'}|[{'var',1461,'ErrorInfo'}]]}]]}]]}|[[{'type',1462,'constraint',[{'atom',1462,'is_subtype'}|[[{'var',1462,'Tokens'}|[{'type',1462,'list',[{'remote_type',1462,[{'atom',1462,'erl_scan'}|[{'atom',1462,'token'}|[[]]]]}]}]]]]}|[{'type',1463,'constraint',[{'atom',1463,'is_subtype'}|[[{'var',1463,'Term'}|[{'type',1463,'term',[]}]]]]}|[{'type',1464,'constraint',[{'atom',1464,'is_subtype'}|[[{'var',1464,'ErrorInfo'}|[{'remote_type',1464,[{'atom',1464,'erl_parse'}|[{'atom',1464,'error_info'}|[[]]]]}]]]]}]]]]]}]}]
, 'spec' = [{{'eval_str',1},[{'type',1587,'fun',[{'type',1587,'product',[{'type',1587,'union',[{'type',1587,'string',[]}|[{'remote_type',1587,[{'atom',1587,'unicode'}|[{'atom',1587,'latin1_binary'}|[[]]]]}]]}]}|[{'type',1588,'union',[{'type',1588,'tuple',[{'atom',1588,'ok'}|[{'type',1588,'string',[]}]]}|[{'type',1588,'tuple',[{'atom',1588,'error'}|[{'type',1588,'string',[]}]]}]]}]]}]}] ] 'exprs'/2 = fun (_0,_1) -> case apply 'check_command'/2 (_0,_1) of <'ok'> when 'true' -> apply 'exprs'/5 (_0,_1,'none','none','none')
<{'error',{_X_Line,_X_Mod,Error}}> when 'true' -> let <_2> = call 'erlang':'self' () in let <_3> = call 'erlang':'process_info' (_2,'current_stacktrace') in let <_4> = call 'erlang':'element' (2,_3) in call 'erlang':'raise' ('error',Error,_4)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'exprs'/3 = fun (_0,_1,_2) -> apply 'exprs'/5 (_0,_1,_2,'none','none')
'exprs'/4 = fun (_0,_1,_2,_3) -> apply 'exprs'/5 (_0,_1,_2,_3,'none')
'exprs'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[E|[]],Bs0,Lf,Ef,RBs> when 'true' -> apply 'expr'/5 (E,Bs0,Lf,Ef,RBs)
<[E|Es],Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (E,Bs0,Lf,Ef,'none') of <{'value',_X_V,Bs}> when 'true' -> apply 'exprs'/5 (Es,Bs,Lf,Ef,RBs)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'exprs',5}}] )-|['compiler_generated'] ) end
'expr'/2 = fun (_0,_1) -> case apply 'check_command'/2 ([_0|[]],_1) of <'ok'> when 'true' -> apply 'expr'/5 (_0,_1,'none','none','none')
<{'error',{_X_Line,_X_Mod,Error}}> when 'true' -> let <_2> = call 'erlang':'self' () in let <_3> = call 'erlang':'process_info' (_2,'current_stacktrace') in let <_4> = call 'erlang':'element' (2,_3) in call 'erlang':'raise' ('error',Error,_4)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'expr'/3 = fun (_0,_1,_2) -> apply 'expr'/5 (_0,_1,_2,'none','none')
'expr'/4 = fun (_0,_1,_2,_3) -> apply 'expr'/5 (_0,_1,_2,_3,'none')
'check_command'/2 = fun (_0,_1) -> let <_3> = apply 'bindings'/1 (_1) in case call 'erl_lint':'exprs_opt' (_0,_3,['bitlevel_binaries'|['binary_comprehension']]) of <{'ok',_X_Ws}> when 'true' -> 'ok'
<{'error',[{_X_File,[Error|_7]}|[]],_X_Ws}> when 'true' -> {'error',Error}
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'fun_data'/1 = fun (_0) -> case _0 of <F> when call 'erlang':'is_function' (_0) -> case call 'erlang':'fun_info' (F,'module') of <{'module','erl_eval'}> when 'true' -> case call 'erlang':'fun_info' (F,'env') of <{'env',[{FBs,_X_FLf,_X_FEf,FCs}|[]]}> when 'true' -> {'fun_data',FBs,FCs}
<{'env',[{FBs,_X_FLf,_X_FEf,FCs,FName}|[]]}> when 'true' -> {'named_fun_data',FBs,FName,FCs}
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
<_4> when 'true' -> 'false' end
<_X_T> when 'true' -> 'false' end
'expr'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <{'var',_999,V},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> case apply 'binding'/2 (V,Bs) of <{'value',Val}> when 'true' -> apply 'ret_expr'/3 (Val,Bs,RBs)
<'unbound'> when 'true' -> let <_5> = call 'erlang':'self' () in let <_6> = call 'erlang':'process_info' (_5,'current_stacktrace') in let <_7> = call 'erlang':'element' (2,_6) in call 'erlang':'raise' ('error',{'unbound',V},_7)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<{'char',_1000,C},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> apply 'ret_expr'/3 (C,Bs,RBs)
<{'integer',_1001,I},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> apply 'ret_expr'/3 (I,Bs,RBs)
<{'float',_1002,F},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> apply 'ret_expr'/3 (F,Bs,RBs)
<{'atom',_1003,A},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> apply 'ret_expr'/3 (A,Bs,RBs)
<{'string',_1004,S},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> apply 'ret_expr'/3 (S,Bs,RBs)
<{'nil',_1005},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> apply 'ret_expr'/3 ([],Bs,RBs)
<{'cons',_1006,H0,T0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (H0,Bs0,Lf,Ef,'none') of <{'value',H,Bs1}> when 'true' -> case apply 'expr'/5 (T0,Bs0,Lf,Ef,'none') of <{'value',T,Bs2}> when 'true' -> let <_11> = apply 'merge_bindings'/2 (Bs1,Bs2) in apply 'ret_expr'/3 ([H|T],_11,RBs)
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<{'lc',_1007,E,Qs},Bs,Lf,Ef,RBs> when 'true' -> apply 'eval_lc'/6 (E,Qs,Bs,Lf,Ef,RBs)
<{'bc',_1008,E,Qs},Bs,Lf,Ef,RBs> when 'true' -> apply 'eval_bc'/6 (E,Qs,Bs,Lf,Ef,RBs)
<{'tuple',_1009,Es},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr_list'/4 (Es,Bs0,Lf,Ef) of <{Vs,Bs}> when 'true' -> let <_13> = call 'erlang':'list_to_tuple' (Vs) in apply 'ret_expr'/3 (_13,Bs,RBs)
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<{'record_field',_1010,_1011,Name,_1012},_X_Bs,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_14> = call 'erlang':'self' () in let <_15> = call 'erlang':'process_info' (_14,'current_stacktrace') in let <_16> = call 'erlang':'element' (2,_15) in call 'erlang':'raise' ('error',{'undef_record',Name},_16)
<{'record_index',_1013,Name,_1014},_X_Bs,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_17> = call 'erlang':'self' () in let <_18> = call 'erlang':'process_info' (_17,'current_stacktrace') in let <_19> = call 'erlang':'element' (2,_18) in call 'erlang':'raise' ('error',{'undef_record',Name},_19)
<{'record',_1015,Name,_1016},_X_Bs,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_20> = call 'erlang':'self' () in let <_21> = call 'erlang':'process_info' (_20,'current_stacktrace') in let <_22> = call 'erlang':'element' (2,_21) in call 'erlang':'raise' ('error',{'undef_record',Name},_22)
<{'record',_1017,_1018,Name,_1019},_X_Bs,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_23> = call 'erlang':'self' () in let <_24> = call 'erlang':'process_info' (_23,'current_stacktrace') in let <_25> = call 'erlang':'element' (2,_24) in call 'erlang':'raise' ('error',{'undef_record',Name},_25)
<{'map',_1020,Binding,Es},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (Binding,Bs0,Lf,Ef,'none') of <{'value',Map0,Bs1}> when 'true' -> case apply 'eval_map_fields'/4 (Es,Bs0,Lf,Ef) of <{Vs,Bs2}> when 'true' -> do (call ('maps'-|['result_not_wanted'] ):('put'-|['result_not_wanted'] ) (('k'-|['result_not_wanted'] ),('v'-|['result_not_wanted'] ),Map0)-|['result_not_wanted'] ) let <_33> = fun (_30,_29) -> case <_30,_29> of <{'map_assoc',K,V},Mi> when 'true' -> call 'maps':'put' (K,V,Mi)
<{'map_exact',K,V},Mi> when 'true' -> call 'maps':'update' (K,V,Mi)
(<_32,_31> when 'true' -> (primop 'match_fail' ({'function_clause',_32,_31})-|[{'function_name',{'-expr/5-fun-0-',2}}] )-|['compiler_generated'] ) end in let <Map1> = call 'lists':'foldl' (_33,Map0,Vs) in let <_35> = apply 'merge_bindings'/2 (Bs2,Bs1) in apply 'ret_expr'/3 (Map1,_35,RBs)
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end
(<_26> when 'true' -> primop 'match_fail' ({'badmatch',_26})-|['compiler_generated'] ) end
<{'map',_1021,Es},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'eval_map_fields'/4 (Es,Bs0,Lf,Ef) of <{Vs,Bs}> when 'true' -> let <_42> = fun (_39,_38) -> case <_39,_38> of <{'map_assoc',K,V},Mi> when 'true' -> call 'maps':'put' (K,V,Mi)
(<_41,_40> when 'true' -> (primop 'match_fail' ({'function_clause',_41,_40})-|[{'function_name',{'-expr/5-fun-1-',2}}] )-|['compiler_generated'] ) end in let <_37> = call 'maps':'new' () in let <_43> = call 'lists':'foldl' (_42,_37,Vs) in apply 'ret_expr'/3 (_43,Bs,RBs)
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end
<{'block',_1022,Es},Bs,Lf,Ef,RBs> when 'true' -> apply 'exprs'/5 (Es,Bs,Lf,Ef,RBs)
<{'if',_1023,Cs},Bs,Lf,Ef,RBs> when 'true' -> apply 'if_clauses'/5 (Cs,Bs,Lf,Ef,RBs)
<{'case',_1024,E,Cs},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (E,Bs0,Lf,Ef,'none') of <{'value',Val,Bs}> when 'true' -> apply 'case_clauses'/6 (Val,Cs,Bs,Lf,Ef,RBs)
(<_44> when 'true' -> primop 'match_fail' ({'badmatch',_44})-|['compiler_generated'] ) end
<{'try',_1025,B,Cases,Catches,AB},Bs,Lf,Ef,RBs> when 'true' -> apply 'try_clauses'/8 (B,Cases,Catches,AB,Bs,Lf,Ef,RBs)
<{'receive',_1026,Cs},Bs,Lf,Ef,RBs> when 'true' -> apply 'receive_clauses'/5 (Cs,Bs,Lf,Ef,RBs)
<{'receive',_1027,Cs,E,TB},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (E,Bs0,Lf,Ef,'none') of <{'value',T,Bs}> when 'true' -> apply 'receive_clauses'/7 (T,Cs,{TB,Bs},Bs0,Lf,Ef,RBs)
(<_45> when 'true' -> primop 'match_fail' ({'badmatch',_45})-|['compiler_generated'] ) end
<{'fun',_X_Line,{'function',Mod0,Name0,Arity0}},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr_list'/4 ([Mod0|[Name0|[Arity0|[]]]],Bs0,Lf,Ef) of <{[Mod|[Name|[Arity|[]]]],Bs}> when 'true' -> let <F> = call 'erlang':'make_fun' (Mod,Name,Arity) in apply 'ret_expr'/3 (F,Bs,RBs)
(<_46> when 'true' -> primop 'match_fail' ({'badmatch',_46})-|['compiler_generated'] ) end
<{'fun',_X_Line,{'function',Name,Arity}},_X_Bs0,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_48> = call 'erlang':'self' () in let <_49> = call 'erlang':'process_info' (_48,'current_stacktrace') in let <_50> = call 'erlang':'element' (2,_49) in call 'erlang':'raise' ('error','undef',[{'erl_eval',Name,Arity}|_50])
<Ex = {'fun',Line,{'clauses',Cs}},Bs,Lf,Ef,RBs> when 'true' -> case apply 'hide_calls'/2 (Ex,0) of <{Ex1,_1028}> when 'true' -> case call 'erl_lint':'used_vars' ([Ex1|[]],Bs) of <{'ok',Used}> when 'true' -> let <_57> = fun (_54,_53) -> call 'lists':'member' (_54,Used) in let <En> = call 'orddict':'filter' (_57,Bs) in let <Info> = {En,Lf,Ef,Cs} in let <_60> = call 'erlang':'hd' (Cs) in let <_61> = call 'erlang':'element' (3,_60) in let <_488> = case call 'erlang':'length' (_61) of <0> when 'true' -> (fun () -> apply 'eval_fun'/2 ([],Info)-|[{'id',{0,0,'-expr/5-fun-3-'}}] )
<1> when 'true' -> (fun (_62) -> apply 'eval_fun'/2 ([_62|[]],Info)-|[{'id',{0,0,'-expr/5-fun-4-'}}] )
<2> when 'true' -> (fun (_65,_64) -> apply 'eval_fun'/2 ([_65|[_64|[]]],Info)-|[{'id',{0,0,'-expr/5-fun-5-'}}] )
<3> when 'true' -> (fun (_70,_69,_68) -> apply 'eval_fun'/2 ([_70|[_69|[_68|[]]]],Info)-|[{'id',{0,0,'-expr/5-fun-6-'}}] )
<4> when 'true' -> (fun (_77,_76,_75,_74) -> apply 'eval_fun'/2 ([_77|[_76|[_75|[_74|[]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-7-'}}] )
<5> when 'true' -> (fun (_86,_85,_84,_83,_82) -> apply 'eval_fun'/2 ([_86|[_85|[_84|[_83|[_82|[]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-8-'}}] )
<6> when 'true' -> (fun (_97,_96,_95,_94,_93,_92) -> apply 'eval_fun'/2 ([_97|[_96|[_95|[_94|[_93|[_92|[]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-9-'}}] )
<7> when 'true' -> (fun (_110,_109,_108,_107,_106,_105,_104) -> apply 'eval_fun'/2 ([_110|[_109|[_108|[_107|[_106|[_105|[_104|[]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-10-'}}] )
<8> when 'true' -> (fun (_125,_124,_123,_122,_121,_120,_119,_118) -> apply 'eval_fun'/2 ([_125|[_124|[_123|[_122|[_121|[_120|[_119|[_118|[]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-11-'}}] )
<9> when 'true' -> (fun (_142,_141,_140,_139,_138,_137,_136,_135,_134) -> apply 'eval_fun'/2 ([_142|[_141|[_140|[_139|[_138|[_137|[_136|[_135|[_134|[]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-12-'}}] )
<10> when 'true' -> (fun (_161,_160,_159,_158,_157,_156,_155,_154,_153,_152) -> apply 'eval_fun'/2 ([_161|[_160|[_159|[_158|[_157|[_156|[_155|[_154|[_153|[_152|[]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-13-'}}] )
<11> when 'true' -> (fun (_182,_181,_180,_179,_178,_177,_176,_175,_174,_173,_172) -> apply 'eval_fun'/2 ([_182|[_181|[_180|[_179|[_178|[_177|[_176|[_175|[_174|[_173|[_172|[]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-14-'}}] )
<12> when 'true' -> (fun (_205,_204,_203,_202,_201,_200,_199,_198,_197,_196,_195,_194) -> apply 'eval_fun'/2 ([_205|[_204|[_203|[_202|[_201|[_200|[_199|[_198|[_197|[_196|[_195|[_194|[]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-15-'}}] )
<13> when 'true' -> (fun (_230,_229,_228,_227,_226,_225,_224,_223,_222,_221,_220,_219,_218) -> apply 'eval_fun'/2 ([_230|[_229|[_228|[_227|[_226|[_225|[_224|[_223|[_222|[_221|[_220|[_219|[_218|[]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-16-'}}] )
<14> when 'true' -> (fun (_257,_256,_255,_254,_253,_252,_251,_250,_249,_248,_247,_246,_245,_244) -> apply 'eval_fun'/2 ([_257|[_256|[_255|[_254|[_253|[_252|[_251|[_250|[_249|[_248|[_247|[_246|[_245|[_244|[]]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-17-'}}] )
<15> when 'true' -> (fun (_286,_285,_284,_283,_282,_281,_280,_279,_278,_277,_276,_275,_274,_273,_272) -> apply 'eval_fun'/2 ([_286|[_285|[_284|[_283|[_282|[_281|[_280|[_279|[_278|[_277|[_276|[_275|[_274|[_273|[_272|[]]]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-18-'}}] )
<16> when 'true' -> (fun (_317,_316,_315,_314,_313,_312,_311,_310,_309,_308,_307,_306,_305,_304,_303,_302) -> apply 'eval_fun'/2 ([_317|[_316|[_315|[_314|[_313|[_312|[_311|[_310|[_309|[_308|[_307|[_306|[_305|[_304|[_303|[_302|[]]]]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-19-'}}] )
<17> when 'true' -> (fun (_350,_349,_348,_347,_346,_345,_344,_343,_342,_341,_340,_339,_338,_337,_336,_335,_334) -> apply 'eval_fun'/2 ([_350|[_349|[_348|[_347|[_346|[_345|[_344|[_343|[_342|[_341|[_340|[_339|[_338|[_337|[_336|[_335|[_334|[]]]]]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-20-'}}] )
<18> when 'true' -> (fun (_385,_384,_383,_382,_381,_380,_379,_378,_377,_376,_375,_374,_373,_372,_371,_370,_369,_368) -> apply 'eval_fun'/2 ([_385|[_384|[_383|[_382|[_381|[_380|[_379|[_378|[_377|[_376|[_375|[_374|[_373|[_372|[_371|[_370|[_369|[_368|[]]]]]]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-21-'}}] )
<19> when 'true' -> (fun (_422,_421,_420,_419,_418,_417,_416,_415,_414,_413,_412,_411,_410,_409,_408,_407,_406,_405,_404) -> apply 'eval_fun'/2 ([_422|[_421|[_420|[_419|[_418|[_417|[_416|[_415|[_414|[_413|[_412|[_411|[_410|[_409|[_408|[_407|[_406|[_405|[_404|[]]]]]]]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-22-'}}] )
<20> when 'true' -> (fun (_461,_460,_459,_458,_457,_456,_455,_454,_453,_452,_451,_450,_449,_448,_447,_446,_445,_444,_443,_442) -> apply 'eval_fun'/2 ([_461|[_460|[_459|[_458|[_457|[_456|[_455|[_454|[_453|[_452|[_451|[_450|[_449|[_448|[_447|[_446|[_445|[_444|[_443|[_442|[]]]]]]]]]]]]]]]]]]]]],Info)-|[{'id',{0,0,'-expr/5-fun-23-'}}] )
<_X_Other> when 'true' -> let <L> = call 'erl_anno':'location' (Line) in let <_486> = apply 'to_terms'/1 (Cs) in let <_483> = call 'erlang':'self' () in let <_484> = call 'erlang':'process_info' (_483,'current_stacktrace') in let <_485> = call 'erlang':'element' (2,_484) in call 'erlang':'raise' ('error',{'argument_limit',{'fun',L,_486}},_485) end in apply 'ret_expr'/3 (_488,Bs,RBs)
(<_52> when 'true' -> primop 'match_fail' ({'badmatch',_52})-|['compiler_generated'] ) end
(<_51> when 'true' -> primop 'match_fail' ({'badmatch',_51})-|['compiler_generated'] ) end
<Ex = {'named_fun',Line,Name,Cs},Bs,Lf,Ef,RBs> when 'true' -> case apply 'hide_calls'/2 (Ex,0) of <{Ex1,_1029}> when 'true' -> case call 'erl_lint':'used_vars' ([Ex1|[]],Bs) of <{'ok',Used}> when 'true' -> let <_496> = fun (_493,_492) -> call 'lists':'member' (_493,Used) in let <En> = call 'orddict':'filter' (_496,Bs) in let <Info> = {En,Lf,Ef,Cs,Name} in let <_499> = call 'erlang':'hd' (Cs) in let <_500> = call 'erlang':'element' (3,_499) in let <_927> = case call 'erlang':'length' (_500) of <0> when 'true' -> letrec 'RF'/0 = (fun () -> let <RF> = 'RF'/0 in apply 'eval_named_fun'/3 ([],RF,Info)-|[{'id',{0,0,'-expr/5-fun-25-'}}] ) in 'RF'/0
<1> when 'true' -> letrec 'RF'/1 = (fun (_501) -> let <RF> = 'RF'/1 in apply 'eval_named_fun'/3 ([_501|[]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-26-'}}] ) in 'RF'/1
<2> when 'true' -> letrec 'RF'/2 = (fun (_504,_503) -> let <RF> = 'RF'/2 in apply 'eval_named_fun'/3 ([_504|[_503|[]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-27-'}}] ) in 'RF'/2
<3> when 'true' -> letrec 'RF'/3 = (fun (_509,_508,_507) -> let <RF> = 'RF'/3 in apply 'eval_named_fun'/3 ([_509|[_508|[_507|[]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-28-'}}] ) in 'RF'/3
<4> when 'true' -> letrec 'RF'/4 = (fun (_516,_515,_514,_513) -> let <RF> = 'RF'/4 in apply 'eval_named_fun'/3 ([_516|[_515|[_514|[_513|[]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-29-'}}] ) in 'RF'/4
<5> when 'true' -> letrec 'RF'/5 = (fun (_525,_524,_523,_522,_521) -> let <RF> = 'RF'/5 in apply 'eval_named_fun'/3 ([_525|[_524|[_523|[_522|[_521|[]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-30-'}}] ) in 'RF'/5
<6> when 'true' -> letrec 'RF'/6 = (fun (_536,_535,_534,_533,_532,_531) -> let <RF> = 'RF'/6 in apply 'eval_named_fun'/3 ([_536|[_535|[_534|[_533|[_532|[_531|[]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-31-'}}] ) in 'RF'/6
<7> when 'true' -> letrec 'RF'/7 = (fun (_549,_548,_547,_546,_545,_544,_543) -> let <RF> = 'RF'/7 in apply 'eval_named_fun'/3 ([_549|[_548|[_547|[_546|[_545|[_544|[_543|[]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-32-'}}] ) in 'RF'/7
<8> when 'true' -> letrec 'RF'/8 = (fun (_564,_563,_562,_561,_560,_559,_558,_557) -> let <RF> = 'RF'/8 in apply 'eval_named_fun'/3 ([_564|[_563|[_562|[_561|[_560|[_559|[_558|[_557|[]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-33-'}}] ) in 'RF'/8
<9> when 'true' -> letrec 'RF'/9 = (fun (_581,_580,_579,_578,_577,_576,_575,_574,_573) -> let <RF> = 'RF'/9 in apply 'eval_named_fun'/3 ([_581|[_580|[_579|[_578|[_577|[_576|[_575|[_574|[_573|[]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-34-'}}] ) in 'RF'/9
<10> when 'true' -> letrec 'RF'/10 = (fun (_600,_599,_598,_597,_596,_595,_594,_593,_592,_591) -> let <RF> = 'RF'/10 in apply 'eval_named_fun'/3 ([_600|[_599|[_598|[_597|[_596|[_595|[_594|[_593|[_592|[_591|[]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-35-'}}] ) in 'RF'/10
<11> when 'true' -> letrec 'RF'/11 = (fun (_621,_620,_619,_618,_617,_616,_615,_614,_613,_612,_611) -> let <RF> = 'RF'/11 in apply 'eval_named_fun'/3 ([_621|[_620|[_619|[_618|[_617|[_616|[_615|[_614|[_613|[_612|[_611|[]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-36-'}}] ) in 'RF'/11
<12> when 'true' -> letrec 'RF'/12 = (fun (_644,_643,_642,_641,_640,_639,_638,_637,_636,_635,_634,_633) -> let <RF> = 'RF'/12 in apply 'eval_named_fun'/3 ([_644|[_643|[_642|[_641|[_640|[_639|[_638|[_637|[_636|[_635|[_634|[_633|[]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-37-'}}] ) in 'RF'/12
<13> when 'true' -> letrec 'RF'/13 = (fun (_669,_668,_667,_666,_665,_664,_663,_662,_661,_660,_659,_658,_657) -> let <RF> = 'RF'/13 in apply 'eval_named_fun'/3 ([_669|[_668|[_667|[_666|[_665|[_664|[_663|[_662|[_661|[_660|[_659|[_658|[_657|[]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-38-'}}] ) in 'RF'/13
<14> when 'true' -> letrec 'RF'/14 = (fun (_696,_695,_694,_693,_692,_691,_690,_689,_688,_687,_686,_685,_684,_683) -> let <RF> = 'RF'/14 in apply 'eval_named_fun'/3 ([_696|[_695|[_694|[_693|[_692|[_691|[_690|[_689|[_688|[_687|[_686|[_685|[_684|[_683|[]]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-39-'}}] ) in 'RF'/14
<15> when 'true' -> letrec 'RF'/15 = (fun (_725,_724,_723,_722,_721,_720,_719,_718,_717,_716,_715,_714,_713,_712,_711) -> let <RF> = 'RF'/15 in apply 'eval_named_fun'/3 ([_725|[_724|[_723|[_722|[_721|[_720|[_719|[_718|[_717|[_716|[_715|[_714|[_713|[_712|[_711|[]]]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-40-'}}] ) in 'RF'/15
<16> when 'true' -> letrec 'RF'/16 = (fun (_756,_755,_754,_753,_752,_751,_750,_749,_748,_747,_746,_745,_744,_743,_742,_741) -> let <RF> = 'RF'/16 in apply 'eval_named_fun'/3 ([_756|[_755|[_754|[_753|[_752|[_751|[_750|[_749|[_748|[_747|[_746|[_745|[_744|[_743|[_742|[_741|[]]]]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-41-'}}] ) in 'RF'/16
<17> when 'true' -> letrec 'RF'/17 = (fun (_789,_788,_787,_786,_785,_784,_783,_782,_781,_780,_779,_778,_777,_776,_775,_774,_773) -> let <RF> = 'RF'/17 in apply 'eval_named_fun'/3 ([_789|[_788|[_787|[_786|[_785|[_784|[_783|[_782|[_781|[_780|[_779|[_778|[_777|[_776|[_775|[_774|[_773|[]]]]]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-42-'}}] ) in 'RF'/17
<18> when 'true' -> letrec 'RF'/18 = (fun (_824,_823,_822,_821,_820,_819,_818,_817,_816,_815,_814,_813,_812,_811,_810,_809,_808,_807) -> let <RF> = 'RF'/18 in apply 'eval_named_fun'/3 ([_824|[_823|[_822|[_821|[_820|[_819|[_818|[_817|[_816|[_815|[_814|[_813|[_812|[_811|[_810|[_809|[_808|[_807|[]]]]]]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-43-'}}] ) in 'RF'/18
<19> when 'true' -> letrec 'RF'/19 = (fun (_861,_860,_859,_858,_857,_856,_855,_854,_853,_852,_851,_850,_849,_848,_847,_846,_845,_844,_843) -> let <RF> = 'RF'/19 in apply 'eval_named_fun'/3 ([_861|[_860|[_859|[_858|[_857|[_856|[_855|[_854|[_853|[_852|[_851|[_850|[_849|[_848|[_847|[_846|[_845|[_844|[_843|[]]]]]]]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-44-'}}] ) in 'RF'/19
<20> when 'true' -> letrec 'RF'/20 = (fun (_900,_899,_898,_897,_896,_895,_894,_893,_892,_891,_890,_889,_888,_887,_886,_885,_884,_883,_882,_881) -> let <RF> = 'RF'/20 in apply 'eval_named_fun'/3 ([_900|[_899|[_898|[_897|[_896|[_895|[_894|[_893|[_892|[_891|[_890|[_889|[_888|[_887|[_886|[_885|[_884|[_883|[_882|[_881|[]]]]]]]]]]]]]]]]]]]]],RF,Info)-|[{'id',{0,0,'-expr/5-fun-45-'}}] ) in 'RF'/20
<_X_Other> when 'true' -> let <L> = call 'erl_anno':'location' (Line) in let <_925> = apply 'to_terms'/1 (Cs) in let <_922> = call 'erlang':'self' () in let <_923> = call 'erlang':'process_info' (_922,'current_stacktrace') in let <_924> = call 'erlang':'element' (2,_923) in call 'erlang':'raise' ('error',{'argument_limit',{'named_fun',L,Name,_925}},_924) end in apply 'ret_expr'/3 (_927,Bs,RBs)
(<_491> when 'true' -> primop 'match_fail' ({'badmatch',_491})-|['compiler_generated'] ) end
(<_490> when 'true' -> primop 'match_fail' ({'badmatch',_490})-|['compiler_generated'] ) end
<{'call',_1030,{'remote',_1031,{'atom',_1032,'qlc'},{'atom',_1033,'q'}},[LC = {'lc',_1034,_X_E,_X_Qs}|As0]},Bs0,Lf,Ef,RBs> when try let <_929> = call 'erlang':'length' (As0) in call 'erlang':'=<' (_929,1) of <Try> -> Try catch <T,R> -> 'false' -> let <MaxLine> = apply 'find_maxline'/1 (LC) in case apply 'hide_calls'/2 (LC,MaxLine) of <{LC1,D}> when 'true' -> case call 'qlc':'transform_from_evaluator' (LC1,Bs0) of <{'ok',{'call',L,Remote,[QLC|[]]}}> when 'true' -> let <QLC1> = apply 'unhide_calls'/3 (QLC,MaxLine,D) in apply 'expr'/5 ({'call',L,Remote,[QLC1|As0]},Bs0,Lf,Ef,RBs)
<{'not_ok',Error}> when 'true' -> apply 'ret_expr'/3 (Error,Bs0,RBs)
(<_933> when 'true' -> primop 'match_fail' ({'case_clause',_933})-|['compiler_generated'] ) end
(<_931> when 'true' -> primop 'match_fail' ({'badmatch',_931})-|['compiler_generated'] ) end
<{'call',L1,{'remote',L2,{'record_field',_1035,{'atom',_1036,''},Mod = {'atom',_1037,'qlc'}},Func = {'atom',_1038,'q'}},As = [{'lc',_1039,_X_E,_X_Qs}|As0]},Bs,Lf,Ef,RBs> when try let <_934> = call 'erlang':'length' (As0) in call 'erlang':'=<' (_934,1) of <Try> -> Try catch <T,R> -> 'false' -> apply 'expr'/5 ({'call',L1,{'remote',L2,Mod,Func},As},Bs,Lf,Ef,RBs)
<{'call',_1040,{'remote',_1041,Mod,Func},As0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (Mod,Bs0,Lf,Ef,'none') of <{'value',M,Bs1}> when 'true' -> case apply 'expr'/5 (Func,Bs0,Lf,Ef,'none') of <{'value',F,Bs2}> when 'true' -> let <_937> = apply 'merge_bindings'/2 (Bs1,Bs2) in case apply 'expr_list'/4 (As0,_937,Lf,Ef) of <{As,Bs3}> when 'true' -> let <_942> = case <> of (<> when call 'erlang':'is_atom' (M) -> let <_940> = call 'erlang':'length' (As) in call 'erl_internal':'bif' (M,F,_940)-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end in case _942 of <'true'> when 'true' -> apply 'bif'/5 (F,As,Bs3,Ef,RBs)
<'false'> when 'true' -> apply 'do_apply'/6 (M,F,As,Bs3,Ef,RBs)
(<_943> when 'true' -> primop 'match_fail' ({'case_clause',_943})-|['compiler_generated'] ) end
(<_938> when 'true' -> primop 'match_fail' ({'badmatch',_938})-|['compiler_generated'] ) end
(<_936> when 'true' -> primop 'match_fail' ({'badmatch',_936})-|['compiler_generated'] ) end
(<_935> when 'true' -> primop 'match_fail' ({'badmatch',_935})-|['compiler_generated'] ) end
<{'call',_1042,{'atom',_1043,Func},As0},Bs0,Lf,Ef,RBs> when 'true' -> let <_944> = call 'erlang':'length' (As0) in case call 'erl_internal':'bif' (Func,_944) of <'true'> when 'true' -> case apply 'expr_list'/4 (As0,Bs0,Lf,Ef) of <{As,Bs}> when 'true' -> apply 'bif'/5 (Func,As,Bs,Ef,RBs)
(<_945> when 'true' -> primop 'match_fail' ({'badmatch',_945})-|['compiler_generated'] ) end
<'false'> when 'true' -> apply 'local_func'/6 (Func,As0,Bs0,Lf,Ef,RBs)
(<_946> when 'true' -> primop 'match_fail' ({'case_clause',_946})-|['compiler_generated'] ) end
<{'call',_1044,Func0,As0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (Func0,Bs0,Lf,Ef,'none') of <{'value',Func,Bs1}> when 'true' -> case apply 'expr_list'/4 (As0,Bs1,Lf,Ef) of <{As,Bs2}> when 'true' -> case Func of <{M,F}> when let <_949> = call 'erlang':'is_atom' (M) in let <_950> = call 'erlang':'is_atom' (F) in call 'erlang':'and' (_949,_950) -> let <_951> = call 'erlang':'self' () in let <_952> = call 'erlang':'process_info' (_951,'current_stacktrace') in let <_953> = call 'erlang':'element' (2,_952) in call 'erlang':'raise' ('error',{'badfun',Func},_953)
<_1045> when 'true' -> apply 'do_apply'/5 (Func,As,Bs2,Ef,RBs) end
(<_948> when 'true' -> primop 'match_fail' ({'badmatch',_948})-|['compiler_generated'] ) end
(<_947> when 'true' -> primop 'match_fail' ({'badmatch',_947})-|['compiler_generated'] ) end
<{'catch',_1046,Expr},Bs0,Lf,Ef,RBs> when 'true' -> try apply 'expr'/5 (Expr,Bs0,Lf,Ef,'none') of <_955> -> case _955 of <{'value',V,Bs}> when 'true' -> apply 'ret_expr'/3 (V,Bs,RBs)
(<_956> when 'true' -> primop 'match_fail' ({'try_clause',_956})-|['compiler_generated'] ) end catch <_959,_958,_957> -> case <_959,_958,_957> of <('throw'-|['compiler_generated'] ),Term,_1047> when 'true' -> apply 'ret_expr'/3 (Term,Bs0,RBs)
<('exit'-|['compiler_generated'] ),Reason,_1048> when 'true' -> apply 'ret_expr'/3 ({'EXIT',Reason},Bs0,RBs)
<('error'-|['compiler_generated'] ),Reason,_1487> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_1487) in apply 'ret_expr'/3 ({'EXIT',{Reason,Stacktrace}},Bs0,RBs)
(<_1488,_1489,_1490> when 'true' -> primop 'raise' (_1490,_1489)-|['compiler_generated'] ) end
<{'match',_1049,Lhs,Rhs0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (Rhs0,Bs0,Lf,Ef,'none') of <{'value',Rhs,Bs1}> when 'true' -> case apply 'match'/3 (Lhs,Rhs,Bs1) of <{'match',Bs}> when 'true' -> apply 'ret_expr'/3 (Rhs,Bs,RBs)
<'nomatch'> when 'true' -> let <_961> = call 'erlang':'self' () in let <_962> = call 'erlang':'process_info' (_961,'current_stacktrace') in let <_963> = call 'erlang':'element' (2,_962) in call 'erlang':'raise' ('error',{'badmatch',Rhs},_963)
(<_964> when 'true' -> primop 'match_fail' ({'case_clause',_964})-|['compiler_generated'] ) end
(<_960> when 'true' -> primop 'match_fail' ({'badmatch',_960})-|['compiler_generated'] ) end
<{'op',_1050,Op,A0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (A0,Bs0,Lf,Ef,'none') of <{'value',A,Bs}> when 'true' -> apply 'eval_op'/5 (Op,A,Bs,Ef,RBs)
(<_965> when 'true' -> primop 'match_fail' ({'badmatch',_965})-|['compiler_generated'] ) end
<{'op',_1051,'andalso',L0,R0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (L0,Bs0,Lf,Ef,'none') of <{'value',L,Bs1}> when 'true' -> let <_972> = case L of <'true'> when 'true' -> case apply 'expr'/5 (R0,Bs1,Lf,Ef,'none') of <{'value',R,_1052}> when 'true' -> R
(<_967> when 'true' -> primop 'match_fail' ({'badmatch',_967})-|['compiler_generated'] ) end
<'false'> when 'true' -> 'false'
<_1053> when 'true' -> let <_968> = call 'erlang':'self' () in let <_969> = call 'erlang':'process_info' (_968,'current_stacktrace') in let <_970> = call 'erlang':'element' (2,_969) in call 'erlang':'raise' ('error',{'badarg',L},_970) end in apply 'ret_expr'/3 (_972,Bs1,RBs)
(<_966> when 'true' -> primop 'match_fail' ({'badmatch',_966})-|['compiler_generated'] ) end
<{'op',_1054,'orelse',L0,R0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (L0,Bs0,Lf,Ef,'none') of <{'value',L,Bs1}> when 'true' -> let <_980> = case L of <'true'> when 'true' -> 'true'
<'false'> when 'true' -> case apply 'expr'/5 (R0,Bs1,Lf,Ef,'none') of <{'value',R,_1055}> when 'true' -> R
(<_975> when 'true' -> primop 'match_fail' ({'badmatch',_975})-|['compiler_generated'] ) end
<_1056> when 'true' -> let <_976> = call 'erlang':'self' () in let <_977> = call 'erlang':'process_info' (_976,'current_stacktrace') in let <_978> = call 'erlang':'element' (2,_977) in call 'erlang':'raise' ('error',{'badarg',L},_978) end in apply 'ret_expr'/3 (_980,Bs1,RBs)
(<_974> when 'true' -> primop 'match_fail' ({'badmatch',_974})-|['compiler_generated'] ) end
<{'op',_1057,Op,L0,R0},Bs0,Lf,Ef,RBs> when 'true' -> case apply 'expr'/5 (L0,Bs0,Lf,Ef,'none') of <{'value',L,Bs1}> when 'true' -> case apply 'expr'/5 (R0,Bs0,Lf,Ef,'none') of <{'value',R,Bs2}> when 'true' -> let <_984> = apply 'merge_bindings'/2 (Bs1,Bs2) in apply 'eval_op'/6 (Op,L,R,_984,Ef,RBs)
(<_983> when 'true' -> primop 'match_fail' ({'badmatch',_983})-|['compiler_generated'] ) end
(<_982> when 'true' -> primop 'match_fail' ({'badmatch',_982})-|['compiler_generated'] ) end
<{'bin',_1058,Fs},Bs0,Lf,Ef,RBs> when 'true' -> let <EvalFun> = fun (_986,_985) -> apply 'expr'/5 (_986,_985,Lf,Ef,'none') in case call 'eval_bits':'expr_grp' (Fs,Bs0,EvalFun) of <{'value',V,Bs}> when 'true' -> apply 'ret_expr'/3 (V,Bs,RBs)
(<_990> when 'true' -> primop 'match_fail' ({'badmatch',_990})-|['compiler_generated'] ) end
<{'remote',_1059,_1060,_1061},_X_Bs,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_991> = call 'erlang':'self' () in let <_992> = call 'erlang':'process_info' (_991,'current_stacktrace') in let <_993> = call 'erlang':'element' (2,_992) in call 'erlang':'raise' ('error',{'badexpr',':'},_993)
<{'value',_1062,Val},Bs,_X_Lf,_X_Ef,RBs> when 'true' -> apply 'ret_expr'/3 (Val,Bs,RBs)
(<_998,_997,_996,_995,_994> when 'true' -> (primop 'match_fail' ({'function_clause',_998,_997,_996,_995,_994})-|[{'function_name',{'expr',5}}] )-|['compiler_generated'] ) end
'find_maxline'/1 = fun (_0) -> do call 'erlang':'put' ('$erl_eval_max_line',0) let <F> = fun (_6) -> let <L> = call 'erl_anno':'line' (_6) in let <_4> = call 'erlang':'is_integer' (L) in let <_2> = call 'erlang':'get' ('$erl_eval_max_line') in let <_3> = call 'erlang':'>' (L,_2) in case call 'erlang':'and' (_4,_3) of <'true'> when 'true' -> call 'erlang':'put' ('$erl_eval_max_line',L)
<'false'> when 'true' -> 'ok' end in do (call ('erl_parse'-|['result_not_wanted'] ):('map_anno'-|['result_not_wanted'] ) (F,_0)-|['result_not_wanted'] ) call 'erlang':'erase' ('$erl_eval_max_line')
'hide_calls'/2 = fun (_0,_1) -> let <LineId0> = call 'erlang':'+' (_1,1) in let <_3> = call 'maps':'new' () in case apply 'hide'/3 (_0,LineId0,_3) of <{NLC,_7,D}> when 'true' -> {NLC,D}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'hide'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_@r0 = {'value',L,V},Id,D> when 'true' -> let <A> = call 'erl_anno':'new' (Id) in let <_5> = call 'erlang':'+' (Id,1) in let <_4> = call 'maps':'put' (Id,_@r0,D) in {{'atom',A,'ok'},_5,_4}
<{'call',L,Atom = {'atom',_22,N},Args},Id0,D0> when 'true' -> case apply 'hide'/3 (Args,Id0,D0) of <{NArgs,Id,D}> when 'true' -> let <_7> = call 'erlang':'length' (Args) in let <_10> = case call 'erl_internal':'bif' (N,_7) of <'true'> when 'true' -> {'call',L,Atom,NArgs}
<'false'> when 'true' -> let <A> = call 'erl_anno':'new' (Id) in {'call',A,{'remote',L,{'atom',L,'m'},{'atom',L,'f'}},NArgs}
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end in let <_13> = call 'erlang':'+' (Id,1) in let <_12> = call 'maps':'put' (Id,{'call',Atom},D) in {_10,_13,_12}
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<T0,Id0,D0> when call 'erlang':'is_tuple' (T0) -> let <_14> = call 'erlang':'tuple_to_list' (T0) in case apply 'hide'/3 (_14,Id0,D0) of <{L,Id,D}> when 'true' -> let <_16> = call 'erlang':'list_to_tuple' (L) in {_16,Id,D}
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<[E0|Es0],Id0,D0> when 'true' -> case apply 'hide'/3 (E0,Id0,D0) of <{E,Id1,D1}> when 'true' -> case apply 'hide'/3 (Es0,Id1,D1) of <{Es,Id,D}> when 'true' -> {[E|Es],Id,D}
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<E,Id,D> when 'true' -> {E,Id,D} end
'unhide_calls'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <E = {'atom',A,'ok'},MaxLine,D> when 'true' -> let <L> = call 'erl_anno':'line' (A) in case <> of <> when call 'erlang':'>' (L,MaxLine) -> call 'erlang':'map_get' (L,D)
<> when 'true' -> E end
<{'call',A,F = {'remote',L,{'atom',_15,'m'},{'atom',_16,'f'}},Args},MaxLine,D> when let <_17> = call 'erlang':'=:=' (_15,L) in let <_18> = call 'erlang':'=:=' (_16,L) in call 'erlang':'and' (_17,_18) -> let <Line> = call 'erl_anno':'line' (A) in case <> of <> when call 'erlang':'>' (Line,MaxLine) -> case call 'erlang':'map_get' (Line,D) of <{'call',Atom}> when 'true' -> let <_6> = apply 'unhide_calls'/3 (Args,MaxLine,D) in {'call',L,Atom,_6}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<> when 'true' -> let <_7> = apply 'unhide_calls'/3 (Args,MaxLine,D) in {'call',A,F,_7} end
<T,MaxLine,D> when call 'erlang':'is_tuple' (T) -> let <_8> = call 'erlang':'tuple_to_list' (T) in let <_9> = apply 'unhide_calls'/3 (_8,MaxLine,D) in call 'erlang':'list_to_tuple' (_9)
<[E|Es],MaxLine,D> when 'true' -> let <_10> = apply 'unhide_calls'/3 (E,MaxLine,D) in let <_11> = apply 'unhide_calls'/3 (Es,MaxLine,D) in [_10|_11]
<E,_X_MaxLine,_X_D> when 'true' -> E end
'local_func'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Func,As0,Bs0,_@r0 = {'value',F},Ef,'value'> when 'true' -> case apply 'expr_list'/4 (As0,Bs0,_@r0,Ef) of <{As1,_X_Bs1}> when 'true' -> apply F (Func,As1)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<Func,As0,Bs0,_@r1 = {'value',F},Ef,RBs> when 'true' -> case apply 'expr_list'/4 (As0,Bs0,_@r1,Ef) of <{As1,Bs1}> when 'true' -> let <_8> = apply F (Func,As1) in apply 'ret_expr'/3 (_8,Bs1,RBs)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<Func,As0,Bs0,{'value',F,Eas},Ef,RBs> when 'true' -> let <Fun> = fun (_10,_9) -> call 'erlang':'apply' (F,[_10|[_9|Eas]]) in apply 'local_func'/6 (Func,As0,Bs0,{'value',Fun},Ef,RBs)
<Func,As,Bs,{'eval',F},_X_Ef,RBs> when 'true' -> let <_14> = apply F (Func,As,Bs) in apply 'local_func2'/2 (_14,RBs)
<Func,As,Bs,{'eval',F,Eas},_X_Ef,RBs> when 'true' -> let <_15> = call 'erlang':'apply' (F,[Func|[As|[Bs|Eas]]]) in apply 'local_func2'/2 (_15,RBs)
<Func,As0,Bs0,_@r2 = {M,F},Ef,RBs> when 'true' -> case apply 'expr_list'/4 (As0,Bs0,_@r2,Ef) of <{As1,Bs1}> when 'true' -> let <_17> = call M:F (Func,As1) in apply 'ret_expr'/3 (_17,Bs1,RBs)
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
<Func,As,_X_Bs,{M,F,Eas},_X_Ef,RBs> when 'true' -> let <_18> = call 'erlang':'apply' (M,F,[Func|[As|Eas]]) in apply 'local_func2'/2 (_18,RBs)
<Func,As0,_X_Bs0,'none',_X_Ef,_X_RBs> when 'true' -> let <_19> = call 'erlang':'length' (As0) in let <_20> = call 'erlang':'self' () in let <_21> = call 'erlang':'process_info' (_20,'current_stacktrace') in let <_22> = call 'erlang':'element' (2,_21) in call 'erlang':'raise' ('error','undef',[{'erl_eval',Func,_19}|_22])
(<_28,_27,_26,_25,_24,_23> when 'true' -> (primop 'match_fail' ({'function_clause',_28,_27,_26,_25,_24,_23})-|[{'function_name',{'local_func',6}}] )-|['compiler_generated'] ) end
'local_func2'/2 = fun (_0,_1) -> case <_0,_1> of <{'value',V,Bs},RBs> when 'true' -> apply 'ret_expr'/3 (V,Bs,RBs)
<{'eval',F,As,Bs},RBs> when 'true' -> apply 'do_apply'/5 (F,As,Bs,'none',RBs)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'local_func2',2}}] )-|['compiler_generated'] ) end
'bif'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <'apply',['erlang'|['apply'|[As|[]]]],Bs,Ef,RBs> when 'true' -> apply 'bif'/5 ('apply',As,Bs,Ef,RBs)
<'apply',[M|[F|[As|[]]]],Bs,Ef,RBs> when 'true' -> apply 'do_apply'/6 (M,F,As,Bs,Ef,RBs)
<'apply',[F|[As|[]]],Bs,Ef,RBs> when 'true' -> apply 'do_apply'/5 (F,As,Bs,Ef,RBs)
<Name,As,Bs,Ef,RBs> when 'true' -> apply 'do_apply'/6 ('erlang',Name,As,Bs,Ef,RBs) end
'do_apply'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Func = {M,F},As,Bs0,Ef,RBs> when try let <_5> = call 'erlang':'tuple_size' (M) in let <_6> = call 'erlang':'>=' (_5,1) in let <_7> = call 'erlang':'element' (1,M) in let <_8> = call 'erlang':'is_atom' (_7) in let <_9> = call 'erlang':'is_atom' (F) in let <_10> = call 'erlang':'and' (_8,_9) in call 'erlang':'and' (_6,_10) of <Try> -> Try catch <T,R> -> 'false' -> case Ef of <'none'> when call 'erlang':'=:=' (RBs,'value') -> call 'erlang':'apply' (M,F,As)
<'none'> when 'true' -> let <_11> = call 'erlang':'apply' (M,F,As) in apply 'ret_expr'/3 (_11,Bs0,RBs)
<{'value',Fun}> when call 'erlang':'=:=' (RBs,'value') -> apply Fun (Func,As)
<{'value',Fun}> when 'true' -> let <_12> = apply Fun (Func,As) in apply 'ret_expr'/3 (_12,Bs0,RBs)
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<Func,As,Bs0,Ef,RBs> when 'true' -> let <_17> = case <> of <> when call 'erlang':'is_function' (Func) -> let <_15> = call 'erlang':'fun_info' (Func,'module') in let <_14> = call 'erlang':'fun_info' (Func,'env') in case <_15,_14> of <({'module','erl_eval'}-|['compiler_generated'] ),((_@r0-|['compiler_generated'] ) = ({('env'-|['compiler_generated'] ),Env1}-|['compiler_generated'] )-|['compiler_generated'] )> when call 'erlang':'=/=' (Env1,[]) -> _@r0
<(_50-|['compiler_generated'] ),(_51-|['compiler_generated'] )> when 'true' -> 'no_env' end
<> when 'true' -> 'no_env' end in case <_17,Ef> of <({('env'-|['compiler_generated'] ),([({FBs,FLf,FEf,FCs}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] ),_44> when 'true' -> let <_19> = case <> of <> when call 'erlang':'=:=' (RBs,'none') -> Bs0
<> when 'true' -> RBs end in let <_22> = call 'erlang':'fun_info' (Func,'arity') in let <_21> = call 'erlang':'length' (As) in case <_22,_21> of <({('arity'-|['compiler_generated'] ),Arity}-|['compiler_generated'] ),_45> when call 'erlang':'=:=' (_45,Arity) -> apply 'eval_fun'/6 (FCs,As,FBs,FLf,FEf,_19)
<(_56-|['compiler_generated'] ),(_57-|['compiler_generated'] )> when 'true' -> let <_23> = call 'erlang':'self' () in let <_24> = call 'erlang':'process_info' (_23,'current_stacktrace') in let <_25> = call 'erlang':'element' (2,_24) in call 'erlang':'raise' ('error',{'badarity',{Func,As}},_25) end
<({('env'-|['compiler_generated'] ),([({FBs,FLf,FEf,FCs,FName}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] )}-|['compiler_generated'] ),_47> when 'true' -> let <_27> = case <> of <> when call 'erlang':'=:=' (RBs,'none') -> Bs0
<> when 'true' -> RBs end in let <_30> = call 'erlang':'fun_info' (Func,'arity') in let <_29> = call 'erlang':'length' (As) in case <_30,_29> of <({('arity'-|['compiler_generated'] ),Arity}-|['compiler_generated'] ),_48> when call 'erlang':'=:=' (_48,Arity) -> apply 'eval_named_fun'/8 (FCs,As,FBs,FLf,FEf,FName,Func,_27)
<(_60-|['compiler_generated'] ),(_61-|['compiler_generated'] )> when 'true' -> let <_31> = call 'erlang':'self' () in let <_32> = call 'erlang':'process_info' (_31,'current_stacktrace') in let <_33> = call 'erlang':'element' (2,_32) in call 'erlang':'raise' ('error',{'badarity',{Func,As}},_33) end
<'no_env','none'> when call 'erlang':'=:=' (RBs,'value') -> call 'erlang':'apply' (Func,As)
<'no_env','none'> when 'true' -> let <_35> = call 'erlang':'apply' (Func,As) in apply 'ret_expr'/3 (_35,Bs0,RBs)
<('no_env'-|['compiler_generated'] ),({('value'-|['compiler_generated'] ),F}-|['compiler_generated'] )> when call 'erlang':'=:=' (RBs,'value') -> apply F (Func,As)
<('no_env'-|['compiler_generated'] ),({('value'-|['compiler_generated'] ),F}-|['compiler_generated'] )> when 'true' -> let <_36> = apply F (Func,As) in apply 'ret_expr'/3 (_36,Bs0,RBs)
(<(_54-|['compiler_generated'] ),(_55-|['compiler_generated'] )> when 'true' -> let <_37> = {(_54-|['compiler_generated'] ),(_55-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_37})-|['compiler_generated'] ) end end
'do_apply'/6 = fun (_0,_1,_2,_3,_4,_5) -> case _4 of <'none'> when call 'erlang':'=:=' (_5,'value') -> call 'erlang':'apply' (_0,_1,_2)
<'none'> when 'true' -> let <_6> = call 'erlang':'apply' (_0,_1,_2) in apply 'ret_expr'/3 (_6,_3,_5)
<{'value',F}> when call 'erlang':'=:=' (_5,'value') -> apply F ({_0,_1},_2)
<{'value',F}> when 'true' -> let <_7> = apply F ({_0,_1},_2) in apply 'ret_expr'/3 (_7,_3,_5)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
'eval_lc'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <_6> = apply 'eval_lc1'/6 (_0,_1,_2,_3,_4,[]) in let <_7> = call 'lists':'reverse' (_6) in apply 'ret_expr'/3 (_7,_2,_5)
'eval_lc1'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <E,[{'generate',_28,P,L0}|Qs],Bs0,Lf,Ef,Acc0> when 'true' -> case apply 'expr'/5 (L0,Bs0,Lf,Ef,'none') of <{'value',L1,_X_Bs1}> when 'true' -> let <CompFun> = fun (_8,_7) -> apply 'eval_lc1'/6 (E,Qs,_8,Lf,Ef,_7) in apply 'eval_generate'/7 (L1,P,Bs0,Lf,Ef,CompFun,Acc0)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<E,[{'b_generate',_29,P,L0}|Qs],Bs0,Lf,Ef,Acc0> when 'true' -> case apply 'expr'/5 (L0,Bs0,Lf,Ef,'none') of <{'value',Bin,_X_Bs1}> when 'true' -> let <CompFun> = fun (_14,_13) -> apply 'eval_lc1'/6 (E,Qs,_14,Lf,Ef,_13) in apply 'eval_b_generate'/7 (Bin,P,Bs0,Lf,Ef,CompFun,Acc0)
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<E,[F|Qs],Bs0,Lf,Ef,Acc> when 'true' -> let <CompFun> = fun (_18) -> apply 'eval_lc1'/6 (E,Qs,_18,Lf,Ef,Acc) in apply 'eval_filter'/6 (F,Bs0,Lf,Ef,CompFun,Acc)
<E,[],Bs,Lf,Ef,Acc> when 'true' -> case apply 'expr'/5 (E,Bs,Lf,Ef,'none') of <{'value',V,_30}> when 'true' -> [V|Acc]
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
(<_27,_26,_25,_24,_23,_22> when 'true' -> (primop 'match_fail' ({'function_clause',_27,_26,_25,_24,_23,_22})-|[{'function_name',{'eval_lc1',6}}] )-|['compiler_generated'] ) end
'eval_bc'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <_6> = apply 'eval_bc1'/6 (_0,_1,_2,_3,_4,#{}#) in apply 'ret_expr'/3 (_6,_2,_5)
'eval_bc1'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <E,[{'b_generate',_28,P,L0}|Qs],Bs0,Lf,Ef,Acc0> when 'true' -> case apply 'expr'/5 (L0,Bs0,Lf,Ef,'none') of <{'value',Bin,_X_Bs1}> when 'true' -> let <CompFun> = fun (_8,_7) -> apply 'eval_bc1'/6 (E,Qs,_8,Lf,Ef,_7) in apply 'eval_b_generate'/7 (Bin,P,Bs0,Lf,Ef,CompFun,Acc0)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<E,[{'generate',_29,P,L0}|Qs],Bs0,Lf,Ef,Acc0> when 'true' -> case apply 'expr'/5 (L0,Bs0,Lf,Ef,'none') of <{'value',List,_X_Bs1}> when 'true' -> let <CompFun> = fun (_14,_13) -> apply 'eval_bc1'/6 (E,Qs,_14,Lf,Ef,_13) in apply 'eval_generate'/7 (List,P,Bs0,Lf,Ef,CompFun,Acc0)
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<E,[F|Qs],Bs0,Lf,Ef,Acc> when 'true' -> let <CompFun> = fun (_18) -> apply 'eval_bc1'/6 (E,Qs,_18,Lf,Ef,Acc) in apply 'eval_filter'/6 (F,Bs0,Lf,Ef,CompFun,Acc)
<E,[],Bs,Lf,Ef,Acc> when 'true' -> case apply 'expr'/5 (E,Bs,Lf,Ef,'none') of <{'value',V,_30}> when 'true' -> #{#<Acc>('all',1,'binary',['unsigned'|['big']]),#<V>('all',1,'binary',['unsigned'|['big']])}#
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
(<_27,_26,_25,_24,_23,_22> when 'true' -> (primop 'match_fail' ({'function_clause',_27,_26,_25,_24,_23,_22})-|[{'function_name',{'eval_bc1',6}}] )-|['compiler_generated'] ) end
'eval_generate'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[V|Rest],P,Bs0,Lf,Ef,CompFun,Acc> when 'true' -> let <_7> = apply 'new_bindings'/0 () in case apply 'match'/4 (P,V,_7,Bs0) of <{'match',Bsn}> when 'true' -> let <Bs2> = apply 'add_bindings'/2 (Bsn,Bs0) in let <NewAcc> = apply CompFun (Bs2,Acc) in apply 'eval_generate'/7 (Rest,P,Bs0,Lf,Ef,CompFun,NewAcc)
<'nomatch'> when 'true' -> apply 'eval_generate'/7 (Rest,P,Bs0,Lf,Ef,CompFun,Acc)
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<[],_X_P,_X_Bs0,_X_Lf,_X_Ef,_X_CompFun,Acc> when 'true' -> Acc
<Term,_X_P,_X_Bs0,_X_Lf,_X_Ef,_X_CompFun,_X_Acc> when 'true' -> let <_11> = call 'erlang':'self' () in let <_12> = call 'erlang':'process_info' (_11,'current_stacktrace') in let <_13> = call 'erlang':'element' (2,_12) in call 'erlang':'raise' ('error',{'bad_generator',Term},_13) end
'eval_b_generate'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <Bin = #{#<_27>('all',1,'binary',['unsigned'|['big']])}#,P,Bs0,Lf,Ef,CompFun,Acc> when 'true' -> let <Mfun> = apply 'match_fun'/1 (Bs0) in let <Efun> = fun (_9,_8) -> apply 'expr'/5 (_9,_8,Lf,Ef,'none') in let <_13> = apply 'new_bindings'/0 () in case call 'eval_bits':'bin_gen' (P,Bin,_13,Bs0,Mfun,Efun) of <{'match',Rest,Bs1}> when 'true' -> let <Bs2> = apply 'add_bindings'/2 (Bs1,Bs0) in let <NewAcc> = apply CompFun (Bs2,Acc) in apply 'eval_b_generate'/7 (Rest,P,Bs0,Lf,Ef,CompFun,NewAcc)
<{'nomatch',Rest}> when 'true' -> apply 'eval_b_generate'/7 (Rest,P,Bs0,Lf,Ef,CompFun,Acc)
<'done'> when 'true' -> Acc
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end
<Term,_X_P,_X_Bs0,_X_Lf,_X_Ef,_X_CompFun,_X_Acc> when 'true' -> let <_17> = call 'erlang':'self' () in let <_18> = call 'erlang':'process_info' (_17,'current_stacktrace') in let <_19> = call 'erlang':'element' (2,_18) in call 'erlang':'raise' ('error',{'bad_generator',Term},_19) end
'eval_filter'/6 = fun (_0,_1,_2,_3,_4,_5) -> case call 'erl_lint':'is_guard_test' (_0) of <'true'> when 'true' -> case apply 'guard_test'/4 (_0,_1,_2,_3) of <{'value','true',Bs1}> when 'true' -> apply _4 (Bs1)
<{'value','false',_18}> when 'true' -> _5
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<'false'> when 'true' -> case apply 'expr'/5 (_0,_1,_2,_3,'none') of <{'value','true',Bs1}> when 'true' -> apply _4 (Bs1)
<{'value','false',_19}> when 'true' -> _5
<{'value',V,_20}> when 'true' -> let <_7> = call 'erlang':'self' () in let <_8> = call 'erlang':'process_info' (_7,'current_stacktrace') in let <_9> = call 'erlang':'element' (2,_8) in call 'erlang':'raise' ('error',{'bad_filter',V},_9)
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
'eval_map_fields'/4 = fun (_0,_1,_2,_3) -> apply 'eval_map_fields'/5 (_0,_1,_2,_3,[])
'eval_map_fields'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{'map_field_assoc',_15,K0,V0}|Fs],Bs0,Lf,Ef,Acc> when 'true' -> case apply 'expr'/5 (K0,Bs0,Lf,Ef,'none') of <{'value',K1,Bs1}> when 'true' -> case apply 'expr'/5 (V0,Bs1,Lf,Ef,'none') of <{'value',V1,Bs2}> when 'true' -> apply 'eval_map_fields'/5 (Fs,Bs2,Lf,Ef,[{'map_assoc',K1,V1}|Acc])
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<[{'map_field_exact',_16,K0,V0}|Fs],Bs0,Lf,Ef,Acc> when 'true' -> case apply 'expr'/5 (K0,Bs0,Lf,Ef,'none') of <{'value',K1,Bs1}> when 'true' -> case apply 'expr'/5 (V0,Bs1,Lf,Ef,'none') of <{'value',V1,Bs2}> when 'true' -> apply 'eval_map_fields'/5 (Fs,Bs2,Lf,Ef,[{'map_exact',K1,V1}|Acc])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<[],Bs,_X_Lf,_X_Ef,Acc> when 'true' -> let <_9> = call 'lists':'reverse' (Acc) in {_9,Bs}
(<_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11,_10})-|[{'function_name',{'eval_map_fields',5}}] )-|['compiler_generated'] ) end
'ret_expr'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <V,_X_Bs,'value'> when 'true' -> V
<V,Bs,'none'> when 'true' -> {'value',V,Bs}
<V,_X_Bs,RBs> when call 'erlang':'is_list' (RBs) -> {'value',V,RBs}
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'ret_expr',3}}] )-|['compiler_generated'] ) end
'eval_fun'/2 = fun (_0,_1) -> case <_0,_1> of <As,{Bs0,Lf,Ef,Cs}> when 'true' -> apply 'eval_fun'/6 (Cs,As,Bs0,Lf,Ef,'value')
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'eval_fun',2}}] )-|['compiler_generated'] ) end
'eval_fun'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[{'clause',_19,H,G,B}|Cs],As,Bs0,Lf,Ef,RBs> when 'true' -> let <_6> = apply 'new_bindings'/0 () in case apply 'match_list'/4 (H,As,_6,Bs0) of <{'match',Bsn}> when 'true' -> let <Bs1> = apply 'add_bindings'/2 (Bsn,Bs0) in case apply 'guard'/4 (G,Bs1,Lf,Ef) of <'true'> when 'true' -> apply 'exprs'/5 (B,Bs1,Lf,Ef,RBs)
<'false'> when 'true' -> apply 'eval_fun'/6 (Cs,As,Bs0,Lf,Ef,RBs)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<'nomatch'> when 'true' -> apply 'eval_fun'/6 (Cs,As,Bs0,Lf,Ef,RBs)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<[],As,_X_Bs,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_10> = call 'erlang':'self' () in let <_11> = call 'erlang':'process_info' (_10,'current_stacktrace') in let <_12> = call 'erlang':'element' (2,_11) in call 'erlang':'raise' ('error','function_clause',[{'erl_eval','-inside-an-interpreted-fun-',As}|_12])
(<_18,_17,_16,_15,_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17,_16,_15,_14,_13})-|[{'function_name',{'eval_fun',6}}] )-|['compiler_generated'] ) end
'eval_named_fun'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <As,Fun,{Bs0,Lf,Ef,Cs,Name}> when 'true' -> apply 'eval_named_fun'/8 (Cs,As,Bs0,Lf,Ef,Name,Fun,'value')
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'eval_named_fun',3}}] )-|['compiler_generated'] ) end
'eval_named_fun'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case <_0,_1,_2,_3,_4,_5,_6,_7> of <[{'clause',_24,H,G,B}|Cs],As,Bs0,Lf,Ef,Name,Fun,RBs> when 'true' -> let <Bs1> = apply 'add_binding'/3 (Name,Fun,Bs0) in let <_9> = apply 'new_bindings'/0 () in case apply 'match_list'/4 (H,As,_9,Bs1) of <{'match',Bsn}> when 'true' -> let <Bs2> = apply 'add_bindings'/2 (Bsn,Bs1) in case apply 'guard'/4 (G,Bs2,Lf,Ef) of <'true'> when 'true' -> apply 'exprs'/5 (B,Bs2,Lf,Ef,RBs)
<'false'> when 'true' -> apply 'eval_named_fun'/8 (Cs,As,Bs0,Lf,Ef,Name,Fun,RBs)
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
<'nomatch'> when 'true' -> apply 'eval_named_fun'/8 (Cs,As,Bs0,Lf,Ef,Name,Fun,RBs)
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
<[],As,_X_Bs,_X_Lf,_X_Ef,_X_Name,_X_Fun,_X_RBs> when 'true' -> let <_13> = call 'erlang':'self' () in let <_14> = call 'erlang':'process_info' (_13,'current_stacktrace') in let <_15> = call 'erlang':'element' (2,_14) in call 'erlang':'raise' ('error','function_clause',[{'erl_eval','-inside-an-interpreted-fun-',As}|_15])
(<_23,_22,_21,_20,_19,_18,_17,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21,_20,_19,_18,_17,_16})-|[{'function_name',{'eval_named_fun',8}}] )-|['compiler_generated'] ) end
'expr_list'/2 = fun (_0,_1) -> apply 'expr_list'/4 (_0,_1,'none','none')
'expr_list'/3 = fun (_0,_1,_2) -> apply 'expr_list'/4 (_0,_1,_2,'none')
'expr_list'/4 = fun (_0,_1,_2,_3) -> apply 'expr_list'/6 (_0,[],_1,_1,_2,_3)
'expr_list'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[E|Es],Vs,BsOrig,Bs0,Lf,Ef> when 'true' -> case apply 'expr'/5 (E,BsOrig,Lf,Ef,'none') of <{'value',V,Bs1}> when 'true' -> let <_7> = apply 'merge_bindings'/2 (Bs1,Bs0) in apply 'expr_list'/6 (Es,[V|Vs],BsOrig,_7,Lf,Ef)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<[],Vs,_15,Bs,_X_Lf,_X_Ef> when 'true' -> let <_8> = call 'lists':'reverse' (Vs) in {_8,Bs}
(<_14,_13,_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11,_10,_9})-|[{'function_name',{'expr_list',6}}] )-|['compiler_generated'] ) end
'eval_op'/6 = fun (_0,_1,_2,_3,_4,_5) -> apply 'do_apply'/6 ('erlang',_0,[_1|[_2|[]]],_3,_4,_5)
'eval_op'/5 = fun (_0,_1,_2,_3,_4) -> apply 'do_apply'/6 ('erlang',_0,[_1|[]],_2,_3,_4)
'if_clauses'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{'clause',_14,[],G,B}|Cs],Bs,Lf,Ef,RBs> when 'true' -> case apply 'guard'/4 (G,Bs,Lf,Ef) of <'true'> when 'true' -> apply 'exprs'/5 (B,Bs,Lf,Ef,RBs)
<'false'> when 'true' -> apply 'if_clauses'/5 (Cs,Bs,Lf,Ef,RBs)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<[],_X_Bs,_X_Lf,_X_Ef,_X_RBs> when 'true' -> let <_6> = call 'erlang':'self' () in let <_7> = call 'erlang':'process_info' (_6,'current_stacktrace') in let <_8> = call 'erlang':'element' (2,_7) in call 'erlang':'raise' ('error','if_clause',_8)
(<_13,_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10,_9})-|[{'function_name',{'if_clauses',5}}] )-|['compiler_generated'] ) end
'try_clauses'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> do apply 'check_stacktrace_vars'/2 (_2,_4) letrec 'after$^0'/0 = fun () -> case <> of <> when call 'erlang':'=:=' (_3,[]) -> _4
<> when 'true' -> apply 'exprs'/5 (_3,_4,_5,_6,'none') end in try try apply 'exprs'/5 (_0,_4,_5,_6,'none') of <_8> -> case _8 of <{'value',V,Bs1}> when call 'erlang':'=:=' (_1,[]) -> apply 'ret_expr'/3 (V,Bs1,_7)
<{'value',V,Bs1}> when 'true' -> case apply 'match_clause'/5 (_1,[V|[]],Bs1,_5,_6) of <{B2,Bs2}> when 'true' -> apply 'exprs'/5 (B2,Bs2,_5,_6,_7)
<'nomatch'> when 'true' -> let <_9> = call 'erlang':'self' () in let <_10> = call 'erlang':'process_info' (_9,'current_stacktrace') in let <_11> = call 'erlang':'element' (2,_10) in call 'erlang':'raise' ('error',{'try_clause',V},_11)
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'try_clause',_13})-|['compiler_generated'] ) end catch <_16,_15,_14> -> case <_16,_15,_14> of <Class,Reason,_31> when call 'erlang':'=:=' (_2,[]) -> primop 'raw_raise' (Class,Reason,_31)
<Class,Reason,_32> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_32) in let <V> = {Class,Reason,Stacktrace} in case apply 'match_clause'/5 (_2,[V|[]],_4,_5,_6) of <{B2,Bs2}> when 'true' -> apply 'exprs'/5 (B2,Bs2,_5,_6,_7)
<'nomatch'> when 'true' -> call 'erlang':'raise' (Class,Reason,Stacktrace)
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end end of <_19> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) _19 catch <_22,_21,_20> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) primop 'raise' (_20,_21)
'check_stacktrace_vars'/2 = fun (_0,_1) -> case <_0,_1> of <[{'clause',_12,[{'tuple',_13,[_14|[_15|[STV|[]]]]}|[]],_16,_17}|Cs],Bs> when 'true' -> case STV of <{'var',_18,V}> when 'true' -> case apply 'binding'/2 (V,Bs) of <{'value',_19}> when 'true' -> let <_2> = call 'erlang':'self' () in let <_3> = call 'erlang':'process_info' (_2,'current_stacktrace') in let <_4> = call 'erlang':'element' (2,_3) in call 'erlang':'raise' ('error','stacktrace_bound',_4)
<'unbound'> when 'true' -> apply 'check_stacktrace_vars'/2 (Cs,Bs)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<_20> when 'true' -> let <_6> = call 'erlang':'self' () in let <_7> = call 'erlang':'process_info' (_6,'current_stacktrace') in let <_8> = call 'erlang':'element' (2,_7) in call 'erlang':'raise' ('error',{'illegal_stacktrace_variable',STV},_8) end
<[],_X_Bs> when 'true' -> 'ok'
(<_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10})-|[{'function_name',{'check_stacktrace_vars',2}}] )-|['compiler_generated'] ) end
'case_clauses'/6 = fun (_0,_1,_2,_3,_4,_5) -> case apply 'match_clause'/5 (_1,[_0|[]],_2,_3,_4) of <{B,Bs1}> when 'true' -> apply 'exprs'/5 (B,Bs1,_3,_4,_5)
<'nomatch'> when 'true' -> let <_6> = call 'erlang':'self' () in let <_7> = call 'erlang':'process_info' (_6,'current_stacktrace') in let <_8> = call 'erlang':'element' (2,_7) in call 'erlang':'raise' ('error',{'case_clause',_0},_8)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
'receive_clauses'/5 = fun (_0,_1,_2,_3,_4) -> apply 'receive_clauses'/7 ('infinity',_0,'unused',_1,_2,_3,_4)
'receive_clauses'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <F> = fun (_7) -> apply 'match_clause'/5 (_1,[_7|[]],_3,_4,_5) in case call 'prim_eval':'receive' (F,_0) of <{B,Bs1}> when 'true' -> apply 'exprs'/5 (B,Bs1,_4,_5,_6)
<'timeout'> when 'true' -> case _2 of <{B,Bs1}> when 'true' -> apply 'exprs'/5 (B,Bs1,_4,_5,_6)
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
'match_clause'/4 = fun (_0,_1,_2,_3) -> apply 'match_clause'/5 (_0,_1,_2,_3,'none')
'match_clause'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{'clause',_12,H,G,B}|Cs],Vals,Bs,Lf,Ef> when 'true' -> case apply 'match_list'/3 (H,Vals,Bs) of <{'match',Bs1}> when 'true' -> case apply 'guard'/4 (G,Bs1,Lf,Ef) of <'true'> when 'true' -> {B,Bs1}
<'false'> when 'true' -> apply 'match_clause'/5 (Cs,Vals,Bs,Lf,Ef)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<'nomatch'> when 'true' -> apply 'match_clause'/5 (Cs,Vals,Bs,Lf,Ef)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<[],_X_Vals,_X_Bs,_X_Lf,_X_Ef> when 'true' -> 'nomatch'
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'match_clause',5}}] )-|['compiler_generated'] ) end
'guard'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <L = [G|_8],Bs0,Lf,Ef> when call 'erlang':'is_list' (G) -> apply 'guard1'/4 (L,Bs0,Lf,Ef)
<L,Bs0,Lf,Ef> when 'true' -> apply 'guard0'/4 (L,Bs0,Lf,Ef) end
'guard1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[G|Gs],Bs0,Lf,Ef> when call 'erlang':'is_list' (G) -> case apply 'guard0'/4 (G,Bs0,Lf,Ef) of <'true'> when 'true' -> 'true'
<'false'> when 'true' -> apply 'guard1'/4 (Gs,Bs0,Lf,Ef)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[],_X_Bs,_X_Lf,_X_Ef> when 'true' -> 'false'
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'guard1',4}}] )-|['compiler_generated'] ) end
'guard0'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[G|Gs],Bs0,Lf,Ef> when 'true' -> case call 'erl_lint':'is_guard_test' (G) of <'true'> when 'true' -> case apply 'guard_test'/4 (G,Bs0,Lf,Ef) of <{'value','true',Bs}> when 'true' -> apply 'guard0'/4 (Gs,Bs,Lf,Ef)
<{'value','false',_13}> when 'true' -> 'false'
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_5> = call 'erlang':'self' () in let <_6> = call 'erlang':'process_info' (_5,'current_stacktrace') in let <_7> = call 'erlang':'element' (2,_6) in call 'erlang':'raise' ('error','guard_expr',_7)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<[],_X_Bs,_X_Lf,_X_Ef> when 'true' -> 'true'
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'guard0',4}}] )-|['compiler_generated'] ) end
'guard_test'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <{'call',L,{'atom',Ln,F},As0},Bs0,Lf,Ef> when 'true' -> let <TT> = apply 'type_test'/1 (F) in let <G> = {'call',L,{'atom',Ln,TT},As0} in apply 'expr_guard_test'/4 (G,Bs0,Lf,Ef)
<{'call',L,{'remote',Lr,_@r0 = {'atom',Lm,'erlang'},{'atom',Lf,F}},As0},Bs0,_12,Ef> when call 'erlang':'=:=' (_12,Lf) -> let <TT> = apply 'type_test'/1 (F) in let <G> = {'call',L,{'remote',Lr,_@r0,{'atom',Lf,TT}},As0} in apply 'expr_guard_test'/4 (G,Bs0,Lf,Ef)
<G,Bs0,Lf,Ef> when 'true' -> apply 'expr_guard_test'/4 (G,Bs0,Lf,Ef) end
'expr_guard_test'/4 = fun (_0,_1,_2,_3) -> try let <_13> = apply 'expr'/5 (_0,_1,_2,_3,'none') in case _13 of <{'value','true',_14}> when 'true' -> (_13-|['compiler_generated'] )
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end of <_5> -> _5 catch <_8,_7,_6> -> case <_8,_7,_6> of <('error'-|['compiler_generated'] ),_15,_16> when 'true' -> {'value','false',_1}
(<_17,_18,_19> when 'true' -> primop 'raise' (_19,_18)-|['compiler_generated'] ) end
'type_test'/1 = fun (_0) -> case _0 of <'integer'> when 'true' -> 'is_integer'
<'float'> when 'true' -> 'is_float'
<'number'> when 'true' -> 'is_number'
<'atom'> when 'true' -> 'is_atom'
<'list'> when 'true' -> 'is_list'
<'tuple'> when 'true' -> 'is_tuple'
<'pid'> when 'true' -> 'is_pid'
<'reference'> when 'true' -> 'is_reference'
<'port'> when 'true' -> 'is_port'
<'function'> when 'true' -> 'is_function'
<'binary'> when 'true' -> 'is_binary'
<'record'> when 'true' -> 'is_record'
<'map'> when 'true' -> 'is_map'
<Test> when 'true' -> Test end
'match'/3 = fun (_0,_1,_2) -> apply 'match'/4 (_0,_1,_2,_2)
'match'/4 = fun (_0,_1,_2,_3) -> let <_4> = catch apply 'match1'/4 (_0,_1,_2,_3) in case _4 of <'invalid'> when 'true' -> let <_8> = apply 'to_term'/1 (_0) in let <_5> = call 'erlang':'self' () in let <_6> = call 'erlang':'process_info' (_5,'current_stacktrace') in let <_7> = call 'erlang':'element' (2,_6) in call 'erlang':'raise' ('error',{'illegal_pattern',_8},_7)
<Other> when 'true' -> Other end
'string_to_conses'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],_7,Tail> when 'true' -> Tail
<[E|Rest],Line,Tail> when 'true' -> let <_3> = apply 'string_to_conses'/3 (Rest,Line,Tail) in {'cons',Line,{'integer',Line,E},_3}
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'string_to_conses',3}}] )-|['compiler_generated'] ) end
'match1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <{'atom',_34,A0},A,Bs,_X_BBs> when 'true' -> case A of <_35> when call 'erlang':'=:=' (A,A0) -> {'match',Bs}
<_36> when 'true' -> call 'erlang':'throw' ('nomatch') end
<{'integer',_37,I0},I,Bs,_X_BBs> when 'true' -> case I of <_38> when call 'erlang':'=:=' (I,I0) -> {'match',Bs}
<_39> when 'true' -> call 'erlang':'throw' ('nomatch') end
<{'float',_40,F0},F,Bs,_X_BBs> when 'true' -> case F of <_41> when call 'erlang':'=:=' (F,F0) -> {'match',Bs}
<_42> when 'true' -> call 'erlang':'throw' ('nomatch') end
<{'char',_43,C0},C,Bs,_X_BBs> when 'true' -> case C of <_44> when call 'erlang':'=:=' (C,C0) -> {'match',Bs}
<_45> when 'true' -> call 'erlang':'throw' ('nomatch') end
<{'var',_46,'_'},_47,Bs,_X_BBs> when 'true' -> {'match',Bs}
<{'var',_48,Name},Term,Bs,_X_BBs> when 'true' -> case apply 'binding'/2 (Name,Bs) of <{'value',_49}> when call 'erlang':'=:=' (_49,Term) -> {'match',Bs}
<{'value',_50}> when 'true' -> call 'erlang':'throw' ('nomatch')
<'unbound'> when 'true' -> let <_8> = apply 'add_binding'/3 (Name,Term,Bs) in {'match',_8}
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<{'match',_51,Pat1,Pat2},Term,Bs0,BBs> when 'true' -> case apply 'match1'/4 (Pat1,Term,Bs0,BBs) of <{'match',Bs1}> when 'true' -> apply 'match1'/4 (Pat2,Term,Bs1,BBs)
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<{'string',_52,S0},S,Bs,_X_BBs> when 'true' -> case S of <_53> when call 'erlang':'=:=' (S,S0) -> {'match',Bs}
<_54> when 'true' -> call 'erlang':'throw' ('nomatch') end
<{'nil',_55},Nil,Bs,_X_BBs> when 'true' -> case Nil of <[]> when 'true' -> {'match',Bs}
<_56> when 'true' -> call 'erlang':'throw' ('nomatch') end
<{'cons',_57,H,T},[H1|T1],Bs0,BBs> when 'true' -> case apply 'match1'/4 (H,H1,Bs0,BBs) of <{'match',Bs}> when 'true' -> apply 'match1'/4 (T,T1,Bs,BBs)
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
<{'cons',_58,_59,_60},_61,_X_Bs,_X_BBs> when 'true' -> call 'erlang':'throw' ('nomatch')
<{'tuple',_62,Elts},Tuple,Bs,BBs> when try let <_15> = call 'erlang':'length' (Elts) in let <_14> = call 'erlang':'tuple_size' (Tuple) in call 'erlang':'=:=' (_15,_14) of <Try> -> Try catch <T,R> -> 'false' -> apply 'match_tuple'/5 (Elts,Tuple,1,Bs,BBs)
<{'tuple',_63,_64},_65,_X_Bs,_X_BBs> when 'true' -> call 'erlang':'throw' ('nomatch')
<{'map',_66,Fs},Map = ~{}~,Bs,BBs> when 'true' -> apply 'match_map'/4 (Fs,Map,Bs,BBs)
<{'map',_67,_68},_69,_X_Bs,_X_BBs> when 'true' -> call 'erlang':'throw' ('nomatch')
<{'bin',_70,Fs},B = #{#<_71>('all',1,'binary',['unsigned'|['big']])}#,Bs0,BBs> when 'true' -> let <EvalFun> = fun (_22,_21) -> do case call 'erl_lint':'is_guard_expr' (_22) of <'true'> when 'true' -> 'ok'
<'false'> when 'true' -> call 'erlang':'throw' ('invalid')
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end try apply 'expr'/5 (_22,_21,'none','none','none') of <_17> -> _17 catch <_20,_19,_18> -> case <_20,_19,_18> of <('error'-|['compiler_generated'] ),({('unbound'-|['compiler_generated'] ),_72}-|['compiler_generated'] ),_73> when 'true' -> call 'erlang':'throw' ('invalid')
(<_101,_102,_103> when 'true' -> primop 'raise' (_103,_102)-|['compiler_generated'] ) end in let <_26> = apply 'match_fun'/1 (BBs) in call 'eval_bits':'match_bits' (Fs,B,Bs0,BBs,_26,EvalFun)
<{'bin',_74,_75},_76,_X_Bs,_X_BBs> when 'true' -> call 'erlang':'throw' ('nomatch')
<{'op',_77,'++',{'nil',_78},R},Term,Bs,BBs> when 'true' -> apply 'match1'/4 (R,Term,Bs,BBs)
<{'op',_79,'++',{'cons',Li,_@r0 = {'integer',L2,I},T},R},Term,Bs,BBs> when 'true' -> apply 'match1'/4 ({'cons',Li,_@r0,{'op',Li,'++',T,R}},Term,Bs,BBs)
<{'op',_80,'++',{'cons',Li,_@r1 = {'char',L2,C},T},R},Term,Bs,BBs> when 'true' -> apply 'match1'/4 ({'cons',Li,_@r1,{'op',Li,'++',T,R}},Term,Bs,BBs)
<{'op',_81,'++',{'string',Li,L},R},Term,Bs,BBs> when 'true' -> let <_27> = apply 'string_to_conses'/3 (L,Li,R) in apply 'match1'/4 (_27,Term,Bs,BBs)
<_@r2 = {'op',Line,Op,A},Term,Bs,BBs> when 'true' -> case apply 'partial_eval'/1 (_@r2) of <{'op',_82,_83,_84}> when let <_87> = call 'erlang':'=:=' (_82,Line) in let <_85> = call 'erlang':'=:=' (_83,Op) in let <_86> = call 'erlang':'=:=' (_84,A) in let <_88> = call 'erlang':'and' (_85,_86) in call 'erlang':'and' (_87,_88) -> call 'erlang':'throw' ('invalid')
<X> when 'true' -> apply 'match1'/4 (X,Term,Bs,BBs) end
<_@r3 = {'op',Line,Op,L,R},Term,Bs,BBs> when 'true' -> case apply 'partial_eval'/1 (_@r3) of <{'op',_89,_90,_91,_92}> when let <_97> = call 'erlang':'=:=' (_89,Line) in let <_95> = call 'erlang':'=:=' (_90,Op) in let <_93> = call 'erlang':'=:=' (_91,L) in let <_94> = call 'erlang':'=:=' (_92,R) in let <_96> = call 'erlang':'and' (_93,_94) in let <_98> = call 'erlang':'and' (_95,_96) in call 'erlang':'and' (_97,_98) -> call 'erlang':'throw' ('invalid')
<X> when 'true' -> apply 'match1'/4 (X,Term,Bs,BBs) end
<_99,_100,_X_Bs,_X_BBs> when 'true' -> call 'erlang':'throw' ('invalid') end
'match_fun'/1 = fun (_0) -> (fun (_2,_1) -> case <_2,_1> of <'match',{L,R,Bs}> when 'true' -> apply 'match1'/4 (L,R,Bs,_0)
<'binding',{Name,Bs}> when 'true' -> apply 'binding'/2 (Name,Bs)
<'add_binding',{Name,Val,Bs}> when 'true' -> apply 'add_binding'/3 (Name,Val,Bs)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'-match_fun/1-fun-0-',2}}] )-|['compiler_generated'] ) end-|[{'id',{0,0,'-match_fun/1-fun-0-'}}] )
'match_tuple'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[E|Es],Tuple,I,Bs0,BBs> when 'true' -> let <_5> = call 'erlang':'element' (I,Tuple) in case apply 'match1'/4 (E,_5,Bs0,BBs) of <{'match',Bs}> when 'true' -> let <_7> = call 'erlang':'+' (I,1) in apply 'match_tuple'/5 (Es,Tuple,_7,Bs,BBs)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<[],_13,_14,Bs,_X_BBs> when 'true' -> {'match',Bs}
(<_12,_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9,_8})-|[{'function_name',{'match_tuple',5}}] )-|['compiler_generated'] ) end
'match_map'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{'map_field_exact',_16,K,V}|Fs],Map,Bs0,BBs> when 'true' -> let <_9> = try case apply 'expr'/2 (K,BBs) of <{'value',Ke,_17}> when 'true' -> call 'maps':'get' (Ke,Map)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end of <_5> -> _5 catch <_8,_7,_6> -> case <_8,_7,_6> of <('error'-|['compiler_generated'] ),_18,_19> when 'true' -> call 'erlang':'throw' ('nomatch')
(<_22,_23,_24> when 'true' -> primop 'raise' (_24,_23)-|['compiler_generated'] ) end in case apply 'match1'/4 (V,_9,Bs0,BBs) of <{'match',Bs}> when 'true' -> apply 'match_map'/4 (Fs,Map,Bs,BBs)
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
<[],_20,Bs,_21> when 'true' -> {'match',Bs}
(<_15,_14,_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12})-|[{'function_name',{'match_map',4}}] )-|['compiler_generated'] ) end
'match_list'/3 = fun (_0,_1,_2) -> apply 'match_list'/4 (_0,_1,_2,_2)
'match_list'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[P|Ps],[T|Ts],Bs0,BBs> when 'true' -> case apply 'match'/4 (P,T,Bs0,BBs) of <{'match',Bs1}> when 'true' -> apply 'match_list'/4 (Ps,Ts,Bs1,BBs)
<'nomatch'> when 'true' -> 'nomatch'
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
<[],[],Bs,_X_BBs> when 'true' -> {'match',Bs}
<_9,_10,_X_Bs,_X_BBs> when 'true' -> 'nomatch' end
'new_bindings'/0 = fun () -> call 'orddict':'new' ()
'bindings'/1 = fun (_0) -> call 'orddict':'to_list' (_0)
'binding'/2 = fun (_0,_1) -> case call 'orddict':'find' (_0,_1) of <{'ok',Val}> when 'true' -> {'value',Val}
<'error'> when 'true' -> 'unbound'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'add_binding'/3 = fun (_0,_1,_2) -> call 'orddict':'store' (_0,_1,_2)
'del_binding'/2 = fun (_0,_1) -> call 'orddict':'erase' (_0,_1)
'add_bindings'/2 = fun (_0,_1) -> let <_7> = fun (_4,_3) -> case <_4,_3> of <{Name,Val},Bs> when 'true' -> call 'orddict':'store' (Name,Val,Bs)
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'-add_bindings/2-fun-0-',2}}] )-|['compiler_generated'] ) end in let <_2> = call 'orddict':'to_list' (_0) in call 'lists':'foldl' (_7,_1,_2)
'merge_bindings'/2 = fun (_0,_1) -> let <_11> = fun (_8,_7) -> case <_8,_7> of <{Name,Val},Bs> when 'true' -> case call 'orddict':'find' (Name,Bs) of <{'ok',_14}> when call 'erlang':'=:=' (_14,Val) -> Bs
<{'ok',V1}> when 'true' -> let <_3> = call 'erlang':'self' () in let <_4> = call 'erlang':'process_info' (_3,'current_stacktrace') in let <_5> = call 'erlang':'element' (2,_4) in call 'erlang':'raise' ('error',{'badmatch',V1},_5)
<'error'> when 'true' -> call 'orddict':'store' (Name,Val,Bs)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
(<_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9})-|[{'function_name',{'-merge_bindings/2-fun-0-',2}}] )-|['compiler_generated'] ) end in let <_2> = call 'orddict':'to_list' (_0) in call 'lists':'foldl' (_11,_1,_2)
'to_terms'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[Abstr|_2]> when 'true' -> let <_4> = apply 'to_term'/1 (Abstr) in let <_5> = apply 'lc$^0'/1 (_2) in ([_4|_5]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'to_term'/1 = fun (_0) -> call 'erl_parse':'anno_to_term' (_0)
'subst_values_for_vars'/2 = fun (_0,_1) -> case <_0,_1> of <Var = {'var',A,V},Bs> when 'true' -> case call 'erl_eval':'binding' (V,Bs) of <{'value',Value}> when 'true' -> {'value',A,Value}
<'unbound'> when 'true' -> Var
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<L,Bs> when call 'erlang':'is_list' (L) -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[E|_4]> when 'true' -> let <_6> = apply 'subst_values_for_vars'/2 (E,Bs) in let <_7> = apply 'lc$^0'/1 (_4) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (L)-|['list_comprehension'] )
<T,Bs> when call 'erlang':'is_tuple' (T) -> let <_8> = call 'erlang':'tuple_to_list' (T) in let <_9> = apply 'subst_values_for_vars'/2 (_8,Bs) in call 'erlang':'list_to_tuple' (_9)
<T,_X_Bs> when 'true' -> T end
'extended_parse_exprs'/1 = fun (_0) -> let <Ts> = apply 'tokens_fixup'/1 (_0) in case call 'erl_parse':'parse_exprs' (Ts) of <{'ok',Exprs0}> when 'true' -> case apply 'expr_fixup'/1 (Exprs0) of <{Exprs,Bs}> when 'true' -> let <_3> = apply 'reset_expr_anno'/1 (Exprs) in {'ok',_3,Bs}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<_X_ErrorInfo> when 'true' -> let <_4> = apply 'reset_token_anno'/1 (Ts) in call 'erl_parse':'parse_exprs' (_4) end
'tokens_fixup'/1 = fun (_0) -> case _0 of <[]> when 'true' -> []
<Ts0 = [T|Ts]> when 'true' -> try apply 'token_fixup'/1 (Ts0) of <_1> -> case _1 of <{NewT,NewTs}> when 'true' -> let <_2> = apply 'tokens_fixup'/1 (NewTs) in [NewT|_2]
(<_3> when 'true' -> primop 'match_fail' ({'try_clause',_3})-|['compiler_generated'] ) end catch <_6,_5,_4> -> let <_7> = apply 'tokens_fixup'/1 (Ts) in [T|_7]
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'tokens_fixup',1}}] )-|['compiler_generated'] ) end
'token_fixup'/1 = fun (_0) -> case apply 'unscannable'/1 (_0) of <{AnnoL,NewTs,FixupTag}> when 'true' -> let <_7> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[A|_3]> when 'true' -> let <_5> = call 'erl_anno':'text' (A) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (AnnoL) in let <String> = call 'lists':'append' (_7) in let <_9> = apply 'fixup_fun'/1 (FixupTag) in do apply _9 (String) let <_12> = apply 'fixup_text'/1 (FixupTag) in let <_11> = call 'erlang':'hd' (AnnoL) in let <NewAnno> = call 'erl_anno':'set_text' (_12,_11) in {{'string',NewAnno,String},NewTs}
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'unscannable'/1 = fun (_0) -> case _0 of <[{'#',A1}|[{'var',A2,'Fun'}|[{'<',A3}|[{'atom',A4,_2}|[{'.',A5}|[{'float',A6,_3}|[{'>',A7}|Ts]]]]]]]> when 'true' -> {[A1|[A2|[A3|[A4|[A5|[A6|[A7|[]]]]]]]],Ts,'function'}
<[{'#',A1}|[{'var',A2,'Fun'}|[{'<',A3}|[{'atom',A4,_4}|[{'.',A5}|[{'atom',A6,_5}|[{'.',A7}|[{'integer',A8,_6}|[{'>',A9}|Ts]]]]]]]]]> when 'true' -> {[A1|[A2|[A3|[A4|[A5|[A6|[A7|[A8|[A9|[]]]]]]]]]],Ts,'function'}
<[{'<',A1}|[{'float',A2,_7}|[{'.',A3}|[{'integer',A4,_8}|[{'>',A5}|Ts]]]]]> when 'true' -> {[A1|[A2|[A3|[A4|[A5|[]]]]]],Ts,'pid'}
<[{'#',A1}|[{'var',A2,'Port'}|[{'<',A3}|[{'float',A4,_9}|[{'>',A5}|Ts]]]]]> when 'true' -> {[A1|[A2|[A3|[A4|[A5|[]]]]]],Ts,'port'}
<[{'#',A1}|[{'var',A2,'Ref'}|[{'<',A3}|[{'float',A4,_10}|[{'.',A5}|[{'float',A6,_11}|[{'>',A7}|Ts]]]]]]]> when 'true' -> {[A1|[A2|[A3|[A4|[A5|[A6|[A7|[]]]]]]]],Ts,'reference'}
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'unscannable',1}}] )-|['compiler_generated'] ) end
'expr_fixup'/1 = fun (_0) -> let <_1> = call 'erl_eval':'new_bindings' () in case apply 'expr_fixup'/3 (_0,_1,1) of <{Expr,Bs,_4}> when 'true' -> {Expr,Bs}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'expr_fixup'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <T = {'string',A,S},Bs0,I> when 'true' -> try apply 'string_fixup'/2 (A,S) of <_3> -> let <Var> = apply 'new_var'/1 (I) in let <Bs> = call 'erl_eval':'add_binding' (Var,_3,Bs0) in let <_6> = call 'erlang':'+' (I,1) in {{'var',A,Var},Bs,_6} catch <_10,_9,_8> -> {T,Bs0,I}
<Tuple,Bs0,I0> when call 'erlang':'is_tuple' (Tuple) -> let <_11> = call 'erlang':'tuple_to_list' (Tuple) in case apply 'expr_fixup'/3 (_11,Bs0,I0) of <{L,Bs,I}> when 'true' -> let <_13> = call 'erlang':'list_to_tuple' (L) in {_13,Bs,I}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<[E0|Es0],Bs0,I0> when 'true' -> case apply 'expr_fixup'/3 (E0,Bs0,I0) of <{E,Bs1,I1}> when 'true' -> case apply 'expr_fixup'/3 (Es0,Bs1,I1) of <{Es,Bs,I}> when 'true' -> {[E|Es],Bs,I}
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<T,Bs,I> when 'true' -> {T,Bs,I} end
'string_fixup'/2 = fun (_0,_1) -> let <Text> = call 'erl_anno':'text' (_0) in let <FixupTag> = apply 'fixup_tag'/2 (Text,_1) in let <_4> = apply 'fixup_fun'/1 (FixupTag) in apply _4 (_1)
'new_var'/1 = fun (_0) -> let <_1> = call 'lists':'concat' (['__ExtendedParseExprs_'|[_0|['__']]]) in call 'erlang':'list_to_atom' (_1)
'reset_token_anno'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[T|_2]> when 'true' -> let <_4> = apply 'reset_anno'/0 () in let <_5> = call 'erlang':'element' (2,T) in let <_6> = apply _4 (_5) in let <_7> = call 'erlang':'setelement' (2,T,_6) in let <_8> = apply 'lc$^0'/1 (_2) in ([_7|_8]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'reset_expr_anno'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[E|_2]> when 'true' -> let <_4> = apply 'reset_anno'/0 () in let <_5> = call 'erl_parse':'map_anno' (_4,E) in let <_6> = apply 'lc$^0'/1 (_2) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'reset_anno'/0 = fun () -> (fun (_1) -> let <_0> = call 'erl_anno':'location' (_1) in call 'erl_anno':'new' (_0)-|[{'id',{0,0,'-reset_anno/0-fun-0-'}}] )
'fixup_fun'/1 = fun (_0) -> case _0 of <'function'> when 'true' -> ('function'/1-|[{'id',{0,0,'-fixup_fun/1-fun-0-'}}] )
<'pid'> when 'true' -> fun 'erlang':'list_to_pid'/1
<'port'> when 'true' -> fun 'erlang':'list_to_port'/1
<'reference'> when 'true' -> fun 'erlang':'list_to_ref'/1
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'fixup_fun',1}}] )-|['compiler_generated'] ) end
'function'/1 = fun (_0) -> case call 'erl_scan':'string' (_0) of <{'ok',[_3|[_4|[_5|[{'atom',_6,Module}|[_7|[{'atom',_8,Function}|[_9|[{'integer',_10,Arity}|_11]]]]]]]],_12}> when 'true' -> call 'erlang':'make_fun' (Module,Function,Arity)
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'fixup_text'/1 = fun (_0) -> case _0 of <'function'> when 'true' -> [102|[117|[110|[99|[116|[105|[111|[110]]]]]]]]
<'pid'> when 'true' -> [112|[105|[100]]]
<'port'> when 'true' -> [112|[111|[114|[116]]]]
<'reference'> when 'true' -> [114|[101|[102|[101|[114|[101|[110|[99|[101]]]]]]]]]
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'fixup_text',1}}] )-|['compiler_generated'] ) end
'fixup_tag'/2 = fun (_0,_1) -> case <_0,_1> of <[102|[117|[110|[99|[116|[105|[111|[110]]]]]]]],[35|_4]> when 'true' -> 'function'
<[112|[105|[100]]],[60|_5]> when 'true' -> 'pid'
<[112|[111|[114|[116]]]],[35|_6]> when 'true' -> 'port'
<[114|[101|[102|[101|[114|[101|[110|[99|[101]]]]]]]]],[35|_7]> when 'true' -> 'reference'
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'fixup_tag',2}}] )-|['compiler_generated'] ) end
'extended_parse_term'/1 = fun (_0) -> case apply 'extended_parse_exprs'/1 (_0) of <{'ok',[Expr|[]],Bindings}> when 'true' -> try apply 'normalise'/2 (Expr,Bindings) of <_1> -> {'ok',_1} catch <_5,_4,_3> -> let <_6> = call 'erlang':'element' (2,Expr) in let <Loc> = call 'erl_anno':'location' (_6) in {'error',{Loc,'erl_eval',[98|[97|[100|[32|[116|[101|[114|[109]]]]]]]]}}
<{'ok',[_15|[Expr|_16]],_X_Bindings}> when 'true' -> let <_8> = call 'erlang':'element' (2,Expr) in let <Loc> = call 'erl_anno':'location' (_8) in {'error',{Loc,'erl_eval',[98|[97|[100|[32|[116|[101|[114|[109]]]]]]]]}}
<Error = {'error',_17}> when 'true' -> Error
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
'normalise'/2 = fun (_0,_1) -> case <_0,_1> of <{'var',_21,V},Bs> when 'true' -> case call 'erl_eval':'binding' (V,Bs) of <{'value',Value}> when 'true' -> Value
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{'char',_22,C},_X_Bs> when 'true' -> C
<{'integer',_23,I},_X_Bs> when 'true' -> I
<{'float',_24,F},_X_Bs> when 'true' -> F
<{'atom',_25,A},_X_Bs> when 'true' -> A
<{'string',_26,S},_X_Bs> when 'true' -> S
<{'nil',_27},_X_Bs> when 'true' -> []
<{'bin',_28,Fs},Bs> when 'true' -> let <_8> = fun (_5,_4) -> let <_3> = apply 'normalise'/2 (_5,Bs) in {'value',_3,[]} in case call 'eval_bits':'expr_grp' (Fs,[],_8,[],'true') of <{'value',B,_30}> when 'true' -> B
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<{'cons',_31,Head,Tail},Bs> when 'true' -> let <_10> = apply 'normalise'/2 (Head,Bs) in let <_11> = apply 'normalise'/2 (Tail,Bs) in [_10|_11]
<{'tuple',_32,Args},Bs> when 'true' -> let <_12> = apply 'normalise_list'/2 (Args,Bs) in call 'erlang':'list_to_tuple' (_12)
<{'map',_33,Pairs},Bs> when 'true' -> let <_17> = fun (_15) -> case _15 of <{'map_field_assoc',_34,K,V}> when 'true' -> let <_14> = apply 'normalise'/2 (K,Bs) in let <_13> = apply 'normalise'/2 (V,Bs) in {_14,_13}
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'-normalise/2-fun-1-',1}}] )-|['compiler_generated'] ) end in let <_18> = call 'lists':'map' (_17,Pairs) in call 'maps':'from_list' (_18)
<{'op',_35,'+',{'char',_36,I}},_X_Bs> when 'true' -> I
<{'op',_37,'+',{'integer',_38,I}},_X_Bs> when 'true' -> I
<{'op',_39,'+',{'float',_40,F}},_X_Bs> when 'true' -> F
<{'op',_41,'-',{'char',_42,I}},_X_Bs> when 'true' -> call 'erlang':'-' (I)
<{'op',_43,'-',{'integer',_44,I}},_X_Bs> when 'true' -> call 'erlang':'-' (I)
<{'op',_45,'-',{'float',_46,F}},_X_Bs> when 'true' -> call 'erlang':'-' (F)
<{'fun',_47,{'function',{'atom',_48,M},{'atom',_49,F},{'integer',_50,A}}},_X_Bs> when 'true' -> call 'erlang':'make_fun' (M,F,A)
(<_20,_19> when 'true' -> (primop 'match_fail' ({'function_clause',_20,_19})-|[{'function_name',{'normalise',2}}] )-|['compiler_generated'] ) end
'normalise_list'/2 = fun (_0,_1) -> case <_0,_1> of <[H|T],Bs> when 'true' -> let <_2> = apply 'normalise'/2 (H,Bs) in let <_3> = apply 'normalise_list'/2 (T,Bs) in [_2|_3]
<[],_X_Bs> when 'true' -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'normalise_list',2}}] )-|['compiler_generated'] ) end
'is_constant_expr'/1 = fun (_0) -> case apply 'eval_expr'/1 (_0) of <{'ok',X}> when call 'erlang':'is_number' (X) -> 'true'
<_3> when 'true' -> 'false' end
'eval_expr'/1 = fun (_0) -> let <_1> = catch apply 'ev_expr'/1 (_0) in case _1 of <X> when call 'erlang':'is_integer' (_1) -> {'ok',X}
<X> when call 'erlang':'is_float' (_1) -> {'ok',X}
<X> when call 'erlang':'is_atom' (_1) -> {'ok',X}
<{'EXIT',Reason}> when 'true' -> {'error',Reason}
<_4> when 'true' -> {'error','badarg'} end
'partial_eval'/1 = fun (_0) -> let <Line> = apply 'line'/1 (_0) in let <_2> = catch apply 'ev_expr'/1 (_0) in case _2 of <X> when call 'erlang':'is_integer' (_2) -> apply 'ret_expr'/2 (_0,{'integer',Line,X})
<X> when call 'erlang':'is_float' (_2) -> apply 'ret_expr'/2 (_0,{'float',Line,X})
<X> when call 'erlang':'is_atom' (_2) -> apply 'ret_expr'/2 (_0,{'atom',Line,X})
<_5> when 'true' -> _0 end
'ev_expr'/1 = fun (_0) -> case _0 of <{'op',_13,Op,L,R}> when 'true' -> let <_2> = apply 'ev_expr'/1 (L) in let <_1> = apply 'ev_expr'/1 (R) in call 'erlang':Op (_2,_1)
<{'op',_14,Op,A}> when 'true' -> let <_3> = apply 'ev_expr'/1 (A) in call 'erlang':Op (_3)
<{'integer',_15,X}> when 'true' -> X
<{'char',_16,X}> when 'true' -> X
<{'float',_17,X}> when 'true' -> X
<{'atom',_18,X}> when 'true' -> X
<{'tuple',_19,Es}> when 'true' -> let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[X|_5]> when 'true' -> let <_7> = apply 'ev_expr'/1 (X) in let <_8> = apply 'lc$^0'/1 (_5) in ([_7|_8]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_22> when 'true' -> (primop 'match_fail' ({'function_clause',_22})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Es) in call 'erlang':'list_to_tuple' (_9)
<{'nil',_20}> when 'true' -> []
<{'cons',_21,H,T}> when 'true' -> let <_10> = apply 'ev_expr'/1 (H) in let <_11> = apply 'ev_expr'/1 (T) in [_10|_11]
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'ev_expr',1}}] )-|['compiler_generated'] ) end
'eval_str'/1 = fun (_0) -> case _0 of <Str> when call 'erlang':'is_list' (_0) -> case call 'erl_scan':'tokens' ([],Str,0) of <{'more',_16}> when 'true' -> {'error',[73|[110|[99|[111|[109|[112|[108|[101|[116|[101|[32|[102|[111|[114|[109|[32|[40|[109|[105|[115|[115|[105|[110|[103|[32|[46|[60|[99|[114|[62|[41|[63|[63]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]}
<{'done',{'ok',Toks,_17},Rest}> when 'true' -> case apply 'all_white'/1 (Rest) of <'true'> when 'true' -> case call 'erl_parse':'parse_exprs' (Toks) of <{'ok',Exprs}> when 'true' -> let <_2> = catch let <_1> = call 'erl_eval':'new_bindings' () in call 'erl_eval':'exprs' (Exprs,_1) in case _2 of <{'value',Val,_18}> when 'true' -> {'ok',Val}
<Other> when 'true' -> let <_3> = call 'io_lib':'format' ([42|[42|[42|[32|[101|[118|[97|[108|[58|[32|[126|[112]]]]]]]]]]]],[Other|[]]) in let <_4> = call 'lists':'flatten' (_3) in {'error',_4} end
<{'error',{_X_Line,Mod,Args}}> when 'true' -> let <_6> = call Mod:'format_error' (Args) in let <_7> = call 'io_lib':'format' ([42|[42|[42|[32|[126|[116|[115]]]]]]],[_6|[]]) in let <Msg> = call 'lists':'flatten' (_7) in {'error',Msg}
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_10> = call 'io_lib':'format' ([78|[111|[110|[45|[119|[104|[105|[116|[101|[32|[115|[112|[97|[99|[101|[32|[102|[111|[117|[110|[100|[32|[97|[102|[116|[101|[114|[32|[101|[110|[100|[45|[111|[102|[45|[102|[111|[114|[109|[32|[58|[126|[116|[115]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Rest|[]]) in let <_11> = call 'lists':'flatten' (_10) in {'error',_11}
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<Bin> when call 'erlang':'is_binary' (_0) -> let <_14> = call 'erlang':'binary_to_list' (Bin) in apply 'eval_str'/1 (_14)
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'eval_str',1}}] )-|['compiler_generated'] ) end
'all_white'/1 = fun (_0) -> case _0 of <[32|T]> when 'true' -> apply 'all_white'/1 (T)
<[10|T]> when 'true' -> apply 'all_white'/1 (T)
<[9|T]> when 'true' -> apply 'all_white'/1 (T)
<[]> when 'true' -> 'true'
<_2> when 'true' -> 'false' end
'ret_expr'/2 = fun (_0,_1) -> _1
'line'/1 = fun (_0) -> call 'erlang':'element' (2,_0)
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('erl_eval')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('erl_eval',_0) end