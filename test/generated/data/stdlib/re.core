module 're' ['compile'/1,'compile'/2,'grun'/3,'inspect'/2,'internal_run'/4,'module_info'/0,'module_info'/1,'replace'/3,'replace'/4,'run'/2,'run'/3,'split'/2,'split'/3,'ucompile'/2,'urun'/3,'version'/0] attributes [ 'file' = [{[115|[114|[99|[47|[114|[101|[46|[101|[114|[108]]]]]]]]]],1}]
, 'type' = [{'mp',{'type',23,'tuple',[{'atom',23,'re_pattern'}|[{'var',23,'_'}|[{'var',23,'_'}|[{'var',23,'_'}|[{'var',23,'_'}]]]]]},[]}]
, 'type' = [{'nl_spec',{'type',25,'union',[{'atom',25,'cr'}|[{'atom',25,'crlf'}|[{'atom',25,'lf'}|[{'atom',25,'anycrlf'}|[{'atom',25,'any'}]]]]]},[]}]
, 'type' = [{'compile_option',{'type',27,'union',[{'atom',27,'unicode'}|[{'atom',27,'anchored'}|[{'atom',27,'caseless'}|[{'atom',27,'dollar_endonly'}|[{'atom',28,'dotall'}|[{'atom',28,'extended'}|[{'atom',28,'firstline'}|[{'atom',28,'multiline'}|[{'atom',29,'no_auto_capture'}|[{'atom',29,'dupnames'}|[{'atom',29,'ungreedy'}|[{'type',30,'tuple',[{'atom',30,'newline'}|[{'user_type',30,'nl_spec',[]}]]}|[{'atom',31,'bsr_anycrlf'}|[{'atom',31,'bsr_unicode'}|[{'atom',32,'no_start_optimize'}|[{'atom',32,'ucp'}|[{'atom',32,'never_utf'}]]]]]]]]]]]]]]]]]},[]}]
, 'spec' = [{{'version',0},[{'type',40,'fun',[{'type',40,'product',[]}|[{'type',40,'binary',[]}]]}]}]
, 'spec' = [{{'compile',1},[{'type',45,'bounded_fun',[{'type',45,'fun',[{'type',45,'product',[{'var',45,'Regexp'}]}|[{'type',45,'union',[{'type',45,'tuple',[{'atom',45,'ok'}|[{'var',45,'MP'}]]}|[{'type',45,'tuple',[{'atom',45,'error'}|[{'var',45,'ErrSpec'}]]}]]}]]}|[[{'type',46,'constraint',[{'atom',46,'is_subtype'}|[[{'var',46,'Regexp'}|[{'type',46,'iodata',[]}]]]]}|[{'type',47,'constraint',[{'atom',47,'is_subtype'}|[[{'var',47,'MP'}|[{'user_type',47,'mp',[]}]]]]}|[{'type',48,'constraint',[{'atom',48,'is_subtype'}|[[{'var',48,'ErrSpec'}|[{'type',48,'tuple',[{'ann_type',48,[{'var',48,'ErrString'}|[{'type',48,'string',[]}]]}|[{'ann_type',48,[{'var',48,'Position'}|[{'type',48,'non_neg_integer',[]}]]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'compile',2},[{'type',53,'bounded_fun',[{'type',53,'fun',[{'type',53,'product',[{'var',53,'Regexp'}|[{'var',53,'Options'}]]}|[{'type',53,'union',[{'type',53,'tuple',[{'atom',53,'ok'}|[{'var',53,'MP'}]]}|[{'type',53,'tuple',[{'atom',53,'error'}|[{'var',53,'ErrSpec'}]]}]]}]]}|[[{'type',54,'constraint',[{'atom',54,'is_subtype'}|[[{'var',54,'Regexp'}|[{'type',54,'union',[{'type',54,'iodata',[]}|[{'remote_type',54,[{'atom',54,'unicode'}|[{'atom',54,'charlist'}|[[]]]]}]]}]]]]}|[{'type',55,'constraint',[{'atom',55,'is_subtype'}|[[{'var',55,'Options'}|[{'type',55,'list',[{'var',55,'Option'}]}]]]]}|[{'type',56,'constraint',[{'atom',56,'is_subtype'}|[[{'var',56,'Option'}|[{'user_type',56,'compile_option',[]}]]]]}|[{'type',57,'constraint',[{'atom',57,'is_subtype'}|[[{'var',57,'MP'}|[{'user_type',57,'mp',[]}]]]]}|[{'type',58,'constraint',[{'atom',58,'is_subtype'}|[[{'var',58,'ErrSpec'}|[{'type',58,'tuple',[{'ann_type',58,[{'var',58,'ErrString'}|[{'type',58,'string',[]}]]}|[{'ann_type',58,[{'var',58,'Position'}|[{'type',58,'non_neg_integer',[]}]]}]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'run',2},[{'type',63,'bounded_fun',[{'type',63,'fun',[{'type',63,'product',[{'var',63,'Subject'}|[{'var',63,'RE'}]]}|[{'type',63,'union',[{'type',63,'tuple',[{'atom',63,'match'}|[{'var',63,'Captured'}]]}|[{'atom',63,'nomatch'}]]}]]}|[[{'type',64,'constraint',[{'atom',64,'is_subtype'}|[[{'var',64,'Subject'}|[{'type',64,'union',[{'type',64,'iodata',[]}|[{'remote_type',64,[{'atom',64,'unicode'}|[{'atom',64,'charlist'}|[[]]]]}]]}]]]]}|[{'type',65,'constraint',[{'atom',65,'is_subtype'}|[[{'var',65,'RE'}|[{'type',65,'union',[{'user_type',65,'mp',[]}|[{'type',65,'iodata',[]}]]}]]]]}|[{'type',66,'constraint',[{'atom',66,'is_subtype'}|[[{'var',66,'Captured'}|[{'type',66,'list',[{'var',66,'CaptureData'}]}]]]]}|[{'type',67,'constraint',[{'atom',67,'is_subtype'}|[[{'var',67,'CaptureData'}|[{'type',67,'tuple',[{'type',67,'integer',[]}|[{'type',67,'integer',[]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'run',3},[{'type',72,'bounded_fun',[{'type',72,'fun',[{'type',72,'product',[{'var',72,'Subject'}|[{'var',72,'RE'}|[{'var',72,'Options'}]]]}|[{'type',72,'union',[{'type',72,'tuple',[{'atom',72,'match'}|[{'var',72,'Captured'}]]}|[{'atom',73,'match'}|[{'atom',74,'nomatch'}|[{'type',75,'tuple',[{'atom',75,'error'}|[{'var',75,'ErrType'}]]}]]]]}]]}|[[{'type',76,'constraint',[{'atom',76,'is_subtype'}|[[{'var',76,'Subject'}|[{'type',76,'union',[{'type',76,'iodata',[]}|[{'remote_type',76,[{'atom',76,'unicode'}|[{'atom',76,'charlist'}|[[]]]]}]]}]]]]}|[{'type',77,'constraint',[{'atom',77,'is_subtype'}|[[{'var',77,'RE'}|[{'type',77,'union',[{'user_type',77,'mp',[]}|[{'type',77,'iodata',[]}|[{'remote_type',77,[{'atom',77,'unicode'}|[{'atom',77,'charlist'}|[[]]]]}]]]}]]]]}|[{'type',78,'constraint',[{'atom',78,'is_subtype'}|[[{'var',78,'Options'}|[{'type',78,'list',[{'var',78,'Option'}]}]]]]}|[{'type',79,'constraint',[{'atom',79,'is_subtype'}|[[{'var',79,'Option'}|[{'type',79,'union',[{'atom',79,'anchored'}|[{'atom',79,'global'}|[{'atom',79,'notbol'}|[{'atom',79,'noteol'}|[{'atom',79,'notempty'}|[{'atom',80,'notempty_atstart'}|[{'atom',80,'report_errors'}|[{'type',81,'tuple',[{'atom',81,'offset'}|[{'type',81,'non_neg_integer',[]}]]}|[{'type',82,'tuple',[{'atom',82,'match_limit'}|[{'type',82,'non_neg_integer',[]}]]}|[{'type',83,'tuple',[{'atom',83,'match_limit_recursion'}|[{'type',83,'non_neg_integer',[]}]]}|[{'type',84,'tuple',[{'atom',84,'newline'}|[{'ann_type',84,[{'var',84,'NLSpec'}|[{'user_type',84,'nl_spec',[]}]]}]]}|[{'atom',85,'bsr_anycrlf'}|[{'atom',85,'bsr_unicode'}|[{'type',85,'tuple',[{'atom',85,'capture'}|[{'var',85,'ValueSpec'}]]}|[{'type',86,'tuple',[{'atom',86,'capture'}|[{'var',86,'ValueSpec'}|[{'var',86,'Type'}]]]}|[{'var',86,'CompileOpt'}]]]]]]]]]]]]]]]]}]]]]}|[{'type',87,'constraint',[{'atom',87,'is_subtype'}|[[{'var',87,'Type'}|[{'type',87,'union',[{'atom',87,'index'}|[{'atom',87,'list'}|[{'atom',87,'binary'}]]]}]]]]}|[{'type',88,'constraint',[{'atom',88,'is_subtype'}|[[{'var',88,'ValueSpec'}|[{'type',88,'union',[{'atom',88,'all'}|[{'atom',88,'all_but_first'}|[{'atom',88,'all_names'}|[{'atom',88,'first'}|[{'atom',88,'none'}|[{'var',88,'ValueList'}]]]]]]}]]]]}|[{'type',89,'constraint',[{'atom',89,'is_subtype'}|[[{'var',89,'ValueList'}|[{'type',89,'list',[{'var',89,'ValueID'}]}]]]]}|[{'type',90,'constraint',[{'atom',90,'is_subtype'}|[[{'var',90,'ValueID'}|[{'type',90,'union',[{'type',90,'integer',[]}|[{'type',90,'string',[]}|[{'type',90,'atom',[]}]]]}]]]]}|[{'type',91,'constraint',[{'atom',91,'is_subtype'}|[[{'var',91,'CompileOpt'}|[{'user_type',91,'compile_option',[]}]]]]}|[{'type',92,'constraint',[{'atom',92,'is_subtype'}|[[{'var',92,'Captured'}|[{'type',92,'union',[{'type',92,'list',[{'var',92,'CaptureData'}]}|[{'type',92,'list',[{'type',92,'list',[{'var',92,'CaptureData'}]}]}]]}]]]]}|[{'type',93,'constraint',[{'atom',93,'is_subtype'}|[[{'var',93,'CaptureData'}|[{'type',93,'union',[{'type',93,'tuple',[{'type',93,'integer',[]}|[{'type',93,'integer',[]}]]}|[{'var',94,'ListConversionData'}|[{'type',95,'binary',[]}]]]}]]]]}|[{'type',96,'constraint',[{'atom',96,'is_subtype'}|[[{'var',96,'ListConversionData'}|[{'type',96,'union',[{'type',96,'string',[]}|[{'type',97,'tuple',[{'atom',97,'error'}|[{'type',97,'string',[]}|[{'type',97,'binary',[]}]]]}|[{'type',98,'tuple',[{'atom',98,'incomplete'}|[{'type',98,'string',[]}|[{'type',98,'binary',[]}]]]}]]]}]]]]}|[{'type',99,'constraint',[{'atom',99,'is_subtype'}|[[{'var',99,'ErrType'}|[{'type',99,'union',[{'atom',99,'match_limit'}|[{'atom',99,'match_limit_recursion'}|[{'type',99,'tuple',[{'atom',99,'compile'}|[{'var',99,'CompileErr'}]]}]]]}]]]]}|[{'type',100,'constraint',[{'atom',100,'is_subtype'}|[[{'var',100,'CompileErr'}|[{'type',100,'tuple',[{'ann_type',100,[{'var',100,'ErrString'}|[{'type',100,'string',[]}]]}|[{'ann_type',100,[{'var',100,'Position'}|[{'type',100,'non_neg_integer',[]}]]}]]}]]]]}]]]]]]]]]]]]]]]]}]}]
, 'spec' = [{{'internal_run',4},[{'type',105,'bounded_fun',[{'type',105,'fun',[{'type',105,'product',[{'var',105,'Subject'}|[{'var',105,'RE'}|[{'var',105,'Options'}|[{'var',105,'FirstCall'}]]]]}|[{'type',105,'union',[{'type',105,'tuple',[{'atom',105,'match'}|[{'var',105,'Captured'}]]}|[{'atom',106,'match'}|[{'atom',107,'nomatch'}|[{'type',108,'tuple',[{'atom',108,'error'}|[{'var',108,'ErrType'}]]}]]]]}]]}|[[{'type',109,'constraint',[{'atom',109,'is_subtype'}|[[{'var',109,'Subject'}|[{'type',109,'union',[{'type',109,'iodata',[]}|[{'remote_type',109,[{'atom',109,'unicode'}|[{'atom',109,'charlist'}|[[]]]]}]]}]]]]}|[{'type',110,'constraint',[{'atom',110,'is_subtype'}|[[{'var',110,'RE'}|[{'type',110,'union',[{'user_type',110,'mp',[]}|[{'type',110,'iodata',[]}|[{'remote_type',110,[{'atom',110,'unicode'}|[{'atom',110,'charlist'}|[[]]]]}]]]}]]]]}|[{'type',111,'constraint',[{'atom',111,'is_subtype'}|[[{'var',111,'Options'}|[{'type',111,'list',[{'var',111,'Option'}]}]]]]}|[{'type',112,'constraint',[{'atom',112,'is_subtype'}|[[{'var',112,'Option'}|[{'type',112,'union',[{'atom',112,'anchored'}|[{'atom',112,'global'}|[{'atom',112,'notbol'}|[{'atom',112,'noteol'}|[{'atom',112,'notempty'}|[{'atom',113,'notempty_atstart'}|[{'atom',113,'report_errors'}|[{'type',114,'tuple',[{'atom',114,'offset'}|[{'type',114,'non_neg_integer',[]}]]}|[{'type',115,'tuple',[{'atom',115,'match_limit'}|[{'type',115,'non_neg_integer',[]}]]}|[{'type',116,'tuple',[{'atom',116,'match_limit_recursion'}|[{'type',116,'non_neg_integer',[]}]]}|[{'type',117,'tuple',[{'atom',117,'newline'}|[{'ann_type',117,[{'var',117,'NLSpec'}|[{'user_type',117,'nl_spec',[]}]]}]]}|[{'atom',118,'bsr_anycrlf'}|[{'atom',118,'bsr_unicode'}|[{'type',118,'tuple',[{'atom',118,'capture'}|[{'var',118,'ValueSpec'}]]}|[{'type',119,'tuple',[{'atom',119,'capture'}|[{'var',119,'ValueSpec'}|[{'var',119,'Type'}]]]}|[{'var',119,'CompileOpt'}]]]]]]]]]]]]]]]]}]]]]}|[{'type',120,'constraint',[{'atom',120,'is_subtype'}|[[{'var',120,'Type'}|[{'type',120,'union',[{'atom',120,'index'}|[{'atom',120,'list'}|[{'atom',120,'binary'}]]]}]]]]}|[{'type',121,'constraint',[{'atom',121,'is_subtype'}|[[{'var',121,'ValueSpec'}|[{'type',121,'union',[{'atom',121,'all'}|[{'atom',121,'all_but_first'}|[{'atom',121,'all_names'}|[{'atom',121,'first'}|[{'atom',121,'none'}|[{'var',121,'ValueList'}]]]]]]}]]]]}|[{'type',122,'constraint',[{'atom',122,'is_subtype'}|[[{'var',122,'ValueList'}|[{'type',122,'list',[{'var',122,'ValueID'}]}]]]]}|[{'type',123,'constraint',[{'atom',123,'is_subtype'}|[[{'var',123,'ValueID'}|[{'type',123,'union',[{'type',123,'integer',[]}|[{'type',123,'string',[]}|[{'type',123,'atom',[]}]]]}]]]]}|[{'type',124,'constraint',[{'atom',124,'is_subtype'}|[[{'var',124,'CompileOpt'}|[{'user_type',124,'compile_option',[]}]]]]}|[{'type',125,'constraint',[{'atom',125,'is_subtype'}|[[{'var',125,'Captured'}|[{'type',125,'union',[{'type',125,'list',[{'var',125,'CaptureData'}]}|[{'type',125,'list',[{'type',125,'list',[{'var',125,'CaptureData'}]}]}]]}]]]]}|[{'type',126,'constraint',[{'atom',126,'is_subtype'}|[[{'var',126,'CaptureData'}|[{'type',126,'union',[{'type',126,'tuple',[{'type',126,'integer',[]}|[{'type',126,'integer',[]}]]}|[{'var',127,'ListConversionData'}|[{'type',128,'binary',[]}]]]}]]]]}|[{'type',129,'constraint',[{'atom',129,'is_subtype'}|[[{'var',129,'ListConversionData'}|[{'type',129,'union',[{'type',129,'string',[]}|[{'type',130,'tuple',[{'atom',130,'error'}|[{'type',130,'string',[]}|[{'type',130,'binary',[]}]]]}|[{'type',131,'tuple',[{'atom',131,'incomplete'}|[{'type',131,'string',[]}|[{'type',131,'binary',[]}]]]}]]]}]]]]}|[{'type',132,'constraint',[{'atom',132,'is_subtype'}|[[{'var',132,'ErrType'}|[{'type',132,'union',[{'atom',132,'match_limit'}|[{'atom',132,'match_limit_recursion'}|[{'type',132,'tuple',[{'atom',132,'compile'}|[{'var',132,'CompileErr'}]]}]]]}]]]]}|[{'type',133,'constraint',[{'atom',133,'is_subtype'}|[[{'var',133,'CompileErr'}|[{'type',133,'tuple',[{'ann_type',133,[{'var',133,'ErrString'}|[{'type',133,'string',[]}]]}|[{'ann_type',133,[{'var',133,'Position'}|[{'type',133,'non_neg_integer',[]}]]}]]}]]]]}|[{'type',134,'constraint',[{'atom',134,'is_subtype'}|[[{'var',134,'FirstCall'}|[{'type',134,'boolean',[]}]]]]}]]]]]]]]]]]]]]]]]}]}]
, 'spec' = [{{'inspect',2},[{'type',139,'bounded_fun',[{'type',139,'fun',[{'type',139,'product',[{'var',139,'MP'}|[{'var',139,'Item'}]]}|[{'type',139,'tuple',[{'atom',139,'namelist'}|[{'type',139,'list',[{'type',139,'binary',[]}]}]]}]]}|[[{'type',140,'constraint',[{'atom',140,'is_subtype'}|[[{'var',140,'MP'}|[{'user_type',140,'mp',[]}]]]]}|[{'type',141,'constraint',[{'atom',141,'is_subtype'}|[[{'var',141,'Item'}|[{'atom',141,'namelist'}]]]]}]]]]}]}]
, 'spec' = [{{'split',2},[{'type',149,'bounded_fun',[{'type',149,'fun',[{'type',149,'product',[{'var',149,'Subject'}|[{'var',149,'RE'}]]}|[{'var',149,'SplitList'}]]}|[[{'type',150,'constraint',[{'atom',150,'is_subtype'}|[[{'var',150,'Subject'}|[{'type',150,'union',[{'type',150,'iodata',[]}|[{'remote_type',150,[{'atom',150,'unicode'}|[{'atom',150,'charlist'}|[[]]]]}]]}]]]]}|[{'type',151,'constraint',[{'atom',151,'is_subtype'}|[[{'var',151,'RE'}|[{'type',151,'union',[{'user_type',151,'mp',[]}|[{'type',151,'iodata',[]}]]}]]]]}|[{'type',152,'constraint',[{'atom',152,'is_subtype'}|[[{'var',152,'SplitList'}|[{'type',152,'list',[{'type',152,'union',[{'type',152,'iodata',[]}|[{'remote_type',152,[{'atom',152,'unicode'}|[{'atom',152,'charlist'}|[[]]]]}]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'split',3},[{'type',157,'bounded_fun',[{'type',157,'fun',[{'type',157,'product',[{'var',157,'Subject'}|[{'var',157,'RE'}|[{'var',157,'Options'}]]]}|[{'var',157,'SplitList'}]]}|[[{'type',158,'constraint',[{'atom',158,'is_subtype'}|[[{'var',158,'Subject'}|[{'type',158,'union',[{'type',158,'iodata',[]}|[{'remote_type',158,[{'atom',158,'unicode'}|[{'atom',158,'charlist'}|[[]]]]}]]}]]]]}|[{'type',159,'constraint',[{'atom',159,'is_subtype'}|[[{'var',159,'RE'}|[{'type',159,'union',[{'user_type',159,'mp',[]}|[{'type',159,'iodata',[]}|[{'remote_type',159,[{'atom',159,'unicode'}|[{'atom',159,'charlist'}|[[]]]]}]]]}]]]]}|[{'type',160,'constraint',[{'atom',160,'is_subtype'}|[[{'var',160,'Options'}|[{'type',160,'list',[{'var',160,'Option'}]}]]]]}|[{'type',161,'constraint',[{'atom',161,'is_subtype'}|[[{'var',161,'Option'}|[{'type',161,'union',[{'atom',161,'anchored'}|[{'atom',161,'notbol'}|[{'atom',161,'noteol'}|[{'atom',161,'notempty'}|[{'atom',161,'notempty_atstart'}|[{'type',162,'tuple',[{'atom',162,'offset'}|[{'type',162,'non_neg_integer',[]}]]}|[{'type',162,'tuple',[{'atom',162,'newline'}|[{'user_type',162,'nl_spec',[]}]]}|[{'type',163,'tuple',[{'atom',163,'match_limit'}|[{'type',163,'non_neg_integer',[]}]]}|[{'type',164,'tuple',[{'atom',164,'match_limit_recursion'}|[{'type',164,'non_neg_integer',[]}]]}|[{'atom',165,'bsr_anycrlf'}|[{'atom',165,'bsr_unicode'}|[{'type',165,'tuple',[{'atom',165,'return'}|[{'var',165,'ReturnType'}]]}|[{'type',166,'tuple',[{'atom',166,'parts'}|[{'var',166,'NumParts'}]]}|[{'atom',166,'group'}|[{'atom',166,'trim'}|[{'var',166,'CompileOpt'}]]]]]]]]]]]]]]]]}]]]]}|[{'type',167,'constraint',[{'atom',167,'is_subtype'}|[[{'var',167,'NumParts'}|[{'type',167,'union',[{'type',167,'non_neg_integer',[]}|[{'atom',167,'infinity'}]]}]]]]}|[{'type',168,'constraint',[{'atom',168,'is_subtype'}|[[{'var',168,'ReturnType'}|[{'type',168,'union',[{'atom',168,'iodata'}|[{'atom',168,'list'}|[{'atom',168,'binary'}]]]}]]]]}|[{'type',169,'constraint',[{'atom',169,'is_subtype'}|[[{'var',169,'CompileOpt'}|[{'user_type',169,'compile_option',[]}]]]]}|[{'type',170,'constraint',[{'atom',170,'is_subtype'}|[[{'var',170,'SplitList'}|[{'type',170,'union',[{'type',170,'list',[{'var',170,'RetData'}]}|[{'type',170,'list',[{'var',170,'GroupedRetData'}]}]]}]]]]}|[{'type',171,'constraint',[{'atom',171,'is_subtype'}|[[{'var',171,'GroupedRetData'}|[{'type',171,'list',[{'var',171,'RetData'}]}]]]]}|[{'type',172,'constraint',[{'atom',172,'is_subtype'}|[[{'var',172,'RetData'}|[{'type',172,'union',[{'type',172,'iodata',[]}|[{'remote_type',172,[{'atom',172,'unicode'}|[{'atom',172,'charlist'}|[[]]]]}|[{'type',172,'binary',[]}|[{'type',172,'list',[]}]]]]}]]]]}]]]]]]]]]]]]}]}]
, 'spec' = [{{'replace',3},[{'type',344,'bounded_fun',[{'type',344,'fun',[{'type',344,'product',[{'var',344,'Subject'}|[{'var',344,'RE'}|[{'var',344,'Replacement'}]]]}|[{'type',344,'union',[{'type',344,'iodata',[]}|[{'remote_type',344,[{'atom',344,'unicode'}|[{'atom',344,'charlist'}|[[]]]]}]]}]]}|[[{'type',345,'constraint',[{'atom',345,'is_subtype'}|[[{'var',345,'Subject'}|[{'type',345,'union',[{'type',345,'iodata',[]}|[{'remote_type',345,[{'atom',345,'unicode'}|[{'atom',345,'charlist'}|[[]]]]}]]}]]]]}|[{'type',346,'constraint',[{'atom',346,'is_subtype'}|[[{'var',346,'RE'}|[{'type',346,'union',[{'user_type',346,'mp',[]}|[{'type',346,'iodata',[]}]]}]]]]}|[{'type',347,'constraint',[{'atom',347,'is_subtype'}|[[{'var',347,'Replacement'}|[{'type',347,'union',[{'type',347,'iodata',[]}|[{'remote_type',347,[{'atom',347,'unicode'}|[{'atom',347,'charlist'}|[[]]]]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'replace',4},[{'type',352,'bounded_fun',[{'type',352,'fun',[{'type',352,'product',[{'var',352,'Subject'}|[{'var',352,'RE'}|[{'var',352,'Replacement'}|[{'var',352,'Options'}]]]]}|[{'type',352,'union',[{'type',352,'iodata',[]}|[{'remote_type',352,[{'atom',352,'unicode'}|[{'atom',352,'charlist'}|[[]]]]}]]}]]}|[[{'type',353,'constraint',[{'atom',353,'is_subtype'}|[[{'var',353,'Subject'}|[{'type',353,'union',[{'type',353,'iodata',[]}|[{'remote_type',353,[{'atom',353,'unicode'}|[{'atom',353,'charlist'}|[[]]]]}]]}]]]]}|[{'type',354,'constraint',[{'atom',354,'is_subtype'}|[[{'var',354,'RE'}|[{'type',354,'union',[{'user_type',354,'mp',[]}|[{'type',354,'iodata',[]}|[{'remote_type',354,[{'atom',354,'unicode'}|[{'atom',354,'charlist'}|[[]]]]}]]]}]]]]}|[{'type',355,'constraint',[{'atom',355,'is_subtype'}|[[{'var',355,'Replacement'}|[{'type',355,'union',[{'type',355,'iodata',[]}|[{'remote_type',355,[{'atom',355,'unicode'}|[{'atom',355,'charlist'}|[[]]]]}]]}]]]]}|[{'type',356,'constraint',[{'atom',356,'is_subtype'}|[[{'var',356,'Options'}|[{'type',356,'list',[{'var',356,'Option'}]}]]]]}|[{'type',357,'constraint',[{'atom',357,'is_subtype'}|[[{'var',357,'Option'}|[{'type',357,'union',[{'atom',357,'anchored'}|[{'atom',357,'global'}|[{'atom',357,'notbol'}|[{'atom',357,'noteol'}|[{'atom',357,'notempty'}|[{'atom',358,'notempty_atstart'}|[{'type',359,'tuple',[{'atom',359,'offset'}|[{'type',359,'non_neg_integer',[]}]]}|[{'type',359,'tuple',[{'atom',359,'newline'}|[{'var',359,'NLSpec'}]]}|[{'atom',359,'bsr_anycrlf'}|[{'type',360,'tuple',[{'atom',360,'match_limit'}|[{'type',360,'non_neg_integer',[]}]]}|[{'type',361,'tuple',[{'atom',361,'match_limit_recursion'}|[{'type',361,'non_neg_integer',[]}]]}|[{'atom',362,'bsr_unicode'}|[{'type',362,'tuple',[{'atom',362,'return'}|[{'var',362,'ReturnType'}]]}|[{'var',362,'CompileOpt'}]]]]]]]]]]]]]]}]]]]}|[{'type',363,'constraint',[{'atom',363,'is_subtype'}|[[{'var',363,'ReturnType'}|[{'type',363,'union',[{'atom',363,'iodata'}|[{'atom',363,'list'}|[{'atom',363,'binary'}]]]}]]]]}|[{'type',364,'constraint',[{'atom',364,'is_subtype'}|[[{'var',364,'CompileOpt'}|[{'user_type',364,'compile_option',[]}]]]]}|[{'type',365,'constraint',[{'atom',365,'is_subtype'}|[[{'var',365,'NLSpec'}|[{'type',365,'union',[{'atom',365,'cr'}|[{'atom',365,'crlf'}|[{'atom',365,'lf'}|[{'atom',365,'anycrlf'}|[{'atom',365,'any'}]]]]]}]]]]}]]]]]]]]]]}]}] ] 'version'/0 = fun () -> call 'erlang':'nif_error' ('undef')
'compile'/1 = fun (_0) -> call 'erlang':'nif_error' ('undef')
'compile'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'run'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'run'/3 = fun (_0,_1,_2) -> call 'erlang':'nif_error' ('undef')
'internal_run'/4 = fun (_0,_1,_2,_3) -> call 'erlang':'nif_error' ('undef')
'inspect'/2 = fun (_0,_1) -> call 'erlang':'nif_error' ('undef')
'split'/2 = fun (_0,_1) -> apply 'split'/3 (_0,_1,[])
'split'/3 = fun (_0,_1,_2) -> try case apply 'process_split_params'/5 (_2,'iodata',-1,'false','false') of <{NewOpt,Convert,Limit,Strip,Group}> when 'true' -> let <Unicode> = apply 'check_for_unicode'/2 (_1,_2) in let <FlatSubject> = apply 'to_binary'/2 (_0,Unicode) in case apply 'compile_split'/2 (_1,NewOpt) of <{'error',_X_Err}> when 'true' -> call 'erlang':'throw' ('badre')
<{PreCompiled,NumSub,RunOpt}> when 'true' -> let <_7> = call 'erlang':'++' (RunOpt,['global']) in case call 're':'run' (FlatSubject,PreCompiled,_7) of <'nomatch'> when 'true' -> case Group of <'true'> when 'true' -> apply 'convert_any_split_result'/4 ([[FlatSubject|[]]|[]],Convert,Unicode,'true')
<'false'> when 'true' -> apply 'convert_any_split_result'/4 ([FlatSubject|[]],Convert,Unicode,'false')
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<{'match',Matches}> when 'true' -> let <Res> = apply 'do_split'/6 (FlatSubject,0,Matches,NumSub,Limit,Group) in let <_11> = case Strip of <'true'> when 'true' -> apply 'backstrip_empty'/2 (Res,Group)
<'false'> when 'true' -> Res
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end in apply 'convert_any_split_result'/4 (_11,Convert,Unicode,Group)
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end of <_15> -> _15 catch <_18,_17,_16> -> case <_18,_17,_16> of <('throw'-|['compiler_generated'] ),('badopt'-|['compiler_generated'] ),_22> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[]]]])
<('throw'-|['compiler_generated'] ),('badre'-|['compiler_generated'] ),_23> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[]]]])
<('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_24> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[]]]])
(<_25,_26,_27> when 'true' -> primop 'raise' (_27,_26)-|['compiler_generated'] ) end
'backstrip_empty'/2 = fun (_0,_1) -> case <_0,_1> of <List,'false'> when 'true' -> apply 'do_backstrip_empty'/1 (List)
<List,'true'> when 'true' -> apply 'do_backstrip_empty_g'/1 (List)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'backstrip_empty',2}}] )-|['compiler_generated'] ) end
'do_backstrip_empty_g'/1 = fun (_0) -> case _0 of <[]> when 'true' -> []
<_@r0 = [H|[]]> when 'true' -> case apply 'do_backstrip_empty'/1 (H) of <[]> when 'true' -> []
<_5> when 'true' -> _@r0 end
<[H|T]> when 'true' -> case apply 'do_backstrip_empty_g'/1 (T) of <[]> when 'true' -> case apply 'do_backstrip_empty'/1 (H) of <[]> when 'true' -> []
<_6> when 'true' -> [H|[]] end
<Other> when 'true' -> [H|Other] end
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'do_backstrip_empty_g',1}}] )-|['compiler_generated'] ) end
'do_backstrip_empty'/1 = fun (_0) -> case _0 of <[]> when 'true' -> []
<[#{}#|[]]> when 'true' -> []
<[#{}#|T]> when 'true' -> case apply 'do_backstrip_empty'/1 (T) of <[]> when 'true' -> []
<Other> when 'true' -> [#{}#|Other] end
<[H|T]> when 'true' -> let <_2> = apply 'do_backstrip_empty'/1 (T) in [H|_2]
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'do_backstrip_empty',1}}] )-|['compiler_generated'] ) end
'convert_any_split_result'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <List,Type,Uni,'true'> when 'true' -> (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[Part|_5]> when 'true' -> let <_7> = apply 'convert_split_result'/3 (Part,Type,Uni) in let <_8> = apply 'lc$^0'/1 (_5) in ([_7|_8]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_13> when 'true' -> (primop 'match_fail' ({'function_clause',_13})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (List)-|['list_comprehension'] )
<List,Type,Uni,'false'> when 'true' -> apply 'convert_split_result'/3 (List,Type,Uni)
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'convert_any_split_result',4}}] )-|['compiler_generated'] ) end
'convert_split_result'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <List,'iodata',_X_Unicode> when 'true' -> List
<List,'binary',_X_Unicode> when 'true' -> List
<List,'list','true'> when 'true' -> (letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[Element|_4]> when 'true' -> let <_6> = call 'unicode':'characters_to_list' (Element,'unicode') in let <_7> = apply 'lc$^0'/1 (_4) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_16> when 'true' -> (primop 'match_fail' ({'function_clause',_16})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (List)-|['list_comprehension'] )
<List,'list','false'> when 'true' -> (letrec 'lc$^1'/1 = fun (_10) -> case _10 of <[Element|_9]> when 'true' -> let <_11> = call 'erlang':'binary_to_list' (Element) in let <_12> = apply 'lc$^1'/1 (_9) in ([_11|_12]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (List)-|['list_comprehension'] )
(<_15,_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13})-|[{'function_name',{'convert_split_result',3}}] )-|['compiler_generated'] ) end
'do_split'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Subj,Off,_31,_32,0,'false'> when 'true' -> case Subj of <#{#<_33>(Off,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> [Rest|[]]
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<Subj,Off,[],_34,_35,'false'> when 'true' -> case Subj of <#{#<_36>(Off,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> [Rest|[]]
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<Subj,Off,_37,_38,_39,'false'> when try let <_8> = call 'erlang':'byte_size' (Subj) in call 'erlang':'=<' (_8,Off) of <Try> -> Try catch <T,R> -> 'false' -> [#{}#]
<Subj,Off,_40,_41,0,'true'> when 'true' -> case Subj of <#{#<_42>(Off,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> [[Rest|[]]|[]]
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<Subj,Off,[],_43,_44,'true'> when 'true' -> case Subj of <#{#<_45>(Off,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> [[Rest|[]]|[]]
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
<Subj,Off,_46,_47,_48,'true'> when try let <_11> = call 'erlang':'byte_size' (Subj) in call 'erlang':'=<' (_11,Off) of <Try> -> Try catch <T,R> -> 'false' -> [[#{}#]]
<Subj,Offset,[[{MainI,MainL}|Sub]|T],NumSub,Limit,Group> when 'true' -> let <NewOffset> = call 'erlang':'+' (MainI,MainL) in let <KeptLen> = call 'erlang':'-' (MainI,Offset) in let <_14> = apply 'empty_sub'/1 (Sub) in case <KeptLen,_14,MainL> of <0,'true',0> when 'true' -> apply 'do_split'/6 (Subj,NewOffset,T,NumSub,Limit,Group)
<(_52-|['compiler_generated'] ),(_53-|['compiler_generated'] ),(_54-|['compiler_generated'] )> when 'true' -> case Subj of <#{#<_50>(Offset,8,'binary',['unsigned'|['big']]),#<Keep>(KeptLen,8,'binary',['unsigned'|['big']]),#<_51>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <ESub> = apply 'extend_subpatterns'/2 (Sub,NumSub) in let <_17> = call 'erlang':'-' (Limit,1) in let <Tail> = apply 'do_split'/6 (Subj,NewOffset,T,NumSub,_17,Group) in case Group of <'false'> when 'true' -> let <_19> = call 'lists':'reverse' (ESub) in let <_20> = apply 'dig_subpatterns'/3 (Subj,_19,Tail) in [Keep|_20]
<'true'> when 'true' -> let <_21> = call 'lists':'reverse' (ESub) in let <_22> = apply 'dig_subpatterns'/3 (Subj,_21,[]) in [[Keep|_22]|Tail]
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end end
(<_30,_29,_28,_27,_26,_25> when 'true' -> (primop 'match_fail' ({'function_clause',_30,_29,_28,_27,_26,_25})-|[{'function_name',{'do_split',6}}] )-|['compiler_generated'] ) end
'empty_sub'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'true'
<[{_2,0}|T]> when 'true' -> apply 'empty_sub'/1 (T)
<_3> when 'true' -> 'false' end
'dig_subpatterns'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_7,[],Acc> when 'true' -> Acc
<Subj,[{-1,0}|T],Acc> when 'true' -> apply 'dig_subpatterns'/3 (Subj,T,[#{}#|Acc])
<Subj,[{I,L}|T],Acc> when 'true' -> case Subj of <#{#<_8>(I,8,'binary',['unsigned'|['big']]),#<Part>(L,8,'binary',['unsigned'|['big']]),#<_9>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> apply 'dig_subpatterns'/3 (Subj,T,[Part|Acc])
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'dig_subpatterns',3}}] )-|['compiler_generated'] ) end
'extend_subpatterns'/2 = fun (_0,_1) -> case <_0,_1> of <_8,0> when 'true' -> []
<[],N> when 'true' -> let <_2> = call 'erlang':'-' (N,1) in let <_3> = apply 'extend_subpatterns'/2 ([],_2) in [{0,0}|_3]
<[H|T],N> when 'true' -> let <_4> = call 'erlang':'-' (N,1) in let <_5> = apply 'extend_subpatterns'/2 (T,_4) in [H|_5]
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'extend_subpatterns',2}}] )-|['compiler_generated'] ) end
'compile_split'/2 = fun (_0,_1) -> case <_0,_1> of <Comp = {'re_pattern',N,_16,_17,_18},Options> when 'true' -> {Comp,N,Options}
<Pat,Options0> when let <_2> = call 'erlang':'is_tuple' (Pat) in call 'erlang':'not' (_2) -> let <_6> = fun (_4) -> let <_3> = apply 'runopt'/1 (_4) in call 'erlang':'not' (_3) in let <Options> = call 'lists':'filter' (_6,Options0) in case call 're':'compile' (Pat,Options) of <_@r0 = {'error',Err}> when 'true' -> _@r0
<{'ok',Comp = {'re_pattern',N,_19,_20,_21}}> when 'true' -> let <_11> = fun (_9) -> let <_8> = apply 'copt'/1 (_9) in call 'erlang':'not' (_8) in let <NewOpt> = call 'lists':'filter' (_11,Options0) in {Comp,N,NewOpt}
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
<_22,_23> when 'true' -> call 'erlang':'throw' ('badre') end
'replace'/3 = fun (_0,_1,_2) -> apply 'replace'/4 (_0,_1,_2,[])
'replace'/4 = fun (_0,_1,_2,_3) -> try case apply 'process_repl_params'/2 (_3,'iodata') of <{NewOpt,Convert}> when 'true' -> let <Unicode> = apply 'check_for_unicode'/2 (_1,_3) in let <FlatSubject> = apply 'to_binary'/2 (_0,Unicode) in let <FlatReplacement> = apply 'to_binary'/2 (_2,Unicode) in let <IoList> = apply 'do_replace'/5 (FlatSubject,_0,_1,FlatReplacement,NewOpt) in case Convert of <'iodata'> when 'true' -> IoList
<'binary'> when 'true' -> case Unicode of <'false'> when 'true' -> call 'erlang':'iolist_to_binary' (IoList)
<'true'> when 'true' -> call 'unicode':'characters_to_binary' (IoList,'unicode')
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<'list'> when 'true' -> case Unicode of <'false'> when 'true' -> let <_10> = call 'erlang':'iolist_to_binary' (IoList) in call 'erlang':'binary_to_list' (_10)
<'true'> when 'true' -> call 'unicode':'characters_to_list' (IoList,'unicode')
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end of <_13> -> _13 catch <_16,_15,_14> -> case <_16,_15,_14> of <('throw'-|['compiler_generated'] ),('badopt'-|['compiler_generated'] ),_21> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[_3|[]]]]])
<('throw'-|['compiler_generated'] ),('badre'-|['compiler_generated'] ),_22> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[_3|[]]]]])
<('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_23> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[_3|[]]]]])
(<_24,_25,_26> when 'true' -> primop 'raise' (_26,_25)-|['compiler_generated'] ) end
'do_replace'/5 = fun (_0,_1,_2,_3,_4) -> case call 're':'run' (_0,_2,_4) of <'nomatch'> when 'true' -> _1
<{'match',_@r0 = [Mlist|T]}> when call 'erlang':'is_list' (Mlist) -> apply 'apply_mlist'/3 (_0,_3,_@r0)
<{'match',Slist}> when 'true' -> apply 'apply_mlist'/3 (_0,_3,[Slist|[]])
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'process_repl_params'/2 = fun (_0,_1) -> case <_0,_1> of <[],Convert> when 'true' -> {[],Convert}
<['report_errors'|_5],_6> when 'true' -> call 'erlang':'throw' ('badopt')
<[{'capture',_7,_8}|_9],_10> when 'true' -> call 'erlang':'throw' ('badopt')
<[{'capture',_11}|_12],_13> when 'true' -> call 'erlang':'throw' ('badopt')
<[{'return','iodata'}|T],_X_C> when 'true' -> apply 'process_repl_params'/2 (T,'iodata')
<[{'return','list'}|T],_X_C> when 'true' -> apply 'process_repl_params'/2 (T,'list')
<[{'return','binary'}|T],_X_C> when 'true' -> apply 'process_repl_params'/2 (T,'binary')
<[{'return',_14}|_15],_16> when 'true' -> call 'erlang':'throw' ('badopt')
<[H|T],C> when 'true' -> case apply 'process_repl_params'/2 (T,C) of <{NT,NC}> when 'true' -> {[H|NT],NC}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'process_repl_params',2}}] )-|['compiler_generated'] ) end
'process_split_params'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[],Convert,Limit,Strip,Group> when 'true' -> {[],Convert,Limit,Strip,Group}
<['trim'|T],C,_X_L,_X_S,G> when 'true' -> apply 'process_split_params'/5 (T,C,-1,'true',G)
<[{'parts',0}|T],C,_X_L,_X_S,G> when 'true' -> apply 'process_split_params'/5 (T,C,-1,'true',G)
<[{'parts',N}|T],C,_X_L,_X_S,G> when let <_7> = call 'erlang':'is_integer' (N) in let <_8> = call 'erlang':'>=' (N,1) in call 'erlang':'and' (_7,_8) -> let <_9> = call 'erlang':'-' (N,1) in apply 'process_split_params'/5 (T,C,_9,'false',G)
<[{'parts','infinity'}|T],C,_X_L,_X_S,G> when 'true' -> apply 'process_split_params'/5 (T,C,-1,'false',G)
<[{'parts',_17}|_18],_19,_20,_21,_22> when 'true' -> call 'erlang':'throw' ('badopt')
<['group'|T],C,L,S,_X_G> when 'true' -> apply 'process_split_params'/5 (T,C,L,S,'true')
<['global'|_23],_24,_25,_26,_27> when 'true' -> call 'erlang':'throw' ('badopt')
<['report_errors'|_28],_29,_30,_31,_32> when 'true' -> call 'erlang':'throw' ('badopt')
<[{'capture',_33,_34}|_35],_36,_37,_38,_39> when 'true' -> call 'erlang':'throw' ('badopt')
<[{'capture',_40}|_41],_42,_43,_44,_45> when 'true' -> call 'erlang':'throw' ('badopt')
<[{'return','iodata'}|T],_X_C,L,S,G> when 'true' -> apply 'process_split_params'/5 (T,'iodata',L,S,G)
<[{'return','list'}|T],_X_C,L,S,G> when 'true' -> apply 'process_split_params'/5 (T,'list',L,S,G)
<[{'return','binary'}|T],_X_C,L,S,G> when 'true' -> apply 'process_split_params'/5 (T,'binary',L,S,G)
<[{'return',_46}|_47],_48,_49,_50,_51> when 'true' -> call 'erlang':'throw' ('badopt')
<[H|T],C,L,S,G> when 'true' -> case apply 'process_split_params'/5 (T,C,L,S,G) of <{NT,NC,NL,NS,NG}> when 'true' -> {[H|NT],NC,NL,NS,NG}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_16,_15,_14,_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14,_13,_12})-|[{'function_name',{'process_split_params',5}}] )-|['compiler_generated'] ) end
'apply_mlist'/3 = fun (_0,_1,_2) -> let <_3> = apply 'precomp_repl'/1 (_1) in apply 'do_mlist'/5 (_0,_0,0,_3,_2)
'precomp_repl'/1 = fun (_0) -> case _0 of <#{}#> when 'true' -> []
<#{#<92>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<123>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when try let <_1> = call 'erlang':'byte_size' (Rest) in call 'erlang':'>' (_1,0) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'pick_int'/1 (Rest) of <{NS,#{#<125>(8,1,'integer',['unsigned'|['big']]),#<NRest>('all',8,'binary',['unsigned'|['big']])}#}> when 'true' -> let <_3> = call 'erlang':'list_to_integer' (NS) in let <_4> = apply 'precomp_repl'/1 (NRest) in [_3|_4]
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<#{#<92>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when try let <_5> = call 'erlang':'byte_size' (Rest) in call 'erlang':'>' (_5,0) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'pick_int'/1 (Rest) of <{NS,NRest}> when 'true' -> let <_7> = call 'erlang':'list_to_integer' (NS) in let <_8> = apply 'precomp_repl'/1 (NRest) in [_7|_8]
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<#{#<92>(8,1,'integer',['unsigned'|['big']]),#<X>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when let <_9> = call 'erlang':'<' (X,49) in let <_10> = call 'erlang':'>' (X,57) in call 'erlang':'or' (_9,_10) -> case apply 'precomp_repl'/1 (Rest) of <[BHead|T0]> when call 'erlang':'is_binary' (BHead) -> let <_11> = #{#<X>(8,1,'integer',['unsigned'|['big']]),#<BHead>('all',8,'binary',['unsigned'|['big']])}# in [_11|T0]
<Other> when 'true' -> let <_12> = #{#<X>(8,1,'integer',['unsigned'|['big']])}# in [_12|Other] end
<#{#<92>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when try let <_14> = call 'erlang':'byte_size' (Rest) in call 'erlang':'>' (_14,0) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'pick_int'/1 (Rest) of <{NS,NRest}> when 'true' -> let <_16> = call 'erlang':'list_to_integer' (NS) in let <_17> = apply 'precomp_repl'/1 (NRest) in [_16|_17]
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<#{#<38>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_18> = apply 'precomp_repl'/1 (Rest) in [0|_18]
<#{#<X>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case apply 'precomp_repl'/1 (Rest) of <[BHead|T0]> when call 'erlang':'is_binary' (BHead) -> let <_19> = #{#<X>(8,1,'integer',['unsigned'|['big']]),#<BHead>('all',8,'binary',['unsigned'|['big']])}# in [_19|T0]
<Other> when 'true' -> let <_20> = #{#<X>(8,1,'integer',['unsigned'|['big']])}# in [_20|Other] end
(<_22> when 'true' -> (primop 'match_fail' ({'function_clause',_22})-|[{'function_name',{'precomp_repl',1}}] )-|['compiler_generated'] ) end
'pick_int'/1 = fun (_0) -> case _0 of <#{#<X>(8,1,'integer',['unsigned'|['big']]),#<R>('all',8,'binary',['unsigned'|['big']])}#> when let <_1> = call 'erlang':'>=' (X,48) in let <_2> = call 'erlang':'=<' (X,57) in call 'erlang':'and' (_1,_2) -> case apply 'pick_int'/1 (R) of <{Found,Rest}> when 'true' -> {[X|Found],Rest}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<Bin> when 'true' -> {[],Bin} end
'do_mlist'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_18,#{}#,_19,_20,[]> when 'true' -> []
<_21,Subject,_22,_23,[]> when 'true' -> Subject
<Whole,Subject,Pos,Repl,_@r0 = [[{MPos,Count}|Sub]|Tail]> when call 'erlang':'>' (MPos,Pos) -> let <EatLength> = call 'erlang':'-' (MPos,Pos) in case Subject of <#{#<Untouched>(EatLength,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_7> = apply 'do_mlist'/5 (Whole,Rest,MPos,Repl,_@r0) in [Untouched|_7]
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<Whole,Subject,Pos,Repl,[[{MPos,Count}|Sub]|Tail]> when call 'erlang':'=:=' (MPos,Pos) -> case Subject of <#{#<_24>(Count,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <NewData> = apply 'do_replace'/3 (Whole,Repl,[{MPos,Count}|Sub]) in let <_11> = call 'erlang':'+' (Pos,Count) in let <_12> = apply 'do_mlist'/5 (Whole,Rest,_11,Repl,Tail) in [NewData|_12]
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_17,_16,_15,_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_17,_16,_15,_14,_13})-|[{'function_name',{'do_mlist',5}}] )-|['compiler_generated'] ) end
'do_replace'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_17,[Bin|[]],_18> when call 'erlang':'is_binary' (Bin) -> Bin
<Subject,Repl,SubExprs0> when 'true' -> let <SubExprs> = call 'erlang':'list_to_tuple' (SubExprs0) in (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[Part|_5]> when 'true' -> let <_12> = case Part of <N> when call 'erlang':'is_integer' (Part) -> case <> of <> when try let <_7> = call 'erlang':'tuple_size' (SubExprs) in call 'erlang':'=<' (_7,N) of <Try> -> Try catch <T,R> -> 'false' -> #{}#
<> when 'true' -> let <_8> = call 'erlang':'+' (N,1) in case call 'erlang':'element' (_8,SubExprs) of <{SPos,SLen}> when 'true' -> case <> of <> when call 'erlang':'<' (SPos,0) -> #{}#
<> when 'true' -> case Subject of <#{#<_19>(SPos,8,'binary',['unsigned'|['big']]),#<Res>(SLen,8,'binary',['unsigned'|['big']]),#<_20>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> Res
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end end
<Other> when 'true' -> Other end in let <_13> = apply 'lc$^0'/1 (_5) in ([_12|_13]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_21> when 'true' -> (primop 'match_fail' ({'function_clause',_21})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Repl)-|['list_comprehension'] ) end
'check_for_unicode'/2 = fun (_0,_1) -> case <_0,_1> of <{'re_pattern',_4,1,_5,_6},_7> when 'true' -> 'true'
<{'re_pattern',_8,0,_9,_10},_11> when 'true' -> 'false'
<_12,L> when 'true' -> call 'lists':'member' ('unicode',L) end
'check_for_crlf'/2 = fun (_0,_1) -> case <_0,_1> of <{'re_pattern',_5,_6,1,_7},_8> when 'true' -> 'true'
<{'re_pattern',_9,_10,0,_11},_12> when 'true' -> 'false'
<_13,L> when 'true' -> case call 'lists':'keysearch' ('newline',1,L) of <{'value',{'newline','any'}}> when 'true' -> 'true'
<{'value',{'newline','crlf'}}> when 'true' -> 'true'
<{'value',{'newline','anycrlf'}}> when 'true' -> 'true'
<_14> when 'true' -> 'false' end end
'process_parameters'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[],InitialOffset,SelectReturn,ConvertReturn,_19,_20> when 'true' -> {[],InitialOffset,SelectReturn,ConvertReturn}
<[{'offset',N}|T],_X_Init0,Select0,Return0,CC,RE> when 'true' -> apply 'process_parameters'/6 (T,N,Select0,Return0,CC,RE)
<['global'|T],Init0,Select0,Return0,CC,RE> when 'true' -> apply 'process_parameters'/6 (T,Init0,Select0,Return0,CC,RE)
<[{'capture',Values,Type}|T],Init0,Select0,_X_Return0,CC,RE> when 'true' -> apply 'process_parameters'/6 ([{'capture',Values}|T],Init0,Select0,Type,CC,RE)
<[{'capture',Values}|T],Init0,Select0,Return0,CC,RE> when 'true' -> case apply 'process_parameters'/6 (T,Init0,Select0,Return0,CC,RE) of <_@r0 = {NewTail,Init1,Select1,Return1}> when 'true' -> case Select1 of <'false'> when 'true' -> case Values of <'all'> when 'true' -> {[{'capture','all'}|NewTail],Init1,'all',Return0}
<'all_names'> when 'true' -> case call 're':'inspect' (RE,'namelist') of <{'namelist',[]}> when 'true' -> {[{'capture','first'}|NewTail],Init1,'none',Return0}
<{'namelist',List}> when 'true' -> {[{'capture',[0|List]}|NewTail],Init1,'stripfirst',Return0}
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<'first'> when 'true' -> {[{'capture','first'}|NewTail],Init1,'all',Return0}
<'all_but_first'> when 'true' -> {[{'capture','all'}|NewTail],Init1,'stripfirst',Return0}
<'none'> when 'true' -> {[{'capture','first'}|NewTail],Init1,'none',Return0}
<[]> when 'true' -> {[{'capture','first'}|NewTail],Init1,'none',Return0}
<List> when call 'erlang':'is_list' (Values) -> {[{'capture',[0|List]}|NewTail],Init1,'stripfirst',Return0}
<_21> when 'true' -> call 'erlang':'throw' ('badlist') end
<_22> when 'true' -> _@r0 end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<[H|T],Init0,Select0,Return0,'true',RE> when 'true' -> case apply 'copt'/1 (H) of <'true'> when 'true' -> apply 'process_parameters'/6 (T,Init0,Select0,Return0,'true',RE)
<'false'> when 'true' -> case apply 'process_parameters'/6 (T,Init0,Select0,Return0,'true',RE) of <{NewT,Init,Select,Return}> when 'true' -> {[H|NewT],Init,Select,Return}
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
<[H|T],Init0,Select0,Return0,'false',RE> when 'true' -> case apply 'process_parameters'/6 (T,Init0,Select0,Return0,'false',RE) of <{NewT,Init,Select,Return}> when 'true' -> {[H|NewT],Init,Select,Return}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<_23,_24,_25,_26,_27,_28> when 'true' -> call 'erlang':'throw' ('badlist') end
'postprocess'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <{'match',[]},_17,_18,_19,_20> when 'true' -> 'nomatch'
<{'match',_21},'none',_22,_23,_24> when 'true' -> 'match'
<_@r0 = {'match',M},Any,'binary',Flat,Uni> when 'true' -> let <_5> = apply 'postprocess'/5 (_@r0,Any,'index',Flat,Uni) in apply 'binarify'/2 (_5,Flat)
<_@r1 = {'match',M},Any,'list',Flat,Uni> when 'true' -> let <_6> = apply 'postprocess'/5 (_@r1,Any,'index',Flat,Uni) in apply 'listify'/3 (_6,Flat,Uni)
<_@r2 = {'match',M},'all','index',_25,_26> when 'true' -> _@r2
<_@r3 = {'match',M},'false','index',_27,_28> when 'true' -> _@r3
<{'match',M},'stripfirst','index',_29,_30> when 'true' -> let <_11> = letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[[_31|T]|_8]> when 'true' -> let <_10> = apply 'lc$^0'/1 (_8) in ([T|_10]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_32> when 'true' -> (primop 'match_fail' ({'function_clause',_32})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (M) in {'match',_11}
(<_16,_15,_14,_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14,_13,_12})-|[{'function_name',{'postprocess',5}}] )-|['compiler_generated'] ) end
'binarify'/2 = fun (_0,_1) -> case <_0,_1> of <{'match',M},Flat> when 'true' -> let <_14> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[One|_3]> when 'true' -> let <_12> = letrec 'lc$^1'/1 = fun (_7) -> case _7 of <[{I,L}|_6]> when 'true' -> let <_10> = case <I,L> of <-1,0> when 'true' -> #{}#
<SPos,SLen> when 'true' -> case Flat of <#{#<_17>(SPos,8,'binary',['unsigned'|['big']]),#<Res>(SLen,8,'binary',['unsigned'|['big']]),#<_18>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> Res
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end in let <_11> = apply 'lc$^1'/1 (_6) in ([_10|_11]-|['compiler_generated'] )
(<[_5|_6]> when 'true' -> apply 'lc$^1'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_21> when 'true' -> (primop 'match_fail' ({'function_clause',_21})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (One) in let <_13> = apply 'lc$^0'/1 (_3) in ([_12|_13]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_22> when 'true' -> (primop 'match_fail' ({'function_clause',_22})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (M) in {'match',_14}
(<_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15})-|[{'function_name',{'binarify',2}}] )-|['compiler_generated'] ) end
'listify'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'match',M},Flat,Uni> when 'true' -> let <_18> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[One|_4]> when 'true' -> let <_16> = letrec 'lc$^1'/1 = fun (_8) -> case _8 of <[{I,L}|_7]> when 'true' -> let <_14> = case <I,L> of <_22,(0-|['compiler_generated'] )> when 'true' -> []
<SPos,SLen> when 'true' -> case Uni of <'true'> when 'true' -> case Flat of <#{#<_23>(SPos,8,'binary',['unsigned'|['big']]),#<Res>(SLen,8,'binary',['unsigned'|['big']]),#<_24>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> call 'unicode':'characters_to_list' (Res,'unicode')
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <Start> = call 'erlang':'+' (SPos,1) in let <End> = call 'erlang':'+' (SPos,SLen) in call 'erlang':'binary_to_list' (Flat,Start,End)
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end end in let <_15> = apply 'lc$^1'/1 (_7) in ([_14|_15]-|['compiler_generated'] )
(<[_6|_7]> when 'true' -> apply 'lc$^1'/1 (_7)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_27> when 'true' -> (primop 'match_fail' ({'function_clause',_27})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (One) in let <_17> = apply 'lc$^0'/1 (_4) in ([_16|_17]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_28> when 'true' -> (primop 'match_fail' ({'function_clause',_28})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (M) in {'match',_18}
(<_21,_20,_19> when 'true' -> (primop 'match_fail' ({'function_clause',_21,_20,_19})-|[{'function_name',{'listify',3}}] )-|['compiler_generated'] ) end
'ubinarify'/2 = fun (_0,_1) -> case <_0,_1> of <{'match',M},Flat> when 'true' -> let <_9> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{I,L}|_3]> when 'true' -> let <_7> = case <I,L> of <-1,0> when 'true' -> #{}#
<SPos,SLen> when 'true' -> case Flat of <#{#<_12>(SPos,8,'binary',['unsigned'|['big']]),#<Res>(SLen,8,'binary',['unsigned'|['big']]),#<_13>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> Res
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end end in let <_8> = apply 'lc$^0'/1 (_3) in ([_7|_8]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (M) in {'match',_9}
<Else,_14> when 'true' -> Else end
'ulistify'/2 = fun (_0,_1) -> case <_0,_1> of <{'match',M},Flat> when 'true' -> let <_9> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{I,L}|_3]> when 'true' -> let <_7> = case <I,L> of <_12,(0-|['compiler_generated'] )> when 'true' -> []
<SPos,SLen> when 'true' -> case Flat of <#{#<_13>(SPos,8,'binary',['unsigned'|['big']]),#<Res>(SLen,8,'binary',['unsigned'|['big']]),#<_14>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> call 'unicode':'characters_to_list' (Res,'unicode')
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end end in let <_8> = apply 'lc$^0'/1 (_3) in ([_7|_8]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_18> when 'true' -> (primop 'match_fail' ({'function_clause',_18})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (M) in {'match',_9}
<Else,_15> when 'true' -> Else end
'process_uparams'/2 = fun (_0,_1) -> case <_0,_1> of <['global'|_X_T],_X_RetType> when 'true' -> call 'erlang':'throw' ('false')
<[{'capture',Values,Type}|T],_X_OldType> when 'true' -> apply 'process_uparams'/2 ([{'capture',Values}|T],Type)
<[H|T],Type> when 'true' -> case apply 'process_uparams'/2 (T,Type) of <{NL,NType}> when 'true' -> {[H|NL],NType}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<[],Type> when 'true' -> {[],Type}
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'process_uparams',2}}] )-|['compiler_generated'] ) end
'ucompile'/2 = fun (_0,_1) -> try let <_2> = call 'unicode':'characters_to_binary' (_0,'unicode') in call 're':'compile' (_2,_1) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('error'-|['compiler_generated'] ),AnyError,_11> when 'true' -> let <_7> = catch call 'erlang':'error' ('new_stacktrace',[_0|[_1|[]]]) in case _7 of <{'EXIT',{'new_stacktrace',[{Mod,_12,L,Loc}|Rest]}}> when 'true' -> call 'erlang':'raise' ('error',AnyError,[{Mod,'compile',L,Loc}|Rest])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_13,_14,_15> when 'true' -> primop 'raise' (_15,_14)-|['compiler_generated'] ) end
'urun'/3 = fun (_0,_1,_2) -> try apply 'urun2'/3 (_0,_1,_2) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('error'-|['compiler_generated'] ),AnyError,_12> when 'true' -> let <_7> = catch call 'erlang':'error' ('new_stacktrace',[_0|[_1|[_2|[]]]]) in case _7 of <{'EXIT',{'new_stacktrace',[{Mod,_13,L,Loc}|Rest]}}> when 'true' -> call 'erlang':'raise' ('error',AnyError,[{Mod,'run',L,Loc}|Rest])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_14,_15,_16> when 'true' -> primop 'raise' (_16,_15)-|['compiler_generated'] ) end
'urun2'/3 = fun (_0,_1,_2) -> let <_3> = catch apply 'process_uparams'/2 (_2,'index') in let <_22,_23> = case _3 of <{A,B}> when 'true' -> <A,B>
<_16> when 'true' -> <_2,'false'> end in let <Subject> = call 'unicode':'characters_to_binary' (_0,'unicode') in let <_9> = case _1 of <BinRE> when call 'erlang':'is_binary' (_1) -> BinRE
<ReCompiled = {'re_pattern',_17,_18,_19,_20}> when 'true' -> ReCompiled
<ListRE> when 'true' -> call 'unicode':'characters_to_binary' (ListRE,'unicode') end in let <Ret> = call 're':'run' (Subject,_9,(_22-|['compiler_generated'] )) in case (_23-|['compiler_generated'] ) of <'binary'> when 'true' -> apply 'ubinarify'/2 (Ret,Subject)
<'list'> when 'true' -> apply 'ulistify'/2 (Ret,Subject)
<_21> when 'true' -> Ret end
'grun'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Subject,RE,_@r0 = {Options,NeedClean}> when 'true' -> try apply 'grun2'/3 (Subject,RE,_@r0) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('error'-|['compiler_generated'] ),AnyError,_18> when 'true' -> let <_7> = catch call 'erlang':'error' ('new_stacktrace',[Subject|[RE|[Options|[]]]]) in case _7 of <{'EXIT',{'new_stacktrace',[{Mod,_19,L,Loc}|Rest]}}> when 'true' -> call 'erlang':'raise' ('error',AnyError,[{Mod,'run',L,Loc}|Rest])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_22,_23,_24> when 'true' -> primop 'raise' (_24,_23)-|['compiler_generated'] ) end
<Subject,RE,{Options,NeedClean,OrigRE}> when 'true' -> try apply 'grun2'/3 (Subject,RE,{Options,NeedClean}) of <_9> -> _9 catch <_12,_11,_10> -> case <_12,_11,_10> of <('error'-|['compiler_generated'] ),AnyError,_20> when 'true' -> let <_13> = catch call 'erlang':'error' ('new_stacktrace',[Subject|[OrigRE|[Options|[]]]]) in case _13 of <{'EXIT',{'new_stacktrace',[{Mod,_21,L,Loc}|Rest]}}> when 'true' -> call 'erlang':'raise' ('error',AnyError,[{Mod,'run',L,Loc}|Rest])
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
(<_25,_26,_27> when 'true' -> primop 'raise' (_27,_26)-|['compiler_generated'] ) end
(<_17,_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_17,_16,_15})-|[{'function_name',{'grun',3}}] )-|['compiler_generated'] ) end
'grun2'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Subject,RE,_@r0 = {Options,NeedClean}> when 'true' -> let <Unicode> = apply 'check_for_unicode'/2 (RE,Options) in let <CRLF> = apply 'check_for_crlf'/2 (RE,Options) in let <FlatSubject> = apply 'to_binary'/2 (Subject,Unicode) in apply 'do_grun'/6 (FlatSubject,Subject,Unicode,CRLF,RE,_@r0)
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'grun2',3}}] )-|['compiler_generated'] ) end
'do_grun'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <FlatSubject,Subject,Unicode,CRLF,RE,{Options0,NeedClean}> when 'true' -> let <_6> = catch apply 'process_parameters'/6 (Options0,0,'false','index',NeedClean,RE) in let <_8> = case _6 of <'badlist'> when 'true' -> call 'erlang':'error' ('badarg',[Subject|[RE|[Options0|[]]]])
<CorrectReturn> when 'true' -> CorrectReturn end in case _8 of <{StrippedOptions,InitialOffset,SelectReturn,ConvertReturn}> when 'true' -> try let <_10> = call 'erlang':'byte_size' (FlatSubject) in let <_11> = apply 'loopexec'/8 (FlatSubject,RE,InitialOffset,_10,Unicode,CRLF,StrippedOptions,'true') in apply 'postprocess'/5 (_11,SelectReturn,ConvertReturn,FlatSubject,Unicode) of <_12> -> _12 catch <_15,_14,_13> -> case <_15,_14,_13> of <('throw'-|['compiler_generated'] ),ErrTuple,_22> when 'true' -> ErrTuple
(<_23,_24,_25> when 'true' -> primop 'raise' (_25,_24)-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_21,_20,_19,_18,_17,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_21,_20,_19,_18,_17,_16})-|[{'function_name',{'do_grun',6}}] )-|['compiler_generated'] ) end
'loopexec'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case <_0,_1,_2,_3,_4,_5,_6,_7> of <_31,_32,X,Y,_33,_34,_35,_36> when call 'erlang':'>' (X,Y) -> {'match',[]}
<Subject,RE,X,Y,Unicode,CRLF,Options,First> when 'true' -> let <_8> = [{'offset',X}|Options] in case call 're':'internal_run' (Subject,RE,_8,First) of <_@r0 = {'error',Err}> when 'true' -> call 'erlang':'throw' (_@r0)
<'nomatch'> when 'true' -> {'match',[]}
<{'match',_@r2 = [{A,B}|More]}> when 'true' -> let <_20> = case <> of <> when call 'erlang':'>' (B,0) -> let <_9> = call 'erlang':'+' (A,B) in apply 'loopexec'/8 (Subject,RE,_9,Y,Unicode,CRLF,Options,'false')
<> when 'true' -> let <_10> = [{'offset',X}|['notempty_atstart'|['anchored'|Options]]] in let <_41,_42> = case call 're':'internal_run' (Subject,RE,_10,'false') of <'nomatch'> when 'true' -> <'match',[]>
<{'match',Other}> when 'true' -> <'match',Other>
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end in case (<(_41-|['compiler_generated'] ),(_42-|['compiler_generated'] )>-|['compiler_generated'] ) of <('match'-|['compiler_generated'] ),M> when 'true' -> let <_15> = case M of <[{_37,NStep}|_38]> when call 'erlang':'>' (NStep,0) -> call 'erlang':'+' (A,NStep)
<_39> when 'true' -> apply 'forward'/5 (Subject,A,1,Unicode,CRLF) end in case apply 'loopexec'/8 (Subject,RE,_15,Y,Unicode,CRLF,Options,'false') of <_@r1 = {'match',MM}> when 'true' -> case M of <[]> when 'true' -> _@r1
<_40> when 'true' -> {'match',[M|MM]} end
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
(<(_43-|['compiler_generated'] ),(_44-|['compiler_generated'] )> when 'true' -> let <_13> = {(_43-|['compiler_generated'] ),(_44-|['compiler_generated'] )} in primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end end in case _20 of <{'match',Rest}> when 'true' -> {'match',[_@r2|Rest]}
(<_21> when 'true' -> primop 'match_fail' ({'badmatch',_21})-|['compiler_generated'] ) end
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end end
'forward'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_X_Chal,A,0,_14,_15> when 'true' -> A
<Chal,A,N,U,'true'> when 'true' -> case Chal of <#{#<_16>(A,8,'binary',['unsigned'|['big']]),#<Tl>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case Tl of <#{#<13>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']]),#<_17>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_7> = call 'erlang':'+' (A,2) in let <_6> = call 'erlang':'-' (N,1) in apply 'forward'/5 (Chal,_7,_6,U,'true')
<_18> when 'true' -> apply 'forward2'/5 (Chal,A,N,U,'true') end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<Chal,A,N,U,'false'> when 'true' -> apply 'forward2'/5 (Chal,A,N,U,'false')
(<_13,_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10,_9})-|[{'function_name',{'forward',5}}] )-|['compiler_generated'] ) end
'forward2'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Chal,A,N,'false',CRLF> when 'true' -> let <_6> = call 'erlang':'+' (A,1) in let <_5> = call 'erlang':'-' (N,1) in apply 'forward'/5 (Chal,_6,_5,'false',CRLF)
<Chal,A,N,'true',CRLF> when 'true' -> case Chal of <#{#<_18>(A,8,'binary',['unsigned'|['big']]),#<Tl>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_9> = case Tl of <#{#<1>(1,1,'integer',['unsigned'|['big']]),#<1>(1,1,'integer',['unsigned'|['big']]),#<0>(1,1,'integer',['unsigned'|['big']]),#<_19>(5,1,'integer',['unsigned'|['big']]),#<_20>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> 2
<#{#<1>(1,1,'integer',['unsigned'|['big']]),#<1>(1,1,'integer',['unsigned'|['big']]),#<1>(1,1,'integer',['unsigned'|['big']]),#<0>(1,1,'integer',['unsigned'|['big']]),#<_21>(4,1,'integer',['unsigned'|['big']]),#<_22>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> 3
<#{#<1>(1,1,'integer',['unsigned'|['big']]),#<1>(1,1,'integer',['unsigned'|['big']]),#<1>(1,1,'integer',['unsigned'|['big']]),#<1>(1,1,'integer',['unsigned'|['big']]),#<0>(1,1,'integer',['unsigned'|['big']]),#<_23>(3,1,'integer',['unsigned'|['big']]),#<_24>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> 4
<_25> when 'true' -> 1 end in let <_12> = call 'erlang':'+' (A,_9) in let <_11> = call 'erlang':'-' (N,1) in apply 'forward'/5 (Chal,_12,_11,'true',CRLF)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_17,_16,_15,_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_17,_16,_15,_14,_13})-|[{'function_name',{'forward2',5}}] )-|['compiler_generated'] ) end
'copt'/1 = fun (_0) -> case _0 of <'caseless'> when 'true' -> 'true'
<'no_start_optimize'> when 'true' -> 'true'
<'never_utf'> when 'true' -> 'true'
<'ucp'> when 'true' -> 'true'
<'dollar_endonly'> when 'true' -> 'true'
<'dotall'> when 'true' -> 'true'
<'extended'> when 'true' -> 'true'
<'firstline'> when 'true' -> 'true'
<'multiline'> when 'true' -> 'true'
<'no_auto_capture'> when 'true' -> 'true'
<'dupnames'> when 'true' -> 'true'
<'ungreedy'> when 'true' -> 'true'
<'unicode'> when 'true' -> 'true'
<_2> when 'true' -> 'false' end
'runopt'/1 = fun (_0) -> case _0 of <'notempty'> when 'true' -> 'true'
<'notempty_atstart'> when 'true' -> 'true'
<'notbol'> when 'true' -> 'true'
<'noteol'> when 'true' -> 'true'
<{'offset',_2}> when 'true' -> 'true'
<{'capture',_3,_4}> when 'true' -> 'true'
<{'capture',_5}> when 'true' -> 'true'
<'global'> when 'true' -> 'true'
<{'match_limit',_6}> when 'true' -> 'true'
<{'match_limit_recursion',_7}> when 'true' -> 'true'
<_8> when 'true' -> 'false' end
'to_binary'/2 = fun (_0,_1) -> case <_0,_1> of <Bin,_X_IsUnicode> when call 'erlang':'is_binary' (Bin) -> Bin
<Data,'true'> when 'true' -> call 'unicode':'characters_to_binary' (Data,'unicode')
<Data,'false'> when 'true' -> call 'erlang':'iolist_to_binary' (Data)
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'to_binary',2}}] )-|['compiler_generated'] ) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('re')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('re',_0) end