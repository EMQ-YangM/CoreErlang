module 'erl_anno' ['column'/1,'end_location'/1,'file'/1,'from_term'/1,'generated'/1,'is_anno'/1,'line'/1,'location'/1,'module_info'/0,'module_info'/1,'new'/1,'record'/1,'set_file'/2,'set_generated'/2,'set_line'/2,'set_location'/2,'set_record'/2,'set_text'/2,'text'/1,'to_term'/1] attributes [ 'file' = [{[115|[114|[99|[47|[101|[114|[108|[95|[97|[110|[110|[111|[46|[101|[114|[108]]]]]]]]]]]]]]]],1}]
, 'export_type' = [{'anno',0}|[{'line',0}|[{'column',0}|[{'location',0}|[{'text',0}]]]]]
, 'export_type' = [{'anno_term',0}]
, 'type' = [{'annotation',{'type',49,'union',[{'type',49,'tuple',[{'atom',49,'file'}|[{'user_type',49,'filename',[]}]]}|[{'type',50,'tuple',[{'atom',50,'generated'}|[{'user_type',50,'generated',[]}]]}|[{'type',51,'tuple',[{'atom',51,'location'}|[{'user_type',51,'location',[]}]]}|[{'type',52,'tuple',[{'atom',52,'record'}|[{'user_type',52,'record',[]}]]}|[{'type',53,'tuple',[{'atom',53,'text'}|[{'type',53,'string',[]}]]}]]]]]},[]}]
, 'opaque' = [{'anno',{'type',58,'union',[{'user_type',58,'location',[]}|[{'type',58,'nonempty_list',[{'user_type',58,'annotation',[]}]}]]},[]}]
, 'type' = [{'anno_term',{'type',60,'term',[]},[]}]
, 'type' = [{'column',{'type',62,'pos_integer',[]},[]}]
, 'type' = [{'generated',{'type',63,'boolean',[]},[]}]
, 'type' = [{'filename',{'remote_type',64,[{'atom',64,'file'}|[{'atom',64,'filename_all'}|[[]]]]},[]}]
, 'type' = [{'line',{'type',65,'non_neg_integer',[]},[]}]
, 'type' = [{'location',{'type',66,'union',[{'user_type',66,'line',[]}|[{'type',66,'tuple',[{'user_type',66,'line',[]}|[{'user_type',66,'column',[]}]]}]]},[]}]
, 'type' = [{'record',{'type',67,'boolean',[]},[]}]
, 'type' = [{'text',{'type',68,'string',[]},[]}]
, 'spec' = [{{'to_term',1},[{'type',79,'bounded_fun',[{'type',79,'fun',[{'type',79,'product',[{'var',79,'Anno'}]}|[{'user_type',79,'anno_term',[]}]]}|[[{'type',80,'constraint',[{'atom',80,'is_subtype'}|[[{'var',80,'Anno'}|[{'user_type',80,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'from_term',1},[{'type',90,'bounded_fun',[{'type',90,'fun',[{'type',90,'product',[{'var',90,'Term'}]}|[{'var',90,'Anno'}]]}|[[{'type',91,'constraint',[{'atom',91,'is_subtype'}|[[{'var',91,'Term'}|[{'user_type',91,'anno_term',[]}]]]]}|[{'type',92,'constraint',[{'atom',92,'is_subtype'}|[[{'var',92,'Anno'}|[{'user_type',92,'anno',[]}]]]]}]]]]}]}]
, 'spec' = [{{'new',1},[{'type',108,'bounded_fun',[{'type',108,'fun',[{'type',108,'product',[{'var',108,'Location'}]}|[{'user_type',108,'anno',[]}]]}|[[{'type',109,'constraint',[{'atom',109,'is_subtype'}|[[{'var',109,'Location'}|[{'user_type',109,'location',[]}]]]]}]]]}]}]
, 'spec' = [{{'is_anno',1},[{'type',126,'bounded_fun',[{'type',126,'fun',[{'type',126,'product',[{'var',126,'Term'}]}|[{'type',126,'boolean',[]}]]}|[[{'type',127,'constraint',[{'atom',127,'is_subtype'}|[[{'var',127,'Term'}|[{'type',127,'any',[]}]]]]}]]]}]}]
, 'spec' = [{{'column',1},[{'type',164,'bounded_fun',[{'type',164,'fun',[{'type',164,'product',[{'var',164,'Anno'}]}|[{'type',164,'union',[{'user_type',164,'column',[]}|[{'atom',164,'undefined'}]]}]]}|[[{'type',165,'constraint',[{'atom',165,'is_subtype'}|[[{'var',165,'Anno'}|[{'user_type',165,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'end_location',1},[{'type',179,'bounded_fun',[{'type',179,'fun',[{'type',179,'product',[{'var',179,'Anno'}]}|[{'type',179,'union',[{'user_type',179,'location',[]}|[{'atom',179,'undefined'}]]}]]}|[[{'type',180,'constraint',[{'atom',180,'is_subtype'}|[[{'var',180,'Anno'}|[{'user_type',180,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'file',1},[{'type',195,'bounded_fun',[{'type',195,'fun',[{'type',195,'product',[{'var',195,'Anno'}]}|[{'type',195,'union',[{'user_type',195,'filename',[]}|[{'atom',195,'undefined'}]]}]]}|[[{'type',196,'constraint',[{'atom',196,'is_subtype'}|[[{'var',196,'Anno'}|[{'user_type',196,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'generated',1},[{'type',205,'bounded_fun',[{'type',205,'fun',[{'type',205,'product',[{'var',205,'Anno'}]}|[{'user_type',205,'generated',[]}]]}|[[{'type',206,'constraint',[{'atom',206,'is_subtype'}|[[{'var',206,'Anno'}|[{'user_type',206,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'line',1},[{'type',215,'bounded_fun',[{'type',215,'fun',[{'type',215,'product',[{'var',215,'Anno'}]}|[{'user_type',215,'line',[]}]]}|[[{'type',216,'constraint',[{'atom',216,'is_subtype'}|[[{'var',216,'Anno'}|[{'user_type',216,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'location',1},[{'type',226,'bounded_fun',[{'type',226,'fun',[{'type',226,'product',[{'var',226,'Anno'}]}|[{'user_type',226,'location',[]}]]}|[[{'type',227,'constraint',[{'atom',227,'is_subtype'}|[[{'var',227,'Anno'}|[{'user_type',227,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'record',1},[{'type',236,'bounded_fun',[{'type',236,'fun',[{'type',236,'product',[{'var',236,'Anno'}]}|[{'user_type',236,'record',[]}]]}|[[{'type',237,'constraint',[{'atom',237,'is_subtype'}|[[{'var',237,'Anno'}|[{'user_type',237,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'text',1},[{'type',246,'bounded_fun',[{'type',246,'fun',[{'type',246,'product',[{'var',246,'Anno'}]}|[{'type',246,'union',[{'user_type',246,'text',[]}|[{'atom',246,'undefined'}]]}]]}|[[{'type',247,'constraint',[{'atom',247,'is_subtype'}|[[{'var',247,'Anno'}|[{'user_type',247,'anno',[]}]]]]}]]]}]}]
, 'spec' = [{{'set_file',2},[{'type',256,'bounded_fun',[{'type',256,'fun',[{'type',256,'product',[{'var',256,'File'}|[{'var',256,'Anno'}]]}|[{'var',256,'Anno'}]]}|[[{'type',257,'constraint',[{'atom',257,'is_subtype'}|[[{'var',257,'File'}|[{'user_type',257,'filename',[]}]]]]}|[{'type',258,'constraint',[{'atom',258,'is_subtype'}|[[{'var',258,'Anno'}|[{'user_type',258,'anno',[]}]]]]}]]]]}]}]
, 'spec' = [{{'set_generated',2},[{'type',263,'bounded_fun',[{'type',263,'fun',[{'type',263,'product',[{'var',263,'Generated'}|[{'var',263,'Anno'}]]}|[{'var',263,'Anno'}]]}|[[{'type',264,'constraint',[{'atom',264,'is_subtype'}|[[{'var',264,'Generated'}|[{'user_type',264,'generated',[]}]]]]}|[{'type',265,'constraint',[{'atom',265,'is_subtype'}|[[{'var',265,'Anno'}|[{'user_type',265,'anno',[]}]]]]}]]]]}]}]
, 'spec' = [{{'set_line',2},[{'type',270,'bounded_fun',[{'type',270,'fun',[{'type',270,'product',[{'var',270,'Line'}|[{'var',270,'Anno'}]]}|[{'var',270,'Anno'}]]}|[[{'type',271,'constraint',[{'atom',271,'is_subtype'}|[[{'var',271,'Line'}|[{'user_type',271,'line',[]}]]]]}|[{'type',272,'constraint',[{'atom',272,'is_subtype'}|[[{'var',272,'Anno'}|[{'user_type',272,'anno',[]}]]]]}]]]]}]}]
, 'spec' = [{{'set_location',2},[{'type',282,'bounded_fun',[{'type',282,'fun',[{'type',282,'product',[{'var',282,'Location'}|[{'var',282,'Anno'}]]}|[{'var',282,'Anno'}]]}|[[{'type',283,'constraint',[{'atom',283,'is_subtype'}|[[{'var',283,'Location'}|[{'user_type',283,'location',[]}]]]]}|[{'type',284,'constraint',[{'atom',284,'is_subtype'}|[[{'var',284,'Anno'}|[{'user_type',284,'anno',[]}]]]]}]]]]}]}]
, 'spec' = [{{'set_record',2},[{'type',299,'bounded_fun',[{'type',299,'fun',[{'type',299,'product',[{'var',299,'Record'}|[{'var',299,'Anno'}]]}|[{'var',299,'Anno'}]]}|[[{'type',300,'constraint',[{'atom',300,'is_subtype'}|[[{'var',300,'Record'}|[{'user_type',300,'record',[]}]]]]}|[{'type',301,'constraint',[{'atom',301,'is_subtype'}|[[{'var',301,'Anno'}|[{'user_type',301,'anno',[]}]]]]}]]]]}]}]
, 'spec' = [{{'set_text',2},[{'type',306,'bounded_fun',[{'type',306,'fun',[{'type',306,'product',[{'var',306,'Text'}|[{'var',306,'Anno'}]]}|[{'var',306,'Anno'}]]}|[[{'type',307,'constraint',[{'atom',307,'is_subtype'}|[[{'var',307,'Text'}|[{'user_type',307,'text',[]}]]]]}|[{'type',308,'constraint',[{'atom',308,'is_subtype'}|[[{'var',308,'Anno'}|[{'user_type',308,'anno',[]}]]]]}]]]]}]}] ] 'to_term'/1 = fun (_0) -> _0
'from_term'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'<' (_0,0) in call 'erlang':'and' (_1,_2) -> let <_3> = call 'erlang':'-' (Line) in let <_4> = apply 'new'/1 (_3) in apply 'set_generated'/2 ('true',_4)
<Term> when 'true' -> Term end
'new'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> apply 'new_location'/1 (Line)
<Loc = {Line,Column}> when try let <_3> = call 'erlang':'is_integer' (Line) in let <_4> = call 'erlang':'>=' (Line,0) in (let <_7> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'and' (_4,_8) in call 'erlang':'and' (_3,_9)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> apply 'new_location'/1 (Loc)
<Term> when 'true' -> call 'erlang':'error' ('badarg',[Term|[]]) end
'new_location'/1 = fun (_0) -> _0
'is_anno'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> 'true'
<{Line,Column}> when try let <_3> = call 'erlang':'is_integer' (Line) in let <_4> = call 'erlang':'>=' (Line,0) in (let <_7> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'and' (_4,_8) in call 'erlang':'and' (_3,_9)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<Anno> when 'true' -> (case <> of (<> when call 'erlang':'=/=' (Anno,[]) -> (case apply 'is_anno1'/1 (Anno) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'lists':'keymember' ('location',1,Anno)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_11}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'is_anno1'/1 = fun (_0) -> case _0 of <[{Item,Value}|Anno]> when 'true' -> (case apply 'is_anno2'/2 (Item,Value) of (<('true'-|['compiler_generated'] )> when 'true' -> apply 'is_anno1'/1 (Anno)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_1> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_1}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<A> when 'true' -> call 'erlang':'=:=' (A,[]) end
'is_anno2'/2 = fun (_0,_1) -> case <_0,_1> of <'location',Line> when let <_2> = call 'erlang':'is_integer' (Line) in let <_3> = call 'erlang':'>=' (Line,0) in call 'erlang':'and' (_2,_3) -> 'true'
<'location',{Line,Column}> when try let <_4> = call 'erlang':'is_integer' (Line) in let <_5> = call 'erlang':'>=' (Line,0) in (let <_8> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_6> when 'true' -> _6-|['compiler_generated'] ) end in let <_9> = call 'erlang':'=:=' ((_8-|['compiler_generated'] ),'true') in let <_10> = call 'erlang':'and' (_5,_9) in call 'erlang':'and' (_4,_10)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<'generated','true'> when 'true' -> 'true'
<'file',Filename> when 'true' -> apply 'is_filename'/1 (Filename)
<'record','true'> when 'true' -> 'true'
<'text',Text> when 'true' -> apply 'is_string'/1 (Text)
<_13,_14> when 'true' -> 'false' end
'is_filename'/1 = fun (_0) -> (case <> of (<> when call 'erlang':'is_list' (_0) -> 'true'-|['compiler_generated'] )
(<> when 'true' -> call 'erlang':'is_binary' (_0)-|['compiler_generated'] ) end-|['compiler_generated'] )
'is_string'/1 = fun (_0) -> call 'erlang':'is_list' (_0)
'column'/1 = fun (_0) -> case _0 of <{Line,Column}> when try let <_1> = call 'erlang':'is_integer' (Line) in let <_2> = call 'erlang':'>=' (Line,0) in (let <_5> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_3> when 'true' -> _3-|['compiler_generated'] ) end in let <_6> = call 'erlang':'=:=' ((_5-|['compiler_generated'] ),'true') in let <_7> = call 'erlang':'and' (_2,_6) in call 'erlang':'and' (_1,_7)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> Column
<Line> when let <_8> = call 'erlang':'is_integer' (_0) in let <_9> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_8,_9) -> 'undefined'
<Anno> when 'true' -> case apply 'location'/1 (Anno) of <{_X_Line,Column}> when 'true' -> Column
<_X_Line> when 'true' -> 'undefined' end end
'end_location'/1 = fun (_0) -> case apply 'text'/1 (_0) of <'undefined'> when 'true' -> 'undefined'
<Text> when 'true' -> case apply 'location'/1 (_0) of <{Line,Column}> when 'true' -> apply 'end_location'/3 (Text,Line,Column)
<Line> when 'true' -> apply 'end_location'/2 (Text,Line) end end
'file'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> 'undefined'
<{Line,Column}> when try let <_3> = call 'erlang':'is_integer' (Line) in let <_4> = call 'erlang':'>=' (Line,0) in (let <_7> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'and' (_4,_8) in call 'erlang':'and' (_3,_9)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> 'undefined'
<Anno> when 'true' -> apply 'anno_info'/2 (Anno,'file') end
'generated'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> 'false'
<{Line,Column}> when try let <_3> = call 'erlang':'is_integer' (Line) in let <_4> = call 'erlang':'>=' (Line,0) in (let <_7> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'and' (_4,_8) in call 'erlang':'and' (_3,_9)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> 'false'
<Anno> when 'true' -> apply 'anno_info'/3 (Anno,'generated','false') end
'line'/1 = fun (_0) -> case apply 'location'/1 (_0) of <{Line,_X_Column}> when 'true' -> Line
<Line> when 'true' -> Line end
'location'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> Line
<Location = {Line,Column}> when try let <_3> = call 'erlang':'is_integer' (Line) in let <_4> = call 'erlang':'>=' (Line,0) in (let <_7> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'and' (_4,_8) in call 'erlang':'and' (_3,_9)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> Location
<Anno> when 'true' -> apply 'anno_info'/2 (Anno,'location') end
'record'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> 'false'
<{Line,Column}> when try let <_3> = call 'erlang':'is_integer' (Line) in let <_4> = call 'erlang':'>=' (Line,0) in (let <_7> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'and' (_4,_8) in call 'erlang':'and' (_3,_9)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> 'false'
<Anno> when 'true' -> apply 'anno_info'/3 (Anno,'record','false') end
'text'/1 = fun (_0) -> case _0 of <Line> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> 'undefined'
<{Line,Column}> when try let <_3> = call 'erlang':'is_integer' (Line) in let <_4> = call 'erlang':'>=' (Line,0) in (let <_7> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_5> when 'true' -> _5-|['compiler_generated'] ) end in let <_8> = call 'erlang':'=:=' ((_7-|['compiler_generated'] ),'true') in let <_9> = call 'erlang':'and' (_4,_8) in call 'erlang':'and' (_3,_9)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> 'undefined'
<Anno> when 'true' -> apply 'anno_info'/2 (Anno,'text') end
'set_file'/2 = fun (_0,_1) -> apply 'set'/3 ('file',_0,_1)
'set_generated'/2 = fun (_0,_1) -> apply 'set'/3 ('generated',_0,_1)
'set_line'/2 = fun (_0,_1) -> case apply 'location'/1 (_1) of <{_X_Line,Column}> when 'true' -> apply 'set_location'/2 ({_0,Column},_1)
<_X_Line> when 'true' -> apply 'set_location'/2 (_0,_1) end
'set_location'/2 = fun (_0,_1) -> case <_0,_1> of <Line,L> when try let <_2> = call 'erlang':'is_integer' (L) in let <_3> = call 'erlang':'>=' (L,0) in let <_4> = call 'erlang':'is_integer' (Line) in let <_5> = call 'erlang':'>=' (Line,0) in let <_6> = call 'erlang':'and' (_4,_5) in let <_7> = call 'erlang':'and' (_3,_6) in call 'erlang':'and' (_2,_7) of <Try> -> Try catch <T,R> -> 'false' -> apply 'new_location'/1 (Line)
<Line,{L,Column}> when try let <_8> = call 'erlang':'is_integer' (L) in let <_9> = call 'erlang':'>=' (L,0) in (let <_12> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_10> when 'true' -> _10-|['compiler_generated'] ) end in let <_13> = call 'erlang':'=:=' ((_12-|['compiler_generated'] ),'true') in let <_14> = call 'erlang':'is_integer' (Line) in let <_15> = call 'erlang':'>=' (Line,0) in let <_16> = call 'erlang':'and' (_14,_15) in let <_17> = call 'erlang':'and' (_13,_16) in let <_18> = call 'erlang':'and' (_9,_17) in call 'erlang':'and' (_8,_18)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> apply 'new_location'/1 (Line)
<Loc = {L,C},Line> when try let <_19> = call 'erlang':'is_integer' (Line) in let <_20> = call 'erlang':'>=' (Line,0) in let <_21> = call 'erlang':'is_integer' (L) in let <_22> = call 'erlang':'>=' (L,0) in (let <_25> = case call 'erlang':'is_integer' (C) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (C,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_23> when 'true' -> _23-|['compiler_generated'] ) end in let <_26> = call 'erlang':'=:=' ((_25-|['compiler_generated'] ),'true') in let <_27> = call 'erlang':'and' (_22,_26) in let <_28> = call 'erlang':'and' (_21,_27) in let <_29> = call 'erlang':'and' (_20,_28) in call 'erlang':'and' (_19,_29)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> apply 'new_location'/1 (Loc)
<Loc = {L,C},{Line,Column}> when try let <_30> = call 'erlang':'is_integer' (Line) in let <_31> = call 'erlang':'>=' (Line,0) in (let <_34> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_32> when 'true' -> _32-|['compiler_generated'] ) end in let <_35> = call 'erlang':'=:=' ((_34-|['compiler_generated'] ),'true') in let <_36> = call 'erlang':'is_integer' (L) in let <_37> = call 'erlang':'>=' (L,0) in (let <_40> = case call 'erlang':'is_integer' (C) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (C,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_38> when 'true' -> _38-|['compiler_generated'] ) end in let <_41> = call 'erlang':'=:=' ((_40-|['compiler_generated'] ),'true') in let <_42> = call 'erlang':'and' (_37,_41) in let <_43> = call 'erlang':'and' (_36,_42) in let <_44> = call 'erlang':'and' (_35,_43) in let <_45> = call 'erlang':'and' (_31,_44) in call 'erlang':'and' (_30,_45)-|['compiler_generated'] )-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> apply 'new_location'/1 (Loc)
<Location,Anno> when 'true' -> apply 'set'/3 ('location',Location,Anno) end
'set_record'/2 = fun (_0,_1) -> apply 'set'/3 ('record',_0,_1)
'set_text'/2 = fun (_0,_1) -> apply 'set'/3 ('text',_0,_1)
'set'/3 = fun (_0,_1,_2) -> let <_3> = apply 'is_settable'/2 (_0,_1) in case <_3,_2> of <('true'-|['compiler_generated'] ),Line> when let <_4> = call 'erlang':'is_integer' (Line) in let <_5> = call 'erlang':'>=' (Line,0) in call 'erlang':'and' (_4,_5) -> apply 'set_anno'/3 (_0,_1,[{'location',Line}|[]])
<('true'-|['compiler_generated'] ),Location = ({L,C}-|['compiler_generated'] )> when try let <_6> = call 'erlang':'is_integer' (L) in let <_7> = call 'erlang':'>=' (L,0) in (let <_10> = case call 'erlang':'is_integer' (C) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (C,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_8> when 'true' -> _8-|['compiler_generated'] ) end in let <_11> = call 'erlang':'=:=' ((_10-|['compiler_generated'] ),'true') in let <_12> = call 'erlang':'and' (_7,_11) in call 'erlang':'and' (_6,_12)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> apply 'set_anno'/3 (_0,_1,[{'location',Location}|[]])
<('true'-|['compiler_generated'] ),A> when let <_13> = call 'erlang':'is_list' (A) in let <_14> = call 'erlang':'=/=' (A,[]) in call 'erlang':'and' (_13,_14) -> apply 'set_anno'/3 (_0,_1,_2)
<(_20-|['compiler_generated'] ),(_21-|['compiler_generated'] )> when 'true' -> call 'erlang':'error' ('badarg',[_0|[_1|[_2|[]]]]) end
'set_anno'/3 = fun (_0,_1,_2) -> case apply 'default'/2 (_0,_1) of <'true'> when 'true' -> apply 'reset'/2 (_2,_0)
<'false'> when 'true' -> let <_4> = case apply 'anno_info'/2 (_2,_0) of <'undefined'> when 'true' -> [{_0,_1}|_2]
<_10> when 'true' -> call 'lists':'keyreplace' (_0,1,_2,{_0,_1}) end in apply 'reset_simplify'/1 (_4)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
'reset'/2 = fun (_0,_1) -> let <A> = call 'lists':'keydelete' (_1,1,_0) in apply 'reset_simplify'/1 (A)
'reset_simplify'/1 = fun (_0) -> apply 'simplify'/1 (_0)
'simplify'/1 = fun (_0) -> case _0 of <[{'location',Location}|[]]> when 'true' -> Location
<Anno> when 'true' -> Anno end
'anno_info'/3 = fun (_0,_1,_2) -> try call 'lists':'keyfind' (_1,1,_0) of <_3> -> case _3 of <'false'> when 'true' -> _2
<{_11,Value}> when call 'erlang':'=:=' (_11,_1) -> Value
(<_4> when 'true' -> primop 'match_fail' ({'try_clause',_4})-|['compiler_generated'] ) end catch <_7,_6,_5> -> call 'erlang':'error' ('badarg',[_0|[]])
'anno_info'/2 = fun (_0,_1) -> try call 'lists':'keyfind' (_1,1,_0) of <_2> -> case _2 of <{_9,Value}> when call 'erlang':'=:=' (_9,_1) -> Value
<'false'> when 'true' -> 'undefined'
(<_3> when 'true' -> primop 'match_fail' ({'try_clause',_3})-|['compiler_generated'] ) end catch <_6,_5,_4> -> call 'erlang':'error' ('badarg',[_0|[]])
'end_location'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],Line,Column> when 'true' -> {Line,Column}
<[10|String],Line,_X_Column> when 'true' -> let <_3> = call 'erlang':'+' (Line,1) in apply 'end_location'/3 (String,_3,1)
<[_8|String],Line,Column> when 'true' -> let <_4> = call 'erlang':'+' (Column,1) in apply 'end_location'/3 (String,Line,_4)
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'end_location',3}}] )-|['compiler_generated'] ) end
'end_location'/2 = fun (_0,_1) -> case <_0,_1> of <[],Line> when 'true' -> Line
<[10|String],Line> when 'true' -> let <_2> = call 'erlang':'+' (Line,1) in apply 'end_location'/2 (String,_2)
<[_5|String],Line> when 'true' -> apply 'end_location'/2 (String,Line)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'end_location',2}}] )-|['compiler_generated'] ) end
'is_settable'/2 = fun (_0,_1) -> case <_0,_1> of <'file',File> when 'true' -> apply 'is_filename'/1 (File)
<'generated',Boolean> when let <_2> = call 'erlang':'=:=' (Boolean,'true') in let <_4> = call 'erlang':'=:=' (Boolean,'false') in call 'erlang':'or' (_2,_4) -> 'true'
<'location',Line> when let <_5> = call 'erlang':'is_integer' (Line) in let <_6> = call 'erlang':'>=' (Line,0) in call 'erlang':'and' (_5,_6) -> 'true'
<'location',{Line,Column}> when try let <_7> = call 'erlang':'is_integer' (Line) in let <_8> = call 'erlang':'>=' (Line,0) in (let <_11> = case call 'erlang':'is_integer' (Column) of (<('true'-|['compiler_generated'] )> when 'true' -> call 'erlang':'>=' (Column,1)-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> 'false'-|['compiler_generated'] )
(<_9> when 'true' -> _9-|['compiler_generated'] ) end in let <_12> = call 'erlang':'=:=' ((_11-|['compiler_generated'] ),'true') in let <_13> = call 'erlang':'and' (_8,_12) in call 'erlang':'and' (_7,_13)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<'record',Boolean> when let <_14> = call 'erlang':'=:=' (Boolean,'true') in let <_16> = call 'erlang':'=:=' (Boolean,'false') in call 'erlang':'or' (_14,_16) -> 'true'
<'text',Text> when 'true' -> apply 'is_string'/1 (Text)
<_19,_20> when 'true' -> 'false' end
'default'/2 = fun (_0,_1) -> case <_0,_1> of <'generated','false'> when 'true' -> 'true'
<'record','false'> when 'true' -> 'true'
<_4,_5> when 'true' -> 'false' end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('erl_anno')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('erl_anno',_0) end