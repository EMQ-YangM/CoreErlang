module 'pool' ['attach'/1,'do_spawn'/4,'get_node'/0,'get_nodes'/0,'get_nodes_and_load'/0,'handle_call'/3,'handle_cast'/2,'handle_info'/2,'init'/1,'module_info'/0,'module_info'/1,'pspawn'/3,'pspawn_link'/3,'start'/1,'start'/2,'statistic_collector'/0,'stop'/0,'terminate'/2] attributes [ 'file' = [{[115|[114|[99|[47|[112|[111|[111|[108|[46|[101|[114|[108]]]]]]]]]]]],1}]
, 'spec' = [{{'start',1},[{'type',56,'bounded_fun',[{'type',56,'fun',[{'type',56,'product',[{'var',56,'Name'}]}|[{'var',56,'Nodes'}]]}|[[{'type',57,'constraint',[{'atom',57,'is_subtype'}|[[{'var',57,'Name'}|[{'type',57,'atom',[]}]]]]}|[{'type',58,'constraint',[{'atom',58,'is_subtype'}|[[{'var',58,'Nodes'}|[{'type',58,'list',[{'type',58,'node',[]}]}]]]]}]]]]}]}]
, 'spec' = [{{'start',2},[{'type',62,'bounded_fun',[{'type',62,'fun',[{'type',62,'product',[{'var',62,'Name'}|[{'var',62,'Args'}]]}|[{'var',62,'Nodes'}]]}|[[{'type',63,'constraint',[{'atom',63,'is_subtype'}|[[{'var',63,'Name'}|[{'type',63,'atom',[]}]]]]}|[{'type',64,'constraint',[{'atom',64,'is_subtype'}|[[{'var',64,'Args'}|[{'type',64,'string',[]}]]]]}|[{'type',65,'constraint',[{'atom',65,'is_subtype'}|[[{'var',65,'Nodes'}|[{'type',65,'list',[{'type',65,'node',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'get_nodes',0},[{'type',76,'fun',[{'type',76,'product',[]}|[{'type',76,'list',[{'type',76,'node',[]}]}]]}]}]
, 'spec' = [{{'attach',1},[{'type',80,'bounded_fun',[{'type',80,'fun',[{'type',80,'product',[{'var',80,'Node'}]}|[{'type',80,'union',[{'atom',80,'already_attached'}|[{'atom',80,'attached'}]]}]]}|[[{'type',81,'constraint',[{'atom',81,'is_subtype'}|[[{'var',81,'Node'}|[{'type',81,'node',[]}]]]]}]]]}]}]
, 'spec' = [{{'get_node',0},[{'type',88,'fun',[{'type',88,'product',[]}|[{'type',88,'node',[]}]]}]}]
, 'spec' = [{{'pspawn',3},[{'type',92,'bounded_fun',[{'type',92,'fun',[{'type',92,'product',[{'var',92,'Mod'}|[{'var',92,'Fun'}|[{'var',92,'Args'}]]]}|[{'type',92,'pid',[]}]]}|[[{'type',93,'constraint',[{'atom',93,'is_subtype'}|[[{'var',93,'Mod'}|[{'type',93,'module',[]}]]]]}|[{'type',94,'constraint',[{'atom',94,'is_subtype'}|[[{'var',94,'Fun'}|[{'type',94,'atom',[]}]]]]}|[{'type',95,'constraint',[{'atom',95,'is_subtype'}|[[{'var',95,'Args'}|[{'type',95,'list',[{'type',95,'term',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'pspawn_link',3},[{'type',99,'bounded_fun',[{'type',99,'fun',[{'type',99,'product',[{'var',99,'Mod'}|[{'var',99,'Fun'}|[{'var',99,'Args'}]]]}|[{'type',99,'pid',[]}]]}|[[{'type',100,'constraint',[{'atom',100,'is_subtype'}|[[{'var',100,'Mod'}|[{'type',100,'module',[]}]]]]}|[{'type',101,'constraint',[{'atom',101,'is_subtype'}|[[{'var',101,'Fun'}|[{'type',101,'atom',[]}]]]]}|[{'type',102,'constraint',[{'atom',102,'is_subtype'}|[[{'var',102,'Args'}|[{'type',102,'list',[{'type',102,'term',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'stop',0},[{'type',119,'fun',[{'type',119,'product',[]}|[{'atom',119,'stopped'}]]}]}]
, 'spec' = [{{'do_spawn',4},[{'type',173,'fun',[{'type',173,'product',[{'type',173,'pid',[]}|[{'type',173,'module',[]}|[{'type',173,'atom',[]}|[{'type',173,'list',[{'type',173,'term',[]}]}]]]]}|[{'type',173,'term',[]}]]}]}] ] 'start'/1 = fun (_0) -> apply 'start'/2 (_0,[])
'start'/2 = fun (_0,_1) -> case <_0,_1> of <Name,Args> when call 'erlang':'is_atom' (Name) -> do (call ('gen_server'-|['result_not_wanted'] ):('start'-|['result_not_wanted'] ) (({'global','pool_master'}-|['result_not_wanted'] ),('pool'-|['result_not_wanted'] ),([]-|['result_not_wanted'] ),([]-|['result_not_wanted'] ))-|['result_not_wanted'] ) let <Hosts> = call 'net_adm':'host_file' () in let <Nodes> = apply 'start_nodes'/3 (Hosts,Name,Args) in let <_5> = 'attach'/1 in do call 'lists':'foreach' (_5,Nodes) Nodes
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'start',2}}] )-|['compiler_generated'] ) end
'get_nodes'/0 = fun () -> let <_0> = apply 'get_nodes_and_load'/0 () in apply 'get_elements'/2 (2,_0)
'attach'/1 = fun (_0) -> call 'gen_server':'call' ({'global','pool_master'},{'attach',_0})
'get_nodes_and_load'/0 = fun () -> call 'gen_server':'call' ({'global','pool_master'},'get_nodes')
'get_node'/0 = fun () -> call 'gen_server':'call' ({'global','pool_master'},'get_node')
'pspawn'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'group_leader' () in call 'gen_server':'call' ({'global','pool_master'},{'spawn',_3,_0,_1,_2})
'pspawn_link'/3 = fun (_0,_1,_2) -> let <_3> = apply 'get_node'/0 () in call 'erlang':'spawn_link' (_3,_0,_1,_2)
'start_nodes'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],_9,_10> when 'true' -> []
<[Host|Tail],Name,Args> when 'true' -> case call 'slave':'start' (Host,Name,Args) of <{'error',_@r0 = {'already_running',Node}}> when 'true' -> do call 'io':'format' ([67|[97|[110|[39|[116|[32|[115|[116|[97|[114|[116|[32|[110|[111|[100|[101|[32|[111|[110|[32|[104|[111|[115|[116|[32|[126|[119|[32|[100|[117|[101|[32|[116|[111|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Host|[_@r0|[]]]) let <_3> = apply 'start_nodes'/3 (Tail,Name,Args) in [Node|_3]
<{'error',R}> when 'true' -> do call 'io':'format' ([67|[97|[110|[39|[116|[32|[115|[116|[97|[114|[116|[32|[110|[111|[100|[101|[32|[111|[110|[32|[104|[111|[115|[116|[32|[126|[119|[32|[100|[117|[101|[32|[116|[111|[32|[126|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Host|[R|[]]]) apply 'start_nodes'/3 (Tail,Name,Args)
<{'ok',Node}> when 'true' -> let <_4> = apply 'start_nodes'/3 (Tail,Name,Args) in [Node|_4]
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'start_nodes',3}}] )-|['compiler_generated'] ) end
'stop'/0 = fun () -> call 'gen_server':'call' ({'global','pool_master'},'stop')
'get_elements'/2 = fun (_0,_1) -> case <_0,_1> of <_X_Pos,[]> when 'true' -> []
<Pos,[E|T]> when 'true' -> let <_2> = call 'erlang':'element' (Pos,E) in let <_3> = apply 'get_elements'/2 (Pos,T) in [_2|_3]
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'get_elements',2}}] )-|['compiler_generated'] ) end
'stop_em'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'stopped'
<[N|Tail]> when 'true' -> do call 'rpc':'cast' (N,'erlang','halt',[]) apply 'stop_em'/1 (Tail)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'stop_em',1}}] )-|['compiler_generated'] ) end
'init'/1 = fun (_0) -> case _0 of <[]> when 'true' -> do call 'erlang':'process_flag' ('trap_exit','true') do call 'erlang':'spawn_link' ('pool','statistic_collector',[]) let <_1> = call 'erlang':'node' () in {'ok',[{0,_1}|[]]}
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'init',1}}] )-|['compiler_generated'] ) end
'handle_call'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'get_nodes',_X_From,Nodes> when 'true' -> {'reply',Nodes,Nodes}
<'get_node',_X_From,[{Load,N}|Tail]> when 'true' -> let <_3> = call 'erlang':'+' (Load,1) in let <_4> = call 'erlang':'++' (Tail,[{_3,N}|[]]) in {'reply',N,_4}
<{'attach',Node},_X_From,Nodes> when 'true' -> case call 'lists':'keymember' (Node,2,Nodes) of <'true'> when 'true' -> {'reply','already_attached',Nodes}
<'false'> when 'true' -> do call 'erlang':'monitor_node' (Node,'true') do call 'erlang':'spawn_link' (Node,'pool','statistic_collector',[]) let <_5> = call 'erlang':'++' (Nodes,[{999999,Node}|[]]) in {'reply','attached',_5}
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<{'spawn',Gl,M,F,A},_X_From,Nodes> when 'true' -> case apply 'handle_call'/3 ('get_node',_X_From,Nodes) of <{'reply',N,NewNodes}> when 'true' -> let <Pid> = call 'erlang':'spawn' (N,'pool','do_spawn',[Gl|[M|[F|[A|[]]]]]) in {'reply',Pid,NewNodes}
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<'stop',_X_From,Nodes> when 'true' -> {'stop','normal','stopped',Nodes}
(<_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9})-|[{'function_name',{'handle_call',3}}] )-|['compiler_generated'] ) end
'handle_cast'/2 = fun (_0,_1) -> {'noreply',_1}
'handle_info'/2 = fun (_0,_1) -> case <_0,_1> of <{Node,'load',Load},Nodes> when 'true' -> let <Nodes2> = apply 'insert_node'/2 ({Load,Node},Nodes) in {'noreply',Nodes2}
<{'nodedown',Node},Nodes> when 'true' -> let <_3> = call 'lists':'keydelete' (Node,2,Nodes) in {'noreply',_3}
<_6,Nodes> when 'true' -> {'noreply',Nodes} end
'terminate'/2 = fun (_0,_1) -> let <_3> = call 'erlang':'node' () in let <_2> = apply 'get_elements'/2 (2,_1) in let <N> = call 'lists':'delete' (_3,_2) in do apply 'stop_em'/1 (N) 'ok'
'do_spawn'/4 = fun (_0,_1,_2,_3) -> let <_4> = call 'erlang':'self' () in do call 'erlang':'group_leader' (_0,_4) call 'erlang':'apply' (_1,_2,_3)
'insert_node'/2 = fun (_0,_1) -> case <_0,_1> of <_@r0 = {Load,Node},[{L,_6}|Tail]> when let <_7> = call 'erlang':'=:=' (_6,Node) in let <_8> = call 'erlang':'>' (Load,L) in call 'erlang':'and' (_7,_8) -> apply 'pure_insert'/2 (_@r0,Tail)
<_@r2 = {Load,Node},_@r1 = [{L,N}|Tail]> when call 'erlang':'=<' (Load,L) -> let <T> = call 'lists':'keydelete' (Node,2,_@r1) in [_@r2|T]
<Ln,[H|T]> when 'true' -> let <_3> = apply 'insert_node'/2 (Ln,T) in [H|_3]
<X,[]> when 'true' -> do call 'error_logger':'error_msg' ([80|[111|[111|[108|[95|[109|[97|[115|[116|[101|[114|[58|[32|[66|[97|[100|[32|[110|[111|[100|[101|[32|[108|[105|[115|[116|[32|[88|[61|[126|[119|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[X|[]]) call 'erlang':'exit' ('crash')
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'insert_node',2}}] )-|['compiler_generated'] ) end
'pure_insert'/2 = fun (_0,_1) -> case <_0,_1> of <_@r0 = {Load,Node},[]> when 'true' -> [_@r0|[]]
<_@r1 = {Load,Node},_@r2 = [{L,N}|Tail]> when call 'erlang':'<' (Load,L) -> [_@r1|_@r2]
<L,[H|T]> when 'true' -> let <_2> = apply 'pure_insert'/2 (L,T) in [H|_2]
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'pure_insert',2}}] )-|['compiler_generated'] ) end
'statistic_collector'/0 = fun () -> apply 'statistic_collector'/1 (5)
'statistic_collector'/1 = fun (_0) -> case _0 of <0> when 'true' -> call 'erlang':'exit' ('normal')
<I> when 'true' -> do call 'timer':'sleep' (300) case call 'global':'whereis_name' ('pool_master') of <'undefined'> when 'true' -> let <_1> = call 'erlang':'-' (I,1) in apply 'statistic_collector'/1 (_1)
<M> when 'true' -> apply 'stat_loop'/2 (M,999999) end end
'stat_loop'/2 = fun (_0,_1) -> do call 'timer':'sleep' (2000) case call 'erlang':'statistics' ('run_queue') of <_6> when call 'erlang':'=:=' (_6,_1) -> apply 'stat_loop'/2 (_0,_1)
<NewLoad> when 'true' -> let <_2> = call 'erlang':'node' () in do call 'erlang':'!' (_0,{_2,'load',NewLoad}) apply 'stat_loop'/2 (_0,NewLoad) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('pool')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('pool',_0) end