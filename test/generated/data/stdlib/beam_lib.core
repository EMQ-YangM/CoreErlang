module 'beam_lib' ['all_chunks'/1,'build_module'/1,'chunks'/2,'chunks'/3,'clear_crypto_key_fun'/0,'cmp'/2,'cmp_dirs'/2,'code_change'/3,'crypto_key_fun'/1,'diff_dirs'/2,'format_error'/1,'get_crypto_key'/1,'handle_call'/3,'handle_cast'/2,'handle_info'/2,'info'/1,'init'/1,'make_crypto_key'/2,'md5'/1,'module_info'/0,'module_info'/1,'significant_chunks'/0,'strip'/1,'strip'/2,'strip_files'/1,'strip_files'/2,'strip_release'/1,'strip_release'/2,'terminate'/2,'version'/1] attributes [ 'file' = [{[115|[114|[99|[47|[98|[101|[97|[109|[95|[108|[105|[98|[46|[101|[114|[108]]]]]]]]]]]]]]]],1}]
, 'behaviour' = ['gen_server']
, 'compile' = [{'nowarn_deprecated_function',{'crypto','block_decrypt',4}}]
, 'compile' = [{'no_auto_import',[{'error',1}]}]
, 'compile' = [{'no_auto_import',[{'error',2}]}]
, 'export_type' = [{'attrib_entry',0}|[{'compinfo_entry',0}|[{'labeled_entry',0}|[{'label',0}]]]]
, 'type' = [{'beam',{'type',61,'union',[{'remote_type',61,[{'atom',61,'file'}|[{'atom',61,'filename'}|[[]]]]}|[{'type',61,'binary',[]}]]},[]}]
, 'type' = [{'debug_info',{'type',62,'union',[{'type',62,'tuple',[{'ann_type',62,[{'var',62,'DbgiVersion'}|[{'type',62,'atom',[]}]]}|[{'ann_type',62,[{'var',62,'Backend'}|[{'type',62,'module',[]}]]}|[{'ann_type',62,[{'var',62,'Data'}|[{'type',62,'term',[]}]]}]]]}|[{'atom',62,'no_debug_info'}]]},[]}]
, 'type' = [{'forms',{'type',64,'list',[{'type',64,'union',[{'remote_type',64,[{'atom',64,'erl_parse'}|[{'atom',64,'abstract_form'}|[[]]]]}|[{'remote_type',64,[{'atom',64,'erl_parse'}|[{'atom',64,'form_info'}|[[]]]]}]]}]},[]}]
, 'type' = [{'abst_code',{'type',66,'union',[{'type',66,'tuple',[{'ann_type',66,[{'var',66,'AbstVersion'}|[{'type',66,'atom',[]}]]}|[{'user_type',66,'forms',[]}]]}|[{'atom',66,'no_abstract_code'}]]},[]}]
, 'type' = [{'dataB',{'type',67,'binary',[]},[]}]
, 'type' = [{'index',{'type',68,'non_neg_integer',[]},[]}]
, 'type' = [{'label',{'type',69,'integer',[]},[]}]
, 'type' = [{'chunkid',{'type',71,'nonempty_string',[]},[]}]
, 'type' = [{'chunkname',{'type',73,'union',[{'atom',73,'abstract_code'}|[{'atom',73,'debug_info'}|[{'atom',74,'attributes'}|[{'atom',74,'compile_info'}|[{'atom',75,'exports'}|[{'atom',75,'labeled_exports'}|[{'atom',76,'imports'}|[{'atom',76,'indexed_imports'}|[{'atom',77,'locals'}|[{'atom',77,'labeled_locals'}|[{'atom',78,'atoms'}]]]]]]]]]]]},[]}]
, 'type' = [{'chunkref',{'type',79,'union',[{'user_type',79,'chunkname',[]}|[{'user_type',79,'chunkid',[]}]]},[]}]
, 'type' = [{'attrib_entry',{'type',81,'tuple',[{'ann_type',81,[{'var',81,'Attribute'}|[{'type',81,'atom',[]}]]}|[{'type',81,'list',[{'ann_type',81,[{'var',81,'AttributeValue'}|[{'type',81,'term',[]}]]}]}]]},[]}]
, 'type' = [{'compinfo_entry',{'type',82,'tuple',[{'ann_type',82,[{'var',82,'InfoKey'}|[{'type',82,'atom',[]}]]}|[{'type',82,'term',[]}]]},[]}]
, 'type' = [{'labeled_entry',{'type',83,'tuple',[{'ann_type',83,[{'var',83,'Function'}|[{'type',83,'atom',[]}]]}|[{'type',83,'arity',[]}|[{'user_type',83,'label',[]}]]]},[]}]
, 'type' = [{'chunkdata',{'type',85,'union',[{'type',85,'tuple',[{'user_type',85,'chunkid',[]}|[{'user_type',85,'dataB',[]}]]}|[{'type',86,'tuple',[{'atom',86,'abstract_code'}|[{'user_type',86,'abst_code',[]}]]}|[{'type',87,'tuple',[{'atom',87,'debug_info'}|[{'user_type',87,'debug_info',[]}]]}|[{'type',88,'tuple',[{'atom',88,'attributes'}|[{'type',88,'list',[{'user_type',88,'attrib_entry',[]}]}]]}|[{'type',89,'tuple',[{'atom',89,'compile_info'}|[{'type',89,'list',[{'user_type',89,'compinfo_entry',[]}]}]]}|[{'type',90,'tuple',[{'atom',90,'exports'}|[{'type',90,'list',[{'type',90,'tuple',[{'type',90,'atom',[]}|[{'type',90,'arity',[]}]]}]}]]}|[{'type',91,'tuple',[{'atom',91,'labeled_exports'}|[{'type',91,'list',[{'user_type',91,'labeled_entry',[]}]}]]}|[{'type',92,'tuple',[{'atom',92,'imports'}|[{'type',92,'list',[{'type',92,'mfa',[]}]}]]}|[{'type',93,'tuple',[{'atom',93,'indexed_imports'}|[{'type',93,'list',[{'type',93,'tuple',[{'user_type',93,'index',[]}|[{'type',93,'module',[]}|[{'ann_type',93,[{'var',93,'Function'}|[{'type',93,'atom',[]}]]}|[{'type',93,'arity',[]}]]]]}]}]]}|[{'type',94,'tuple',[{'atom',94,'locals'}|[{'type',94,'list',[{'type',94,'tuple',[{'type',94,'atom',[]}|[{'type',94,'arity',[]}]]}]}]]}|[{'type',95,'tuple',[{'atom',95,'labeled_locals'}|[{'type',95,'list',[{'user_type',95,'labeled_entry',[]}]}]]}|[{'type',96,'tuple',[{'atom',96,'atoms'}|[{'type',96,'list',[{'type',96,'tuple',[{'type',96,'integer',[]}|[{'type',96,'atom',[]}]]}]}]]}]]]]]]]]]]]]},[]}]
, 'type' = [{'info_rsn',{'type',99,'union',[{'type',99,'tuple',[{'atom',99,'chunk_too_big'}|[{'remote_type',99,[{'atom',99,'file'}|[{'atom',99,'filename'}|[[]]]]}|[{'user_type',100,'chunkid',[]}|[{'ann_type',100,[{'var',100,'ChunkSize'}|[{'type',100,'non_neg_integer',[]}]]}|[{'ann_type',101,[{'var',101,'FileSize'}|[{'type',101,'non_neg_integer',[]}]]}]]]]]}|[{'type',102,'tuple',[{'atom',102,'invalid_beam_file'}|[{'remote_type',102,[{'atom',102,'file'}|[{'atom',102,'filename'}|[[]]]]}|[{'ann_type',103,[{'var',103,'Position'}|[{'type',103,'non_neg_integer',[]}]]}]]]}|[{'type',104,'tuple',[{'atom',104,'invalid_chunk'}|[{'remote_type',104,[{'atom',104,'file'}|[{'atom',104,'filename'}|[[]]]]}|[{'user_type',104,'chunkid',[]}]]]}|[{'type',105,'tuple',[{'atom',105,'missing_chunk'}|[{'remote_type',105,[{'atom',105,'file'}|[{'atom',105,'filename'}|[[]]]]}|[{'user_type',105,'chunkid',[]}]]]}|[{'type',106,'tuple',[{'atom',106,'not_a_beam_file'}|[{'remote_type',106,[{'atom',106,'file'}|[{'atom',106,'filename'}|[[]]]]}]]}|[{'type',107,'tuple',[{'atom',107,'file_error'}|[{'remote_type',107,[{'atom',107,'file'}|[{'atom',107,'filename'}|[[]]]]}|[{'remote_type',107,[{'atom',107,'file'}|[{'atom',107,'posix'}|[[]]]]}]]]}]]]]]]},[]}]
, 'type' = [{'chnk_rsn',{'type',108,'union',[{'type',108,'tuple',[{'atom',108,'unknown_chunk'}|[{'remote_type',108,[{'atom',108,'file'}|[{'atom',108,'filename'}|[[]]]]}|[{'type',108,'atom',[]}]]]}|[{'type',109,'tuple',[{'atom',109,'key_missing_or_invalid'}|[{'remote_type',109,[{'atom',109,'file'}|[{'atom',109,'filename'}|[[]]]]}|[{'type',110,'union',[{'atom',110,'abstract_code'}|[{'atom',110,'debug_info'}]]}]]]}|[{'user_type',111,'info_rsn',[]}]]]},[]}]
, 'type' = [{'cmp_rsn',{'type',112,'union',[{'type',112,'tuple',[{'atom',112,'modules_different'}|[{'type',112,'module',[]}|[{'type',112,'module',[]}]]]}|[{'type',113,'tuple',[{'atom',113,'chunks_different'}|[{'user_type',113,'chunkid',[]}]]}|[{'atom',114,'different_chunks'}|[{'user_type',115,'info_rsn',[]}]]]]},[]}]
, 'spec' = [{{'info',1},[{'type',123,'bounded_fun',[{'type',123,'fun',[{'type',123,'product',[{'var',123,'Beam'}]}|[{'type',123,'union',[{'type',123,'list',[{'var',123,'InfoPair'}]}|[{'type',123,'tuple',[{'atom',123,'error'}|[{'atom',123,'beam_lib'}|[{'user_type',123,'info_rsn',[]}]]]}]]}]]}|[[{'type',124,'constraint',[{'atom',124,'is_subtype'}|[[{'var',124,'Beam'}|[{'user_type',124,'beam',[]}]]]]}|[{'type',125,'constraint',[{'atom',125,'is_subtype'}|[[{'var',125,'InfoPair'}|[{'type',125,'union',[{'type',125,'tuple',[{'atom',125,'file'}|[{'ann_type',125,[{'var',125,'Filename'}|[{'remote_type',125,[{'atom',125,'file'}|[{'atom',125,'filename'}|[[]]]]}]]}]]}|[{'type',126,'tuple',[{'atom',126,'binary'}|[{'ann_type',126,[{'var',126,'Binary'}|[{'type',126,'binary',[]}]]}]]}|[{'type',127,'tuple',[{'atom',127,'module'}|[{'ann_type',127,[{'var',127,'Module'}|[{'type',127,'module',[]}]]}]]}|[{'type',128,'tuple',[{'atom',128,'chunks'}|[{'type',128,'list',[{'type',128,'tuple',[{'ann_type',128,[{'var',128,'ChunkId'}|[{'user_type',128,'chunkid',[]}]]}|[{'ann_type',129,[{'var',129,'Pos'}|[{'type',129,'non_neg_integer',[]}]]}|[{'ann_type',130,[{'var',130,'Size'}|[{'type',130,'non_neg_integer',[]}]]}]]]}]}]]}]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'chunks',2},[{'type',135,'bounded_fun',[{'type',135,'fun',[{'type',135,'product',[{'var',135,'Beam'}|[{'var',135,'ChunkRefs'}]]}|[{'type',136,'union',[{'type',136,'tuple',[{'atom',136,'ok'}|[{'type',136,'tuple',[{'type',136,'module',[]}|[{'type',136,'list',[{'user_type',136,'chunkdata',[]}]}]]}]]}|[{'type',137,'tuple',[{'atom',137,'error'}|[{'atom',137,'beam_lib'}|[{'user_type',137,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',138,'constraint',[{'atom',138,'is_subtype'}|[[{'var',138,'Beam'}|[{'user_type',138,'beam',[]}]]]]}|[{'type',139,'constraint',[{'atom',139,'is_subtype'}|[[{'var',139,'ChunkRefs'}|[{'type',139,'list',[{'user_type',139,'chunkref',[]}]}]]]]}]]]]}]}]
, 'spec' = [{{'chunks',3},[{'type',144,'bounded_fun',[{'type',144,'fun',[{'type',144,'product',[{'var',144,'Beam'}|[{'var',144,'ChunkRefs'}|[{'var',144,'Options'}]]]}|[{'type',145,'union',[{'type',145,'tuple',[{'atom',145,'ok'}|[{'type',145,'tuple',[{'type',145,'module',[]}|[{'type',145,'list',[{'var',145,'ChunkResult'}]}]]}]]}|[{'type',146,'tuple',[{'atom',146,'error'}|[{'atom',146,'beam_lib'}|[{'user_type',146,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',147,'constraint',[{'atom',147,'is_subtype'}|[[{'var',147,'Beam'}|[{'user_type',147,'beam',[]}]]]]}|[{'type',148,'constraint',[{'atom',148,'is_subtype'}|[[{'var',148,'ChunkRefs'}|[{'type',148,'list',[{'user_type',148,'chunkref',[]}]}]]]]}|[{'type',149,'constraint',[{'atom',149,'is_subtype'}|[[{'var',149,'Options'}|[{'type',149,'list',[{'atom',149,'allow_missing_chunks'}]}]]]]}|[{'type',150,'constraint',[{'atom',150,'is_subtype'}|[[{'var',150,'ChunkResult'}|[{'type',150,'union',[{'user_type',150,'chunkdata',[]}|[{'type',150,'tuple',[{'ann_type',150,[{'var',150,'ChunkRef'}|[{'user_type',150,'chunkref',[]}]]}|[{'atom',150,'missing_chunk'}]]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'all_chunks',1},[{'type',156,'fun',[{'type',156,'product',[{'user_type',156,'beam',[]}]}|[{'type',157,'union',[{'type',157,'tuple',[{'atom',157,'ok'}|[{'atom',157,'beam_lib'}|[{'type',157,'list',[{'type',157,'tuple',[{'user_type',157,'chunkid',[]}|[{'user_type',157,'dataB',[]}]]}]}]]]}|[{'type',157,'tuple',[{'atom',157,'error'}|[{'atom',157,'beam_lib'}|[{'user_type',157,'info_rsn',[]}]]]}]]}]]}]}]
, 'spec' = [{{'cmp',2},[{'type',162,'bounded_fun',[{'type',162,'fun',[{'type',162,'product',[{'var',162,'Beam1'}|[{'var',162,'Beam2'}]]}|[{'type',162,'union',[{'atom',162,'ok'}|[{'type',162,'tuple',[{'atom',162,'error'}|[{'atom',162,'beam_lib'}|[{'user_type',162,'cmp_rsn',[]}]]]}]]}]]}|[[{'type',163,'constraint',[{'atom',163,'is_subtype'}|[[{'var',163,'Beam1'}|[{'user_type',163,'beam',[]}]]]]}|[{'type',164,'constraint',[{'atom',164,'is_subtype'}|[[{'var',164,'Beam2'}|[{'user_type',164,'beam',[]}]]]]}]]]]}]}]
, 'spec' = [{{'cmp_dirs',2},[{'type',170,'bounded_fun',[{'type',170,'fun',[{'type',170,'product',[{'var',170,'Dir1'}|[{'var',170,'Dir2'}]]}|[{'type',171,'union',[{'type',171,'tuple',[{'var',171,'Only1'}|[{'var',171,'Only2'}|[{'var',171,'Different'}]]]}|[{'type',171,'tuple',[{'atom',171,'error'}|[{'atom',171,'beam_lib'}|[{'var',171,'Reason'}]]]}]]}]]}|[[{'type',172,'constraint',[{'atom',172,'is_subtype'}|[[{'var',172,'Dir1'}|[{'type',172,'union',[{'type',172,'atom',[]}|[{'remote_type',172,[{'atom',172,'file'}|[{'atom',172,'filename'}|[[]]]]}]]}]]]]}|[{'type',173,'constraint',[{'atom',173,'is_subtype'}|[[{'var',173,'Dir2'}|[{'type',173,'union',[{'type',173,'atom',[]}|[{'remote_type',173,[{'atom',173,'file'}|[{'atom',173,'filename'}|[[]]]]}]]}]]]]}|[{'type',174,'constraint',[{'atom',174,'is_subtype'}|[[{'var',174,'Only1'}|[{'type',174,'list',[{'remote_type',174,[{'atom',174,'file'}|[{'atom',174,'filename'}|[[]]]]}]}]]]]}|[{'type',175,'constraint',[{'atom',175,'is_subtype'}|[[{'var',175,'Only2'}|[{'type',175,'list',[{'remote_type',175,[{'atom',175,'file'}|[{'atom',175,'filename'}|[[]]]]}]}]]]]}|[{'type',176,'constraint',[{'atom',176,'is_subtype'}|[[{'var',176,'Different'}|[{'type',176,'list',[{'type',176,'tuple',[{'ann_type',176,[{'var',176,'Filename1'}|[{'remote_type',176,[{'atom',176,'file'}|[{'atom',176,'filename'}|[[]]]]}]]}|[{'ann_type',176,[{'var',176,'Filename2'}|[{'remote_type',176,[{'atom',176,'file'}|[{'atom',176,'filename'}|[[]]]]}]]}]]}]}]]]]}|[{'type',177,'constraint',[{'atom',177,'is_subtype'}|[[{'var',177,'Reason'}|[{'type',177,'union',[{'type',177,'tuple',[{'atom',177,'not_a_directory'}|[{'type',177,'term',[]}]]}|[{'user_type',177,'info_rsn',[]}]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'diff_dirs',2},[{'type',182,'bounded_fun',[{'type',182,'fun',[{'type',182,'product',[{'var',182,'Dir1'}|[{'var',182,'Dir2'}]]}|[{'type',182,'union',[{'atom',182,'ok'}|[{'type',182,'tuple',[{'atom',182,'error'}|[{'atom',182,'beam_lib'}|[{'var',182,'Reason'}]]]}]]}]]}|[[{'type',183,'constraint',[{'atom',183,'is_subtype'}|[[{'var',183,'Dir1'}|[{'type',183,'union',[{'type',183,'atom',[]}|[{'remote_type',183,[{'atom',183,'file'}|[{'atom',183,'filename'}|[[]]]]}]]}]]]]}|[{'type',184,'constraint',[{'atom',184,'is_subtype'}|[[{'var',184,'Dir2'}|[{'type',184,'union',[{'type',184,'atom',[]}|[{'remote_type',184,[{'atom',184,'file'}|[{'atom',184,'filename'}|[[]]]]}]]}]]]]}|[{'type',185,'constraint',[{'atom',185,'is_subtype'}|[[{'var',185,'Reason'}|[{'type',185,'union',[{'type',185,'tuple',[{'atom',185,'not_a_directory'}|[{'type',185,'term',[]}]]}|[{'user_type',185,'info_rsn',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'strip',1},[{'type',190,'bounded_fun',[{'type',190,'fun',[{'type',190,'product',[{'var',190,'Beam1'}]}|[{'type',191,'union',[{'type',191,'tuple',[{'atom',191,'ok'}|[{'type',191,'tuple',[{'type',191,'module',[]}|[{'var',191,'Beam2'}]]}]]}|[{'type',191,'tuple',[{'atom',191,'error'}|[{'atom',191,'beam_lib'}|[{'user_type',191,'info_rsn',[]}]]]}]]}]]}|[[{'type',192,'constraint',[{'atom',192,'is_subtype'}|[[{'var',192,'Beam1'}|[{'user_type',192,'beam',[]}]]]]}|[{'type',193,'constraint',[{'atom',193,'is_subtype'}|[[{'var',193,'Beam2'}|[{'user_type',193,'beam',[]}]]]]}]]]]}]}]
, 'spec' = [{{'strip',2},[{'type',198,'bounded_fun',[{'type',198,'fun',[{'type',198,'product',[{'var',198,'Beam1'}|[{'var',198,'AdditionalChunks'}]]}|[{'type',199,'union',[{'type',199,'tuple',[{'atom',199,'ok'}|[{'type',199,'tuple',[{'type',199,'module',[]}|[{'var',199,'Beam2'}]]}]]}|[{'type',199,'tuple',[{'atom',199,'error'}|[{'atom',199,'beam_lib'}|[{'user_type',199,'info_rsn',[]}]]]}]]}]]}|[[{'type',200,'constraint',[{'atom',200,'is_subtype'}|[[{'var',200,'Beam1'}|[{'user_type',200,'beam',[]}]]]]}|[{'type',201,'constraint',[{'atom',201,'is_subtype'}|[[{'var',201,'AdditionalChunks'}|[{'type',201,'list',[{'user_type',201,'chunkid',[]}]}]]]]}|[{'type',202,'constraint',[{'atom',202,'is_subtype'}|[[{'var',202,'Beam2'}|[{'user_type',202,'beam',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'strip_files',1},[{'type',208,'bounded_fun',[{'type',208,'fun',[{'type',208,'product',[{'var',208,'Files'}]}|[{'type',209,'union',[{'type',209,'tuple',[{'atom',209,'ok'}|[{'type',209,'list',[{'type',209,'tuple',[{'type',209,'module',[]}|[{'var',209,'Beam'}]]}]}]]}|[{'type',209,'tuple',[{'atom',209,'error'}|[{'atom',209,'beam_lib'}|[{'user_type',209,'info_rsn',[]}]]]}]]}]]}|[[{'type',210,'constraint',[{'atom',210,'is_subtype'}|[[{'var',210,'Files'}|[{'type',210,'list',[{'user_type',210,'beam',[]}]}]]]]}|[{'type',211,'constraint',[{'atom',211,'is_subtype'}|[[{'var',211,'Beam'}|[{'user_type',211,'beam',[]}]]]]}]]]]}]}]
, 'spec' = [{{'strip_files',2},[{'type',216,'bounded_fun',[{'type',216,'fun',[{'type',216,'product',[{'var',216,'Files'}|[{'var',216,'AdditionalChunks'}]]}|[{'type',217,'union',[{'type',217,'tuple',[{'atom',217,'ok'}|[{'type',217,'list',[{'type',217,'tuple',[{'type',217,'module',[]}|[{'var',217,'Beam'}]]}]}]]}|[{'type',217,'tuple',[{'atom',217,'error'}|[{'atom',217,'beam_lib'}|[{'user_type',217,'info_rsn',[]}]]]}]]}]]}|[[{'type',218,'constraint',[{'atom',218,'is_subtype'}|[[{'var',218,'Files'}|[{'type',218,'list',[{'user_type',218,'beam',[]}]}]]]]}|[{'type',219,'constraint',[{'atom',219,'is_subtype'}|[[{'var',219,'AdditionalChunks'}|[{'type',219,'list',[{'user_type',219,'chunkid',[]}]}]]]]}|[{'type',220,'constraint',[{'atom',220,'is_subtype'}|[[{'var',220,'Beam'}|[{'user_type',220,'beam',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'strip_release',1},[{'type',226,'bounded_fun',[{'type',226,'fun',[{'type',226,'product',[{'var',226,'Dir'}]}|[{'type',227,'union',[{'type',227,'tuple',[{'atom',227,'ok'}|[{'type',227,'list',[{'type',227,'tuple',[{'type',227,'module',[]}|[{'remote_type',227,[{'atom',227,'file'}|[{'atom',227,'filename'}|[[]]]]}]]}]}]]}|[{'type',228,'tuple',[{'atom',228,'error'}|[{'atom',228,'beam_lib'}|[{'var',228,'Reason'}]]]}]]}]]}|[[{'type',229,'constraint',[{'atom',229,'is_subtype'}|[[{'var',229,'Dir'}|[{'type',229,'union',[{'type',229,'atom',[]}|[{'remote_type',229,[{'atom',229,'file'}|[{'atom',229,'filename'}|[[]]]]}]]}]]]]}|[{'type',230,'constraint',[{'atom',230,'is_subtype'}|[[{'var',230,'Reason'}|[{'type',230,'union',[{'type',230,'tuple',[{'atom',230,'not_a_directory'}|[{'type',230,'term',[]}]]}|[{'user_type',230,'info_rsn',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'strip_release',2},[{'type',235,'bounded_fun',[{'type',235,'fun',[{'type',235,'product',[{'var',235,'Dir'}|[{'var',235,'AdditionalChunks'}]]}|[{'type',236,'union',[{'type',236,'tuple',[{'atom',236,'ok'}|[{'type',236,'list',[{'type',236,'tuple',[{'type',236,'module',[]}|[{'remote_type',236,[{'atom',236,'file'}|[{'atom',236,'filename'}|[[]]]]}]]}]}]]}|[{'type',237,'tuple',[{'atom',237,'error'}|[{'atom',237,'beam_lib'}|[{'var',237,'Reason'}]]]}]]}]]}|[[{'type',238,'constraint',[{'atom',238,'is_subtype'}|[[{'var',238,'Dir'}|[{'type',238,'union',[{'type',238,'atom',[]}|[{'remote_type',238,[{'atom',238,'file'}|[{'atom',238,'filename'}|[[]]]]}]]}]]]]}|[{'type',239,'constraint',[{'atom',239,'is_subtype'}|[[{'var',239,'AdditionalChunks'}|[{'type',239,'list',[{'user_type',239,'chunkid',[]}]}]]]]}|[{'type',240,'constraint',[{'atom',240,'is_subtype'}|[[{'var',240,'Reason'}|[{'type',240,'union',[{'type',240,'tuple',[{'atom',240,'not_a_directory'}|[{'type',240,'term',[]}]]}|[{'user_type',240,'info_rsn',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'version',1},[{'type',245,'bounded_fun',[{'type',245,'fun',[{'type',245,'product',[{'var',245,'Beam'}]}|[{'type',246,'union',[{'type',246,'tuple',[{'atom',246,'ok'}|[{'type',246,'tuple',[{'type',246,'module',[]}|[{'type',246,'list',[{'ann_type',246,[{'var',246,'Version'}|[{'type',246,'term',[]}]]}]}]]}]]}|[{'type',247,'tuple',[{'atom',247,'error'}|[{'atom',247,'beam_lib'}|[{'user_type',247,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',248,'constraint',[{'atom',248,'is_subtype'}|[[{'var',248,'Beam'}|[{'user_type',248,'beam',[]}]]]]}]]]}]}]
, 'spec' = [{{'md5',1},[{'type',259,'bounded_fun',[{'type',259,'fun',[{'type',259,'product',[{'var',259,'Beam'}]}|[{'type',260,'union',[{'type',260,'tuple',[{'atom',260,'ok'}|[{'type',260,'tuple',[{'type',260,'module',[]}|[{'var',260,'MD5'}]]}]]}|[{'type',260,'tuple',[{'atom',260,'error'}|[{'atom',260,'beam_lib'}|[{'user_type',260,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',261,'constraint',[{'atom',261,'is_subtype'}|[[{'var',261,'Beam'}|[{'user_type',261,'beam',[]}]]]]}|[{'type',262,'constraint',[{'atom',262,'is_subtype'}|[[{'var',262,'MD5'}|[{'type',262,'binary',[]}]]]]}]]]]}]}]
, 'spec' = [{{'format_error',1},[{'type',273,'bounded_fun',[{'type',273,'fun',[{'type',273,'product',[{'var',273,'Reason'}]}|[{'remote_type',273,[{'atom',273,'io_lib'}|[{'atom',273,'chars'}|[[]]]]}]]}|[[{'type',274,'constraint',[{'atom',274,'is_subtype'}|[[{'var',274,'Reason'}|[{'type',274,'term',[]}]]]]}]]]}]}]
, 'type' = [{'mode',{'atom',321,'des3_cbc'},[]}]
, 'type' = [{'crypto_fun_arg',{'type',322,'union',[{'atom',322,'init'}|[{'atom',323,'clear'}|[{'type',324,'tuple',[{'atom',324,'debug_info'}|[{'user_type',324,'mode',[]}|[{'type',324,'module',[]}|[{'remote_type',324,[{'atom',324,'file'}|[{'atom',324,'filename'}|[[]]]]}]]]]}]]]},[]}]
, 'type' = [{'crypto_fun',{'type',325,'fun',[{'type',325,'product',[{'user_type',325,'crypto_fun_arg',[]}]}|[{'type',325,'term',[]}]]},[]}]
, 'spec' = [{{'crypto_key_fun',1},[{'type',327,'bounded_fun',[{'type',327,'fun',[{'type',327,'product',[{'var',327,'CryptoKeyFun'}]}|[{'type',327,'union',[{'atom',327,'ok'}|[{'type',327,'tuple',[{'atom',327,'error'}|[{'var',327,'Reason'}]]}]]}]]}|[[{'type',328,'constraint',[{'atom',328,'is_subtype'}|[[{'var',328,'CryptoKeyFun'}|[{'user_type',328,'crypto_fun',[]}]]]]}|[{'type',329,'constraint',[{'atom',329,'is_subtype'}|[[{'var',329,'Reason'}|[{'type',329,'union',[{'atom',329,'badfun'}|[{'atom',329,'exists'}|[{'type',329,'term',[]}]]]}]]]]}]]]]}]}]
, 'spec' = [{{'clear_crypto_key_fun',0},[{'type',334,'bounded_fun',[{'type',334,'fun',[{'type',334,'product',[]}|[{'type',334,'union',[{'atom',334,'undefined'}|[{'type',334,'tuple',[{'atom',334,'ok'}|[{'var',334,'Result'}]]}]]}]]}|[[{'type',335,'constraint',[{'atom',335,'is_subtype'}|[[{'var',335,'Result'}|[{'type',335,'union',[{'atom',335,'undefined'}|[{'type',335,'term',[]}]]}]]]]}]]]}]}]
, 'spec' = [{{'make_crypto_key',2},[{'type',340,'fun',[{'type',340,'product',[{'user_type',340,'mode',[]}|[{'type',340,'string',[]}]]}|[{'type',341,'tuple',[{'user_type',341,'mode',[]}|[{'type',341,'list',[{'type',341,'binary',[]}]}|[{'type',341,'binary',[]}|[{'type',341,'integer',[]}]]]]}]]}]}]
, 'spec' = [{{'build_module',1},[{'type',348,'bounded_fun',[{'type',348,'fun',[{'type',348,'product',[{'var',348,'Chunks'}]}|[{'type',348,'tuple',[{'atom',348,'ok'}|[{'var',348,'Binary'}]]}]]}|[[{'type',349,'constraint',[{'atom',349,'is_subtype'}|[[{'var',349,'Chunks'}|[{'type',349,'list',[{'type',349,'tuple',[{'user_type',349,'chunkid',[]}|[{'user_type',349,'dataB',[]}]]}]}]]]]}|[{'type',350,'constraint',[{'atom',350,'is_subtype'}|[[{'var',350,'Binary'}|[{'type',350,'binary',[]}]]]]}]]]]}]}]
, 'record' = [{'bb',[{'typed_record_field',{'record_field',856,{'atom',856,'pos'},{'integer',856,0}},{'type',856,'integer',[]}}|[{'typed_record_field',{'record_field',857,{'atom',857,'bin'}},{'type',857,'binary',[]}}|[{'typed_record_field',{'record_field',858,{'atom',858,'source'}},{'type',858,'union',[{'type',858,'binary',[]}|[{'type',858,'string',[]}]]}}]]]}]
, 'spec' = [{{'file_error',2},[{'type',933,'fun',[{'type',933,'product',[{'remote_type',933,[{'atom',933,'file'}|[{'atom',933,'filename'}|[[]]]]}|[{'type',933,'tuple',[{'atom',933,'error'}|[{'type',933,'atom',[]}]]}]]}|[{'type',933,'no_return',[]}]]}]}]
, 'spec' = [{{'error',1},[{'type',938,'fun',[{'type',938,'product',[{'type',938,'term',[]}]}|[{'type',938,'no_return',[]}]]}]}]
, 'record' = [{'state',[{'typed_record_field',{'record_field',968,{'atom',968,'crypto_key_f'}},{'type',968,'union',[{'user_type',968,'crypto_fun',[]}|[{'atom',968,'undefined'}]]}}]}]
, 'spec' = [{{'init',1},[{'type',1043,'fun',[{'type',1043,'product',[{'type',1043,'nil',[]}]}|[{'type',1043,'tuple',[{'atom',1043,'ok'}|[{'type',1043,'record',[{'atom',1043,'state'}]}]]}]]}]}]
, 'type' = [{'calls',{'type',1048,'union',[{'atom',1048,'clear_crypto_key_fun'}|[{'type',1049,'tuple',[{'atom',1049,'crypto_key_fun'}|[{'var',1049,'_'}]]}|[{'type',1050,'tuple',[{'atom',1050,'get_crypto_key'}|[{'var',1050,'_'}]]}]]]},[]}]
, 'spec' = [{{'handle_call',3},[{'type',1052,'fun',[{'type',1052,'product',[{'user_type',1052,'calls',[]}|[{'type',1052,'tuple',[{'type',1052,'pid',[]}|[{'type',1052,'term',[]}]]}|[{'type',1052,'record',[{'atom',1052,'state'}]}]]]}|[{'type',1053,'union',[{'type',1053,'tuple',[{'atom',1053,'noreply'}|[{'type',1053,'record',[{'atom',1053,'state'}]}]]}|[{'type',1054,'tuple',[{'atom',1054,'reply'}|[{'type',1054,'union',[{'atom',1054,'error'}|[{'type',1054,'tuple',[{'atom',1054,'error'}|[{'type',1054,'union',[{'atom',1054,'badfun'}|[{'atom',1054,'exists'}]]}]]}]]}|[{'type',1054,'record',[{'atom',1054,'state'}]}]]]}|[{'type',1055,'tuple',[{'atom',1055,'stop'}|[{'atom',1055,'normal'}|[{'type',1055,'union',[{'atom',1055,'undefined'}|[{'type',1055,'tuple',[{'atom',1055,'ok'}|[{'type',1055,'term',[]}]]}]]}|[{'type',1055,'record',[{'atom',1055,'state'}]}]]]]}]]]}]]}]}]
, 'spec' = [{{'handle_cast',2},[{'type',1122,'fun',[{'type',1122,'product',[{'type',1122,'term',[]}|[{'type',1122,'record',[{'atom',1122,'state'}]}]]}|[{'type',1122,'tuple',[{'atom',1122,'noreply'}|[{'type',1122,'record',[{'atom',1122,'state'}]}]]}]]}]}]
, 'spec' = [{{'handle_info',2},[{'type',1127,'fun',[{'type',1127,'product',[{'type',1127,'term',[]}|[{'type',1127,'record',[{'atom',1127,'state'}]}]]}|[{'type',1127,'tuple',[{'atom',1127,'noreply'}|[{'type',1127,'record',[{'atom',1127,'state'}]}]]}]]}]}]
, 'spec' = [{{'code_change',3},[{'type',1132,'fun',[{'type',1132,'product',[{'type',1132,'term',[]}|[{'type',1132,'record',[{'atom',1132,'state'}]}|[{'type',1132,'term',[]}]]]}|[{'type',1132,'tuple',[{'atom',1132,'ok'}|[{'type',1132,'record',[{'atom',1132,'state'}]}]]}]]}]}]
, 'spec' = [{{'terminate',2},[{'type',1137,'fun',[{'type',1137,'product',[{'type',1137,'term',[]}|[{'type',1137,'record',[{'atom',1137,'state'}]}]]}|[{'atom',1137,'ok'}]]}]}] ] 'info'/1 = fun (_0) -> let <_1> = apply 'beam_filename'/1 (_0) in apply 'read_info'/1 (_1)
'chunks'/2 = fun (_0,_1) -> apply 'read_chunk_data'/2 (_0,_1)
'chunks'/3 = fun (_0,_1,_2) -> try apply 'read_chunk_data'/3 (_0,_1,_2) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),Error,_10> when 'true' -> Error
(<_11,_12,_13> when 'true' -> primop 'raise' (_13,_12)-|['compiler_generated'] ) end
'all_chunks'/1 = fun (_0) -> apply 'read_all_chunks'/1 (_0)
'cmp'/2 = fun (_0,_1) -> try apply 'cmp_files'/2 (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end
'cmp_dirs'/2 = fun (_0,_1) -> catch apply 'compare_dirs'/2 (_0,_1)
'diff_dirs'/2 = fun (_0,_1) -> catch apply 'diff_directories'/2 (_0,_1)
'strip'/1 = fun (_0) -> apply 'strip'/2 (_0,[])
'strip'/2 = fun (_0,_1) -> try apply 'strip_file'/2 (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end
'strip_files'/1 = fun (_0) -> apply 'strip_files'/2 (_0,[])
'strip_files'/2 = fun (_0,_1) -> case <_0,_1> of <Files,AdditionalChunks> when call 'erlang':'is_list' (Files) -> try apply 'strip_fils'/2 (Files,AdditionalChunks) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'strip_files',2}}] )-|['compiler_generated'] ) end
'strip_release'/1 = fun (_0) -> apply 'strip_release'/2 (_0,[])
'strip_release'/2 = fun (_0,_1) -> catch apply 'strip_rel'/2 (_0,_1)
'version'/1 = fun (_0) -> let <_1> = catch apply 'read_chunk_data'/2 (_0,['attributes']) in case _1 of <{'ok',{Module,[{'attributes',Attrs}|[]]}}> when 'true' -> case call 'lists':'keyfind' ('vsn',1,Attrs) of <{'vsn',Version}> when 'true' -> {'ok',{Module,Version}}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<Error> when 'true' -> Error end
'md5'/1 = fun (_0) -> let <_2> = catch let <_1> = apply 'md5_chunks'/0 () in apply 'read_significant_chunks'/2 (_0,_1) in case _2 of <{'ok',{Module,Chunks0}}> when 'true' -> let <Chunks> = apply 'filter_funtab'/1 (Chunks0) in let <_8> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{_X_Id,C}|_5]> when 'true' -> let <_7> = apply 'lc$^0'/1 (_5) in ([C|_7]-|['compiler_generated'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_12> when 'true' -> (primop 'match_fail' ({'function_clause',_12})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Chunks) in let <_9> = call 'erlang':'md5' (_8) in {'ok',{Module,_9}}
<Error> when 'true' -> Error end
'format_error'/1 = fun (_0) -> case _0 of <{'error',Error}> when 'true' -> apply 'format_error'/1 (Error)
<{'error',Module,Error}> when 'true' -> call Module:'format_error' (Error)
<{'unknown_chunk',File,ChunkName}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[67|[97|[110|[110|[111|[116|[32|[102|[105|[110|[100|[32|[99|[104|[117|[110|[107|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkName|[]]])
<{'invalid_chunk',File,ChunkId}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[73|[110|[118|[97|[108|[105|[100|[32|[99|[111|[110|[116|[101|[110|[116|[115|[32|[111|[102|[32|[99|[104|[117|[110|[107|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[]]])
<{'not_a_beam_file',File}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[78|[111|[116|[32|[97|[32|[66|[69|[65|[77|[32|[102|[105|[108|[101|[126|[110]]]]]]]]]]]]]]]]]]]]]],[File|[]])
<{'file_error',File,Reason}> when 'true' -> let <_1> = call 'file':'format_error' (Reason) in call 'io_lib':'format' ([126|[116|[112|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]],[File|[_1|[]]])
<{'missing_chunk',File,ChunkId}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[78|[111|[116|[32|[97|[32|[66|[69|[65|[77|[32|[102|[105|[108|[101|[58|[32|[110|[111|[32|[73|[70|[70|[32|[34|[126|[115|[34|[32|[99|[104|[117|[110|[107|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[]]])
<{'invalid_beam_file',File,Pos}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[73|[110|[118|[97|[108|[105|[100|[32|[102|[111|[114|[109|[97|[116|[32|[111|[102|[32|[66|[69|[65|[77|[32|[102|[105|[108|[101|[32|[110|[101|[97|[114|[32|[98|[121|[116|[101|[32|[110|[117|[109|[98|[101|[114|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[Pos|[]]])
<{'chunk_too_big',File,ChunkId,Size,Len}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[83|[105|[122|[101|[32|[111|[102|[32|[99|[104|[117|[110|[107|[32|[34|[126|[115|[34|[32|[105|[115|[32|[126|[112|[32|[98|[121|[116|[101|[115|[44|[32|[98|[117|[116|[32|[111|[110|[108|[121|[32|[126|[112|[32|[98|[121|[116|[101|[115|[32|[99|[111|[117|[108|[100|[32|[98|[101|[32|[114|[101|[97|[100|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[Size|[Len|[]]]]])
<{'chunks_different',Id}> when 'true' -> call 'io_lib':'format' ([67|[104|[117|[110|[107|[32|[34|[126|[115|[34|[32|[100|[105|[102|[102|[101|[114|[115|[32|[105|[110|[32|[116|[104|[101|[32|[116|[119|[111|[32|[102|[105|[108|[101|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Id|[]])
<'different_chunks'> when 'true' -> [84|[104|[101|[32|[116|[119|[111|[32|[102|[105|[108|[101|[115|[32|[104|[97|[118|[101|[32|[100|[105|[102|[102|[101|[114|[101|[110|[116|[32|[99|[104|[117|[110|[107|[115|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
<{'modules_different',Module1,Module2}> when 'true' -> call 'io_lib':'format' ([77|[111|[100|[117|[108|[101|[32|[110|[97|[109|[101|[115|[32|[126|[112|[32|[97|[110|[100|[32|[126|[112|[32|[100|[105|[102|[102|[101|[114|[32|[105|[110|[32|[116|[104|[101|[32|[116|[119|[111|[32|[102|[105|[108|[101|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Module1|[Module2|[]]])
<{'not_a_directory',Name}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[78|[111|[116|[32|[97|[32|[100|[105|[114|[101|[99|[116|[111|[114|[121|[126|[110]]]]]]]]]]]]]]]]]]]]]],[Name|[]])
<{'key_missing_or_invalid',File,ChunkId}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[67|[97|[110|[110|[111|[116|[32|[100|[101|[99|[114|[121|[112|[116|[32|[126|[116|[115|[32|[98|[101|[99|[97|[117|[115|[101|[32|[107|[101|[121|[32|[105|[115|[32|[109|[105|[115|[115|[105|[110|[103|[32|[111|[114|[32|[105|[110|[118|[97|[108|[105|[100]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[]]])
<'badfun'> when 'true' -> [110|[111|[116|[32|[97|[32|[102|[117|[110|[32|[111|[114|[32|[116|[104|[101|[32|[102|[117|[110|[32|[104|[97|[115|[32|[116|[104|[101|[32|[119|[114|[111|[110|[103|[32|[97|[114|[105|[116|[121]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
<'exists'> when 'true' -> [97|[32|[102|[117|[110|[32|[104|[97|[115|[32|[97|[108|[114|[101|[97|[100|[121|[32|[98|[101|[101|[110|[32|[105|[110|[115|[116|[97|[108|[108|[101|[100]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
<E> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[126|[110]]]]],[E|[]]) end
'crypto_key_fun'/1 = fun (_0) -> apply 'call_crypto_server'/1 ({'crypto_key_fun',_0})
'clear_crypto_key_fun'/0 = fun () -> apply 'call_crypto_server'/1 ('clear_crypto_key_fun')
'make_crypto_key'/2 = fun (_0,_1) -> case <_0,_1> of <Type = 'des3_cbc',String> when 'true' -> case call 'erlang':'md5' (String) of <First = #{#<K1>(8,8,'binary',['unsigned'|['big']]),#<K2>(8,8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_3> = call 'lists':'reverse' (String) in case call 'erlang':'md5' ([First|_3]) of <#{#<K3>(8,8,'binary',['unsigned'|['big']]),#<IVec>(8,8,'binary',['unsigned'|['big']])}#> when 'true' -> {Type,[K1|[K2|[K3|[]]]],IVec,8}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'make_crypto_key',2}}] )-|['compiler_generated'] ) end
'build_module'/1 = fun (_0) -> let <_1> = apply 'build_chunks'/1 (_0) in let <Chunks> = call 'erlang':'list_to_binary' (_1) in let <Size> = call 'erlang':'byte_size' (Chunks) in case call 'erlang':'rem' (Size,4) of <0> when 'true' -> let <_5> = call 'erlang':'+' (Size,4) in let <_6> = #{#<1179603505>(32,1,'integer',['unsigned'|['big']]),#<_5>(32,1,'integer',['unsigned'|['big']]),#<1111834957>(32,1,'integer',['unsigned'|['big']]),#<Chunks>('all',8,'binary',['unsigned'|['big']])}# in {'ok',_6}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'read_info'/1 = fun (_0) -> try case apply 'scan_beam'/2 (_0,'info') of <{'ok',Module,Data}> when 'true' -> let <_2> = case <> of <> when call 'erlang':'is_binary' (_0) -> {'binary',_0}
<> when 'true' -> {'file',_0} end in [_2|[{'module',Module}|[{'chunks',Data}|[]]]]
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end
'diff_directories'/2 = fun (_0,_1) -> case apply 'compare_dirs'/2 (_0,_1) of <{OnlyDir1,OnlyDir2,Diff}> when 'true' -> do apply 'diff_only'/2 (_0,OnlyDir1) do apply 'diff_only'/2 (_1,OnlyDir2) let <_5> = fun (_3) -> call 'io':'format' ([42|[42|[32|[100|[105|[102|[102|[101|[114|[101|[110|[116|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]],[_3|[]]) in do call 'lists':'foreach' (_5,Diff) 'ok'
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'diff_only'/2 = fun (_0,_1) -> case <_0,_1> of <_X_Dir,[]> when 'true' -> 'ok'
<Dir,Only> when 'true' -> call 'io':'format' ([79|[110|[108|[121|[32|[105|[110|[32|[126|[116|[112|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]],[Dir|[Only|[]]]) end
'compare_dirs'/2 = fun (_0,_1) -> let <_2> = apply 'beam_files'/1 (_0) in let <R1> = call 'sofs':'relation' (_2) in let <_4> = apply 'beam_files'/1 (_1) in let <R2> = call 'sofs':'relation' (_4) in let <F1> = call 'sofs':'domain' (R1) in let <F2> = call 'sofs':'domain' (R2) in case call 'sofs':'symmetric_partition' (F1,F2) of <{O1,Both,O2}> when 'true' -> let <OnlyL1> = call 'sofs':'image' (R1,O1) in let <OnlyL2> = call 'sofs':'image' (R2,O2) in let <_11> = call 'sofs':'restriction' (R1,Both) in let <B1> = call 'sofs':'to_external' (_11) in let <_13> = call 'sofs':'restriction' (R2,Both) in let <B2> = call 'sofs':'to_external' (_13) in let <Diff> = apply 'compare_files'/3 (B1,B2,[]) in let <_17> = call 'sofs':'to_external' (OnlyL1) in let <_16> = call 'sofs':'to_external' (OnlyL2) in {_17,_16,Diff}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
'compare_files'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],[],Acc> when 'true' -> call 'lists':'reverse' (Acc)
<[{_10,F1}|R1],[{_11,F2}|R2],Acc> when 'true' -> let <_3> = catch apply 'cmp_files'/2 (F1,F2) in let <_5> = case _3 of <{'error',_X_Mod,_X_Reason}> when 'true' -> [{F1,F2}|Acc]
<'ok'> when 'true' -> Acc
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in apply 'compare_files'/3 (R1,R2,_5)
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'compare_files',3}}] )-|['compiler_generated'] ) end
'beam_files'/1 = fun (_0) -> case apply 'assert_directory'/1 (_0) of <'ok'> when 'true' -> let <_2> = call 'filename':'join' (_0,[42|[46|[98|[101|[97|[109]]]]]]) in let <L> = call 'filelib':'wildcard' (_2) in (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[Path|_5]> when 'true' -> let <_7> = call 'filename':'basename' (Path) in let <_8> = apply 'lc$^0'/1 (_5) in ([{_7,Path}|_8]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (L)-|['list_comprehension'] )
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'cmp_files'/2 = fun (_0,_1) -> case apply 'read_all_but_useless_chunks'/1 (_0) of <{'ok',{M1,L1}}> when 'true' -> case apply 'read_all_but_useless_chunks'/1 (_1) of <{'ok',{M2,L2}}> when 'true' -> case <> of <> when call 'erlang':'=:=' (M1,M2) -> apply 'cmp_lists'/2 (L1,L2)
<> when 'true' -> apply 'error'/1 ({'modules_different',M1,M2}) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'cmp_lists'/2 = fun (_0,_1) -> case <_0,_1> of <[],[]> when 'true' -> 'ok'
<[{Id,C1}|R1],[{_4,C2}|R2]> when call 'erlang':'=:=' (_4,Id) -> case <> of <> when call 'erlang':'=:=' (C1,C2) -> apply 'cmp_lists'/2 (R1,R2)
<> when 'true' -> apply 'error'/1 ({'chunks_different',Id}) end
<_5,_6> when 'true' -> apply 'error'/1 ('different_chunks') end
'strip_rel'/2 = fun (_0,_1) -> case apply 'assert_directory'/1 (_0) of <'ok'> when 'true' -> let <_3> = call 'filename':'join' (_0,[108|[105|[98|[47|[42|[47|[101|[98|[105|[110|[47|[42|[46|[98|[101|[97|[109]]]]]]]]]]]]]]]]]) in let <_4> = call 'filelib':'wildcard' (_3) in apply 'strip_fils'/2 (_4,_1)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'strip_fils'/2 = fun (_0,_1) -> let <_7> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[F|_3]> when 'true' -> case apply 'strip_file'/2 (F,_1) of <{'ok',Reply}> when 'true' -> let <_6> = apply 'lc$^0'/1 (_3) in ([Reply|_6]-|['compiler_generated'] )
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in {'ok',_7}
'strip_file'/2 = fun (_0,_1) -> let <_2> = apply 'significant_chunks'/0 () in let <_3> = call 'erlang':'++' (_1,_2) in case apply 'read_significant_chunks'/2 (_0,_3) of <{'ok',{Mod,Chunks}}> when 'true' -> case apply 'build_module'/1 (Chunks) of <{'ok',Stripped0}> when 'true' -> let <Stripped> = apply 'compress'/1 (Stripped0) in case _0 of <_15> when call 'erlang':'is_binary' (_0) -> {'ok',{Mod,Stripped}}
<_16> when 'true' -> let <FileName> = apply 'beam_filename'/1 (_0) in case call 'file':'open' (FileName,['raw'|['binary'|['write']]]) of <{'ok',Fd}> when 'true' -> case call 'file':'write' (Fd,Stripped) of <'ok'> when 'true' -> case call 'file':'close' (Fd) of <'ok'> when 'true' -> {'ok',{Mod,FileName}}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<Error> when 'true' -> case call 'file':'close' (Fd) of <'ok'> when 'true' -> apply 'file_error'/2 (FileName,Error)
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end end
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'build_chunks'/1 = fun (_0) -> case _0 of <[{Id,Data}|Chunks]> when 'true' -> let <BId> = call 'erlang':'list_to_binary' (Id) in let <Size> = call 'erlang':'byte_size' (Data) in let <_3> = #{#<BId>('all',8,'binary',['unsigned'|['big']]),#<Size>(32,1,'integer',['unsigned'|['big']])}# in let <_4> = apply 'pad'/1 (Size) in let <Chunk> = [_3|[Data|_4]] in let <_6> = apply 'build_chunks'/1 (Chunks) in [Chunk|_6]
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'build_chunks',1}}] )-|['compiler_generated'] ) end
'pad'/1 = fun (_0) -> case call 'erlang':'rem' (_0,4) of <0> when 'true' -> []
<Rem> when 'true' -> let <_1> = call 'erlang':'-' (4,Rem) in call 'lists':'duplicate' (_1,0) end
'read_all_but_useless_chunks'/1 = fun (_0) -> case _0 of <File0> when let <_1> = call 'erlang':'is_atom' (_0) in let <_2> = call 'erlang':'is_list' (_0) in let <_3> = call 'erlang':'is_binary' (_0) in let <_4> = call 'erlang':'or' (_2,_3) in call 'erlang':'or' (_1,_4) -> let <File> = apply 'beam_filename'/1 (File0) in case apply 'scan_beam'/2 (File,'info') of <{'ok',Module,ChunkIds0}> when 'true' -> let <_13> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[{Name,_18,_19}|_8]> when 'true' -> (case apply 'is_useless_chunk'/1 (Name) of <'false'> when 'true' -> let <_11> = apply 'lc$^0'/1 (_8) in ([Name|_11]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_21> when 'true' -> (primop 'match_fail' ({'function_clause',_21})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (ChunkIds0) in case apply 'scan_beam'/2 (File,_13) of <{'ok',_20,Chunks}> when call 'erlang':'=:=' (_20,Module) -> let <_16> = call 'lists':'reverse' (Chunks) in {'ok',{Module,_16}}
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'read_all_but_useless_chunks',1}}] )-|['compiler_generated'] ) end
'is_useless_chunk'/1 = fun (_0) -> case _0 of <[67|[73|[110|[102]]]]> when 'true' -> 'true'
<_2> when 'true' -> 'false' end
'read_significant_chunks'/2 = fun (_0,_1) -> case apply 'read_chunk_data'/3 (_0,_1,['allow_missing_chunks']) of <{'ok',{Module,Chunks0}}> when 'true' -> let <Mandatory> = apply 'mandatory_chunks'/0 () in let <Chunks> = apply 'filter_significant_chunks'/4 (Chunks0,Mandatory,_0,Module) in {'ok',{Module,Chunks}}
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'filter_significant_chunks'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[Pair = {_10,Data}|Cs],Mandatory,File,Mod> when call 'erlang':'is_binary' (Data) -> let <_4> = apply 'filter_significant_chunks'/4 (Cs,Mandatory,File,Mod) in [Pair|_4]
<[{Id,'missing_chunk'}|Cs],Mandatory,File,Mod> when 'true' -> case call 'lists':'member' (Id,Mandatory) of <'false'> when 'true' -> apply 'filter_significant_chunks'/4 (Cs,Mandatory,File,Mod)
<'true'> when 'true' -> apply 'error'/1 ({'missing_chunk',File,Id})
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<[],_11,_12,_13> when 'true' -> []
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'filter_significant_chunks',4}}] )-|['compiler_generated'] ) end
'filter_funtab'/1 = fun (_0) -> case _0 of <[{Tag = [70|[117|[110|[84]]]],#{#<L>(4,8,'binary',['unsigned'|['big']]),#<Data0>('all',8,'binary',['unsigned'|['big']])}#}|Cs]> when 'true' -> let <Data> = apply 'filter_funtab_1'/2 (Data0,#{#<0>(8,1,'integer',['unsigned'|['big']]),#<0>(8,1,'integer',['unsigned'|['big']]),#<0>(8,1,'integer',['unsigned'|['big']]),#<0>(8,1,'integer',['unsigned'|['big']])}#) in let <_2> = call 'erlang':'iolist_to_binary' (Data) in let <Funtab> = #{#<L>('all',8,'binary',['unsigned'|['big']]),#<_2>('all',8,'binary',['unsigned'|['big']])}# in let <_4> = apply 'filter_funtab'/1 (Cs) in [{Tag,Funtab}|_4]
<[H|T]> when 'true' -> let <_5> = apply 'filter_funtab'/1 (T) in [H|_5]
<[]> when 'true' -> []
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'filter_funtab',1}}] )-|['compiler_generated'] ) end
'filter_funtab_1'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<Important>(20,8,'binary',['unsigned'|['big']]),#<_X_OldUniq>(4,8,'binary',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Zero> when 'true' -> let <_2> = apply 'filter_funtab_1'/2 (T,Zero) in [Important|[Zero|_2]]
<Tail,_5> when call 'erlang':'is_binary' (Tail) -> [Tail|[]]
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'filter_funtab_1',2}}] )-|['compiler_generated'] ) end
'read_all_chunks'/1 = fun (_0) -> case _0 of <File0> when let <_1> = call 'erlang':'is_atom' (_0) in let <_2> = call 'erlang':'is_list' (_0) in let <_3> = call 'erlang':'is_binary' (_0) in let <_4> = call 'erlang':'or' (_2,_3) in call 'erlang':'or' (_1,_4) -> try let <File> = apply 'beam_filename'/1 (File0) in case apply 'scan_beam'/2 (File,'info') of <{'ok',Module,ChunkIds0}> when 'true' -> let <_11> = letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[{Name,_20,_21}|_8]> when 'true' -> let <_10> = apply 'lc$^0'/1 (_8) in ([Name|_10]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_24> when 'true' -> (primop 'match_fail' ({'function_clause',_24})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (ChunkIds0) in case apply 'scan_beam'/2 (File,_11) of <{'ok',_22,Chunks}> when call 'erlang':'=:=' (_22,Module) -> let <_14> = call 'lists':'reverse' (Chunks) in {'ok',Module,_14}
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end of <_15> -> _15 catch <_18,_17,_16> -> case <_18,_17,_16> of <('throw'-|['compiler_generated'] ),Error,_23> when 'true' -> Error
(<_25,_26,_27> when 'true' -> primop 'raise' (_27,_26)-|['compiler_generated'] ) end
(<_19> when 'true' -> (primop 'match_fail' ({'function_clause',_19})-|[{'function_name',{'read_all_chunks',1}}] )-|['compiler_generated'] ) end
'read_chunk_data'/2 = fun (_0,_1) -> try apply 'read_chunk_data'/3 (_0,_1,[]) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end
'read_chunk_data'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <File0,ChunkNames0,Options> when let <_3> = call 'erlang':'is_atom' (File0) in let <_4> = call 'erlang':'is_list' (File0) in let <_5> = call 'erlang':'is_binary' (File0) in let <_6> = call 'erlang':'or' (_4,_5) in call 'erlang':'or' (_3,_6) -> let <File> = apply 'beam_filename'/1 (File0) in case apply 'check_chunks'/5 (ChunkNames0,File,[],[],[]) of <{ChunkIds,Names,Optional}> when 'true' -> let <AllowMissingChunks> = call 'lists':'member' ('allow_missing_chunks',Options) in case apply 'scan_beam'/4 (File,ChunkIds,AllowMissingChunks,Optional) of <{'ok',Module,Chunks}> when 'true' -> let <AT> = call 'ets':'new' ('beam_symbols',[]) in let <T> = {'empty',AT} in letrec 'after$^0'/0 = fun () -> call 'ets':'delete' (AT) in try apply 'chunks_to_data'/7 (Names,Chunks,File,Chunks,Module,T,[]) of <_13> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) _13 catch <_16,_15,_14> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) primop 'raise' (_14,_15)
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_19,_18,_17> when 'true' -> (primop 'match_fail' ({'function_clause',_19,_18,_17})-|[{'function_name',{'read_chunk_data',3}}] )-|['compiler_generated'] ) end
'check_chunks'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <['atoms'|Ids],File,IL,L,O> when 'true' -> apply 'check_chunks'/5 (Ids,File,[[65|[116|[111|[109]]]]|[[65|[116|[85|[56]]]]|IL]],[{'atom_chunk','atoms'}|L],[[65|[116|[111|[109]]]]|[[65|[116|[85|[56]]]]|O]])
<['abstract_code'|Ids],File,IL,L,O> when 'true' -> apply 'check_chunks'/5 (Ids,File,[[65|[98|[115|[116]]]]|[[68|[98|[103|[105]]]]|IL]],[{'abst_chunk','abstract_code'}|L],[[65|[98|[115|[116]]]]|[[68|[98|[103|[105]]]]|O]])
<[ChunkName|Ids],File,IL,L,O> when call 'erlang':'is_atom' (ChunkName) -> let <ChunkId> = apply 'chunk_name_to_id'/2 (ChunkName,File) in apply 'check_chunks'/5 (Ids,File,[ChunkId|IL],[{ChunkId,ChunkName}|L],O)
<[ChunkId|Ids],File,IL,L,O> when 'true' -> apply 'check_chunks'/5 (Ids,File,[ChunkId|IL],[{ChunkId,ChunkId}|L],O)
<[],_X_File,IL,L,O> when 'true' -> let <_7> = call 'lists':'usort' (IL) in let <_6> = call 'lists':'reverse' (L) in {_7,_6,O}
(<_12,_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9,_8})-|[{'function_name',{'check_chunks',5}}] )-|['compiler_generated'] ) end
'scan_beam'/2 = fun (_0,_1) -> apply 'scan_beam'/4 (_0,_1,'false',[])
'scan_beam'/4 = fun (_0,_1,_2,_3) -> case apply 'scan_beam1'/2 (_0,_1) of <{'missing',_X_FD,Mod,Data,What}> when (call 'erlang':'=:=' (_2,'true')-|['compiler_generated'] ) -> let <_8> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[Id|_5]> when 'true' -> let <_7> = apply 'lc$^0'/1 (_5) in ([{Id,'missing_chunk'}|_7]-|['compiler_generated'] )
<[]> when 'true' -> Data
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (What) in {'ok',Mod,_8}
<{'missing',FD,Mod,Data,What}> when 'true' -> case call 'erlang':'--' (What,_3) of <[]> when 'true' -> {'ok',Mod,Data}
<[Missing|_16]> when 'true' -> let <_9> = apply 'filename'/1 (FD) in apply 'error'/1 ({'missing_chunk',_9,Missing})
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<R> when 'true' -> R end
'scan_beam1'/2 = fun (_0,_1) -> let <FD> = apply 'open_file'/1 (_0) in let <_3> = catch apply 'scan_beam2'/2 (FD,_1) in case _3 of <Error> when try let <_4> = call 'erlang':'element' (1,_3) in call 'erlang':'=:=' ('error',_4) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'throw' (Error)
<R> when 'true' -> R end
'scan_beam2'/2 = fun (_0,_1) -> case apply 'pread'/3 (_0,0,12) of <{NFD,{'ok',#{#<70>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<49>(8,1,'integer',['unsigned'|['big']]),#<_X_Size>(32,1,'integer',['unsigned'|['big']]),#<66>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<65>(8,1,'integer',['unsigned'|['big']]),#<77>(8,1,'integer',['unsigned'|['big']])}#}}> when 'true' -> apply 'scan_beam'/5 (NFD,12,_1,17,[])
<_X_Error> when 'true' -> let <_3> = apply 'filename'/1 (_0) in apply 'error'/1 ({'not_a_beam_file',_3}) end
'scan_beam'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_X_FD,_X_Pos,[],Mod,Data> when call 'erlang':'=/=' (Mod,17) -> {'ok',Mod,Data}
<FD,Pos,What,Mod,Data> when 'true' -> case apply 'pread'/3 (FD,Pos,8) of <{_X_NFD,'eof'}> when call 'erlang':'=:=' (Mod,17) -> let <_5> = apply 'filename'/1 (FD) in apply 'error'/1 ({'missing_chunk',_5,[65|[116|[111|[109]]]]})
<{_X_NFD,'eof'}> when call 'erlang':'=:=' (What,'info') -> let <_6> = call 'lists':'reverse' (Data) in {'ok',Mod,_6}
<{NFD,'eof'}> when 'true' -> {'missing',NFD,Mod,Data,What}
<{NFD,{'ok',#{#<IdL>(4,8,'binary',['unsigned'|['big']]),#<Sz>(32,1,'integer',['unsigned'|['big']])}#}}> when 'true' -> let <Id> = call 'erlang':'binary_to_list' (IdL) in let <Pos1> = call 'erlang':'+' (Pos,8) in let <_9> = call 'erlang':'+' (Sz,3) in let <_10> = call 'erlang':'/' (_9,4) in let <_11> = call 'erlang':'trunc' (_10) in let <_12> = call 'erlang':'*' (4,_11) in let <Pos2> = call 'erlang':'+' (_12,Pos1) in apply 'get_data'/8 (What,Id,NFD,Sz,Pos1,Pos2,Mod,Data)
<{_X_NFD,{'ok',_X_ChunkHead}}> when 'true' -> let <_14> = apply 'filename'/1 (FD) in apply 'error'/1 ({'invalid_beam_file',_14,Pos})
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end end
'get_atom_data'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> let <NewCs> = apply 'del_chunk'/2 (_1,_0) in case apply 'get_chunk'/4 (_1,_4,_3,_2) of <{NFD,Chunk}> when 'true' -> case Chunk of <#{#<_X_Num>(32,1,'integer',['unsigned'|['big']]),#<Chunk2>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case apply 'extract_atom'/2 (Chunk2,_7) of <{Module,_23}> when 'true' -> let <_13> = case _0 of <'info'> when 'true' -> {_1,_4,_3}
<_24> when 'true' -> {_1,Chunk} end in apply 'scan_beam'/5 (NFD,_5,NewCs,Module,[_13|_6])
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
'get_data'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case <_0,_1,_2,_3,_4,_5,_6,_7> of <Cs,Id = [65|[116|[111|[109]]]],FD,Size,Pos,Pos2,_X_Mod,Data> when 'true' -> apply 'get_atom_data'/8 (Cs,Id,FD,Size,Pos,Pos2,Data,'latin1')
<Cs,Id = [65|[116|[85|[56]]]],FD,Size,Pos,Pos2,_X_Mod,Data> when 'true' -> apply 'get_atom_data'/8 (Cs,Id,FD,Size,Pos,Pos2,Data,'utf8')
<'info',Id,FD,Size,Pos,Pos2,Mod,Data> when 'true' -> apply 'scan_beam'/5 (FD,Pos2,'info',Mod,[{Id,Pos,Size}|Data])
<Chunks,Id,FD,Size,Pos,Pos2,Mod,Data> when 'true' -> let <_21,_22> = case call 'lists':'member' (Id,Chunks) of <'true'> when 'true' -> case apply 'get_chunk'/4 (Id,Pos,Size,FD) of <{FD1,Chunk}> when 'true' -> <FD1,[{Id,Chunk}|Data]>
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<'false'> when 'true' -> <FD,Data>
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end in let <NewChunks> = apply 'del_chunk'/2 (Id,Chunks) in apply 'scan_beam'/5 ((_21-|['compiler_generated'] ),Pos2,NewChunks,Mod,(_22-|['compiler_generated'] )) end
'del_chunk'/2 = fun (_0,_1) -> case <_0,_1> of <_X_Id,'info'> when 'true' -> 'info'
<Id,Chunks> when 'true' -> call 'lists':'delete' (Id,Chunks) end
'get_chunk'/4 = fun (_0,_1,_2,_3) -> case apply 'pread'/3 (_3,_1,_2) of <{NFD,'eof'}> when call 'erlang':'=:=' (_2,0) -> {NFD,#{}#}
<{_X_NFD,'eof'}> when call 'erlang':'>' (_2,0) -> let <_4> = apply 'filename'/1 (_3) in apply 'error'/1 ({'chunk_too_big',_4,_0,_2,0})
<{_X_NFD,{'ok',Chunk}}> when try let <_5> = call 'erlang':'byte_size' (Chunk) in call 'erlang':'>' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = apply 'filename'/1 (_3) in let <_6> = call 'erlang':'byte_size' (Chunk) in apply 'error'/1 ({'chunk_too_big',_7,_0,_2,_6})
<{NFD,{'ok',Chunk}}> when 'true' -> {NFD,Chunk}
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
'chunks_to_data'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[{'atom_chunk',Name}|CNs],Chunks,File,Cs,Module,Atoms,L> when 'true' -> case apply 'chunk_to_data'/6 (Name,#{}#,File,Cs,Atoms,Module) of <{NewAtoms,Ret}> when 'true' -> apply 'chunks_to_data'/7 (CNs,Chunks,File,Cs,Module,NewAtoms,[Ret|L])
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<[{'abst_chunk',Name}|CNs],Chunks,File,Cs,Module,Atoms,L> when 'true' -> let <DbgiChunk> = call 'proplists':'get_value' ([68|[98|[103|[105]]]],Chunks,#{}#) in let <_9> = catch apply 'chunk_to_data'/6 ('debug_info',DbgiChunk,File,Cs,Atoms,Module) in let <_13> = case _9 of <{DbgiAtoms,{'debug_info',{'debug_info_v1',Backend,Metadata}}}> when 'true' -> case call Backend:'debug_info' ('erlang_v1',Module,Metadata,[]) of <{'ok',Code}> when 'true' -> {DbgiAtoms,{'abstract_code',{'raw_abstract_v1',Code}}}
<{'error',_25}> when 'true' -> {DbgiAtoms,{'abstract_code','no_abstract_code'}}
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<{'error','beam_lib',{'key_missing_or_invalid',Path,'debug_info'}}> when 'true' -> apply 'error'/1 ({'key_missing_or_invalid',Path,'abstract_code'})
<_26> when 'true' -> let <AbstChunk> = call 'proplists':'get_value' ([65|[98|[115|[116]]]],Chunks,#{}#) in apply 'chunk_to_data'/6 (Name,AbstChunk,File,Cs,Atoms,Module) end in case _13 of <{NewAtoms,Ret}> when 'true' -> apply 'chunks_to_data'/7 (CNs,Chunks,File,Cs,Module,NewAtoms,[Ret|L])
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<[{Id,Name}|CNs],Chunks,File,Cs,Module,Atoms,L> when 'true' -> case call 'lists':'keyfind' (Id,1,Chunks) of <{_X_Id,Chunk}> when 'true' -> case apply 'chunk_to_data'/6 (Name,Chunk,File,Cs,Atoms,Module) of <{NewAtoms,Ret}> when 'true' -> apply 'chunks_to_data'/7 (CNs,Chunks,File,Cs,Module,NewAtoms,[Ret|L])
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<[],_X_Chunks,_X_File,_X_Cs,Module,_X_Atoms,L> when 'true' -> let <_17> = call 'lists':'reverse' (L) in {'ok',{Module,_17}}
(<_24,_23,_22,_21,_20,_19,_18> when 'true' -> (primop 'match_fail' ({'function_clause',_24,_23,_22,_21,_20,_19,_18})-|[{'function_name',{'chunks_to_data',7}}] )-|['compiler_generated'] ) end
'chunk_to_data'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Id = 'attributes',Chunk,File,_X_Cs,AtomTable,_X_Mod> when 'true' -> try let <Term> = call 'erlang':'binary_to_term' (Chunk) in let <_7> = apply 'attributes'/1 (Term) in {AtomTable,{Id,_7}} of <_8> -> _8 catch <_11,_10,_9> -> case <_11,_10,_9> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_52> when 'true' -> let <_12> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_12})
(<_62,_63,_64> when 'true' -> primop 'raise' (_64,_63)-|['compiler_generated'] ) end
<Id = 'compile_info',Chunk,File,_X_Cs,AtomTable,_X_Mod> when 'true' -> try let <_13> = call 'erlang':'binary_to_term' (Chunk) in {AtomTable,{Id,_13}} of <_14> -> _14 catch <_17,_16,_15> -> case <_17,_16,_15> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_53> when 'true' -> let <_18> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_18})
(<_65,_66,_67> when 'true' -> primop 'raise' (_67,_66)-|['compiler_generated'] ) end
<Id = 'debug_info',Chunk,File,_X_Cs,AtomTable,Mod> when 'true' -> case Chunk of <#{}#> when 'true' -> {AtomTable,{Id,'no_debug_info'}}
<#{#<0>(8,1,'integer',['unsigned'|['big']]),#<N>(8,1,'integer',['unsigned'|['big']]),#<Mode0>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Mode> = call 'erlang':'binary_to_atom' (Mode0,'utf8') in let <Term> = apply 'decrypt_chunk'/5 (Mode,Mod,File,Id,Rest) in let <_21> = apply 'anno_from_term'/1 (Term) in {AtomTable,{Id,_21}}
<_54> when 'true' -> let <_22> = catch call 'erlang':'binary_to_term' (Chunk) in case _22 of <{'EXIT',_55}> when 'true' -> let <_23> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_23})
<Term> when 'true' -> let <_24> = apply 'anno_from_term'/1 (Term) in {AtomTable,{Id,_24}} end end
<Id = 'abstract_code',Chunk,File,_X_Cs,AtomTable,Mod> when 'true' -> case Chunk of <#{}#> when 'true' -> {AtomTable,{Id,'no_abstract_code'}}
<#{#<0>(8,1,'integer',['unsigned'|['big']]),#<N>(8,1,'integer',['unsigned'|['big']]),#<Mode0>(N,8,'binary',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Mode> = call 'erlang':'binary_to_atom' (Mode0,'utf8') in let <Term> = apply 'decrypt_chunk'/5 (Mode,Mod,File,Id,Rest) in let <_29> = apply 'old_anno_from_term'/1 (Term) in {AtomTable,{Id,_29}}
<_56> when 'true' -> let <_30> = catch call 'erlang':'binary_to_term' (Chunk) in case _30 of <{'EXIT',_57}> when 'true' -> let <_31> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_31})
<Term> when 'true' -> try let <_32> = apply 'old_anno_from_term'/1 (Term) in {AtomTable,{Id,_32}} of <_33> -> _33 catch <_36,_35,_34> -> let <_37> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_37}) end end
<Id = 'atoms',_X_Chunk,_X_File,Cs,AtomTable0,_X_Mod> when 'true' -> let <AtomTable> = apply 'ensure_atoms'/2 (AtomTable0,Cs) in let <Atoms> = call 'ets':'tab2list' (AtomTable) in let <_42> = call 'lists':'sort' (Atoms) in {AtomTable,{Id,_42}}
<ChunkName,Chunk,File,Cs,AtomTable,_X_Mod> when call 'erlang':'is_atom' (ChunkName) -> let <_43> = catch apply 'symbols'/4 (Chunk,AtomTable,Cs,ChunkName) in case _43 of <{'ok',NewAtomTable,S}> when 'true' -> {NewAtomTable,{ChunkName,S}}
<{'EXIT',_61}> when 'true' -> let <_44> = apply 'chunk_name_to_id'/2 (ChunkName,File) in apply 'error'/1 ({'invalid_chunk',File,_44})
(<_45> when 'true' -> primop 'match_fail' ({'case_clause',_45})-|['compiler_generated'] ) end
<ChunkId,Chunk,_X_File,_X_Cs,AtomTable,_X_Module> when call 'erlang':'is_list' (ChunkId) -> {AtomTable,{ChunkId,Chunk}}
(<_51,_50,_49,_48,_47,_46> when 'true' -> (primop 'match_fail' ({'function_clause',_51,_50,_49,_48,_47,_46})-|[{'function_name',{'chunk_to_data',6}}] )-|['compiler_generated'] ) end
'chunk_name_to_id'/2 = fun (_0,_1) -> case <_0,_1> of <'indexed_imports',_4> when 'true' -> [73|[109|[112|[84]]]]
<'imports',_5> when 'true' -> [73|[109|[112|[84]]]]
<'exports',_6> when 'true' -> [69|[120|[112|[84]]]]
<'labeled_exports',_7> when 'true' -> [69|[120|[112|[84]]]]
<'locals',_8> when 'true' -> [76|[111|[99|[84]]]]
<'labeled_locals',_9> when 'true' -> [76|[111|[99|[84]]]]
<'attributes',_10> when 'true' -> [65|[116|[116|[114]]]]
<'abstract_code',_11> when 'true' -> [65|[98|[115|[116]]]]
<'debug_info',_12> when 'true' -> [68|[98|[103|[105]]]]
<'compile_info',_13> when 'true' -> [67|[73|[110|[102]]]]
<Other,File> when 'true' -> apply 'error'/1 ({'unknown_chunk',File,Other}) end
'attributes'/1 = fun (_0) -> let <_1> = call 'lists':'keysort' (1,_0) in apply 'attributes'/2 (_1,[])
'attributes'/2 = fun (_0,_1) -> case <_0,_1> of <[],R> when 'true' -> call 'lists':'reverse' (R)
<L,R> when 'true' -> let <_2> = call 'erlang':'hd' (L) in let <K> = call 'erlang':'element' (1,_2) in let <_7> = fun (_5) -> let <_4> = call 'erlang':'element' (1,_5) in call 'erlang':'=:=' (_4,K) in case call 'lists':'splitwith' (_7,L) of <{L1,L2}> when 'true' -> let <_13> = letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[{_17,A}|_10]> when 'true' -> let <_12> = apply 'lc$^1'/1 (_10) in ([A|_12]-|['compiler_generated'] )
(<[_9|_10]> when 'true' -> apply 'lc$^1'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_19> when 'true' -> (primop 'match_fail' ({'function_clause',_19})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (L1) in let <V> = call 'lists':'append' (_13) in apply 'attributes'/2 (L2,[{K,V}|R])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end
'symbols'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <#{#<_X_Num>(32,1,'integer',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}#,AT0,Cs,Name> when 'true' -> let <AT> = apply 'ensure_atoms'/2 (AT0,Cs) in apply 'symbols1'/5 (B,AT,Name,[],1)
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'symbols',4}}] )-|['compiler_generated'] ) end
'symbols1'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <#{#<I1>(32,1,'integer',['unsigned'|['big']]),#<I2>(32,1,'integer',['unsigned'|['big']]),#<I3>(32,1,'integer',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}#,AT,Name,S,Cnt> when 'true' -> let <Symbol> = apply 'symbol'/6 (Name,AT,I1,I2,I3,Cnt) in let <_6> = call 'erlang':'+' (Cnt,1) in apply 'symbols1'/5 (B,AT,Name,[Symbol|S],_6)
<#{}#,AT,_X_Name,S,_X_Cnt> when 'true' -> let <_7> = call 'lists':'sort' (S) in {'ok',AT,_7}
(<_12,_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9,_8})-|[{'function_name',{'symbols1',5}}] )-|['compiler_generated'] ) end
'symbol'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <'indexed_imports',AT,I1,I2,I3,Cnt> when 'true' -> let <_7> = apply 'atm'/2 (AT,I1) in let <_6> = apply 'atm'/2 (AT,I2) in {Cnt,_7,_6,I3}
<'imports',AT,I1,I2,I3,_X_Cnt> when 'true' -> let <_9> = apply 'atm'/2 (AT,I1) in let <_8> = apply 'atm'/2 (AT,I2) in {_9,_8,I3}
<'labeled_exports',AT,I1,I2,I3,_X_Cnt> when 'true' -> let <_10> = apply 'atm'/2 (AT,I1) in {_10,I2,I3}
<'labeled_locals',AT,I1,I2,I3,_X_Cnt> when 'true' -> let <_11> = apply 'atm'/2 (AT,I1) in {_11,I2,I3}
<_19,AT,I1,I2,_X_I3,_X_Cnt> when 'true' -> let <_12> = apply 'atm'/2 (AT,I1) in {_12,I2} end
'atm'/2 = fun (_0,_1) -> case call 'ets':'lookup' (_0,_1) of <[{_X_N,S}|[]]> when 'true' -> S
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'ensure_atoms'/2 = fun (_0,_1) -> case <_0,_1> of <{'empty',AT},Cs> when 'true' -> do case call 'lists':'keyfind' ([65|[116|[85|[56]]]],1,Cs) of <{_X_Id,AtomChunk}> when call 'erlang':'is_binary' (AtomChunk) -> apply 'extract_atoms'/3 (AtomChunk,AT,'utf8')
<_6> when 'true' -> case call 'lists':'keyfind' ([65|[116|[111|[109]]]],1,Cs) of <{_X_Id,AtomChunk}> when 'true' -> apply 'extract_atoms'/3 (AtomChunk,AT,'latin1')
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end end AT
<AT,_X_Cs> when 'true' -> AT end
'extract_atoms'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <#{#<_X_Num>(32,1,'integer',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}#,AT,Encoding> when 'true' -> apply 'extract_atoms'/4 (B,1,AT,Encoding)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'extract_atoms',3}}] )-|['compiler_generated'] ) end
'extract_atoms'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <#{}#,_X_I,_X_AT,_X_Encoding> when 'true' -> 'true'
<B,I,AT,Encoding> when 'true' -> case apply 'extract_atom'/2 (B,Encoding) of <{Atom,B1}> when 'true' -> case call 'ets':'insert' (AT,{I,Atom}) of <'true'> when 'true' -> let <_6> = call 'erlang':'+' (I,1) in apply 'extract_atoms'/4 (B1,_6,AT,Encoding)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end end
'extract_atom'/2 = fun (_0,_1) -> case <_0,_1> of <#{#<Len>(8,1,'integer',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}#,Encoding> when 'true' -> case B of <#{#<SB>(Len,8,'binary',['unsigned'|['big']]),#<Tail>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_3> = call 'erlang':'binary_to_atom' (SB,Encoding) in {_3,Tail}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'extract_atom',2}}] )-|['compiler_generated'] ) end
'open_file'/1 = fun (_0) -> case _0 of <Binary = #{#<70>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<49>(8,1,'integer',['unsigned'|['big']]),#<_4>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> {'bb',0,Binary,Binary}
<Binary0> when call 'erlang':'is_binary' (_0) -> let <Binary> = apply 'uncompress'/1 (Binary0) in {'bb',0,Binary,Binary}
<FileName> when 'true' -> case call 'file':'open' (FileName,['read'|['raw'|['binary']]]) of <{'ok',Fd}> when 'true' -> apply 'read_all'/3 (Fd,FileName,[])
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end end
'read_all'/3 = fun (_0,_1,_2) -> case call 'file':'read' (_0,262144) of <{'ok',Bin}> when 'true' -> apply 'read_all'/3 (_0,_1,[Bin|_2])
<'eof'> when 'true' -> case call 'file':'close' (_0) of <'ok'> when 'true' -> let <_5> = call 'lists':'reverse' (_2) in let <_6> = apply 'uncompress'/1 (_5) in {'bb',0,_6,_1}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<Error> when 'true' -> case call 'file':'close' (_0) of <'ok'> when 'true' -> apply 'file_error'/2 (_1,Error)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end end
'pread'/3 = fun (_0,_1,_2) -> case _0 of <{'bb',Pos,Binary,_21}> when 'true' -> let <Skip> = call 'erlang':'-' (_1,Pos) in case Binary of <#{#<_22>(Skip,8,'binary',['unsigned'|['big']]),#<B>(_2,8,'binary',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_rec0> = call 'erlang':'+' (_1,_2) in case _0 of <{'bb',_rec2,_rec3,_rec4}> when 'true' -> let <_8> = {'bb',_rec0,Bin,_rec4} in {_8,{'ok',B}}
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<#{#<_24>(Skip,8,'binary',['unsigned'|['big']]),#<Bin>('all',8,'binary',['unsigned'|['big']])}#> when try let <_10> = call 'erlang':'byte_size' (Bin) in call 'erlang':'>' (_10,0) of <Try> -> Try catch <T,R> -> 'false' -> let <_11> = call 'erlang':'byte_size' (Bin) in let <_rec5> = call 'erlang':'+' (_1,_11) in case _0 of <{'bb',_rec7,_rec8,_rec9}> when 'true' -> let <_15> = {'bb',_rec5,#{}#,_rec9} in {_15,{'ok',Bin}}
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<_26> when 'true' -> {_0,'eof'} end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'filename'/1 = fun (_0) -> case _0 of <BB = {'bb',_11,_12,_13}> when (try let <_5> = call 'erlang':'element' (4,BB) in call 'erlang':'is_binary' (_5) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case BB of (<({'bb',_14,_15,_rec10}-|['compiler_generated'] )> when 'true' -> _rec10-|['compiler_generated'] )
(<_16> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<BB> when 'true' -> (case BB of (<({'bb',_17,_18,_rec11}-|['compiler_generated'] )> when 'true' -> call 'erlang':'list_to_atom' (_rec11)-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'beam_filename'/1 = fun (_0) -> case _0 of <Bin> when call 'erlang':'is_binary' (_0) -> Bin
<File> when 'true' -> let <_1> = call 'filename':'rootname' (File,[46|[98|[101|[97|[109]]]]]) in call 'erlang':'++' (_1,[46|[98|[101|[97|[109]]]]]) end
'uncompress'/1 = fun (_0) -> case call 'ram_file':'open' (_0,['write'|['binary']]) of <{'ok',Fd}> when 'true' -> case call 'ram_file':'uncompress' (Fd) of <{'ok',_6}> when 'true' -> case call 'ram_file':'get_file' (Fd) of <{'ok',Binary}> when 'true' -> case call 'ram_file':'close' (Fd) of <'ok'> when 'true' -> Binary
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'compress'/1 = fun (_0) -> case call 'ram_file':'open' (_0,['write'|['binary']]) of <{'ok',Fd}> when 'true' -> case call 'ram_file':'compress' (Fd) of <{'ok',_6}> when 'true' -> case call 'ram_file':'get_file' (Fd) of <{'ok',Binary}> when 'true' -> case call 'ram_file':'close' (Fd) of <'ok'> when 'true' -> Binary
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'assert_directory'/1 = fun (_0) -> case call 'filelib':'is_dir' (_0) of <'true'> when 'true' -> 'ok'
<'false'> when 'true' -> apply 'error'/1 ({'not_a_directory',_0})
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'file_error'/2 = fun (_0,_1) -> case <_0,_1> of <FileName,{'error',Reason}> when 'true' -> apply 'error'/1 ({'file_error',FileName,Reason})
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'file_error',2}}] )-|['compiler_generated'] ) end
'error'/1 = fun (_0) -> call 'erlang':'throw' ({'error','beam_lib',_0})
'significant_chunks'/0 = fun () -> let <_0> = apply 'md5_chunks'/0 () in [[76|[105|[110|[101]]]]|_0]
'md5_chunks'/0 = fun () -> [[65|[116|[111|[109]]]]|[[65|[116|[85|[56]]]]|[[67|[111|[100|[101]]]]|[[83|[116|[114|[84]]]]|[[73|[109|[112|[84]]]]|[[69|[120|[112|[84]]]]|[[70|[117|[110|[84]]]]|[[76|[105|[116|[84]]]]]]]]]]]]
'mandatory_chunks'/0 = fun () -> [[67|[111|[100|[101]]]]|[[69|[120|[112|[84]]]]|[[73|[109|[112|[84]]]]|[[83|[116|[114|[84]]]]]]]]
'decrypt_chunk'/5 = fun (_0,_1,_2,_3,_4) -> try let <KeyString> = apply 'get_crypto_key'/1 ({'debug_info',_0,_1,_2}) in case apply 'make_crypto_key'/2 (_0,KeyString) of <{_18,Key,IVec,_X_BlockSize}> when call 'erlang':'=:=' (_18,_0) -> case apply 'start_crypto'/0 () of <'ok'> when 'true' -> let <NewBin> = call 'crypto':'block_decrypt' (_0,Key,IVec,_4) in call 'erlang':'binary_to_term' (NewBin)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end of <_9> -> _9 catch <_12,_11,_10> -> apply 'error'/1 ({'key_missing_or_invalid',_2,_3})
'old_anno_from_term'/1 = fun (_0) -> case _0 of <{'raw_abstract_v1',Forms}> when 'true' -> let <_1> = apply 'anno_from_forms'/1 (Forms) in {'raw_abstract_v1',_1}
<_@r0 = {Tag,Forms}> when let <_2> = call 'erlang':'=:=' (Tag,'abstract_v1') in let <_3> = call 'erlang':'=:=' (Tag,'abstract_v2') in call 'erlang':'or' (_2,_3) -> try let <_4> = apply 'anno_from_forms'/1 (Forms) in {Tag,_4} of <_5> -> _5 catch <_8,_7,_6> -> _@r0
<T> when 'true' -> T end
'anno_from_term'/1 = fun (_0) -> case _0 of <_@r0 = {Tag1 = 'debug_info_v1',Tag2 = 'erl_abstract_code',{Forms,Opts}}> when 'true' -> try let <_1> = apply 'anno_from_forms'/1 (Forms) in {Tag1,Tag2,{_1,Opts}} of <_2> -> _2 catch <_5,_4,_3> -> _@r0
<T> when 'true' -> T end
'anno_from_forms'/1 = fun (_0) -> let <Forms> = call 'epp':'restore_typed_record_fields' (_0) in (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[Form|_3]> when 'true' -> let <_5> = call 'erl_parse':'anno_from_term' (Form) in let <_6> = apply 'lc$^0'/1 (_3) in ([_5|_6]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Forms)-|['list_comprehension'] )
'start_crypto'/0 = fun () -> case call 'crypto':'start' () of <{'error',{'already_started',_1}}> when 'true' -> 'ok'
<'ok'> when 'true' -> 'ok'
(<_0> when 'true' -> primop 'match_fail' ({'case_clause',_0})-|['compiler_generated'] ) end
'get_crypto_key'/1 = fun (_0) -> apply 'call_crypto_server'/1 ({'get_crypto_key',_0})
'call_crypto_server'/1 = fun (_0) -> try call 'gen_server':'call' ('beam_lib__crypto_key_server',_0,'infinity') of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('exit'-|['compiler_generated'] ),({('noproc'-|['compiler_generated'] ),_6}-|['compiler_generated'] ),_7> when 'true' -> apply 'call_crypto_server_1'/1 (_0)
<('exit'-|['compiler_generated'] ),({('normal'-|['compiler_generated'] ),_8}-|['compiler_generated'] ),_9> when 'true' -> apply 'call_crypto_server_1'/1 (_0)
(<_10,_11,_12> when 'true' -> primop 'raise' (_12,_11)-|['compiler_generated'] ) end
'call_crypto_server_1'/1 = fun (_0) -> do case call 'gen_server':'start' ({'local','beam_lib__crypto_key_server'},'beam_lib',[],[]) of <{'ok',_3}> when 'true' -> 'ok'
<{'error',{'already_started',_4}}> when 'true' -> 'ok'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end do call 'erlang':'yield' () apply 'call_crypto_server'/1 (_0)
'init'/1 = fun (_0) -> case _0 of <[]> when 'true' -> {'ok',{'state','undefined'}}
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'init',1}}] )-|['compiler_generated'] ) end
'handle_call'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <R = {'get_crypto_key',_32},From,S = {'state','undefined'}> when 'true' -> case apply 'crypto_key_fun_from_file'/0 () of <'error'> when 'true' -> {'reply','error',S}
<F> when call 'erlang':'is_function' (F) -> case S of <{'state',_rec13}> when 'true' -> let <_5> = {'state',F} in apply 'handle_call'/3 (R,From,_5)
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<{'get_crypto_key',What},From,S = {'state',F}> when 'true' -> try let <Result> = apply F (What) in do call 'gen_server':'reply' (From,Result) do call 'erlang':'garbage_collect' () {'noreply',S} of <_8> -> _8 catch <_11,_10,_9> -> {'reply','error',S}
<{'crypto_key_fun',F},From = {_37,_38},S> when 'true' -> (case S of (<({'state',_rec14}-|['compiler_generated'] )> when 'true' -> case _rec14 of <'undefined'> when 'true' -> case <> of <> when call 'erlang':'is_function' (F,1) -> let <_14> = catch apply F ('init') in let <_45,_46,_47> = case _14 of <'ok'> when 'true' -> <'true',F,'ok'>
<{'ok',F1}> when call 'erlang':'is_function' (F1) -> case <> of <> when call 'erlang':'is_function' (F1,1) -> <'true',F1,'ok'>
<> when 'true' -> <'false','undefined',{'error','badfun'}> end
<_@r0 = {'error',Reason}> when 'true' -> <'false','undefined',_@r0>
<{'EXIT',Reason}> when 'true' -> <'false','undefined',{'error',Reason}>
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end in do call 'gen_server':'reply' (From,(_47-|['compiler_generated'] )) do call 'erlang':'garbage_collect' () let <_21> = case (_45-|['compiler_generated'] ) of <'true'> when 'true' -> case S of <{'state',_rec16}> when 'true' -> {'state',(_46-|['compiler_generated'] )}
(<_40> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<'false'> when 'true' -> S
(<_20> when 'true' -> primop 'match_fail' ({'case_clause',_20})-|['compiler_generated'] ) end in {'noreply',_21}
<> when 'true' -> {'reply',{'error','badfun'},S} end
<OtherF> when call 'erlang':'is_function' (_rec14) -> {'reply',{'error','exists'},S}
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_39> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'clear_crypto_key_fun',_X_From,S> when 'true' -> (case S of (<({'state',_rec17}-|['compiler_generated'] )> when 'true' -> case _rec17 of <'undefined'> when 'true' -> {'stop','normal','undefined',S}
<F> when 'true' -> let <_26> = catch apply F ('clear') in {'stop','normal',{'ok',_26},S} end-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_31,_30,_29> when 'true' -> (primop 'match_fail' ({'function_clause',_31,_30,_29})-|[{'function_name',{'handle_call',3}}] )-|['compiler_generated'] ) end
'handle_cast'/2 = fun (_0,_1) -> {'noreply',_1}
'handle_info'/2 = fun (_0,_1) -> {'noreply',_1}
'code_change'/3 = fun (_0,_1,_2) -> {'ok',_1}
'terminate'/2 = fun (_0,_1) -> 'ok'
'crypto_key_fun_from_file'/0 = fun () -> case call 'init':'get_argument' ('home') of <{'ok',[_@r0 = [Home|[]]|[]]}> when 'true' -> apply 'crypto_key_fun_from_file_1'/1 ([[46]|_@r0])
<_1> when 'true' -> apply 'crypto_key_fun_from_file_1'/1 ([[46]]) end
'crypto_key_fun_from_file_1'/1 = fun (_0) -> case apply 'f_p_s'/2 (_0,[46|[101|[114|[108|[97|[110|[103|[46|[99|[114|[121|[112|[116]]]]]]]]]]]]]) of <{'ok',KeyInfo,_3}> when 'true' -> apply 'try_load_crypto_fun'/1 (KeyInfo)
<_4> when 'true' -> 'error' end
'f_p_s'/2 = fun (_0,_1) -> case call 'file':'path_script' (_0,_1) of <{'error','enoent'}> when 'true' -> {'error','enoent'}
<{'error',E = {Line,_X_Mod,_X_Term}}> when 'true' -> let <_2> = call 'file':'format_error' (E) in do apply 'error'/2 ([102|[105|[108|[101|[58|[112|[97|[116|[104|[95|[115|[99|[114|[105|[112|[116|[40|[126|[116|[112|[44|[126|[116|[112|[41|[58|[32|[101|[114|[114|[111|[114|[32|[111|[110|[32|[108|[105|[110|[101|[32|[126|[112|[58|[32|[126|[116|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_0|[_1|[Line|[_2|[]]]]]) 'ok'
<{'error',E}> when call 'erlang':'is_atom' (E) -> let <_3> = call 'file':'format_error' (E) in do apply 'error'/2 ([102|[105|[108|[101|[58|[112|[97|[116|[104|[95|[115|[99|[114|[105|[112|[116|[40|[126|[116|[112|[44|[126|[116|[112|[41|[58|[32|[126|[116|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_0|[_1|[_3|[]]]]) 'ok'
<Other> when 'true' -> Other end
'try_load_crypto_fun'/1 = fun (_0) -> case _0 of <KeyInfo> when call 'erlang':'is_list' (_0) -> let <T> = call 'ets':'new' ('keys',['private'|['set']]) in let <_4> = fun (_2) -> case _2 of <{'debug_info',Mode,M,Key}> when call 'erlang':'is_atom' (M) -> call 'ets':'insert' (T,{{'debug_info',Mode,M,[]},Key})
<{'debug_info',Mode,[],Key}> when 'true' -> call 'ets':'insert' (T,{{'debug_info',Mode,[],[]},Key})
<Other> when 'true' -> apply 'error'/2 ([117|[110|[107|[110|[111|[119|[110|[32|[107|[101|[121|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]],[Other|[]]) end in do call 'lists':'foreach' (_4,KeyInfo) (fun (_5) -> case _5 of <_@r0 = {'debug_info',Mode,M,F}> when 'true' -> apply 'alt_lookup_key'/2 ([_@r0|[{'debug_info',Mode,M,[]}|[{'debug_info',Mode,[],[]}|[]]]],T)
<'clear'> when 'true' -> call 'ets':'delete' (T)
<_8> when 'true' -> 'error' end-|[{'id',{0,0,'-try_load_crypto_fun/1-fun-1-'}}] )
<KeyInfo> when 'true' -> apply 'error'/2 ([117|[110|[114|[101|[99|[111|[103|[110|[105|[122|[101|[100|[32|[99|[114|[121|[112|[116|[111|[32|[107|[101|[121|[32|[105|[110|[102|[111|[58|[32|[126|[112|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[KeyInfo|[]]) end
'alt_lookup_key'/2 = fun (_0,_1) -> case <_0,_1> of <[H|T],Tab> when 'true' -> case call 'ets':'lookup' (Tab,H) of <[]> when 'true' -> apply 'alt_lookup_key'/2 (T,Tab)
<[{_5,Val}|[]]> when 'true' -> Val
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<[],_6> when 'true' -> 'error'
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'alt_lookup_key',2}}] )-|['compiler_generated'] ) end
'error'/2 = fun (_0,_1) -> do call 'error_logger':'error_msg' (_0,_1) 'error'
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('beam_lib')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('beam_lib',_0) end