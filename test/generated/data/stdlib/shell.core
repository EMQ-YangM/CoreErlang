module 'shell' ['catch_exception'/1,'history'/1,'local_allowed'/3,'module_info'/0,'module_info'/1,'non_local_allowed'/3,'prompt_func'/1,'results'/1,'server'/1,'server'/2,'start'/0,'start'/1,'start'/2,'start_restricted'/1,'stop_restricted'/0,'strings'/1,'whereis_evaluator'/0,'whereis_evaluator'/1] attributes [ 'file' = [{[115|[114|[99|[47|[115|[104|[101|[108|[108|[46|[101|[114|[108]]]]]]]]]]]]],1}]
, 'spec' = [{{'start',0},[{'type',51,'fun',[{'type',51,'product',[]}|[{'type',51,'pid',[]}]]}]}]
, 'spec' = [{{'whereis_evaluator',0},[{'type',66,'fun',[{'type',66,'product',[]}|[{'type',66,'union',[{'atom',66,'undefined'}|[{'type',66,'pid',[]}]]}]]}]}]
, 'spec' = [{{'whereis_evaluator',1},[{'type',103,'fun',[{'type',103,'product',[{'type',103,'pid',[]}]}|[{'type',103,'union',[{'atom',103,'undefined'}|[{'type',103,'pid',[]}]]}]]}]}]
, 'spec' = [{{'start_restricted',1},[{'type',120,'bounded_fun',[{'type',120,'fun',[{'type',120,'product',[{'var',120,'Module'}]}|[{'type',120,'tuple',[{'atom',120,'error'}|[{'var',120,'Reason'}]]}]]}|[[{'type',121,'constraint',[{'atom',121,'is_subtype'}|[[{'var',121,'Module'}|[{'type',121,'module',[]}]]]]}|[{'type',122,'constraint',[{'atom',122,'is_subtype'}|[[{'var',122,'Reason'}|[{'remote_type',122,[{'atom',122,'code'}|[{'atom',122,'load_error_rsn'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'stop_restricted',0},[{'type',138,'fun',[{'type',138,'product',[]}|[{'type',138,'no_return',[]}]]}]}]
, 'spec' = [{{'server',2},[{'type',144,'fun',[{'type',144,'product',[{'type',144,'boolean',[]}|[{'type',144,'boolean',[]}]]}|[{'atom',144,'terminated'}]]}]}]
, 'spec' = [{{'server',1},[{'type',161,'fun',[{'type',161,'product',[{'type',161,'boolean',[]}]}|[{'atom',161,'terminated'}]]}]}]
, 'file' = [{[47|[117|[115|[114|[47|[108|[111|[99|[97|[108|[47|[67|[101|[108|[108|[97|[114|[47|[101|[114|[108|[97|[110|[103|[47|[50|[50|[46|[50|[47|[108|[105|[98|[47|[101|[114|[108|[97|[110|[103|[47|[108|[105|[98|[47|[107|[101|[114|[110|[101|[108|[45|[54|[46|[53|[46|[49|[47|[105|[110|[99|[108|[117|[100|[101|[47|[102|[105|[108|[101|[46|[104|[114|[108]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],1}]
, 'record' = [{'file_info',[{'typed_record_field',{'record_field',26,{'atom',26,'size'}},{'type',26,'union',[{'type',26,'non_neg_integer',[]}|[{'atom',26,'undefined'}]]}}|[{'typed_record_field',{'record_field',27,{'atom',27,'type'}},{'type',27,'union',[{'atom',27,'device'}|[{'atom',27,'directory'}|[{'atom',27,'other'}|[{'atom',27,'regular'}|[{'atom',27,'symlink'}|[{'atom',28,'undefined'}]]]]]]}}|[{'typed_record_field',{'record_field',29,{'atom',29,'access'}},{'type',29,'union',[{'atom',29,'read'}|[{'atom',29,'write'}|[{'atom',29,'read_write'}|[{'atom',29,'none'}|[{'atom',29,'undefined'}]]]]]}}|[{'typed_record_field',{'record_field',30,{'atom',30,'atime'}},{'type',30,'union',[{'remote_type',30,[{'atom',30,'file'}|[{'atom',30,'date_time'}|[[]]]]}|[{'type',30,'non_neg_integer',[]}|[{'atom',30,'undefined'}]]]}}|[{'typed_record_field',{'record_field',34,{'atom',34,'mtime'}},{'type',34,'union',[{'remote_type',34,[{'atom',34,'file'}|[{'atom',34,'date_time'}|[[]]]]}|[{'type',34,'non_neg_integer',[]}|[{'atom',34,'undefined'}]]]}}|[{'typed_record_field',{'record_field',36,{'atom',36,'ctime'}},{'type',36,'union',[{'remote_type',36,[{'atom',36,'file'}|[{'atom',36,'date_time'}|[[]]]]}|[{'type',36,'non_neg_integer',[]}|[{'atom',36,'undefined'}]]]}}|[{'typed_record_field',{'record_field',42,{'atom',42,'mode'}},{'type',42,'union',[{'type',42,'non_neg_integer',[]}|[{'atom',42,'undefined'}]]}}|[{'typed_record_field',{'record_field',46,{'atom',46,'links'}},{'type',46,'union',[{'type',46,'non_neg_integer',[]}|[{'atom',46,'undefined'}]]}}|[{'typed_record_field',{'record_field',49,{'atom',49,'major_device'}},{'type',49,'union',[{'type',49,'non_neg_integer',[]}|[{'atom',49,'undefined'}]]}}|[{'typed_record_field',{'record_field',55,{'atom',55,'minor_device'}},{'type',55,'union',[{'type',55,'non_neg_integer',[]}|[{'atom',55,'undefined'}]]}}|[{'typed_record_field',{'record_field',57,{'atom',57,'inode'}},{'type',57,'union',[{'type',57,'non_neg_integer',[]}|[{'atom',57,'undefined'}]]}}|[{'typed_record_field',{'record_field',58,{'atom',58,'uid'}},{'type',58,'union',[{'type',58,'non_neg_integer',[]}|[{'atom',58,'undefined'}]]}}|[{'typed_record_field',{'record_field',59,{'atom',59,'gid'}},{'type',59,'union',[{'type',59,'non_neg_integer',[]}|[{'atom',59,'undefined'}]]}}]]]]]]]]]]]]]}]
, 'record' = [{'file_descriptor',[{'typed_record_field',{'record_field',63,{'atom',63,'module'}},{'type',63,'module',[]}}|[{'typed_record_field',{'record_field',64,{'atom',64,'data'}},{'type',64,'term',[]}}]]}]
, 'file' = [{[115|[114|[99|[47|[115|[104|[101|[108|[108|[46|[101|[114|[108]]]]]]]]]]]]],1203}]
, 'spec' = [{{'history',1},[{'type',1477,'bounded_fun',[{'type',1477,'fun',[{'type',1477,'product',[{'var',1477,'N'}]}|[{'type',1477,'non_neg_integer',[]}]]}|[[{'type',1478,'constraint',[{'atom',1478,'is_subtype'}|[[{'var',1478,'N'}|[{'type',1478,'non_neg_integer',[]}]]]]}]]]}]}]
, 'spec' = [{{'results',1},[{'type',1483,'bounded_fun',[{'type',1483,'fun',[{'type',1483,'product',[{'var',1483,'N'}]}|[{'type',1483,'non_neg_integer',[]}]]}|[[{'type',1484,'constraint',[{'atom',1484,'is_subtype'}|[[{'var',1484,'N'}|[{'type',1484,'non_neg_integer',[]}]]]]}]]]}]}]
, 'spec' = [{{'catch_exception',1},[{'type',1489,'bounded_fun',[{'type',1489,'fun',[{'type',1489,'product',[{'var',1489,'Bool'}]}|[{'type',1489,'boolean',[]}]]}|[[{'type',1490,'constraint',[{'atom',1490,'is_subtype'}|[[{'var',1490,'Bool'}|[{'type',1490,'boolean',[]}]]]]}]]]}]}]
, 'spec' = [{{'prompt_func',1},[{'type',1495,'bounded_fun',[{'type',1495,'fun',[{'type',1495,'product',[{'var',1495,'PromptFunc'}]}|[{'var',1495,'PromptFunc2'}]]}|[[{'type',1496,'constraint',[{'atom',1496,'is_subtype'}|[[{'var',1496,'PromptFunc'}|[{'type',1496,'union',[{'atom',1496,'default'}|[{'type',1496,'tuple',[{'type',1496,'module',[]}|[{'type',1496,'atom',[]}]]}]]}]]]]}|[{'type',1497,'constraint',[{'atom',1497,'is_subtype'}|[[{'var',1497,'PromptFunc2'}|[{'type',1497,'union',[{'atom',1497,'default'}|[{'type',1497,'tuple',[{'type',1497,'module',[]}|[{'type',1497,'atom',[]}]]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'strings',1},[{'type',1502,'bounded_fun',[{'type',1502,'fun',[{'type',1502,'product',[{'var',1502,'Strings'}]}|[{'var',1502,'Strings2'}]]}|[[{'type',1503,'constraint',[{'atom',1503,'is_subtype'}|[[{'var',1503,'Strings'}|[{'type',1503,'boolean',[]}]]]]}|[{'type',1504,'constraint',[{'atom',1504,'is_subtype'}|[[{'var',1504,'Strings2'}|[{'type',1504,'boolean',[]}]]]]}]]]]}]}] ] 'local_allowed'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'q',[],State> when 'true' -> {'true',State}
<_6,_7,State> when 'true' -> {'false',State} end
'non_local_allowed'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'init','stop'},[],State> when 'true' -> {'true',State}
<_6,_7,State> when 'true' -> {'false',State} end
'start'/0 = fun () -> apply 'start'/2 ('false','false')
'start'/1 = fun (_0) -> case _0 of <'init'> when 'true' -> apply 'start'/2 ('false','true')
<NoCtrlG> when 'true' -> apply 'start'/2 (NoCtrlG,'false') end
'start'/2 = fun (_0,_1) -> do (call ('code'-|['result_not_wanted'] ):('ensure_loaded'-|['result_not_wanted'] ) (('user_default'-|['result_not_wanted'] ))-|['result_not_wanted'] ) let <_3> = fun () -> apply 'server'/2 (_0,_1) in call 'erlang':'spawn' (_3)
'whereis_evaluator'/0 = fun () -> case call 'erlang':'whereis' ('user') of <'undefined'> when 'true' -> 'undefined'
<User> when 'true' -> case call 'group':'interfaces' (User) of <[]> when 'true' -> case call 'user':'interfaces' (User) of <[]> when 'true' -> 'undefined'
<[{'shell',Shell}|[]]> when 'true' -> apply 'whereis_evaluator'/1 (Shell)
(<_0> when 'true' -> primop 'match_fail' ({'case_clause',_0})-|['compiler_generated'] ) end
<[{'user_drv',UserDrv}|[]]> when 'true' -> case call 'user_drv':'interfaces' (UserDrv) of <[]> when 'true' -> 'undefined'
<[{'current_group',Group}|[]]> when 'true' -> let <GrIfs> = call 'group':'interfaces' (Group) in case call 'lists':'keyfind' ('shell',1,GrIfs) of <{'shell',Shell}> when 'true' -> apply 'whereis_evaluator'/1 (Shell)
<'false'> when 'true' -> 'undefined'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end end
'whereis_evaluator'/1 = fun (_0) -> case call 'erlang':'process_info' (_0,'dictionary') of <{'dictionary',Dict}> when 'true' -> case call 'lists':'keyfind' ('evaluator',1,Dict) of <{_4,Eval}> when call 'erlang':'is_pid' (Eval) -> Eval
<_5> when 'true' -> 'undefined' end
<_6> when 'true' -> 'undefined' end
'start_restricted'/1 = fun (_0) -> case _0 of <RShMod> when call 'erlang':'is_atom' (_0) -> case call 'code':'ensure_loaded' (RShMod) of <{'module',_5}> when call 'erlang':'=:=' (_5,RShMod) -> do call 'application':'set_env' ('stdlib','restricted_shell',RShMod) call 'erlang':'exit' ('restricted_shell_started')
<Error = {'error',What}> when 'true' -> let <_1> = call 'io_lib':'fwrite' ([82|[101|[115|[116|[114|[105|[99|[116|[101|[100|[32|[115|[104|[101|[108|[108|[32|[109|[111|[100|[117|[108|[101|[32|[126|[119|[32|[110|[111|[116|[32|[102|[111|[117|[110|[100|[58|[32|[126|[116|[112|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[RShMod|[What|[]]]) in let <_2> = call 'lists':'flatten' (_1) in do call 'error_logger':'error_report' (_2) Error
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'start_restricted',1}}] )-|['compiler_generated'] ) end
'stop_restricted'/0 = fun () -> do call 'application':'unset_env' ('stdlib','restricted_shell') call 'erlang':'exit' ('restricted_shell_stopped')
'server'/2 = fun (_0,_1) -> do call 'erlang':'put' ('no_control_g',_0) apply 'server'/1 (_1)
'server'/1 = fun (_0) -> do case call 'init':'get_argument' ('async_shell_start') of <{'ok',_19}> when 'true' -> 'ok'
<_20> when (call 'erlang':'=:=' (_0,'false')-|['compiler_generated'] ) -> 'ok'
<_21> when 'true' -> let <_2> = call 'erlang':'self' () in case call 'init':'notify_when_started' (_2) of <'started'> when 'true' -> 'ok'
<_22> when 'true' -> call 'init':'wait_until_started' () end end let <Bs> = call 'erl_eval':'new_bindings' () in let <RT> = call 'ets':'new' ('shell_records',['public'|['ordered_set']]) in do apply 'initiate_records'/2 (Bs,RT) do call 'erlang':'process_flag' ('trap_exit','true') let <_10> = case call 'application':'get_env' ('stdlib','restricted_shell') of <{'ok',RShMod}> when call 'erlang':'is_atom' (RShMod) -> do call 'io':'fwrite' (#{#<82>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#,[]) case call 'code':'ensure_loaded' (RShMod) of <{'module',_23}> when call 'erlang':'=:=' (_23,RShMod) -> 'undefined'
<{'error',What}> when 'true' -> {RShMod,What}
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<{'ok',Term}> when 'true' -> {Term,'not_an_atom'}
<'undefined'> when 'true' -> 'undefined'
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end in do case call 'erlang':'get' ('no_control_g') of <'true'> when 'true' -> let <_12> = call 'erlang':'system_info' ('version') in call 'io':'fwrite' (#{#<69>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<86>(8,1,'integer',['unsigned'|['big']]),#<126>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#,[_12|[]])
<_X_undefined_or_false> when 'true' -> let <_13> = call 'erlang':'system_info' ('version') in call 'io':'fwrite' (#{#<69>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<86>(8,1,'integer',['unsigned'|['big']]),#<126>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<40>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<94>(8,1,'integer',['unsigned'|['big']]),#<71>(8,1,'integer',['unsigned'|['big']]),#<41>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#,[_13|[]]) end do call 'erlang':'erase' ('no_control_g') do case _10 of <'undefined'> when 'true' -> 'ok'
<{RShMod2,What2}> when 'true' -> do call 'io':'fwrite' ([87|[97|[114|[110|[105|[110|[103|[33|[32|[82|[101|[115|[116|[114|[105|[99|[116|[101|[100|[32|[115|[104|[101|[108|[108|[32|[109|[111|[100|[117|[108|[101|[32|[126|[119|[32|[110|[111|[116|[32|[102|[111|[117|[110|[100|[58|[32|[126|[116|[112|[46|[10|[79|[110|[108|[121|[32|[116|[104|[101|[32|[99|[111|[109|[109|[97|[110|[100|[115|[32|[113|[40|[41|[32|[97|[110|[100|[32|[105|[110|[105|[116|[58|[115|[116|[111|[112|[40|[41|[32|[119|[105|[108|[108|[32|[98|[101|[32|[97|[108|[108|[111|[119|[101|[100|[33|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[RShMod2|[What2|[]]]) call 'application':'set_env' ('stdlib','restricted_shell','shell')
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end case apply 'check_and_get_history_and_results'/0 () of <{History,Results}> when 'true' -> let <_17> = apply 'start_eval'/3 (Bs,RT,[]) in apply 'server_loop'/7 (0,_17,Bs,RT,[],History,Results)
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
'server_loop'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> let <N> = call 'erlang':'+' (_0,1) in case apply 'prompt'/5 (N,_1,_2,_3,_4) of <{Eval_1,Bs0,Ds0,Prompt}> when 'true' -> case apply 'get_command'/5 (Prompt,Eval_1,Bs0,_3,Ds0) of <{Res,Eval0}> when 'true' -> case Res of <{'ok',Es0,XBs}> when 'true' -> let <Es1> = call 'erl_eval':'subst_values_for_vars' (Es0,XBs) in case apply 'expand_hist'/2 (Es1,N) of <{'ok',Es}> when 'true' -> case apply 'shell_cmd'/6 (Es,Eval0,Bs0,_3,Ds0,'cmd') of <{V,Eval,Bs,Ds}> when 'true' -> case apply 'check_and_get_history_and_results'/0 () of <{History,Results}> when 'true' -> do apply 'add_cmd'/3 (N,Es,V) let <_14> = call 'erlang':'-' (N,History) in let <_13> = call 'erlang':'-' (N,_5) in let <HB1> = apply 'del_cmd'/4 ('command',_14,_13,'false') in let <_17> = call 'erlang':'-' (N,Results) in let <_16> = call 'erlang':'-' (N,_6) in let <HB> = apply 'del_cmd'/4 ('result',_17,_16,HB1) in do case <> of <> when (call 'erlang':'=:=' (HB,'true')-|['compiler_generated'] ) -> let <_19> = call 'erlang':'self' () in apply 'garb'/1 (_19)
<> when 'true' -> 'ok' end apply 'server_loop'/7 (N,Eval,Bs,_3,Ds,History,Results)
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
<{'error',E}> when 'true' -> do apply 'fwrite_severity'/3 ('benign',#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#,[E|[]]) apply 'server_loop'/7 (_0,Eval0,Bs0,_3,Ds0,_5,_6)
(<_20> when 'true' -> primop 'match_fail' ({'case_clause',_20})-|['compiler_generated'] ) end
<{'error',{Line,Mod,What}}> when 'true' -> let <_21> = call Mod:'format_error' (What) in do apply 'fwrite_severity'/3 ('benign',#{#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#,[Line|[_21|[]]]) apply 'server_loop'/7 (_0,Eval0,Bs0,_3,Ds0,_5,_6)
<{'error','terminated'}> when 'true' -> do call 'erlang':'exit' (Eval0,'kill') 'terminated'
<{'error','interrupted'}> when 'true' -> do call 'erlang':'exit' (Eval0,'kill') case apply 'shell_rep'/4 (Eval0,Bs0,_3,Ds0) of <{_32,Eval,_33,_34}> when 'true' -> apply 'server_loop'/7 (_0,Eval,Bs0,_3,Ds0,_5,_6)
(<_22> when 'true' -> primop 'match_fail' ({'badmatch',_22})-|['compiler_generated'] ) end
<{'error','tokens'}> when 'true' -> do apply 'fwrite_severity'/3 ('benign',#{#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<73>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<107>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']])}#,[N|[]]) apply 'server_loop'/7 (_0,Eval0,Bs0,_3,Ds0,_5,_6)
<'eof'> when 'true' -> let <_23> = call 'erlang':'node' () in do apply 'fwrite_severity'/3 ('fatal',#{#<84>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<40>(8,1,'integer',['unsigned'|['big']]),#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<41>(8,1,'integer',['unsigned'|['big']])}#,[_23|[]]) call 'erlang':'halt' ()
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
'get_command'/5 = fun (_0,_1,_2,_3,_4) -> let <Parse> = fun () -> let <_5> = call 'erlang':'group_leader' () in let <_12> = case call 'io':'scan_erl_exprs' (_5,_0,1,['text']) of <{'ok',Toks,_X_EndPos}> when 'true' -> call 'erl_eval':'extended_parse_exprs' (Toks)
<{'eof',_X_EndPos}> when 'true' -> 'eof'
<{'error',ErrorInfo,_X_EndPos}> when 'true' -> let <Opts> = call 'io':'getopts' () in let <TmpOpts> = call 'lists':'keyreplace' ('echo',1,Opts,{'echo','false'}) in do (call ('io'-|['result_not_wanted'] ):('setopts'-|['result_not_wanted'] ) (TmpOpts)-|['result_not_wanted'] ) do (call ('io'-|['result_not_wanted'] ):('get_line'-|['result_not_wanted'] ) ((''-|['result_not_wanted'] ))-|['result_not_wanted'] ) do (call ('io'-|['result_not_wanted'] ):('setopts'-|['result_not_wanted'] ) (Opts)-|['result_not_wanted'] ) {'error',ErrorInfo}
<Else> when 'true' -> Else end in call 'erlang':'exit' (_12) in let <Pid> = call 'erlang':'spawn_link' (Parse) in apply 'get_command1'/5 (Pid,_1,_2,_3,_4)
'get_command1'/5 = fun (_0,_1,_2,_3,_4) -> receive <{'EXIT',_12,Res}> when call 'erlang':'=:=' (_12,_0) -> {Res,_1}
<{'EXIT',_13,_@r0 = {Reason,Stacktrace}}> when call 'erlang':'=:=' (_13,_1) -> do apply 'report_exception'/3 ('error',_@r0,_3) let <_5> = apply 'start_eval'/3 (_2,_3,_4) in apply 'get_command1'/5 (_0,_5,_2,_3,_4)
<{'EXIT',_14,Reason}> when call 'erlang':'=:=' (_14,_1) -> do apply 'report_exception'/3 ('error',{Reason,[]},_3) let <_6> = apply 'start_eval'/3 (_2,_3,_4) in apply 'get_command1'/5 (_0,_6,_2,_3,_4) after 'infinity' -> 'true'
'prompt'/5 = fun (_0,_1,_2,_3,_4) -> case apply 'get_prompt_func'/0 () of <_@r0 = {M,F}> when 'true' -> let <L> = [{'history',_0}|[]] in let <A> = call 'erl_anno':'new' (1) in let <C> = {'call',A,{'remote',A,{'atom',A,M},{'atom',A,F}},[{'value',A,L}|[]]} in case apply 'shell_cmd'/6 ([C|[]],_1,_2,_3,_4,'pmt') of <{V,Eval,Bs,Ds}> when 'true' -> let <_10> = case V of <{'pmt',Val}> when 'true' -> Val
<_18> when 'true' -> do apply 'bad_prompt_func'/1 (_@r0) apply 'default_prompt'/1 (_0) end in {Eval,Bs,Ds,_10}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<'default'> when 'true' -> let <_11> = apply 'default_prompt'/1 (_0) in {_1,_2,_4,_11}
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
'get_prompt_func'/0 = fun () -> case call 'application':'get_env' ('stdlib','shell_prompt_func') of <{'ok',PromptFunc = {M,F}}> when let <_0> = call 'erlang':'is_atom' (M) in let <_1> = call 'erlang':'is_atom' (F) in call 'erlang':'and' (_0,_1) -> PromptFunc
<{'ok',Default = 'default'}> when 'true' -> Default
<{'ok',Term}> when 'true' -> do apply 'bad_prompt_func'/1 (Term) 'default'
<'undefined'> when 'true' -> 'default'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'bad_prompt_func'/1 = fun (_0) -> apply 'fwrite_severity'/3 ('benign',[66|[97|[100|[32|[112|[114|[111|[109|[112|[116|[32|[102|[117|[110|[99|[116|[105|[111|[110|[58|[32|[126|[116|[112]]]]]]]]]]]]]]]]]]]]]]]],[_0|[]])
'default_prompt'/1 = fun (_0) -> case call 'erlang':'is_alive' () of <'true'> when 'true' -> let <_1> = call 'erlang':'node' () in call 'io_lib':'format' (#{#<40>(8,1,'integer',['unsigned'|['big']]),#<126>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<41>(8,1,'integer',['unsigned'|['big']]),#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#,[_1|[_0|[]]])
<'false'> when 'true' -> call 'io_lib':'format' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#,[_0|[]])
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'expand_hist'/2 = fun (_0,_1) -> catch let <_2> = apply 'expand_exprs'/2 (_0,_1) in {'ok',_2}
'expand_exprs'/2 = fun (_0,_1) -> case <_0,_1> of <[E|Es],C> when 'true' -> let <_2> = apply 'expand_expr'/2 (E,C) in let <_3> = apply 'expand_exprs'/2 (Es,C) in [_2|_3]
<[],_X_C> when 'true' -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'expand_exprs',2}}] )-|['compiler_generated'] ) end
'expand_expr'/2 = fun (_0,_1) -> case <_0,_1> of <{'cons',L,H,T},C> when 'true' -> let <_3> = apply 'expand_expr'/2 (H,C) in let <_2> = apply 'expand_expr'/2 (T,C) in {'cons',L,_3,_2}
<{'lc',L,E,Qs},C> when 'true' -> let <_5> = apply 'expand_expr'/2 (E,C) in let <_4> = apply 'expand_quals'/2 (Qs,C) in {'lc',L,_5,_4}
<{'bc',L,E,Qs},C> when 'true' -> let <_7> = apply 'expand_expr'/2 (E,C) in let <_6> = apply 'expand_quals'/2 (Qs,C) in {'bc',L,_7,_6}
<{'tuple',L,Elts},C> when 'true' -> let <_8> = apply 'expand_exprs'/2 (Elts,C) in {'tuple',L,_8}
<{'map',L,Es},C> when 'true' -> let <_9> = apply 'expand_exprs'/2 (Es,C) in {'map',L,_9}
<{'map',L,Arg,Es},C> when 'true' -> let <_11> = apply 'expand_expr'/2 (Arg,C) in let <_10> = apply 'expand_exprs'/2 (Es,C) in {'map',L,_11,_10}
<{'map_field_assoc',L,K,V},C> when 'true' -> let <_13> = apply 'expand_expr'/2 (K,C) in let <_12> = apply 'expand_expr'/2 (V,C) in {'map_field_assoc',L,_13,_12}
<{'map_field_exact',L,K,V},C> when 'true' -> let <_15> = apply 'expand_expr'/2 (K,C) in let <_14> = apply 'expand_expr'/2 (V,C) in {'map_field_exact',L,_15,_14}
<{'record_index',L,Name,F},C> when 'true' -> let <_16> = apply 'expand_expr'/2 (F,C) in {'record_index',L,Name,_16}
<{'record',L,Name,Is},C> when 'true' -> let <_17> = apply 'expand_fields'/2 (Is,C) in {'record',L,Name,_17}
<{'record_field',L,R,Name,F},C> when 'true' -> let <_19> = apply 'expand_expr'/2 (R,C) in let <_18> = apply 'expand_expr'/2 (F,C) in {'record_field',L,_19,Name,_18}
<{'record',L,R,Name,Ups},C> when 'true' -> let <_21> = apply 'expand_expr'/2 (R,C) in let <_20> = apply 'expand_fields'/2 (Ups,C) in {'record',L,_21,Name,_20}
<{'record_field',L,R,F},C> when 'true' -> let <_23> = apply 'expand_expr'/2 (R,C) in let <_22> = apply 'expand_expr'/2 (F,C) in {'record_field',L,_23,_22}
<{'block',L,Es},C> when 'true' -> let <_24> = apply 'expand_exprs'/2 (Es,C) in {'block',L,_24}
<{'if',L,Cs},C> when 'true' -> let <_25> = apply 'expand_cs'/2 (Cs,C) in {'if',L,_25}
<{'case',L,E,Cs},C> when 'true' -> let <_27> = apply 'expand_expr'/2 (E,C) in let <_26> = apply 'expand_cs'/2 (Cs,C) in {'case',L,_27,_26}
<{'try',L,Es,Scs,Ccs,As},C> when 'true' -> let <_31> = apply 'expand_exprs'/2 (Es,C) in let <_30> = apply 'expand_cs'/2 (Scs,C) in let <_29> = apply 'expand_cs'/2 (Ccs,C) in let <_28> = apply 'expand_exprs'/2 (As,C) in {'try',L,_31,_30,_29,_28}
<{'receive',L,Cs},C> when 'true' -> let <_32> = apply 'expand_cs'/2 (Cs,C) in {'receive',L,_32}
<{'receive',L,Cs,To,ToEs},C> when 'true' -> let <_35> = apply 'expand_cs'/2 (Cs,C) in let <_34> = apply 'expand_expr'/2 (To,C) in let <_33> = apply 'expand_exprs'/2 (ToEs,C) in {'receive',L,_35,_34,_33}
<{'call',L,{'atom',_54,'e'},[N|[]]},C> when 'true' -> case apply 'get_cmd'/2 (N,C) of <{'undefined',_55,_56}> when 'true' -> apply 'no_command'/1 (N)
<{[Ce|[]],_X_V,_X_CommandN}> when 'true' -> Ce
<{Ces,_X_V,_X_CommandN}> when call 'erlang':'is_list' (Ces) -> {'block',L,Ces}
(<_36> when 'true' -> primop 'match_fail' ({'case_clause',_36})-|['compiler_generated'] ) end
<{'call',_X_L,{'atom',_57,'v'},[N|[]]},C> when 'true' -> case apply 'get_cmd'/2 (N,C) of <{_58,'undefined',_59}> when 'true' -> apply 'no_command'/1 (N)
<{Ces,V,CommandN}> when call 'erlang':'is_list' (Ces) -> let <_37> = call 'erl_anno':'new' (CommandN) in {'value',_37,V}
(<_38> when 'true' -> primop 'match_fail' ({'case_clause',_38})-|['compiler_generated'] ) end
<{'call',L,F,Args},C> when 'true' -> let <_40> = apply 'expand_expr'/2 (F,C) in let <_39> = apply 'expand_exprs'/2 (Args,C) in {'call',L,_40,_39}
<{'catch',L,E},C> when 'true' -> let <_41> = apply 'expand_expr'/2 (E,C) in {'catch',L,_41}
<{'match',L,Lhs,Rhs},C> when 'true' -> let <_42> = apply 'expand_expr'/2 (Rhs,C) in {'match',L,Lhs,_42}
<{'op',L,Op,Arg},C> when 'true' -> let <_43> = apply 'expand_expr'/2 (Arg,C) in {'op',L,Op,_43}
<{'op',L,Op,Larg,Rarg},C> when 'true' -> let <_45> = apply 'expand_expr'/2 (Larg,C) in let <_44> = apply 'expand_expr'/2 (Rarg,C) in {'op',L,Op,_45,_44}
<{'remote',L,M,F},C> when 'true' -> let <_47> = apply 'expand_expr'/2 (M,C) in let <_46> = apply 'expand_expr'/2 (F,C) in {'remote',L,_47,_46}
<{'fun',L,{'clauses',Cs}},C> when 'true' -> let <_48> = apply 'expand_exprs'/2 (Cs,C) in {'fun',L,{'clauses',_48}}
<{'named_fun',L,Name,Cs},C> when 'true' -> let <_49> = apply 'expand_exprs'/2 (Cs,C) in {'named_fun',L,Name,_49}
<{'clause',L,H,G,B},C> when 'true' -> let <_50> = apply 'expand_exprs'/2 (B,C) in {'clause',L,H,G,_50}
<{'bin',L,Fs},C> when 'true' -> let <_51> = apply 'expand_bin_elements'/2 (Fs,C) in {'bin',L,_51}
<E,_X_C> when 'true' -> E end
'expand_cs'/2 = fun (_0,_1) -> case <_0,_1> of <[{'clause',L,P,G,B}|Cs],C> when 'true' -> let <_2> = apply 'expand_exprs'/2 (B,C) in let <_3> = apply 'expand_cs'/2 (Cs,C) in [{'clause',L,P,G,_2}|_3]
<[],_X_C> when 'true' -> []
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'expand_cs',2}}] )-|['compiler_generated'] ) end
'expand_fields'/2 = fun (_0,_1) -> case <_0,_1> of <[{'record_field',L,F,V}|Fs],C> when 'true' -> let <_3> = apply 'expand_expr'/2 (F,C) in let <_2> = apply 'expand_expr'/2 (V,C) in let <_4> = apply 'expand_fields'/2 (Fs,C) in [{'record_field',L,_3,_2}|_4]
<[],_X_C> when 'true' -> []
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'expand_fields',2}}] )-|['compiler_generated'] ) end
'expand_quals'/2 = fun (_0,_1) -> case <_0,_1> of <[{'generate',L,P,E}|Qs],C> when 'true' -> let <_2> = apply 'expand_expr'/2 (E,C) in let <_3> = apply 'expand_quals'/2 (Qs,C) in [{'generate',L,P,_2}|_3]
<[{'b_generate',L,P,E}|Qs],C> when 'true' -> let <_4> = apply 'expand_expr'/2 (E,C) in let <_5> = apply 'expand_quals'/2 (Qs,C) in [{'b_generate',L,P,_4}|_5]
<[E|Qs],C> when 'true' -> let <_6> = apply 'expand_expr'/2 (E,C) in let <_7> = apply 'expand_quals'/2 (Qs,C) in [_6|_7]
<[],_X_C> when 'true' -> []
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'expand_quals',2}}] )-|['compiler_generated'] ) end
'expand_bin_elements'/2 = fun (_0,_1) -> case <_0,_1> of <[],_X_C> when 'true' -> []
<[{'bin_element',L,E,Sz,Ts}|Fs],C> when 'true' -> let <_2> = apply 'expand_expr'/2 (E,C) in let <_3> = apply 'expand_bin_elements'/2 (Fs,C) in [{'bin_element',L,_2,Sz,Ts}|_3]
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'expand_bin_elements',2}}] )-|['compiler_generated'] ) end
'no_command'/1 = fun (_0) -> let <_1> = apply 'enc'/0 () in let <_2> = call 'erl_pp':'expr' (_0,_1) in let <_3> = call 'io_lib':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#,[_2|[]]) in call 'erlang':'throw' ({'error',_3})
'add_cmd'/3 = fun (_0,_1,_2) -> do call 'erlang':'put' ({'command',_0},_1) call 'erlang':'put' ({'result',_0},_2)
'getc'/1 = fun (_0) -> let <_2> = call 'erlang':'get' ({'command',_0}) in let <_1> = call 'erlang':'get' ({'result',_0}) in {_2,_1,_0}
'get_cmd'/2 = fun (_0,_1) -> let <_3> = catch let <_2> = call 'erl_eval':'new_bindings' () in call 'erl_eval':'expr' (_0,_2) in case _3 of <{'value',N,_8}> when call 'erlang':'<' (N,0) -> let <_4> = call 'erlang':'+' (_1,N) in apply 'getc'/1 (_4)
<{'value',N,_9}> when 'true' -> apply 'getc'/1 (N)
<_X_Other> when 'true' -> {'undefined','undefined','undefined'} end
'del_cmd'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_Type,N,N0,HasBin> when call 'erlang':'<' (N,N0) -> HasBin
<Type,N,N0,HasBin0> when 'true' -> let <T> = call 'erlang':'erase' ({Type,N}) in let <_7> = case HasBin0 of (<('true'-|['compiler_generated'] )> when 'true' -> 'true'-|['compiler_generated'] )
(<('false'-|['compiler_generated'] )> when 'true' -> apply 'has_binary'/1 (T)-|['compiler_generated'] )
(<_5> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({('badarg'-|['compiler_generated'] ),_5}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_9> = call 'erlang':'-' (N,1) in apply 'del_cmd'/4 (Type,_9,N0,_7) end
'has_binary'/1 = fun (_0) -> try do apply 'has_bin'/1 (_0) 'false' of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('throw'-|['compiler_generated'] ),Thrown = ('true'-|['compiler_generated'] ),_6> when 'true' -> Thrown
(<_7,_8,_9> when 'true' -> primop 'raise' (_9,_8)-|['compiler_generated'] ) end
'has_bin'/1 = fun (_0) -> case _0 of <T> when call 'erlang':'is_tuple' (_0) -> let <_1> = call 'erlang':'tuple_size' (T) in apply 'has_bin'/2 (T,_1)
<[E|Es]> when 'true' -> do apply 'has_bin'/1 (E) apply 'has_bin'/1 (Es)
<B> when try let <_2> = call 'erlang':'byte_size' (_0) in call 'erlang':'>' (_2,64) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'throw' ('true')
<T> when 'true' -> T end
'has_bin'/2 = fun (_0,_1) -> case <_0,_1> of <T,0> when 'true' -> T
<T,I> when 'true' -> let <_2> = call 'erlang':'element' (I,T) in do apply 'has_bin'/1 (_2) let <_3> = call 'erlang':'-' (I,1) in apply 'has_bin'/2 (T,_3) end
'shell_cmd'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <_6> = call 'erlang':'self' () in do call 'erlang':'!' (_1,{'shell_cmd',_6,{'eval',_0},_5}) apply 'shell_rep'/4 (_1,_2,_3,_4)
'shell_rep'/4 = fun (_0,_1,_2,_3) -> receive <{'shell_rep',_18,{'value',V,Bs,Ds}}> when call 'erlang':'=:=' (_18,_0) -> {V,_0,Bs,Ds}
<{'shell_rep',_19,{'command_error',{Line,M,Error}}}> when call 'erlang':'=:=' (_19,_0) -> let <_4> = call M:'format_error' (Error) in do apply 'fwrite_severity'/3 ('benign',#{#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#,[Line|[_4|[]]]) {{'EXIT',Error},_0,_1,_3}
<{'shell_req',_20,'get_cmd'}> when call 'erlang':'=:=' (_20,_0) -> let <_6> = call 'erlang':'self' () in let <_5> = call 'erlang':'get' () in do call 'erlang':'!' (_0,{'shell_rep',_6,_5}) apply 'shell_rep'/4 (_0,_1,_2,_3)
<{'shell_req',_21,'exit'}> when call 'erlang':'=:=' (_21,_0) -> let <_7> = call 'erlang':'self' () in do call 'erlang':'!' (_0,{'shell_rep',_7,'exit'}) call 'erlang':'exit' ('normal')
<{'shell_req',_22,{'update_dict',Ds}}> when call 'erlang':'=:=' (_22,_0) -> let <_8> = call 'erlang':'self' () in do call 'erlang':'!' (_0,{'shell_rep',_8,'ok'}) apply 'shell_rep'/4 (_0,_1,_2,Ds)
<{'ev_exit',{_23,Class,Reason0}}> when call 'erlang':'=:=' (_23,_0) -> do receive <{'EXIT',_24,'normal'}> when call 'erlang':'=:=' (_24,_0) -> 'ok' after 'infinity' -> 'ok' do apply 'report_exception'/3 (Class,Reason0,_2) let <Reason> = apply 'nocatch'/2 (Class,Reason0) in let <_10> = apply 'start_eval'/3 (_1,_2,_3) in {{'EXIT',Reason},_10,_1,_3}
<{'ev_caught',{_25,Class,Reason0}}> when call 'erlang':'=:=' (_25,_0) -> do apply 'report_exception'/4 (Class,'benign',Reason0,_2) let <Reason> = apply 'nocatch'/2 (Class,Reason0) in {{'EXIT',Reason},_0,_1,_3}
<{'EXIT',_X_Id,'interrupt'}> when 'true' -> do call 'erlang':'exit' (_0,'kill') apply 'shell_rep'/4 (_0,_1,_2,_3)
<{'EXIT',_26,_@r0 = {Reason,Stacktrace}}> when call 'erlang':'=:=' (_26,_0) -> do apply 'report_exception'/3 ('exit',_@r0,_2) let <_12> = apply 'start_eval'/3 (_1,_2,_3) in {{'EXIT',Reason},_12,_1,_3}
<{'EXIT',_27,Reason}> when call 'erlang':'=:=' (_27,_0) -> do apply 'report_exception'/3 ('exit',{Reason,[]},_2) let <_13> = apply 'start_eval'/3 (_1,_2,_3) in {{'EXIT',Reason},_13,_1,_3}
<{'EXIT',_X_Id,R}> when 'true' -> do call 'erlang':'exit' (_0,R) call 'erlang':'exit' (R)
<_X_Other> when 'true' -> apply 'shell_rep'/4 (_0,_1,_2,_3) after 'infinity' -> 'true'
'nocatch'/2 = fun (_0,_1) -> case <_0,_1> of <'throw',{Term,Stack}> when 'true' -> {{'nocatch',Term},Stack}
<'error',Reason> when 'true' -> Reason
<'exit',Reason> when 'true' -> Reason
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'nocatch',2}}] )-|['compiler_generated'] ) end
'report_exception'/3 = fun (_0,_1,_2) -> apply 'report_exception'/4 (_0,'serious',_1,_2)
'report_exception'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Class,Severity,{Reason,Stacktrace},RT> when 'true' -> let <Tag> = apply 'severity_tag'/1 (Severity) in let <_5> = call 'erlang':'iolist_size' (Tag) in let <I> = call 'erlang':'+' (_5,1) in let <PF> = fun (_8,_7) -> apply 'pp'/3 (_8,_7,RT) in let <SF> = fun (_16,_15,_14) -> let <_13> = call 'erlang':'=:=' (_16,'erl_eval') in let <_12> = call 'erlang':'=:=' (_16,'shell') in call 'erlang':'or' (_13,_12) in let <Enc> = apply 'encoding'/0 () in let <Str> = call 'erl_error':'format_exception' (I,Class,Reason,Stacktrace,SF,PF,Enc) in call 'io':'requests' ([{'put_chars','latin1',Tag}|[{'put_chars','unicode',Str}|['nl']]])
(<_26,_25,_24,_23> when 'true' -> (primop 'match_fail' ({'function_clause',_26,_25,_24,_23})-|[{'function_name',{'report_exception',4}}] )-|['compiler_generated'] ) end
'start_eval'/3 = fun (_0,_1,_2) -> let <Self> = call 'erlang':'self' () in let <_4> = fun () -> apply 'evaluator'/4 (Self,_0,_1,_2) in let <Eval> = call 'erlang':'spawn_link' (_4) in do call 'erlang':'put' ('evaluator',Eval) Eval
'evaluator'/4 = fun (_0,_1,_2,_3) -> do apply 'init_dict'/1 (_3) case call 'application':'get_env' ('stdlib','restricted_shell') of <'undefined'> when 'true' -> apply 'eval_loop'/3 (_0,_1,_2)
<{'ok',RShMod}> when 'true' -> do case call 'erlang':'get' ('restricted_shell_state') of <'undefined'> when 'true' -> call 'erlang':'put' ('restricted_shell_state',[])
<_10> when 'true' -> 'ok' end do call 'erlang':'put' ('restricted_expr_state',[]) apply 'restricted_eval_loop'/4 (_0,_1,_2,RShMod)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'eval_loop'/3 = fun (_0,_1,_2) -> receive <{'shell_cmd',_14,{'eval',Es},W}> when call 'erlang':'=:=' (_14,_0) -> let <_7> = fun (_4,_3) -> apply 'apply_fun'/3 (_4,_3,_0) in let <Ef> = {'value',_7} in let <Lf> = apply 'local_func_handler'/3 (_0,_2,Ef) in let <Bs> = apply 'eval_exprs'/7 (Es,_0,_1,_2,Lf,Ef,W) in apply 'eval_loop'/3 (_0,Bs,_2) after 'infinity' -> 'true'
'restricted_eval_loop'/4 = fun (_0,_1,_2,_3) -> receive <{'shell_cmd',_10,{'eval',Es},W}> when call 'erlang':'=:=' (_10,_0) -> case apply 'restrict_handlers'/3 (_3,_0,_2) of <{LFH,NLFH}> when 'true' -> do call 'erlang':'put' ('restricted_expr_state',[]) let <Bs> = apply 'eval_exprs'/7 (Es,_0,_1,_2,{'eval',LFH},{'value',NLFH},W) in apply 'restricted_eval_loop'/4 (_0,Bs,_2,_3)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end after 'infinity' -> 'true'
'eval_exprs'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> try case apply 'exprs'/6 (_0,_2,_3,_4,_5,_6) of <{R,Bs2}> when 'true' -> let <_8> = call 'erlang':'self' () in do call 'erlang':'!' (_1,{'shell_rep',_8,R}) Bs2
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end of <_9> -> _9 catch <_12,_11,_10> -> case <_12,_11,_10> of <('exit'-|['compiler_generated'] ),('normal'-|['compiler_generated'] ),_30> when 'true' -> call 'erlang':'exit' ('normal')
<Class,Reason,_31> when 'true' -> let <_13> = call 'erlang':'self' () in let <Stacktrace> = primop 'build_stacktrace' (_31) in let <M> = {_13,Class,{Reason,Stacktrace}} in case apply 'do_catch'/2 (Class,Reason) of <'true'> when 'true' -> do call 'erlang':'!' (_1,{'ev_caught',M}) _2
<'false'> when 'true' -> let <_15> = call 'erlang':'self' () in case call 'erlang':'process_info' (_15,'links') of <{'links',LPs}> when 'true' -> let <ER> = apply 'nocatch'/2 (Class,{Reason,Stacktrace}) in let <_21> = fun (_19) -> call 'erlang':'exit' (_19,ER) in let <_18> = call 'erlang':'--' (LPs,[_1|[]]) in do call 'lists':'foreach' (_21,_18) do call 'erlang':'!' (_1,{'ev_exit',M}) call 'erlang':'exit' ('normal')
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end end
'do_catch'/2 = fun (_0,_1) -> case <_0,_1> of <'exit','restricted_shell_stopped'> when 'true' -> 'false'
<'exit','restricted_shell_started'> when 'true' -> 'false'
<_X_Class,_X_Reason> when 'true' -> case call 'application':'get_env' ('stdlib','shell_catch_exception') of <{'ok','true'}> when 'true' -> 'true'
<_5> when 'true' -> 'false' end end
'exprs'/6 = fun (_0,_1,_2,_3,_4,_5) -> apply 'exprs'/7 (_0,_1,_2,_3,_4,_1,_5)
'exprs'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <[E0|Es],Bs1,RT,Lf,Ef,Bs0,W> when 'true' -> let <UsedRecords> = apply 'used_record_defs'/2 (E0,RT) in let <RBs> = apply 'record_bindings'/2 (UsedRecords,Bs1) in let <_9> = apply 'prep_check'/1 ([E0|[]]) in case apply 'check_command'/2 (_9,RBs) of <'ok'> when 'true' -> let <E1> = apply 'expand_records'/2 (UsedRecords,E0) in case apply 'expr'/4 (E1,Bs1,Lf,Ef) of <{'value',V0,Bs2}> when 'true' -> let <_19> = letrec 'lc$^0'/1 = fun (_16) -> case _16 of <[VV = {X,_35}|_13]> when 'true' -> (case apply 'is_expand_variable'/1 (X) of <'false'> when 'true' -> let <_17> = apply 'lc$^0'/1 (_13) in ([VV|_17]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^0'/1 (_13)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_12|_13]> when 'true' -> apply 'lc$^0'/1 (_13)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_36> when 'true' -> (primop 'match_fail' ({'function_clause',_36})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_14> = call 'erl_eval':'bindings' (Bs2) in apply 'lc$^0'/1 (_14) in let <Bs> = call 'orddict':'from_list' (_19) in case <> of <> when call 'erlang':'=:=' (Es,[]) -> let <VS> = apply 'pp'/3 (V0,1,RT) in do case W of <'cmd'> when 'true' -> call 'io':'requests' ([{'put_chars','unicode',VS}|['nl']])
<'pmt'> when 'true' -> 'ok'
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end let <_24> = case <> of <> when call 'erlang':'=:=' (W,'pmt') -> {W,V0}
<> when 'true' -> case apply 'result_will_be_saved'/0 () of <'true'> when 'true' -> V0
<'false'> when 'true' -> do call 'erlang':'garbage_collect' () 'ignored'
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end end in let <_26> = call 'erlang':'get' () in {{'value',_24,Bs,_26},Bs}
<> when 'true' -> apply 'exprs'/7 (Es,Bs,RT,Lf,Ef,Bs0,W) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
<{'error',Error}> when 'true' -> {{'command_error',Error},Bs0}
(<_27> when 'true' -> primop 'match_fail' ({'case_clause',_27})-|['compiler_generated'] ) end
(<_34,_33,_32,_31,_30,_29,_28> when 'true' -> (primop 'match_fail' ({'function_clause',_34,_33,_32,_31,_30,_29,_28})-|[{'function_name',{'exprs',7}}] )-|['compiler_generated'] ) end
'is_expand_variable'/1 = fun (_0) -> let <_1> = catch call 'erlang':'atom_to_list' (_0) in case _1 of <[114|[101|[99|_X_Integer]]]> when 'true' -> 'true'
<_4> when 'true' -> 'false' end
'result_will_be_saved'/0 = fun () -> case apply 'get_history_and_results'/0 () of <{_1,0}> when 'true' -> 'false'
<_2> when 'true' -> 'true' end
'used_record_defs'/2 = fun (_0,_1) -> let <_12> = case apply 'used_records'/4 (_0,[],_1,[]) of <[]> when 'true' -> []
<L0> when 'true' -> let <_2> = call 'erlang':'length' (L0) in let <_3> = call 'lists':'seq' (1,_2) in let <L1> = call 'lists':'zip' (L0,_3) in let <_5> = call 'lists':'ukeysort' (1,L1) in let <L2> = call 'lists':'keysort' (2,_5) in (letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[{R,_16}|_8]> when 'true' -> let <_10> = apply 'lc$^0'/1 (_8) in ([R|_10]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (L2)-|['list_comprehension'] ) end in apply 'record_defs'/2 (_1,_12)
'used_records'/4 = fun (_0,_1,_2,_3) -> case apply 'used_records'/1 (_0) of <{'name',Name,E1}> when 'true' -> let <_6> = case call 'lists':'member' (Name,_3) of <'true'> when 'true' -> _1
<'false'> when 'true' -> let <R> = call 'ets':'lookup' (_2,Name) in apply 'used_records'/4 (R,[Name|_1],_2,[Name|_3])
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end in apply 'used_records'/4 (E1,_6,_2,_3)
<{'expr',[E1|Es]}> when 'true' -> let <_8> = apply 'used_records'/4 (E1,_1,_2,_3) in apply 'used_records'/4 (Es,_8,_2,_3)
<_14> when 'true' -> _1 end
'used_records'/1 = fun (_0) -> case _0 of <{'record_index',_3,Name,F}> when 'true' -> {'name',Name,F}
<{'record',_4,Name,Is}> when 'true' -> {'name',Name,Is}
<{'record_field',_5,R,Name,F}> when 'true' -> {'name',Name,[R|F]}
<{'record',_6,R,Name,Ups}> when 'true' -> {'name',Name,[R|Ups]}
<{'record_field',_7,R,F}> when 'true' -> {'expr',[R|F]}
<{'call',_8,{'atom',_9,'record'},[A|[{'atom',_10,Name}|[]]]}> when 'true' -> {'name',Name,A}
<{'call',_11,{'atom',_12,'is_record'},[A|[{'atom',_13,Name}|[]]]}> when 'true' -> {'name',Name,A}
<{'call',_14,{'remote',_15,{'atom',_16,'erlang'},{'atom',_17,'is_record'}},[A|[{'atom',_18,Name}|[]]]}> when 'true' -> {'name',Name,A}
<{'call',_19,{'atom',_20,'record_info'},[A|[{'atom',_21,Name}|[]]]}> when 'true' -> {'name',Name,A}
<{'call',Line,{'tuple',_22,[M|[F|[]]]},As}> when 'true' -> apply 'used_records'/1 ({'call',Line,{'remote',Line,M,F},As})
<{'type',_23,'record',[{'atom',_24,Name}|Fs]}> when 'true' -> {'name',Name,Fs}
<T> when call 'erlang':'is_tuple' (_0) -> let <_1> = call 'erlang':'tuple_to_list' (T) in {'expr',_1}
<E> when 'true' -> {'expr',E} end
'fwrite_severity'/3 = fun (_0,_1,_2) -> let <_3> = apply 'format_severity'/3 (_0,_1,_2) in call 'io':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#,[_3|[]])
'format_severity'/3 = fun (_0,_1,_2) -> let <_3> = call 'io_lib':'fwrite' (_1,_2) in apply 'add_severity'/2 (_0,_3)
'add_severity'/2 = fun (_0,_1) -> let <_2> = apply 'severity_tag'/1 (_0) in [_2|[_1|[]]]
'severity_tag'/1 = fun (_0) -> case _0 of <'fatal'> when 'true' -> #{#<42>(8,1,'integer',['unsigned'|['big']]),#<42>(8,1,'integer',['unsigned'|['big']]),#<42>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#
<'serious'> when 'true' -> #{#<42>(8,1,'integer',['unsigned'|['big']]),#<42>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#
<'benign'> when 'true' -> #{#<42>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'severity_tag',1}}] )-|['compiler_generated'] ) end
'restrict_handlers'/3 = fun (_0,_1,_2) -> let <_14> = fun (_10,_9,_8) -> apply 'local_allowed'/6 (_10,_9,_0,_8,_1,_2) in let <_7> = fun (_4,_3) -> apply 'non_local_allowed'/4 (_4,_3,_0,_1) in {_14,_7}
'local_allowed'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <F,As,RShMod,Bs,Shell,RT> when call 'erlang':'is_atom' (F) -> case apply 'restrict_handlers'/3 (RShMod,Shell,RT) of <{LFH,NLFH}> when 'true' -> case apply 'not_restricted'/2 (F,As) of <'true'> when 'true' -> apply 'local_func'/7 (F,As,Bs,Shell,RT,{'eval',LFH},{'value',NLFH})
<'false'> when 'true' -> case apply 'expr_list'/4 (As,Bs,{'eval',LFH},{'value',NLFH}) of <{AsEv,Bs1}> when 'true' -> let <_9> = call 'erlang':'get' ('restricted_shell_state') in let <_8> = call 'erlang':'get' ('restricted_expr_state') in case call RShMod:'local_allowed' (F,AsEv,{_9,_8}) of <{Result,{RShShSt,RShExprSt}}> when 'true' -> do call 'erlang':'put' ('restricted_shell_state',RShShSt) do call 'erlang':'put' ('restricted_expr_state',RShExprSt) case <> of <> when (call 'erlang':'=:=' (Result,'false')-|['compiler_generated'] ) -> let <_11> = call 'erlang':'get' () in do apply 'shell_req'/2 (Shell,{'update_dict',_11}) call 'erlang':'exit' ({'restricted_shell_disallowed',{F,AsEv}})
<> when 'true' -> apply 'non_builtin_local_func'/3 (F,AsEv,Bs1) end
<Unexpected> when 'true' -> try call 'erlang':'error' ('reason') of <_12> -> _12 catch <_15,_14,_13> -> let <S> = primop 'build_stacktrace' (_13) in call 'erlang':'raise' ('exit',{'restricted_shell_bad_return',Unexpected},[{RShMod,'local_allowed',3}|S]) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_17> when 'true' -> primop 'match_fail' ({'case_clause',_17})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_23,_22,_21,_20,_19,_18> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21,_20,_19,_18})-|[{'function_name',{'local_allowed',6}}] )-|['compiler_generated'] ) end
'non_local_allowed'/4 = fun (_0,_1,_2,_3) -> let <_5> = call 'erlang':'get' ('restricted_shell_state') in let <_4> = call 'erlang':'get' ('restricted_expr_state') in case call _2:'non_local_allowed' (_0,_1,{_5,_4}) of <{Result,{RShShSt,RShExprSt}}> when 'true' -> do call 'erlang':'put' ('restricted_shell_state',RShShSt) do call 'erlang':'put' ('restricted_expr_state',RShExprSt) case Result of <'false'> when 'true' -> let <_6> = call 'erlang':'get' () in do apply 'shell_req'/2 (_3,{'update_dict',_6}) call 'erlang':'exit' ({'restricted_shell_disallowed',{_0,_1}})
<{'redirect',NewMForFun,NewAs}> when 'true' -> apply 'apply_fun'/3 (NewMForFun,NewAs,_3)
<_17> when 'true' -> apply 'apply_fun'/3 (_0,_1,_3) end
<Unexpected> when 'true' -> try call 'erlang':'error' ('reason') of <_8> -> _8 catch <_11,_10,_9> -> let <S> = primop 'build_stacktrace' (_9) in call 'erlang':'raise' ('exit',{'restricted_shell_bad_return',Unexpected},[{_2,'non_local_allowed',3}|S]) end
'not_restricted'/2 = fun (_0,_1) -> case <_0,_1> of <'f',[]> when 'true' -> 'true'
<'f',[_4|[]]> when 'true' -> 'true'
<'h',[]> when 'true' -> 'true'
<'b',[]> when 'true' -> 'true'
<'history',[_5|[]]> when 'true' -> 'true'
<'results',[_6|[]]> when 'true' -> 'true'
<'catch_exception',[_7|[]]> when 'true' -> 'true'
<'exit',[]> when 'true' -> 'true'
<'rd',[_8|[_9|[]]]> when 'true' -> 'true'
<'rf',[]> when 'true' -> 'true'
<'rf',[_10|[]]> when 'true' -> 'true'
<'rl',[]> when 'true' -> 'true'
<'rl',[_11|[]]> when 'true' -> 'true'
<'rp',[_12|[]]> when 'true' -> 'true'
<'rr',[_13|[]]> when 'true' -> 'true'
<'rr',[_14|[_15|[]]]> when 'true' -> 'true'
<'rr',[_16|[_17|[_18|[]]]]> when 'true' -> 'true'
<_19,_20> when 'true' -> 'false' end
'apply_fun'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'erlang','garbage_collect'},[],Shell> when 'true' -> apply 'garb'/1 (Shell)
<{M,F},As,_X_Shell> when 'true' -> call 'erlang':'apply' (M,F,As)
<MForFun,As,_X_Shell> when 'true' -> call 'erlang':'apply' (MForFun,As) end
'prep_check'/1 = fun (_0) -> case _0 of <{'call',Line,{'atom',_7,'f'},[{'var',_8,_X_Name}|[]]}> when 'true' -> {'atom',Line,'ok'}
<{'value',_X_CommandN,_X_Val}> when 'true' -> let <_1> = apply 'a0'/0 () in {'atom',_1,'ok'}
<T> when call 'erlang':'is_tuple' (_0) -> let <_2> = call 'erlang':'tuple_to_list' (T) in let <_3> = apply 'prep_check'/1 (_2) in call 'erlang':'list_to_tuple' (_3)
<[E|Es]> when 'true' -> let <_4> = apply 'prep_check'/1 (E) in let <_5> = apply 'prep_check'/1 (Es) in [_4|_5]
<E> when 'true' -> E end
'expand_records'/2 = fun (_0,_1) -> case <_0,_1> of <[],E0> when 'true' -> E0
<UsedRecords,E0> when 'true' -> let <_6> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[{_X_Name,Def}|_3]> when 'true' -> let <_5> = apply 'lc$^0'/1 (_3) in ([Def|_5]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_19> when 'true' -> (primop 'match_fail' ({'function_clause',_19})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (UsedRecords) in let <L> = call 'erl_anno':'new' (1) in let <E> = apply 'prep_rec'/1 (E0) in let <Forms0> = call 'erlang':'++' (_6,[{'function',L,'foo',0,[{'clause',L,[],[],[E|[]]}|[]]}|[]]) in let <Forms> = call 'erl_expand_records':'module' (Forms0,['strict_record_tests']) in case call 'lists':'last' (Forms) of <{'function',_15,'foo',0,[{'clause',_16,[],[],[NE|[]]}|[]]}> when let <_17> = call 'erlang':'=:=' (_15,L) in let <_18> = call 'erlang':'=:=' (_16,L) in call 'erlang':'and' (_17,_18) -> apply 'prep_rec'/1 (NE)
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end end
'prep_rec'/1 = fun (_0) -> case _0 of <Value = {'value',_X_CommandN,_X_V}> when 'true' -> {'atom',Value,'ok'}
<{'atom',Value = {'value',_X_CommandN,_X_V},'ok'}> when 'true' -> Value
<T> when call 'erlang':'is_tuple' (_0) -> let <_1> = call 'erlang':'tuple_to_list' (T) in let <_2> = apply 'prep_rec'/1 (_1) in call 'erlang':'list_to_tuple' (_2)
<[E|Es]> when 'true' -> let <_3> = apply 'prep_rec'/1 (E) in let <_4> = apply 'prep_rec'/1 (Es) in [_3|_4]
<E> when 'true' -> E end
'init_dict'/1 = fun (_0) -> case _0 of <[{K,V}|Ds]> when 'true' -> do call 'erlang':'put' (K,V) apply 'init_dict'/1 (Ds)
<[]> when 'true' -> 'true'
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'init_dict',1}}] )-|['compiler_generated'] ) end
'local_func'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <'h',[],Bs,Shell,RT,_X_Lf,_X_Ef> when 'true' -> let <Cs> = apply 'shell_req'/2 (Shell,'get_cmd') in let <_10> = fun (_8) -> case _8 of <{{'command',_74},_75}> when 'true' -> 'true'
<{{'result',_76},_77}> when 'true' -> 'true'
<_78> when 'true' -> 'false' end in let <Cs1> = call 'lists':'filter' (_10,Cs) in let <_14> = fun (_12) -> case _12 of <{{T,N},V}> when 'true' -> {{N,T},V}
(<_13> when 'true' -> (primop 'match_fail' ({'function_clause',_13})-|[{'function_name',{'-local_func/7-fun-1-',1}}] )-|['compiler_generated'] ) end in let <Cs2> = call 'lists':'map' (_14,Cs1) in let <Cs3> = call 'lists':'keysort' (1,Cs2) in let <_17> = apply 'list_commands'/2 (Cs3,RT) in {'value',_17,Bs}
<'b',[],Bs,_X_Shell,RT,_X_Lf,_X_Ef> when 'true' -> let <_18> = call 'erl_eval':'bindings' (Bs) in let <_19> = apply 'list_bindings'/2 (_18,RT) in {'value',_19,Bs}
<'f',[],_X_Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> let <_20> = call 'erl_eval':'new_bindings' () in {'value','ok',_20}
<'f',[{'var',_79,Name}|[]],Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> let <_21> = call 'erl_eval':'del_binding' (Name,Bs) in {'value','ok',_21}
<'f',[_X_Other|[]],_X_Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> call 'erlang':'raise' ('error','function_clause',[{'shell','f',1}])
<'rd',[{'atom',_80,RecName0}|[RecDef0|[]]],Bs,_X_Shell,RT,_X_Lf,_X_Ef> when 'true' -> let <RecDef> = apply 'expand_value'/1 (RecDef0) in let <_23> = call 'erl_pp':'expr' (RecDef) in let <RDs> = call 'lists':'flatten' (_23) in let <RecName> = call 'io_lib':'write_atom_as_latin1' (RecName0) in let <Attr> = call 'lists':'concat' ([[45|[114|[101|[99|[111|[114|[100|[40]]]]]]]]|[RecName|[[44]|[RDs|[[41|[46]]]]]]]) in case call 'erl_scan':'string' (Attr) of <{'ok',Tokens,_81}> when 'true' -> case call 'erl_parse':'parse_form' (Tokens) of <{'ok',AttrForm}> when 'true' -> case apply 'add_records'/3 ([AttrForm|[]],Bs,RT) of <[RN|[]]> when 'true' -> {'value',RN,Bs}
(<_28> when 'true' -> primop 'match_fail' ({'badmatch',_28})-|['compiler_generated'] ) end
<{'error',{_X_Line,M,ErrDesc}}> when 'true' -> let <_29> = call M:'format_error' (ErrDesc) in let <ErrStr> = call 'io_lib':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#,[_29|[]]) in let <_31> = call 'lists':'flatten' (ErrStr) in call 'erlang':'exit' (_31)
(<_32> when 'true' -> primop 'match_fail' ({'case_clause',_32})-|['compiler_generated'] ) end
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end
<'rd',[_82|[_83|[]]],_X_Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> call 'erlang':'raise' ('error','function_clause',[{'shell','rd',2}])
<'rf',[],Bs,_X_Shell,RT,_X_Lf,_X_Ef> when 'true' -> case call 'ets':'delete_all_objects' (RT) of <'true'> when 'true' -> let <_34> = apply 'initiate_records'/2 (Bs,RT) in {'value',_34,Bs}
(<_33> when 'true' -> primop 'match_fail' ({'badmatch',_33})-|['compiler_generated'] ) end
<'rf',_@r0 = [A|[]],Bs0,_X_Shell,RT,Lf,Ef> when 'true' -> case apply 'expr_list'/4 (_@r0,Bs0,Lf,Ef) of <{[Recs|[]],Bs}> when 'true' -> do case <> of <> when call 'erlang':'=:=' ('_',Recs) -> case call 'ets':'delete_all_objects' (RT) of <'true'> when 'true' -> 'ok'
(<_36> when 'true' -> primop 'match_fail' ({'badmatch',_36})-|['compiler_generated'] ) end
<> when 'true' -> let <_41> = fun (_39) -> let <_85> = call 'ets':'delete' (RT,_39) in case _85 of <'true'> when 'true' -> (_85-|['compiler_generated'] )
(<_38> when 'true' -> primop 'match_fail' ({'badmatch',_38})-|['compiler_generated'] ) end in let <_37> = apply 'listify'/1 (Recs) in call 'lists':'foreach' (_41,_37) end {'value','ok',Bs}
(<_35> when 'true' -> primop 'match_fail' ({'badmatch',_35})-|['compiler_generated'] ) end
<'rl',[],Bs,_X_Shell,RT,_X_Lf,_X_Ef> when 'true' -> let <_42> = call 'ets':'tab2list' (RT) in let <_43> = apply 'list_records'/1 (_42) in {'value',_43,Bs}
<'rl',_@r1 = [A|[]],Bs0,_X_Shell,RT,Lf,Ef> when 'true' -> case apply 'expr_list'/4 (_@r1,Bs0,Lf,Ef) of <{[Recs|[]],Bs}> when 'true' -> let <_45> = apply 'listify'/1 (Recs) in let <_46> = apply 'record_defs'/2 (RT,_45) in let <_47> = apply 'list_records'/1 (_46) in {'value',_47,Bs}
(<_44> when 'true' -> primop 'match_fail' ({'badmatch',_44})-|['compiler_generated'] ) end
<'rp',_@r2 = [A|[]],Bs0,_X_Shell,RT,Lf,Ef> when 'true' -> case apply 'expr_list'/4 (_@r2,Bs0,Lf,Ef) of <{[V|[]],Bs}> when 'true' -> let <Cs> = apply 'pp'/4 (V,(1-|['compiler_generated'] ),-1,RT) in do call 'io':'requests' ([{'put_chars','unicode',Cs}|['nl']]) {'value','ok',Bs}
(<_48> when 'true' -> primop 'match_fail' ({'badmatch',_48})-|['compiler_generated'] ) end
<'rr',_@r3 = [A|[]],Bs0,_X_Shell,RT,Lf,Ef> when 'true' -> case apply 'expr_list'/4 (_@r3,Bs0,Lf,Ef) of <{[File|[]],Bs}> when 'true' -> let <_55> = apply 'read_and_add_records'/5 (File,'_',[],Bs,RT) in {'value',_55,Bs}
(<_54> when 'true' -> primop 'match_fail' ({'badmatch',_54})-|['compiler_generated'] ) end
<'rr',As0 = [_86|[_87|[]]],Bs0,_X_Shell,RT,Lf,Ef> when 'true' -> case apply 'expr_list'/4 (As0,Bs0,Lf,Ef) of <{[File|[Sel|[]]],Bs}> when 'true' -> let <_57> = apply 'read_and_add_records'/5 (File,Sel,[],Bs,RT) in {'value',_57,Bs}
(<_56> when 'true' -> primop 'match_fail' ({'badmatch',_56})-|['compiler_generated'] ) end
<'rr',As0 = [_88|[_89|[_90|[]]]],Bs0,_X_Shell,RT,Lf,Ef> when 'true' -> case apply 'expr_list'/4 (As0,Bs0,Lf,Ef) of <{[File|[Sel|[Options|[]]]],Bs}> when 'true' -> let <_59> = apply 'read_and_add_records'/5 (File,Sel,Options,Bs,RT) in {'value',_59,Bs}
(<_58> when 'true' -> primop 'match_fail' ({'badmatch',_58})-|['compiler_generated'] ) end
<'history',[{'integer',_91,N}|[]],Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> let <_60> = apply 'history'/1 (N) in {'value',_60,Bs}
<'history',[_X_Other|[]],_X_Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> call 'erlang':'raise' ('error','function_clause',[{'shell','history',1}])
<'results',[{'integer',_92,N}|[]],Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> let <_61> = apply 'results'/1 (N) in {'value',_61,Bs}
<'results',[_X_Other|[]],_X_Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> call 'erlang':'raise' ('error','function_clause',[{'shell','results',1}])
<'catch_exception',[{'atom',_93,Bool}|[]],Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when let <_62> = call 'erlang':'=:=' (Bool,'true') in let <_64> = call 'erlang':'=:=' (Bool,'false') in call 'erlang':'or' (_62,_64) -> let <_65> = apply 'catch_exception'/1 (Bool) in {'value',_65,Bs}
<'catch_exception',[_X_Other|[]],_X_Bs,_X_Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> call 'erlang':'raise' ('error','function_clause',[{'shell','catch_exception',1}])
<'exit',[],_X_Bs,Shell,_X_RT,_X_Lf,_X_Ef> when 'true' -> do apply 'shell_req'/2 (Shell,'exit') call 'erlang':'exit' ('normal')
<F,As0,Bs0,_X_Shell,_X_RT,Lf,Ef> when call 'erlang':'is_atom' (F) -> case apply 'expr_list'/4 (As0,Bs0,Lf,Ef) of <{As,Bs}> when 'true' -> apply 'non_builtin_local_func'/3 (F,As,Bs)
(<_66> when 'true' -> primop 'match_fail' ({'badmatch',_66})-|['compiler_generated'] ) end
(<_73,_72,_71,_70,_69,_68,_67> when 'true' -> (primop 'match_fail' ({'function_clause',_73,_72,_71,_70,_69,_68,_67})-|[{'function_name',{'local_func',7}}] )-|['compiler_generated'] ) end
'non_builtin_local_func'/3 = fun (_0,_1,_2) -> let <Arity> = call 'erlang':'length' (_1) in case call 'erlang':'function_exported' ('user_default',_0,Arity) of <'true'> when 'true' -> let <_4> = call 'erlang':'make_fun' ('user_default',_0,Arity) in {'eval',_4,_1,_2}
<'false'> when 'true' -> apply 'shell_default'/3 (_0,_1,_2)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'shell_default'/3 = fun (_0,_1,_2) -> let <A> = call 'erlang':'length' (_1) in case call 'code':'ensure_loaded' ('shell_default') of <{'module',_11}> when 'true' -> case call 'erlang':'function_exported' ('shell_default',_0,A) of <'true'> when 'true' -> let <_5> = call 'erlang':'make_fun' ('shell_default',_0,A) in {'eval',_5,_1,_2}
<'false'> when 'true' -> apply 'shell_undef'/2 (_0,A)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<{'error',_12}> when 'true' -> apply 'shell_undef'/2 (_0,A)
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
'shell_undef'/2 = fun (_0,_1) -> call 'erlang':'error' ({'shell_undef',_0,_1,[]})
'local_func_handler'/3 = fun (_0,_1,_2) -> let <H> = fun (_10) -> (fun (_6,_5,_4) -> let <_3> = apply _10 (_10) in apply 'local_func'/7 (_6,_5,_4,_0,_1,{'eval',_3},_2)-|[{'id',{0,0,'-local_func_handler/3-fun-0-'}}] ) in let <_13> = apply H (H) in {'eval',_13}
'record_print_fun'/1 = fun (_0) -> (fun (_4,_3) -> case call 'ets':'lookup' (_0,_4) of <[{_8,{'attribute',_9,'record',{_10,Fields}}}|[]]> when let <_11> = call 'erlang':'=:=' (_10,_4) in let <_12> = try let <_1> = call 'erlang':'length' (Fields) in call 'erlang':'=:=' (_1,_3) of <Try> -> Try catch <T,R> -> 'false' in call 'erlang':'and' (_11,_12) -> apply 'record_fields'/1 (Fields)
<_13> when 'true' -> 'no' end-|[{'id',{0,0,'-record_print_fun/1-fun-0-'}}] )
'record_fields'/1 = fun (_0) -> case _0 of <[{'record_field',_4,{'atom',_5,Field}}|Fs]> when 'true' -> let <_1> = apply 'record_fields'/1 (Fs) in [Field|_1]
<[{'record_field',_6,{'atom',_7,Field},_8}|Fs]> when 'true' -> let <_2> = apply 'record_fields'/1 (Fs) in [Field|_2]
<[{'typed_record_field',Field,_X_Type}|Fs]> when 'true' -> apply 'record_fields'/1 ([Field|Fs])
<[]> when 'true' -> []
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'record_fields',1}}] )-|['compiler_generated'] ) end
'initiate_records'/2 = fun (_0,_1) -> let <RNs1> = apply 'init_rec'/3 ('shell_default',_0,_1) in let <_4> = case call 'code':'is_loaded' ('user_default') of <{'file',_X_File}> when 'true' -> apply 'init_rec'/3 ('user_default',_0,_1)
<'false'> when 'true' -> []
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end in let <_6> = call 'erlang':'++' (RNs1,_4) in call 'lists':'usort' (_6)
'init_rec'/3 = fun (_0,_1,_2) -> case apply 'read_records'/2 (_0,[]) of <RAs> when call 'erlang':'is_list' (RAs) -> let <_3> = catch apply 'add_records'/3 (RAs,_1,_2) in case _3 of <{'EXIT',_9}> when 'true' -> []
<RNs> when 'true' -> RNs end
<_X_Error> when 'true' -> [] end
'read_and_add_records'/5 = fun (_0,_1,_2,_3,_4) -> case apply 'read_records'/3 (_0,_1,_2) of <RAs> when call 'erlang':'is_list' (RAs) -> apply 'add_records'/3 (RAs,_3,_4)
<Error> when 'true' -> Error end
'read_records'/3 = fun (_0,_1,_2) -> let <_3> = apply 'listify'/1 (_2) in case apply 'read_records'/2 (_0,_3) of <Error> when call 'erlang':'is_tuple' (Error) -> Error
<RAs> when call 'erlang':'=:=' (_1,'_') -> RAs
<RAs> when 'true' -> let <Sel> = apply 'listify'/1 (_1) in (letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[RA = {'attribute',_14,_15,{Name,_16}}|_6]> when 'true' -> (case call 'lists':'member' (Name,Sel) of <'true'> when 'true' -> let <_8> = apply 'lc$^0'/1 (_6) in ([RA|_8]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (RAs)-|['list_comprehension'] ) end
'add_records'/3 = fun (_0,_1,_2) -> let <_7> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[D = {'attribute',_23,_24,{Name,_25}}|_4]> when 'true' -> let <_6> = apply 'lc$^0'/1 (_4) in ([{Name,D}|_6]-|['compiler_generated'] )
(<[_3|_4]> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_27> when 'true' -> (primop 'match_fail' ({'function_clause',_27})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <Bs1> = apply 'record_bindings'/2 (_7,_1) in case apply 'check_command'/2 ([],Bs1) of <{'error',{_X_Line,M,ErrDesc}}> when 'true' -> let <_10> = call M:'format_error' (ErrDesc) in let <ErrStr> = call 'io_lib':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#,[_10|[]]) in let <_12> = call 'lists':'flatten' (ErrStr) in call 'erlang':'exit' (_12)
<'ok'> when 'true' -> case call 'ets':'insert' (_2,_7) of <'true'> when 'true' -> let <_18> = letrec 'lc$^1'/1 = fun (_16) -> case _16 of <[{Name,_26}|_15]> when 'true' -> let <_17> = apply 'lc$^1'/1 (_15) in ([Name|_17]-|['compiler_generated'] )
(<[_14|_15]> when 'true' -> apply 'lc$^1'/1 (_15)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_28> when 'true' -> (primop 'match_fail' ({'function_clause',_28})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (_7) in call 'lists':'usort' (_18)
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end
(<_19> when 'true' -> primop 'match_fail' ({'case_clause',_19})-|['compiler_generated'] ) end
'listify'/1 = fun (_0) -> case _0 of <L> when call 'erlang':'is_list' (_0) -> L
<E> when 'true' -> [E|[]] end
'check_command'/2 = fun (_0,_1) -> call 'erl_eval':'check_command' (_0,_1)
'expr'/4 = fun (_0,_1,_2,_3) -> call 'erl_eval':'expr' (_0,_1,_2,_3)
'expr_list'/4 = fun (_0,_1,_2,_3) -> call 'erl_eval':'expr_list' (_0,_1,_2,_3)
'record_bindings'/2 = fun (_0,_1) -> case <_0,_1> of <[],Bs> when 'true' -> Bs
<Recs0,Bs0> when 'true' -> let <_7> = fun (_4,_3) -> case <_4,_3> of <{Name,Def},I> when 'true' -> let <_2> = call 'erlang':'+' (I,1) in {{Name,I,Def},_2}
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'-record_bindings/2-fun-0-',2}}] )-|['compiler_generated'] ) end in case call 'lists':'mapfoldl' (_7,0,Recs0) of <{Recs1,_18}> when 'true' -> let <_9> = call 'lists':'ukeysort' (1,Recs1) in let <Recs2> = call 'lists':'keysort' (2,_9) in let <_15> = fun (_12,_11) -> case <_12,_11> of <{Name,I,Def},Bs> when 'true' -> call 'erl_eval':'add_binding' ({'record',I,Name},Def,Bs)
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'-record_bindings/2-fun-1-',2}}] )-|['compiler_generated'] ) end in call 'lists':'foldl' (_15,Bs0,Recs2)
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end
'read_records'/2 = fun (_0,_1) -> let <Opts> = call 'lists':'delete' ('report_warnings',_1) in case apply 'find_file'/1 (_0) of <{'files',[File|[]]}> when 'true' -> apply 'read_file_records'/2 (File,Opts)
<{'files',Files}> when 'true' -> let <_6> = fun (_4) -> case apply 'read_file_records'/2 (_4,Opts) of <RAs> when call 'erlang':'is_list' (RAs) -> RAs
<_10> when 'true' -> [] end in call 'lists':'flatmap' (_6,Files)
<Error> when 'true' -> Error end
'find_file'/1 = fun (_0) -> case _0 of <Mod> when call 'erlang':'is_atom' (_0) -> case call 'code':'which' (Mod) of <File> when call 'erlang':'is_list' (File) -> {'files',[File|[]]}
<'preloaded'> when 'true' -> case call 'code':'get_object_code' (Mod) of <{_X_M,_X_Bin,File}> when 'true' -> {'files',[File|[]]}
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
<_X_Else> when 'true' -> {'error','nofile'} end
<File> when 'true' -> let <_3> = catch call 'filelib':'wildcard' (File) in case _3 of <{'EXIT',_6}> when 'true' -> {'error','invalid_filename'}
<Files> when 'true' -> {'files',Files} end end
'read_file_records'/2 = fun (_0,_1) -> case call 'filename':'extension' (_0) of <[46|[98|[101|[97|[109]]]]]> when 'true' -> case call 'beam_lib':'chunks' (_0,['abstract_code'|[[67|[73|[110|[102]]]]]]) of <{'ok',{_X_Mod,[{'abstract_code',{Version,Forms}}|[{[67|[73|[110|[102]]]],CB}|[]]]}}> when 'true' -> case apply 'record_attrs'/1 (Forms) of <[]> when call 'erlang':'=:=' (Version,'raw_abstract_v1') -> []
<[]> when 'true' -> apply 'try_source'/2 (_0,CB)
<Records> when 'true' -> Records end
<{'ok',{_X_Mod,[{'abstract_code','no_abstract_code'}|[{[67|[73|[110|[102]]]],CB}|[]]]}}> when 'true' -> apply 'try_source'/2 (_0,CB)
<Error> when 'true' -> Error end
<_7> when 'true' -> apply 'parse_file'/2 (_0,_1) end
'try_source'/2 = fun (_0,_1) -> let <EbinDir> = call 'filename':'dirname' (_0) in let <CB> = call 'erlang':'binary_to_term' (_1) in let <Os> = call 'proplists':'get_value' ('options',CB,[]) in let <_5> = call 'filename':'rootname' (_0) in let <Src0> = call 'erlang':'++' (_5,[46|[101|[114|[108]]]]) in let <_7> = call 'filename':'dirname' (EbinDir) in let <_8> = call 'filename':'basename' (Src0) in let <Src1> = call 'filename':'join' ([_7|[[115|[114|[99]]]|[_8|[]]]]) in let <Src2> = call 'proplists':'get_value' ('source',CB,[]) in apply 'try_sources'/2 ([Src0|[Src1|[Src2|[]]]],Os)
'try_sources'/2 = fun (_0,_1) -> case <_0,_1> of <[],_5> when 'true' -> {'error','nofile'}
<[Src|Rest],Os> when 'true' -> case apply 'is_file'/1 (Src) of <'true'> when 'true' -> apply 'parse_file'/2 (Src,Os)
<'false'> when 'true' -> apply 'try_sources'/2 (Rest,Os)
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'try_sources',2}}] )-|['compiler_generated'] ) end
'is_file'/1 = fun (_0) -> case call 'filelib':'is_file' (_0) of <'true'> when 'true' -> let <_1> = call 'filelib':'is_dir' (_0) in call 'erlang':'not' (_1)
<'false'> when 'true' -> 'false'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'parse_file'/2 = fun (_0,_1) -> let <Dir> = call 'filename':'dirname' (_0) in let <_4> = apply 'inc_paths'/1 (_1) in let <IncludePath> = [[46]|[Dir|_4]] in let <_6> = apply 'pre_defs'/1 (_1) in case call 'epp':'parse_file' (_0,IncludePath,_6) of <{'ok',Forms}> when 'true' -> apply 'record_attrs'/1 (Forms)
<Error> when 'true' -> Error end
'pre_defs'/1 = fun (_0) -> case _0 of <[{'d',M,V}|Opts]> when 'true' -> let <_1> = apply 'pre_defs'/1 (Opts) in [{M,V}|_1]
<[{'d',M}|Opts]> when 'true' -> let <_2> = apply 'pre_defs'/1 (Opts) in [M|_2]
<[_4|Opts]> when 'true' -> apply 'pre_defs'/1 (Opts)
<[]> when 'true' -> []
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'pre_defs',1}}] )-|['compiler_generated'] ) end
'inc_paths'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{'i',P}|_2]> when call 'erlang':'is_list' (P) -> let <_4> = apply 'lc$^0'/1 (_2) in ([P|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'record_attrs'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[A = {'attribute',_6,'record',_X_D}|_2]> when 'true' -> let <_4> = apply 'lc$^0'/1 (_2) in ([A|_4]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0)-|['list_comprehension'] )
'shell_req'/2 = fun (_0,_1) -> let <_2> = call 'erlang':'self' () in do call 'erlang':'!' (_0,{'shell_req',_2,_1}) receive <{'shell_rep',_5,Rep}> when call 'erlang':'=:=' (_5,_0) -> Rep after 'infinity' -> 'true'
'list_commands'/2 = fun (_0,_1) -> case <_0,_1> of <[{{N,'command'},Es0}|[{{_15,'result'},V}|Ds]],RT> when call 'erlang':'=:=' (_15,N) -> let <Es> = apply 'prep_list_commands'/1 (Es0) in let <VS> = apply 'pp'/3 (V,4,RT) in let <Ns> = call 'io_lib':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#,[N|[]]) in let <I> = call 'erlang':'iolist_size' (Ns) in let <_6> = apply 'enc'/0 () in let <_7> = call 'erl_pp':'exprs' (Es,I,_6) in do call 'io':'requests' ([{'put_chars','latin1',Ns}|[{'format',#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#,[_7|[]]}|[{'format',#{#<45>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#,[]}|[{'put_chars','unicode',VS}|['nl']]]]]) apply 'list_commands'/2 (Ds,RT)
<[{{N,'command'},Es0}|Ds],RT> when 'true' -> let <Es> = apply 'prep_list_commands'/1 (Es0) in let <Ns> = call 'io_lib':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#,[N|[]]) in let <I> = call 'erlang':'iolist_size' (Ns) in let <_11> = apply 'enc'/0 () in let <_12> = call 'erl_pp':'exprs' (Es,I,_11) in do call 'io':'requests' ([{'put_chars','latin1',Ns}|[{'format',#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#,[_12|[]]}|[]]]) apply 'list_commands'/2 (Ds,RT)
<[_X_D|Ds],RT> when 'true' -> apply 'list_commands'/2 (Ds,RT)
<[],_X_RT> when 'true' -> 'ok'
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'list_commands',2}}] )-|['compiler_generated'] ) end
'list_bindings'/2 = fun (_0,_1) -> case <_0,_1> of <[{Name,Val}|Bs],RT> when 'true' -> do case call 'erl_eval':'fun_data' (Val) of <{'fun_data',_X_FBs,FCs0}> when 'true' -> let <FCs> = apply 'expand_value'/1 (FCs0) in let <A> = apply 'a0'/0 () in let <F> = {'fun',A,{'clauses',FCs}} in let <M> = {'match',A,{'var',A,Name},F} in let <_6> = apply 'enc'/0 () in let <_7> = call 'erl_pp':'expr' (M,_6) in call 'io':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#,[_7|[]])
<{'named_fun_data',_X_FBs,FName,FCs0}> when 'true' -> let <FCs> = apply 'expand_value'/1 (FCs0) in let <A> = apply 'a0'/0 () in let <F> = {'named_fun',A,FName,FCs} in let <M> = {'match',A,{'var',A,Name},F} in let <_12> = apply 'enc'/0 () in let <_13> = call 'erl_pp':'expr' (M,_12) in call 'io':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#,[_13|[]])
<'false'> when 'true' -> let <Namel> = call 'io_lib':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#,[Name|[]]) in let <_15> = call 'erlang':'iolist_size' (Namel) in let <Nl> = call 'erlang':'+' (_15,1) in let <ValS> = apply 'pp'/3 (Val,Nl,RT) in call 'io':'requests' ([{'put_chars','latin1',Namel}|[{'put_chars','unicode',ValS}|['nl']]])
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end apply 'list_bindings'/2 (Bs,RT)
<[],_X_RT> when 'true' -> 'ok'
(<_20,_19> when 'true' -> (primop 'match_fail' ({'function_clause',_20,_19})-|[{'function_name',{'list_bindings',2}}] )-|['compiler_generated'] ) end
'list_records'/1 = fun (_0) -> let <_5> = fun (_3) -> case _3 of <{_X_Name,Attr}> when 'true' -> let <_1> = apply 'enc'/0 () in let <_2> = call 'erl_pp':'attribute' (Attr,_1) in call 'io':'fwrite' (#{#<126>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#,[_2|[]])
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'-list_records/1-fun-0-',1}}] )-|['compiler_generated'] ) end in call 'lists':'foreach' (_5,_0)
'record_defs'/2 = fun (_0,_1) -> let <_4> = fun (_2) -> call 'ets':'lookup' (_0,_2) in call 'lists':'flatmap' (_4,_1)
'expand_value'/1 = fun (_0) -> let <_3> = fun (_1) -> case _1 of <{'value',CommandN,V}> when 'true' -> apply 'try_abstract'/2 (V,CommandN)
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'-expand_value/1-fun-0-',1}}] )-|['compiler_generated'] ) end in apply 'substitute_v1'/2 (_3,_0)
'try_abstract'/2 = fun (_0,_1) -> try call 'erl_parse':'abstract' (_0) of <_2> -> _2 catch <_5,_4,_3> -> let <A> = apply 'a0'/0 () in {'call',A,{'atom',A,'v'},[{'integer',A,_1}|[]]}
'prep_list_commands'/1 = fun (_0) -> let <A> = apply 'a0'/0 () in let <_5> = fun (_3) -> case _3 of <{'value',Anno,_X_V}> when 'true' -> let <CommandN> = call 'erl_anno':'line' (Anno) in {'call',A,{'atom',A,'v'},[{'integer',A,CommandN}|[]]}
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'-prep_list_commands/1-fun-0-',1}}] )-|['compiler_generated'] ) end in apply 'substitute_v1'/2 (_5,_0)
'substitute_v1'/2 = fun (_0,_1) -> case <_0,_1> of <F,Value = {'value',_8,_9}> when 'true' -> apply F (Value)
<F,T> when call 'erlang':'is_tuple' (T) -> let <_2> = call 'erlang':'tuple_to_list' (T) in let <_3> = apply 'substitute_v1'/2 (F,_2) in call 'erlang':'list_to_tuple' (_3)
<F,[E|Es]> when 'true' -> let <_4> = apply 'substitute_v1'/2 (F,E) in let <_5> = apply 'substitute_v1'/2 (F,Es) in [_4|_5]
<_X_F,E> when 'true' -> E end
'a0'/0 = fun () -> call 'erl_anno':'new' (0)
'check_and_get_history_and_results'/0 = fun () -> do apply 'check_env'/1 ('shell_history_length') do apply 'check_env'/1 ('shell_saved_results') apply 'get_history_and_results'/0 ()
'get_history_and_results'/0 = fun () -> let <History> = apply 'get_env'/2 ('shell_history_length',20) in let <Results> = apply 'get_env'/2 ('shell_saved_results',20) in let <_2> = call 'erlang':'min' (Results,History) in {History,_2}
'pp'/3 = fun (_0,_1,_2) -> apply 'pp'/4 (_0,_1,(30-|['compiler_generated'] ),_2)
'pp'/4 = fun (_0,_1,_2,_3) -> let <_5> = case call 'application':'get_env' ('stdlib','shell_strings') of <{'ok','false'}> when 'true' -> 'false'
<_15> when 'true' -> 'true' end in let <_8> = apply 'columns'/0 () in let <_9> = apply 'record_print_fun'/1 (_3) in let <_7> = apply 'enc'/0 () in let <_10> = [{'column',_1}|[{'line_length',_8}|[{'depth',_2}|[{'line_max_chars',60}|[{'strings',_5}|[{'record_print_fun',_9}|_7]]]]]] in call 'io_lib_pretty':'print' (_0,_10)
'columns'/0 = fun () -> case call 'io':'columns' () of <{'ok',N}> when 'true' -> N
<_1> when 'true' -> 80 end
'encoding'/0 = fun () -> case apply 'enc'/0 () of <[{'encoding',Encoding}|[]]> when 'true' -> Encoding
(<_0> when 'true' -> primop 'match_fail' ({'badmatch',_0})-|['compiler_generated'] ) end
'enc'/0 = fun () -> let <_0> = call 'io':'getopts' () in case call 'lists':'keyfind' ('encoding',1,_0) of <'false'> when 'true' -> [{'encoding','latin1'}]
<Enc> when 'true' -> [Enc|[]] end
'garb'/1 = fun (_0) -> do call 'erlang':'garbage_collect' (_0) do try let <_1> = call 'erlang':'whereis' ('user') in call 'erlang':'garbage_collect' (_1) of <_catch_value> -> _catch_value catch <Class,Reason,Stk> -> 'ok' do try let <_2> = call 'erlang':'group_leader' () in call 'erlang':'garbage_collect' (_2) of <_catch_value> -> _catch_value catch <Class,Reason,Stk> -> 'ok' call 'erlang':'garbage_collect' ()
'get_env'/2 = fun (_0,_1) -> case call 'application':'get_env' ('stdlib',_0) of <{'ok',Val}> when let <_2> = call 'erlang':'is_integer' (Val) in let <_3> = call 'erlang':'>=' (Val,0) in call 'erlang':'and' (_2,_3) -> Val
<_7> when 'true' -> _1 end
'check_env'/1 = fun (_0) -> case call 'application':'get_env' ('stdlib',_0) of <'undefined'> when 'true' -> 'ok'
<{'ok',Val}> when let <_1> = call 'erlang':'is_integer' (Val) in let <_2> = call 'erlang':'>=' (Val,0) in call 'erlang':'and' (_1,_2) -> 'ok'
<{'ok',Val}> when 'true' -> let <Txt> = call 'io_lib':'fwrite' ([73|[110|[118|[97|[108|[105|[100|[32|[118|[97|[108|[117|[101|[32|[111|[102|[32|[83|[84|[68|[76|[73|[66|[32|[99|[111|[110|[102|[105|[103|[117|[114|[97|[116|[105|[111|[110|[32|[112|[97|[114|[97|[109|[101|[116|[101|[114|[126|[116|[119|[58|[32|[126|[116|[112|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_0|[Val|[]]]) in let <_4> = call 'lists':'flatten' (Txt) in call 'error_logger':'info_report' (_4)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'set_env'/4 = fun (_0,_1,_2,_3) -> let <_5> = case call 'application':'get_env' (_0,_1) of <'undefined'> when 'true' -> _3
<{'ok',Old}> when 'true' -> Old
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in do call 'application_controller':'set_env' (_0,_1,_2) _5
'history'/1 = fun (_0) -> case _0 of <L> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> apply 'set_env'/4 ('stdlib','shell_history_length',L,20)
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'history',1}}] )-|['compiler_generated'] ) end
'results'/1 = fun (_0) -> case _0 of <L> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> apply 'set_env'/4 ('stdlib','shell_saved_results',L,20)
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'results',1}}] )-|['compiler_generated'] ) end
'catch_exception'/1 = fun (_0) -> apply 'set_env'/4 ('stdlib','shell_catch_exception',_0,'false')
'prompt_func'/1 = fun (_0) -> apply 'set_env'/4 ('stdlib','shell_prompt_func',_0,'default')
'strings'/1 = fun (_0) -> apply 'set_env'/4 ('stdlib','shell_strings',_0,'true')
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('shell')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('shell',_0) end