module 'edlin_expand' ['expand'/1,'format_matches'/1,'module_info'/0,'module_info'/1] attributes [ 'file' = [{[115|[114|[99|[47|[101|[100|[108|[105|[110|[95|[101|[120|[112|[97|[110|[100|[46|[101|[114|[108]]]]]]]]]]]]]]]]]]]],1}] ] 'expand'/1 = fun (_0) -> case call 'edlin':'over_word' (_0,[],0) of <{Bef1,Word,_12}> when 'true' -> case apply 'over_white'/3 (Bef1,[],0) of <{[44|Bef2],_X_White,_X_Nwh}> when 'true' -> case apply 'over_white'/3 (Bef2,[],0) of <{Bef3,_X_White1,_X_Nwh1}> when 'true' -> case call 'edlin':'over_word' (Bef3,[],0) of <{Bef4,Mod,_X_Nm}> when 'true' -> case apply 'expand_function'/1 (Bef4) of <'help'> when 'true' -> apply 'expand_function_name'/3 (Mod,Word,[44])
<_13> when 'true' -> apply 'expand_module_name'/2 (Word,[44]) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{[58|Bef2],_X_White,_X_Nwh}> when 'true' -> case apply 'over_white'/3 (Bef2,[],0) of <{Bef3,_X_White1,_X_Nwh1}> when 'true' -> case call 'edlin':'over_word' (Bef3,[],0) of <{_14,Mod,_X_Nm}> when 'true' -> apply 'expand_function_name'/3 (Mod,Word,[40])
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{_15,_16,_17}> when 'true' -> let <_8> = case apply 'expand_function'/1 (Bef1) of <'help'> when 'true' -> [44]
<_18> when 'true' -> [58] end in apply 'expand_module_name'/2 (Word,_8)
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'expand_function'/1 = fun (_0) -> case _0 of <[40|Str]> when 'true' -> case call 'edlin':'over_word' (Str,[],0) of <{_3,[104],_4}> when 'true' -> 'help'
<{_5,[104|[116]],_6}> when 'true' -> 'help_type'
<_7> when 'true' -> 'module' end
<_8> when 'true' -> 'module' end
'expand_module_name'/2 = fun (_0,_1) -> case <_0,_1> of <[],_11> when 'true' -> {'no',[],[]}
<Prefix,CompleteChar> when 'true' -> let <_8> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[{M,P,_12}|_3]> when 'true' -> let <_6> = call 'erlang':'list_to_atom' (M) in let <_7> = apply 'lc$^0'/1 (_3) in ([{_6,P}|_7]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_13> when 'true' -> (primop 'match_fail' ({'function_clause',_13})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_4> = call 'code':'all_available' () in apply 'lc$^0'/1 (_4) in apply 'match'/3 (Prefix,_8,CompleteChar) end
'expand_function_name'/3 = fun (_0,_1,_2) -> case apply 'to_atom'/1 (_0) of <{'ok',Mod}> when 'true' -> let <_6> = case call 'erlang':'module_loaded' (Mod) of <'true'> when 'true' -> call Mod:'module_info' ('exports')
<'false'> when 'true' -> let <_3> = call 'code':'which' (Mod) in case call 'beam_lib':'chunks' (_3,['exports']) of <{'ok',{_13,[{'exports',E}|[]]}}> when call 'erlang':'=:=' (_13,Mod) -> E
<_14> when 'true' -> {'no',[],[]} end
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end in case _6 of <{'no',[],[]}> when 'true' -> {'no',[],[]}
<_15> when 'true' -> apply 'match'/3 (_1,_6,_2) end
<'error'> when 'true' -> {'no',[],[]}
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
'to_atom'/1 = fun (_0) -> case call 'erl_scan':'string' (_0) of <{'ok',[{'atom',_3,A}|[]],_4}> when 'true' -> {'ok',A}
<_5> when 'true' -> 'error' end
'match'/3 = fun (_0,_1,_2) -> let <Len> = call 'string':'length' (_0) in let <_11> = letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[{H,A}|_5]> when 'true' -> let <_7> = apply 'flat_write'/1 (H) in (case call 'lists':'prefix' (_0,_7) of <'true'> when 'true' -> let <_9> = apply 'lc$^0'/1 (_5) in ([{_7,A}|_9]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_32> when 'true' -> (primop 'match_fail' ({'function_clause',_32})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1) in let <Matches> = call 'lists':'sort' (_11) in let <_17> = letrec 'lc$^1'/1 = fun (_15) -> case _15 of <[{N,_28}|_14]> when 'true' -> let <_16> = apply 'lc$^1'/1 (_14) in ([N|_16]-|['compiler_generated'] )
(<[_13|_14]> when 'true' -> apply 'lc$^1'/1 (_14)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_33> when 'true' -> (primop 'match_fail' ({'function_clause',_33})-|[{'function_name',{'lc$^1',1}}] )-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Matches) in case apply 'longest_common_head'/1 (_17) of <{'partial',[]}> when 'true' -> {'no',[],Matches}
<{'partial',Str}> when 'true' -> case call 'string':'slice' (Str,Len) of <[]> when 'true' -> {'yes',[],Matches}
<Remain> when 'true' -> {'yes',Remain,[]} end
<{'complete',Str}> when 'true' -> let <_20> = case <_2,Matches> of <([40]-|['compiler_generated'] ),([({_29,(0-|['compiler_generated'] )}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when call 'erlang':'=:=' (_29,Str) -> [40|[41]]
<_30,_31> when 'true' -> _2 end in let <_22> = call 'string':'slice' (Str,Len) in let <_23> = call 'erlang':'++' (_22,_20) in {'yes',_23,[]}
<'no'> when 'true' -> {'no',[],[]}
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end
'flat_write'/1 = fun (_0) -> case _0 of <T> when call 'erlang':'is_atom' (_0) -> let <_1> = call 'io_lib':'fwrite' ([126|[116|[119]]],[T|[]]) in call 'lists':'flatten' (_1)
<S> when 'true' -> S end
'format_matches'/1 = fun (_0) -> let <_1> = call 'lists':'sort' (_0) in case apply 'format_col'/2 (_1,[]) of <{S1,Dots}> when 'true' -> let <_11> = case Dots of <'true'> when 'true' -> let <_3> = apply 'vals'/1 (_0) in case apply 'longest_common_head'/1 (_3) of <{_14,Prefix}> when 'true' -> let <PrefixLen> = call 'string':'length' (Prefix) in case <> of <> when call 'erlang':'=<' (PrefixLen,3) -> S1
<> when 'true' -> let <LeadingDotsL> = apply 'leading_dots'/2 (_0,PrefixLen) in let <_7> = call 'lists':'sort' (LeadingDotsL) in case apply 'format_col'/2 (_7,[]) of <{S2,_15}> when 'true' -> S2
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<'false'> when 'true' -> S1
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end in [[10]|_11]
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'format_col'/2 = fun (_0,_1) -> case <_0,_1> of <[],_6> when 'true' -> []
<L,Acc> when 'true' -> let <_3> = apply 'field_width'/2 (L,79) in apply 'format_col'/6 (L,_3,0,Acc,79,'false') end
'format_col'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <X,Width,Len,Acc,LL,Dots> when try let <_6> = call 'erlang':'+' (Width,Len) in call 'erlang':'>' (_6,LL) of <Try> -> Try catch <T,R> -> 'false' -> apply 'format_col'/6 (X,Width,0,[[10]|Acc],LL,Dots)
<[A|T],Width,Len,Acc0,LL,Dots> when 'true' -> case apply 'format_val'/1 (A) of <{H0,R}> when 'true' -> let <_8> = call 'erlang':'length' (R) in let <Hmax> = call 'erlang':'-' (LL,_8) in let <_10> = call 'string':'length' (H0) in let <_30,_31> = case <> of <> when call 'erlang':'>' (_10,Hmax) -> let <_11> = call 'erlang':'-' (Hmax,3) in let <_12> = call 'io_lib':'format' ([126|[45|[42|[116|[115]]]]],[_11|[H0|[]]]) in let <_13> = call 'erlang':'++' (_12,[46|[46|[46]]]) in <_13,'true'>
<> when 'true' -> <H0,Dots> end in let <_17> = call 'erlang':'++' ((_30-|['compiler_generated'] ),R) in let <_18> = call 'io_lib':'format' ([126|[45|[42|[116|[115]]]]],[Width|[_17|[]]]) in let <Acc> = [_18|Acc0] in let <_20> = call 'erlang':'+' (Len,Width) in apply 'format_col'/6 (T,Width,_20,Acc,LL,(_31-|['compiler_generated'] ))
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<[],_28,_29,Acc,_X_LL,Dots> when 'true' -> let <_21> = call 'lists':'reverse' (Acc,[10]) in {_21,Dots}
(<_27,_26,_25,_24,_23,_22> when 'true' -> (primop 'match_fail' ({'function_clause',_27,_26,_25,_24,_23,_22})-|[{'function_name',{'format_col',6}}] )-|['compiler_generated'] ) end
'format_val'/1 = fun (_0) -> case _0 of <{H,I}> when call 'erlang':'is_integer' (I) -> let <_1> = call 'erlang':'integer_to_list' (I) in let <_2> = [47|_1] in {H,_2}
<{H,_4}> when 'true' -> {H,[]}
<H> when 'true' -> {H,[]} end
'field_width'/2 = fun (_0,_1) -> apply 'field_width'/3 (_0,0,_1)
'field_width'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[{H,_9}|T],W,LL> when 'true' -> case call 'string':'length' (H) of <L> when call 'erlang':'>' (L,W) -> apply 'field_width'/3 (T,L,LL)
<_10> when 'true' -> apply 'field_width'/3 (T,W,LL) end
<[H|T],W,LL> when 'true' -> case call 'string':'length' (H) of <L> when call 'erlang':'>' (L,W) -> apply 'field_width'/3 (T,L,LL)
<_11> when 'true' -> apply 'field_width'/3 (T,W,LL) end
<[],W,LL> when try let <_5> = call 'erlang':'-' (LL,3) in call 'erlang':'<' (W,_5) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (W,4)
<[],_12,LL> when 'true' -> LL
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'field_width',3}}] )-|['compiler_generated'] ) end
'vals'/1 = fun (_0) -> case _0 of <[]> when 'true' -> []
<[{S,_4}|L]> when 'true' -> let <_1> = apply 'vals'/1 (L) in [S|_1]
<[S|L]> when 'true' -> let <_2> = apply 'vals'/1 (L) in [S|_2]
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'vals',1}}] )-|['compiler_generated'] ) end
'leading_dots'/2 = fun (_0,_1) -> case <_0,_1> of <[],_X_Len> when 'true' -> []
<[{H,I}|L],Len> when 'true' -> let <_2> = call 'string':'slice' (H,Len) in let <_3> = [46|[46|[46|_2]]] in let <_4> = apply 'leading_dots'/2 (L,Len) in [{_3,I}|_4]
<[H|L],Len> when 'true' -> let <_5> = call 'string':'slice' (H,Len) in let <_6> = [46|[46|[46|_5]]] in let <_7> = apply 'leading_dots'/2 (L,Len) in [_6|_7]
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'leading_dots',2}}] )-|['compiler_generated'] ) end
'longest_common_head'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'no'
<LL> when 'true' -> apply 'longest_common_head'/2 (LL,[]) end
'longest_common_head'/2 = fun (_0,_1) -> case <_0,_1> of <[[]|_11],L> when 'true' -> let <_2> = call 'lists':'reverse' (L) in {'partial',_2}
<LL,L> when 'true' -> case apply 'same_head'/1 (LL) of <'true'> when 'true' -> case LL of <[[H|_12]|_13]> when 'true' -> let <LL1> = apply 'all_tails'/1 (LL) in case apply 'all_nil'/1 (LL1) of <'false'> when 'true' -> apply 'longest_common_head'/2 (LL1,[H|L])
<'true'> when 'true' -> let <_5> = call 'lists':'reverse' ([H|L]) in {'complete',_5}
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_7> = call 'lists':'reverse' (L) in {'partial',_7}
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end end
'same_head'/1 = fun (_0) -> case _0 of <[[H|_2]|T1]> when 'true' -> apply 'same_head'/2 (H,T1)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'same_head',1}}] )-|['compiler_generated'] ) end
'same_head'/2 = fun (_0,_1) -> case <_0,_1> of <H,[[_4|_5]|T]> when call 'erlang':'=:=' (_4,H) -> apply 'same_head'/2 (H,T)
<_6,[]> when 'true' -> 'true'
<_7,_8> when 'true' -> 'false' end
'all_tails'/1 = fun (_0) -> apply 'all_tails'/2 (_0,[])
'all_tails'/2 = fun (_0,_1) -> case <_0,_1> of <[[_4|T]|T1],L> when 'true' -> apply 'all_tails'/2 (T1,[T|L])
<[],L> when 'true' -> L
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'all_tails',2}}] )-|['compiler_generated'] ) end
'all_nil'/1 = fun (_0) -> case _0 of <[]> when 'true' -> 'true'
<[[]|Rest]> when 'true' -> apply 'all_nil'/1 (Rest)
<_2> when 'true' -> 'false' end
'over_white'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[32|Cs],Stack,N> when 'true' -> let <_3> = call 'erlang':'+' (N,1) in apply 'over_white'/3 (Cs,[32|Stack],_3)
<[9|Cs],Stack,N> when 'true' -> let <_4> = call 'erlang':'+' (N,1) in apply 'over_white'/3 (Cs,[9|Stack],_4)
<Cs,Stack,N> when call 'erlang':'is_list' (Cs) -> {Cs,Stack,N}
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'over_white',3}}] )-|['compiler_generated'] ) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('edlin_expand')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('edlin_expand',_0) end