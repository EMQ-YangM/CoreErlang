module 'proc_lib' ['format'/1,'format'/2,'format'/3,'hibernate'/3,'init_ack'/1,'init_ack'/2,'init_p'/3,'init_p'/5,'initial_call'/1,'module_info'/0,'module_info'/1,'report_cb'/2,'spawn'/1,'spawn'/2,'spawn'/3,'spawn'/4,'spawn_link'/1,'spawn_link'/2,'spawn_link'/3,'spawn_link'/4,'spawn_opt'/2,'spawn_opt'/3,'spawn_opt'/4,'spawn_opt'/5,'start'/3,'start'/4,'start'/5,'start_link'/3,'start_link'/4,'start_link'/5,'start_monitor'/3,'start_monitor'/4,'start_monitor'/5,'stop'/1,'stop'/3,'translate_initial_call'/1,'wake_up'/3] attributes [ 'file' = [{[115|[114|[99|[47|[112|[114|[111|[99|[95|[108|[105|[98|[46|[101|[114|[108]]]]]]]]]]]]]]]],1}]
, 'export_type' = [{'spawn_option',0}]
, 'export_type' = [{'start_spawn_option',0}]
, 'file' = [{[47|[85|[115|[101|[114|[115|[47|[102|[101|[110|[103|[108|[101|[101|[47|[72|[97|[109|[108|[101|[114|[47|[111|[116|[112|[45|[79|[84|[80|[45|[50|[51|[46|[48|[45|[114|[99|[49|[47|[108|[105|[98|[47|[115|[116|[100|[108|[105|[98|[47|[46|[46|[47|[107|[101|[114|[110|[101|[108|[47|[105|[110|[99|[108|[117|[100|[101|[47|[108|[111|[103|[103|[101|[114|[46|[104|[114|[108]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],1}]
, 'file' = [{[115|[114|[99|[47|[112|[114|[111|[99|[95|[108|[105|[98|[46|[101|[114|[108]]]]]]]]]]]]]]]],46}]
, 'type' = [{'start_spawn_option',{'type',49,'union',[{'atom',49,'link'}|[{'type',50,'tuple',[{'atom',50,'priority'}|[{'remote_type',50,[{'atom',50,'erlang'}|[{'atom',50,'priority_level'}|[[]]]]}]]}|[{'type',51,'tuple',[{'atom',51,'max_heap_size'}|[{'remote_type',51,[{'atom',51,'erlang'}|[{'atom',51,'max_heap_size'}|[[]]]]}]]}|[{'type',52,'tuple',[{'atom',52,'min_heap_size'}|[{'type',52,'non_neg_integer',[]}]]}|[{'type',53,'tuple',[{'atom',53,'min_bin_vheap_size'}|[{'type',53,'non_neg_integer',[]}]]}|[{'type',54,'tuple',[{'atom',54,'fullsweep_after'}|[{'type',54,'non_neg_integer',[]}]]}|[{'type',55,'tuple',[{'atom',55,'message_queue_data'}|[{'remote_type',55,[{'atom',55,'erlang'}|[{'atom',55,'message_queue_data'}|[[]]]]}]]}]]]]]]]},[]}]
, 'type' = [{'spawn_option',{'remote_type',57,[{'atom',57,'erlang'}|[{'atom',57,'spawn_opt_option'}|[[]]]]},[]}]
, 'type' = [{'dict_or_pid',{'type',59,'union',[{'type',59,'pid',[]}|[{'ann_type',60,[{'var',60,'ProcInfo'}|[{'type',60,'list',[{'var',60,'_'}]}]]}|[{'type',61,'tuple',[{'ann_type',61,[{'var',61,'X'}|[{'type',61,'integer',[]}]]}|[{'ann_type',61,[{'var',61,'Y'}|[{'type',61,'integer',[]}]]}|[{'ann_type',61,[{'var',61,'Z'}|[{'type',61,'integer',[]}]]}]]]}]]]},[]}]
, 'spec' = [{{'spawn',1},[{'type',73,'bounded_fun',[{'type',73,'fun',[{'type',73,'product',[{'var',73,'Fun'}]}|[{'type',73,'pid',[]}]]}|[[{'type',74,'constraint',[{'atom',74,'is_subtype'}|[[{'var',74,'Fun'}|[{'type',74,'function',[]}]]]]}]]]}]}]
, 'spec' = [{{'spawn',3},[{'type',81,'bounded_fun',[{'type',81,'fun',[{'type',81,'product',[{'var',81,'Module'}|[{'var',81,'Function'}|[{'var',81,'Args'}]]]}|[{'type',81,'pid',[]}]]}|[[{'type',82,'constraint',[{'atom',82,'is_subtype'}|[[{'var',82,'Module'}|[{'type',82,'module',[]}]]]]}|[{'type',83,'constraint',[{'atom',83,'is_subtype'}|[[{'var',83,'Function'}|[{'type',83,'atom',[]}]]]]}|[{'type',84,'constraint',[{'atom',84,'is_subtype'}|[[{'var',84,'Args'}|[{'type',84,'list',[{'type',84,'term',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'spawn_link',1},[{'type',91,'bounded_fun',[{'type',91,'fun',[{'type',91,'product',[{'var',91,'Fun'}]}|[{'type',91,'pid',[]}]]}|[[{'type',92,'constraint',[{'atom',92,'is_subtype'}|[[{'var',92,'Fun'}|[{'type',92,'function',[]}]]]]}]]]}]}]
, 'spec' = [{{'spawn_link',3},[{'type',99,'bounded_fun',[{'type',99,'fun',[{'type',99,'product',[{'var',99,'Module'}|[{'var',99,'Function'}|[{'var',99,'Args'}]]]}|[{'type',99,'pid',[]}]]}|[[{'type',100,'constraint',[{'atom',100,'is_subtype'}|[[{'var',100,'Module'}|[{'type',100,'module',[]}]]]]}|[{'type',101,'constraint',[{'atom',101,'is_subtype'}|[[{'var',101,'Function'}|[{'type',101,'atom',[]}]]]]}|[{'type',102,'constraint',[{'atom',102,'is_subtype'}|[[{'var',102,'Args'}|[{'type',102,'list',[{'type',102,'term',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'spawn',2},[{'type',109,'bounded_fun',[{'type',109,'fun',[{'type',109,'product',[{'var',109,'Node'}|[{'var',109,'Fun'}]]}|[{'type',109,'pid',[]}]]}|[[{'type',110,'constraint',[{'atom',110,'is_subtype'}|[[{'var',110,'Node'}|[{'type',110,'node',[]}]]]]}|[{'type',111,'constraint',[{'atom',111,'is_subtype'}|[[{'var',111,'Fun'}|[{'type',111,'function',[]}]]]]}]]]]}]}]
, 'spec' = [{{'spawn',4},[{'type',118,'bounded_fun',[{'type',118,'fun',[{'type',118,'product',[{'var',118,'Node'}|[{'var',118,'Module'}|[{'var',118,'Function'}|[{'var',118,'Args'}]]]]}|[{'type',118,'pid',[]}]]}|[[{'type',119,'constraint',[{'atom',119,'is_subtype'}|[[{'var',119,'Node'}|[{'type',119,'node',[]}]]]]}|[{'type',120,'constraint',[{'atom',120,'is_subtype'}|[[{'var',120,'Module'}|[{'type',120,'module',[]}]]]]}|[{'type',121,'constraint',[{'atom',121,'is_subtype'}|[[{'var',121,'Function'}|[{'type',121,'atom',[]}]]]]}|[{'type',122,'constraint',[{'atom',122,'is_subtype'}|[[{'var',122,'Args'}|[{'type',122,'list',[{'type',122,'term',[]}]}]]]]}]]]]]]}]}]
, 'spec' = [{{'spawn_link',2},[{'type',129,'bounded_fun',[{'type',129,'fun',[{'type',129,'product',[{'var',129,'Node'}|[{'var',129,'Fun'}]]}|[{'type',129,'pid',[]}]]}|[[{'type',130,'constraint',[{'atom',130,'is_subtype'}|[[{'var',130,'Node'}|[{'type',130,'node',[]}]]]]}|[{'type',131,'constraint',[{'atom',131,'is_subtype'}|[[{'var',131,'Fun'}|[{'type',131,'function',[]}]]]]}]]]]}]}]
, 'spec' = [{{'spawn_link',4},[{'type',138,'bounded_fun',[{'type',138,'fun',[{'type',138,'product',[{'var',138,'Node'}|[{'var',138,'Module'}|[{'var',138,'Function'}|[{'var',138,'Args'}]]]]}|[{'type',138,'pid',[]}]]}|[[{'type',139,'constraint',[{'atom',139,'is_subtype'}|[[{'var',139,'Node'}|[{'type',139,'node',[]}]]]]}|[{'type',140,'constraint',[{'atom',140,'is_subtype'}|[[{'var',140,'Module'}|[{'type',140,'module',[]}]]]]}|[{'type',141,'constraint',[{'atom',141,'is_subtype'}|[[{'var',141,'Function'}|[{'type',141,'atom',[]}]]]]}|[{'type',142,'constraint',[{'atom',142,'is_subtype'}|[[{'var',142,'Args'}|[{'type',142,'list',[{'type',142,'term',[]}]}]]]]}]]]]]]}]}]
, 'spec' = [{{'spawn_opt',2},[{'type',149,'bounded_fun',[{'type',149,'fun',[{'type',149,'product',[{'var',149,'Fun'}|[{'var',149,'SpawnOpts'}]]}|[{'type',149,'union',[{'type',149,'pid',[]}|[{'type',149,'tuple',[{'type',149,'pid',[]}|[{'type',149,'reference',[]}]]}]]}]]}|[[{'type',150,'constraint',[{'atom',150,'is_subtype'}|[[{'var',150,'Fun'}|[{'type',150,'function',[]}]]]]}|[{'type',151,'constraint',[{'atom',151,'is_subtype'}|[[{'var',151,'SpawnOpts'}|[{'type',151,'list',[{'user_type',151,'spawn_option',[]}]}]]]]}]]]]}]}]
, 'spec' = [{{'spawn_opt',3},[{'type',158,'bounded_fun',[{'type',158,'fun',[{'type',158,'product',[{'var',158,'Node'}|[{'var',158,'Function'}|[{'var',158,'SpawnOpts'}]]]}|[{'type',158,'union',[{'type',158,'pid',[]}|[{'type',158,'tuple',[{'type',158,'pid',[]}|[{'type',158,'reference',[]}]]}]]}]]}|[[{'type',159,'constraint',[{'atom',159,'is_subtype'}|[[{'var',159,'Node'}|[{'type',159,'node',[]}]]]]}|[{'type',160,'constraint',[{'atom',160,'is_subtype'}|[[{'var',160,'Function'}|[{'type',160,'function',[]}]]]]}|[{'type',161,'constraint',[{'atom',161,'is_subtype'}|[[{'var',161,'SpawnOpts'}|[{'type',161,'list',[{'user_type',161,'spawn_option',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'spawn_opt',4},[{'type',168,'bounded_fun',[{'type',168,'fun',[{'type',168,'product',[{'var',168,'Module'}|[{'var',168,'Function'}|[{'var',168,'Args'}|[{'var',168,'SpawnOpts'}]]]]}|[{'type',168,'union',[{'type',168,'pid',[]}|[{'type',168,'tuple',[{'type',168,'pid',[]}|[{'type',168,'reference',[]}]]}]]}]]}|[[{'type',169,'constraint',[{'atom',169,'is_subtype'}|[[{'var',169,'Module'}|[{'type',169,'module',[]}]]]]}|[{'type',170,'constraint',[{'atom',170,'is_subtype'}|[[{'var',170,'Function'}|[{'type',170,'atom',[]}]]]]}|[{'type',171,'constraint',[{'atom',171,'is_subtype'}|[[{'var',171,'Args'}|[{'type',171,'list',[{'type',171,'term',[]}]}]]]]}|[{'type',172,'constraint',[{'atom',172,'is_subtype'}|[[{'var',172,'SpawnOpts'}|[{'type',172,'list',[{'user_type',172,'spawn_option',[]}]}]]]]}]]]]]]}]}]
, 'spec' = [{{'spawn_opt',5},[{'type',179,'bounded_fun',[{'type',179,'fun',[{'type',179,'product',[{'var',179,'Node'}|[{'var',179,'Module'}|[{'var',179,'Function'}|[{'var',179,'Args'}|[{'var',179,'SpawnOpts'}]]]]]}|[{'type',179,'union',[{'type',179,'pid',[]}|[{'type',179,'tuple',[{'type',179,'pid',[]}|[{'type',179,'reference',[]}]]}]]}]]}|[[{'type',180,'constraint',[{'atom',180,'is_subtype'}|[[{'var',180,'Node'}|[{'type',180,'node',[]}]]]]}|[{'type',181,'constraint',[{'atom',181,'is_subtype'}|[[{'var',181,'Module'}|[{'type',181,'module',[]}]]]]}|[{'type',182,'constraint',[{'atom',182,'is_subtype'}|[[{'var',182,'Function'}|[{'type',182,'atom',[]}]]]]}|[{'type',183,'constraint',[{'atom',183,'is_subtype'}|[[{'var',183,'Args'}|[{'type',183,'list',[{'type',183,'term',[]}]}]]]]}|[{'type',184,'constraint',[{'atom',184,'is_subtype'}|[[{'var',184,'SpawnOpts'}|[{'type',184,'list',[{'user_type',184,'spawn_option',[]}]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'hibernate',3},[{'type',196,'bounded_fun',[{'type',196,'fun',[{'type',196,'product',[{'var',196,'Module'}|[{'var',196,'Function'}|[{'var',196,'Args'}]]]}|[{'type',196,'no_return',[]}]]}|[[{'type',197,'constraint',[{'atom',197,'is_subtype'}|[[{'var',197,'Module'}|[{'type',197,'module',[]}]]]]}|[{'type',198,'constraint',[{'atom',198,'is_subtype'}|[[{'var',198,'Function'}|[{'type',198,'atom',[]}]]]]}|[{'type',199,'constraint',[{'atom',199,'is_subtype'}|[[{'var',199,'Args'}|[{'type',199,'list',[{'type',199,'term',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'init_p',3},[{'type',204,'fun',[{'type',204,'product',[{'type',204,'pid',[]}|[{'type',204,'list',[{'type',204,'pid',[]}]}|[{'type',204,'function',[]}]]]}|[{'type',204,'term',[]}]]}]}]
, 'spec' = [{{'init_p',5},[{'type',217,'fun',[{'type',217,'product',[{'type',217,'pid',[]}|[{'type',217,'list',[{'type',217,'pid',[]}]}|[{'type',217,'atom',[]}|[{'type',217,'atom',[]}|[{'type',217,'list',[{'type',217,'term',[]}]}]]]]]}|[{'type',217,'term',[]}]]}]}]
, 'spec' = [{{'wake_up',3},[{'type',232,'fun',[{'type',232,'product',[{'type',232,'atom',[]}|[{'type',232,'atom',[]}|[{'type',232,'list',[{'type',232,'term',[]}]}]]]}|[{'type',232,'term',[]}]]}]}]
, 'spec' = [{{'start',3},[{'type',262,'bounded_fun',[{'type',262,'fun',[{'type',262,'product',[{'var',262,'Module'}|[{'var',262,'Function'}|[{'var',262,'Args'}]]]}|[{'var',262,'Ret'}]]}|[[{'type',263,'constraint',[{'atom',263,'is_subtype'}|[[{'var',263,'Module'}|[{'type',263,'module',[]}]]]]}|[{'type',264,'constraint',[{'atom',264,'is_subtype'}|[[{'var',264,'Function'}|[{'type',264,'atom',[]}]]]]}|[{'type',265,'constraint',[{'atom',265,'is_subtype'}|[[{'var',265,'Args'}|[{'type',265,'list',[{'type',265,'term',[]}]}]]]]}|[{'type',266,'constraint',[{'atom',266,'is_subtype'}|[[{'var',266,'Ret'}|[{'type',266,'union',[{'type',266,'term',[]}|[{'type',266,'tuple',[{'atom',266,'error'}|[{'ann_type',266,[{'var',266,'Reason'}|[{'type',266,'term',[]}]]}]]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'start',4},[{'type',271,'bounded_fun',[{'type',271,'fun',[{'type',271,'product',[{'var',271,'Module'}|[{'var',271,'Function'}|[{'var',271,'Args'}|[{'var',271,'Time'}]]]]}|[{'var',271,'Ret'}]]}|[[{'type',272,'constraint',[{'atom',272,'is_subtype'}|[[{'var',272,'Module'}|[{'type',272,'module',[]}]]]]}|[{'type',273,'constraint',[{'atom',273,'is_subtype'}|[[{'var',273,'Function'}|[{'type',273,'atom',[]}]]]]}|[{'type',274,'constraint',[{'atom',274,'is_subtype'}|[[{'var',274,'Args'}|[{'type',274,'list',[{'type',274,'term',[]}]}]]]]}|[{'type',275,'constraint',[{'atom',275,'is_subtype'}|[[{'var',275,'Time'}|[{'type',275,'timeout',[]}]]]]}|[{'type',276,'constraint',[{'atom',276,'is_subtype'}|[[{'var',276,'Ret'}|[{'type',276,'union',[{'type',276,'term',[]}|[{'type',276,'tuple',[{'atom',276,'error'}|[{'ann_type',276,[{'var',276,'Reason'}|[{'type',276,'term',[]}]]}]]}]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'start',5},[{'type',281,'bounded_fun',[{'type',281,'fun',[{'type',281,'product',[{'var',281,'Module'}|[{'var',281,'Function'}|[{'var',281,'Args'}|[{'var',281,'Time'}|[{'var',281,'SpawnOpts'}]]]]]}|[{'var',281,'Ret'}]]}|[[{'type',282,'constraint',[{'atom',282,'is_subtype'}|[[{'var',282,'Module'}|[{'type',282,'module',[]}]]]]}|[{'type',283,'constraint',[{'atom',283,'is_subtype'}|[[{'var',283,'Function'}|[{'type',283,'atom',[]}]]]]}|[{'type',284,'constraint',[{'atom',284,'is_subtype'}|[[{'var',284,'Args'}|[{'type',284,'list',[{'type',284,'term',[]}]}]]]]}|[{'type',285,'constraint',[{'atom',285,'is_subtype'}|[[{'var',285,'Time'}|[{'type',285,'timeout',[]}]]]]}|[{'type',286,'constraint',[{'atom',286,'is_subtype'}|[[{'var',286,'SpawnOpts'}|[{'type',286,'list',[{'user_type',286,'start_spawn_option',[]}]}]]]]}|[{'type',287,'constraint',[{'atom',287,'is_subtype'}|[[{'var',287,'Ret'}|[{'type',287,'union',[{'type',287,'term',[]}|[{'type',287,'tuple',[{'atom',287,'error'}|[{'ann_type',287,[{'var',287,'Reason'}|[{'type',287,'term',[]}]]}]]}]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'start_link',3},[{'type',306,'bounded_fun',[{'type',306,'fun',[{'type',306,'product',[{'var',306,'Module'}|[{'var',306,'Function'}|[{'var',306,'Args'}]]]}|[{'var',306,'Ret'}]]}|[[{'type',307,'constraint',[{'atom',307,'is_subtype'}|[[{'var',307,'Module'}|[{'type',307,'module',[]}]]]]}|[{'type',308,'constraint',[{'atom',308,'is_subtype'}|[[{'var',308,'Function'}|[{'type',308,'atom',[]}]]]]}|[{'type',309,'constraint',[{'atom',309,'is_subtype'}|[[{'var',309,'Args'}|[{'type',309,'list',[{'type',309,'term',[]}]}]]]]}|[{'type',310,'constraint',[{'atom',310,'is_subtype'}|[[{'var',310,'Ret'}|[{'type',310,'union',[{'type',310,'term',[]}|[{'type',310,'tuple',[{'atom',310,'error'}|[{'ann_type',310,[{'var',310,'Reason'}|[{'type',310,'term',[]}]]}]]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'start_link',4},[{'type',315,'bounded_fun',[{'type',315,'fun',[{'type',315,'product',[{'var',315,'Module'}|[{'var',315,'Function'}|[{'var',315,'Args'}|[{'var',315,'Time'}]]]]}|[{'var',315,'Ret'}]]}|[[{'type',316,'constraint',[{'atom',316,'is_subtype'}|[[{'var',316,'Module'}|[{'type',316,'module',[]}]]]]}|[{'type',317,'constraint',[{'atom',317,'is_subtype'}|[[{'var',317,'Function'}|[{'type',317,'atom',[]}]]]]}|[{'type',318,'constraint',[{'atom',318,'is_subtype'}|[[{'var',318,'Args'}|[{'type',318,'list',[{'type',318,'term',[]}]}]]]]}|[{'type',319,'constraint',[{'atom',319,'is_subtype'}|[[{'var',319,'Time'}|[{'type',319,'timeout',[]}]]]]}|[{'type',320,'constraint',[{'atom',320,'is_subtype'}|[[{'var',320,'Ret'}|[{'type',320,'union',[{'type',320,'term',[]}|[{'type',320,'tuple',[{'atom',320,'error'}|[{'ann_type',320,[{'var',320,'Reason'}|[{'type',320,'term',[]}]]}]]}]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'start_link',5},[{'type',325,'bounded_fun',[{'type',325,'fun',[{'type',325,'product',[{'var',325,'Module'}|[{'var',325,'Function'}|[{'var',325,'Args'}|[{'var',325,'Time'}|[{'var',325,'SpawnOpts'}]]]]]}|[{'var',325,'Ret'}]]}|[[{'type',326,'constraint',[{'atom',326,'is_subtype'}|[[{'var',326,'Module'}|[{'type',326,'module',[]}]]]]}|[{'type',327,'constraint',[{'atom',327,'is_subtype'}|[[{'var',327,'Function'}|[{'type',327,'atom',[]}]]]]}|[{'type',328,'constraint',[{'atom',328,'is_subtype'}|[[{'var',328,'Args'}|[{'type',328,'list',[{'type',328,'term',[]}]}]]]]}|[{'type',329,'constraint',[{'atom',329,'is_subtype'}|[[{'var',329,'Time'}|[{'type',329,'timeout',[]}]]]]}|[{'type',330,'constraint',[{'atom',330,'is_subtype'}|[[{'var',330,'SpawnOpts'}|[{'type',330,'list',[{'user_type',330,'start_spawn_option',[]}]}]]]]}|[{'type',331,'constraint',[{'atom',331,'is_subtype'}|[[{'var',331,'Ret'}|[{'type',331,'union',[{'type',331,'term',[]}|[{'type',331,'tuple',[{'atom',331,'error'}|[{'ann_type',331,[{'var',331,'Reason'}|[{'type',331,'term',[]}]]}]]}]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'start_monitor',3},[{'type',348,'bounded_fun',[{'type',348,'fun',[{'type',348,'product',[{'var',348,'Module'}|[{'var',348,'Function'}|[{'var',348,'Args'}]]]}|[{'type',348,'tuple',[{'var',348,'Ret'}|[{'var',348,'Mon'}]]}]]}|[[{'type',349,'constraint',[{'atom',349,'is_subtype'}|[[{'var',349,'Module'}|[{'type',349,'module',[]}]]]]}|[{'type',350,'constraint',[{'atom',350,'is_subtype'}|[[{'var',350,'Function'}|[{'type',350,'atom',[]}]]]]}|[{'type',351,'constraint',[{'atom',351,'is_subtype'}|[[{'var',351,'Args'}|[{'type',351,'list',[{'type',351,'term',[]}]}]]]]}|[{'type',352,'constraint',[{'atom',352,'is_subtype'}|[[{'var',352,'Mon'}|[{'type',352,'reference',[]}]]]]}|[{'type',353,'constraint',[{'atom',353,'is_subtype'}|[[{'var',353,'Ret'}|[{'type',353,'union',[{'type',353,'term',[]}|[{'type',353,'tuple',[{'atom',353,'error'}|[{'ann_type',353,[{'var',353,'Reason'}|[{'type',353,'term',[]}]]}]]}]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'start_monitor',4},[{'type',358,'bounded_fun',[{'type',358,'fun',[{'type',358,'product',[{'var',358,'Module'}|[{'var',358,'Function'}|[{'var',358,'Args'}|[{'var',358,'Time'}]]]]}|[{'type',358,'tuple',[{'var',358,'Ret'}|[{'var',358,'Mon'}]]}]]}|[[{'type',359,'constraint',[{'atom',359,'is_subtype'}|[[{'var',359,'Module'}|[{'type',359,'module',[]}]]]]}|[{'type',360,'constraint',[{'atom',360,'is_subtype'}|[[{'var',360,'Function'}|[{'type',360,'atom',[]}]]]]}|[{'type',361,'constraint',[{'atom',361,'is_subtype'}|[[{'var',361,'Args'}|[{'type',361,'list',[{'type',361,'term',[]}]}]]]]}|[{'type',362,'constraint',[{'atom',362,'is_subtype'}|[[{'var',362,'Time'}|[{'type',362,'timeout',[]}]]]]}|[{'type',363,'constraint',[{'atom',363,'is_subtype'}|[[{'var',363,'Mon'}|[{'type',363,'reference',[]}]]]]}|[{'type',364,'constraint',[{'atom',364,'is_subtype'}|[[{'var',364,'Ret'}|[{'type',364,'union',[{'type',364,'term',[]}|[{'type',364,'tuple',[{'atom',364,'error'}|[{'ann_type',364,[{'var',364,'Reason'}|[{'type',364,'term',[]}]]}]]}]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'start_monitor',5},[{'type',369,'bounded_fun',[{'type',369,'fun',[{'type',369,'product',[{'var',369,'Module'}|[{'var',369,'Function'}|[{'var',369,'Args'}|[{'var',369,'Time'}|[{'var',369,'SpawnOpts'}]]]]]}|[{'type',369,'tuple',[{'var',369,'Ret'}|[{'var',369,'Mon'}]]}]]}|[[{'type',370,'constraint',[{'atom',370,'is_subtype'}|[[{'var',370,'Module'}|[{'type',370,'module',[]}]]]]}|[{'type',371,'constraint',[{'atom',371,'is_subtype'}|[[{'var',371,'Function'}|[{'type',371,'atom',[]}]]]]}|[{'type',372,'constraint',[{'atom',372,'is_subtype'}|[[{'var',372,'Args'}|[{'type',372,'list',[{'type',372,'term',[]}]}]]]]}|[{'type',373,'constraint',[{'atom',373,'is_subtype'}|[[{'var',373,'Time'}|[{'type',373,'timeout',[]}]]]]}|[{'type',374,'constraint',[{'atom',374,'is_subtype'}|[[{'var',374,'SpawnOpts'}|[{'type',374,'list',[{'user_type',374,'start_spawn_option',[]}]}]]]]}|[{'type',375,'constraint',[{'atom',375,'is_subtype'}|[[{'var',375,'Mon'}|[{'type',375,'reference',[]}]]]]}|[{'type',376,'constraint',[{'atom',376,'is_subtype'}|[[{'var',376,'Ret'}|[{'type',376,'union',[{'type',376,'term',[]}|[{'type',376,'tuple',[{'atom',376,'error'}|[{'ann_type',376,[{'var',376,'Reason'}|[{'type',376,'term',[]}]]}]]}]]}]]]]}]]]]]]]]]}]}]
, 'spec' = [{{'kill_flush',1},[{'type',397,'bounded_fun',[{'type',397,'fun',[{'type',397,'product',[{'var',397,'Pid'}]}|[{'atom',397,'ok'}]]}|[[{'type',398,'constraint',[{'atom',398,'is_subtype'}|[[{'var',398,'Pid'}|[{'type',398,'pid',[]}]]]]}]]]}]}]
, 'spec' = [{{'init_ack',2},[{'type',406,'bounded_fun',[{'type',406,'fun',[{'type',406,'product',[{'var',406,'Parent'}|[{'var',406,'Ret'}]]}|[{'atom',406,'ok'}]]}|[[{'type',407,'constraint',[{'atom',407,'is_subtype'}|[[{'var',407,'Parent'}|[{'type',407,'pid',[]}]]]]}|[{'type',408,'constraint',[{'atom',408,'is_subtype'}|[[{'var',408,'Ret'}|[{'type',408,'term',[]}]]]]}]]]]}]}]
, 'spec' = [{{'init_ack',1},[{'type',414,'bounded_fun',[{'type',414,'fun',[{'type',414,'product',[{'var',414,'Ret'}]}|[{'atom',414,'ok'}]]}|[[{'type',415,'constraint',[{'atom',415,'is_subtype'}|[[{'var',415,'Ret'}|[{'type',415,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'initial_call',1},[{'type',425,'bounded_fun',[{'type',425,'fun',[{'type',425,'product',[{'var',425,'Process'}]}|[{'type',425,'union',[{'type',425,'tuple',[{'var',425,'Module'}|[{'var',425,'Function'}|[{'var',425,'Args'}]]]}|[{'atom',425,'false'}]]}]]}|[[{'type',426,'constraint',[{'atom',426,'is_subtype'}|[[{'var',426,'Process'}|[{'user_type',426,'dict_or_pid',[]}]]]]}|[{'type',427,'constraint',[{'atom',427,'is_subtype'}|[[{'var',427,'Module'}|[{'type',427,'module',[]}]]]]}|[{'type',428,'constraint',[{'atom',428,'is_subtype'}|[[{'var',428,'Function'}|[{'type',428,'atom',[]}]]]]}|[{'type',429,'constraint',[{'atom',429,'is_subtype'}|[[{'var',429,'Args'}|[{'type',429,'list',[{'type',429,'atom',[]}]}]]]]}]]]]]]}]}]
, 'spec' = [{{'translate_initial_call',1},[{'type',452,'bounded_fun',[{'type',452,'fun',[{'type',452,'product',[{'var',452,'Process'}]}|[{'type',452,'tuple',[{'var',452,'Module'}|[{'var',452,'Function'}|[{'var',452,'Arity'}]]]}]]}|[[{'type',453,'constraint',[{'atom',453,'is_subtype'}|[[{'var',453,'Process'}|[{'user_type',453,'dict_or_pid',[]}]]]]}|[{'type',454,'constraint',[{'atom',454,'is_subtype'}|[[{'var',454,'Module'}|[{'type',454,'module',[]}]]]]}|[{'type',455,'constraint',[{'atom',455,'is_subtype'}|[[{'var',455,'Function'}|[{'type',455,'atom',[]}]]]]}|[{'type',456,'constraint',[{'atom',456,'is_subtype'}|[[{'var',456,'Arity'}|[{'type',456,'byte',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'get_ancestors',1},[{'type',555,'fun',[{'type',555,'product',[{'type',555,'pid',[]}]}|[{'type',555,'tuple',[{'atom',555,'ancestors'}|[{'type',555,'list',[{'type',555,'pid',[]}]}]]}]]}]}]
, 'spec' = [{{'neighbours',1},[{'type',681,'fun',[{'type',681,'product',[{'type',681,'pid',[]}]}|[{'type',681,'list',[{'type',681,'pid',[]}]}]]}]}]
, 'spec' = [{{'adjacents',1},[{'type',708,'fun',[{'type',708,'product',[{'type',708,'pid',[]}]}|[{'type',708,'list',[{'type',708,'pid',[]}]}]]}]}]
, 'spec' = [{{'get_ancestors',0},[{'type',744,'fun',[{'type',744,'product',[]}|[{'type',744,'list',[{'type',744,'pid',[]}]}]]}]}]
, 'spec' = [{{'report_cb',2},[{'type',770,'bounded_fun',[{'type',770,'fun',[{'type',770,'product',[{'var',770,'CrashReport'}|[{'var',770,'FormatOpts'}]]}|[{'remote_type',770,[{'atom',770,'unicode'}|[{'atom',770,'chardata'}|[[]]]]}]]}|[[{'type',771,'constraint',[{'atom',771,'is_subtype'}|[[{'var',771,'CrashReport'}|[{'type',771,'map',[{'type',771,'map_field_assoc',[{'atom',771,'label'}|[{'type',771,'tuple',[{'atom',771,'proc_lib'}|[{'atom',771,'crash'}]]}]]}|[{'type',772,'map_field_assoc',[{'atom',772,'report'}|[{'type',772,'list',[{'type',772,'term',[]}]}]]}]]}]]]]}|[{'type',773,'constraint',[{'atom',773,'is_subtype'}|[[{'var',773,'FormatOpts'}|[{'remote_type',773,[{'atom',773,'logger'}|[{'atom',773,'report_cb_config'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'format',1},[{'type',781,'bounded_fun',[{'type',781,'fun',[{'type',781,'product',[{'var',781,'CrashReport'}]}|[{'type',781,'string',[]}]]}|[[{'type',782,'constraint',[{'atom',782,'is_subtype'}|[[{'var',782,'CrashReport'}|[{'type',782,'list',[{'type',782,'term',[]}]}]]]]}]]]}]}]
, 'spec' = [{{'format',2},[{'type',786,'bounded_fun',[{'type',786,'fun',[{'type',786,'product',[{'var',786,'CrashReport'}|[{'var',786,'Encoding'}]]}|[{'type',786,'string',[]}]]}|[[{'type',787,'constraint',[{'atom',787,'is_subtype'}|[[{'var',787,'CrashReport'}|[{'type',787,'list',[{'type',787,'term',[]}]}]]]]}|[{'type',788,'constraint',[{'atom',788,'is_subtype'}|[[{'var',788,'Encoding'}|[{'type',788,'union',[{'atom',788,'latin1'}|[{'atom',788,'unicode'}|[{'atom',788,'utf8'}]]]}]]]]}]]]]}]}]
, 'spec' = [{{'format',3},[{'type',793,'bounded_fun',[{'type',793,'fun',[{'type',793,'product',[{'var',793,'CrashReport'}|[{'var',793,'Encoding'}|[{'var',793,'Depth'}]]]}|[{'type',793,'string',[]}]]}|[[{'type',794,'constraint',[{'atom',794,'is_subtype'}|[[{'var',794,'CrashReport'}|[{'type',794,'list',[{'type',794,'term',[]}]}]]]]}|[{'type',795,'constraint',[{'atom',795,'is_subtype'}|[[{'var',795,'Encoding'}|[{'type',795,'union',[{'atom',795,'latin1'}|[{'atom',795,'unicode'}|[{'atom',795,'utf8'}]]]}]]]]}|[{'type',796,'constraint',[{'atom',796,'is_subtype'}|[[{'var',796,'Depth'}|[{'type',796,'union',[{'atom',796,'unlimited'}|[{'type',796,'pos_integer',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'stop',1},[{'type',1053,'bounded_fun',[{'type',1053,'fun',[{'type',1053,'product',[{'var',1053,'Process'}]}|[{'atom',1053,'ok'}]]}|[[{'type',1054,'constraint',[{'atom',1054,'is_subtype'}|[[{'var',1054,'Process'}|[{'type',1054,'union',[{'type',1054,'pid',[]}|[{'var',1054,'RegName'}|[{'type',1054,'tuple',[{'var',1054,'RegName'}|[{'type',1054,'node',[]}]]}]]]}]]]]}|[{'type',1055,'constraint',[{'atom',1055,'is_subtype'}|[[{'var',1055,'RegName'}|[{'type',1055,'atom',[]}]]]]}]]]]}]}]
, 'spec' = [{{'stop',3},[{'type',1059,'bounded_fun',[{'type',1059,'fun',[{'type',1059,'product',[{'var',1059,'Process'}|[{'var',1059,'Reason'}|[{'var',1059,'Timeout'}]]]}|[{'atom',1059,'ok'}]]}|[[{'type',1060,'constraint',[{'atom',1060,'is_subtype'}|[[{'var',1060,'Process'}|[{'type',1060,'union',[{'type',1060,'pid',[]}|[{'var',1060,'RegName'}|[{'type',1060,'tuple',[{'var',1060,'RegName'}|[{'type',1060,'node',[]}]]}]]]}]]]]}|[{'type',1061,'constraint',[{'atom',1061,'is_subtype'}|[[{'var',1061,'RegName'}|[{'type',1061,'atom',[]}]]]]}|[{'type',1062,'constraint',[{'atom',1062,'is_subtype'}|[[{'var',1062,'Reason'}|[{'type',1062,'term',[]}]]]]}|[{'type',1063,'constraint',[{'atom',1063,'is_subtype'}|[[{'var',1063,'Timeout'}|[{'type',1063,'timeout',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'do_stop',2},[{'type',1081,'bounded_fun',[{'type',1081,'fun',[{'type',1081,'product',[{'var',1081,'Process'}|[{'var',1081,'Reason'}]]}|[{'var',1081,'Fun'}]]}|[[{'type',1082,'constraint',[{'atom',1082,'is_subtype'}|[[{'var',1082,'Process'}|[{'type',1082,'union',[{'type',1082,'pid',[]}|[{'var',1082,'RegName'}|[{'type',1082,'tuple',[{'var',1082,'RegName'}|[{'type',1082,'node',[]}]]}]]]}]]]]}|[{'type',1083,'constraint',[{'atom',1083,'is_subtype'}|[[{'var',1083,'RegName'}|[{'type',1083,'atom',[]}]]]]}|[{'type',1084,'constraint',[{'atom',1084,'is_subtype'}|[[{'var',1084,'Reason'}|[{'type',1084,'term',[]}]]]]}|[{'type',1085,'constraint',[{'atom',1085,'is_subtype'}|[[{'var',1085,'Fun'}|[{'type',1085,'fun',[{'type',1085,'product',[]}|[{'type',1085,'no_return',[]}]]}]]]]}]]]]]]}]}] ] 'spawn'/1 = fun (_0) -> case _0 of <F> when call 'erlang':'is_function' (_0) -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn' ('proc_lib','init_p',[Parent|[Ancestors|[F|[]]]])
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'spawn',1}}] )-|['compiler_generated'] ) end
'spawn'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <M,F,A> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_list' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn' ('proc_lib','init_p',[Parent|[Ancestors|[M|[F|[A|[]]]]]])
(<_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9})-|[{'function_name',{'spawn',3}}] )-|['compiler_generated'] ) end
'spawn_link'/1 = fun (_0) -> case _0 of <F> when call 'erlang':'is_function' (_0) -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_link' ('proc_lib','init_p',[Parent|[Ancestors|[F|[]]]])
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'spawn_link',1}}] )-|['compiler_generated'] ) end
'spawn_link'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <M,F,A> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_list' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_link' ('proc_lib','init_p',[Parent|[Ancestors|[M|[F|[A|[]]]]]])
(<_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9})-|[{'function_name',{'spawn_link',3}}] )-|['compiler_generated'] ) end
'spawn'/2 = fun (_0,_1) -> case <_0,_1> of <Node,F> when call 'erlang':'is_function' (F) -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn' (Node,'proc_lib','init_p',[Parent|[Ancestors|[F|[]]]])
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'spawn',2}}] )-|['compiler_generated'] ) end
'spawn'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Node,M,F,A> when try let <_4> = call 'erlang':'is_atom' (M) in let <_5> = call 'erlang':'is_atom' (F) in let <_6> = call 'erlang':'is_list' (A) in let <_7> = call 'erlang':'and' (_5,_6) in call 'erlang':'and' (_4,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn' (Node,'proc_lib','init_p',[Parent|[Ancestors|[M|[F|[A|[]]]]]])
(<_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10})-|[{'function_name',{'spawn',4}}] )-|['compiler_generated'] ) end
'spawn_link'/2 = fun (_0,_1) -> case <_0,_1> of <Node,F> when call 'erlang':'is_function' (F) -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_link' (Node,'proc_lib','init_p',[Parent|[Ancestors|[F|[]]]])
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'spawn_link',2}}] )-|['compiler_generated'] ) end
'spawn_link'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Node,M,F,A> when try let <_4> = call 'erlang':'is_atom' (M) in let <_5> = call 'erlang':'is_atom' (F) in let <_6> = call 'erlang':'is_list' (A) in let <_7> = call 'erlang':'and' (_5,_6) in call 'erlang':'and' (_4,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_link' (Node,'proc_lib','init_p',[Parent|[Ancestors|[M|[F|[A|[]]]]]])
(<_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10})-|[{'function_name',{'spawn_link',4}}] )-|['compiler_generated'] ) end
'spawn_opt'/2 = fun (_0,_1) -> case <_0,_1> of <F,Opts> when call 'erlang':'is_function' (F) -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_opt' ('proc_lib','init_p',[Parent|[Ancestors|[F|[]]]],Opts)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'spawn_opt',2}}] )-|['compiler_generated'] ) end
'spawn_opt'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Node,F,Opts> when call 'erlang':'is_function' (F) -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_opt' (Node,'proc_lib','init_p',[Parent|[Ancestors|[F|[]]]],Opts)
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'spawn_opt',3}}] )-|['compiler_generated'] ) end
'spawn_opt'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <M,F,A,Opts> when try let <_4> = call 'erlang':'is_atom' (M) in let <_5> = call 'erlang':'is_atom' (F) in let <_6> = call 'erlang':'is_list' (A) in let <_7> = call 'erlang':'and' (_5,_6) in call 'erlang':'and' (_4,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_opt' ('proc_lib','init_p',[Parent|[Ancestors|[M|[F|[A|[]]]]]],Opts)
(<_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10})-|[{'function_name',{'spawn_opt',4}}] )-|['compiler_generated'] ) end
'spawn_opt'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Node,M,F,A,Opts> when try let <_5> = call 'erlang':'is_atom' (M) in let <_6> = call 'erlang':'is_atom' (F) in let <_7> = call 'erlang':'is_list' (A) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_opt' (Node,'proc_lib','init_p',[Parent|[Ancestors|[M|[F|[A|[]]]]]],Opts)
(<_15,_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12,_11})-|[{'function_name',{'spawn_opt',5}}] )-|['compiler_generated'] ) end
'spawn_mon'/3 = fun (_0,_1,_2) -> let <Parent> = apply 'get_my_name'/0 () in let <Ancestors> = apply 'get_ancestors'/0 () in call 'erlang':'spawn_monitor' ('proc_lib','init_p',[Parent|[Ancestors|[_0|[_1|[_2|[]]]]]])
'hibernate'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <M,F,A> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_list' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'hibernate' ('proc_lib','wake_up',[M|[F|[A|[]]]])
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'hibernate',3}}] )-|['compiler_generated'] ) end
'init_p'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Parent,Ancestors,Fun> when call 'erlang':'is_function' (Fun) -> do call 'erlang':'put' ('$ancestors',[Parent|Ancestors]) let <Mfa> = call 'erlang':'fun_info_mfa' (Fun) in do call 'erlang':'put' ('$initial_call',Mfa) try apply Fun () of <_4> -> _4 catch <_7,_6,_5> -> let <Stacktrace> = primop 'build_stacktrace' (_5) in apply 'exit_p'/3 (_7,_6,Stacktrace)
(<_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8})-|[{'function_name',{'init_p',3}}] )-|['compiler_generated'] ) end
'init_p'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Parent,Ancestors,M,F,A> when try let <_5> = call 'erlang':'is_atom' (M) in let <_6> = call 'erlang':'is_atom' (F) in let <_7> = call 'erlang':'is_list' (A) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> do call 'erlang':'put' ('$ancestors',[Parent|Ancestors]) let <_9> = apply 'trans_init'/3 (M,F,A) in do call 'erlang':'put' ('$initial_call',_9) apply 'init_p_do_apply'/3 (M,F,A)
(<_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12,_11,_10})-|[{'function_name',{'init_p',5}}] )-|['compiler_generated'] ) end
'init_p_do_apply'/3 = fun (_0,_1,_2) -> try call 'erlang':'apply' (_0,_1,_2) of <_3> -> _3 catch <_6,_5,_4> -> let <Stacktrace> = primop 'build_stacktrace' (_4) in apply 'exit_p'/3 (_6,_5,Stacktrace)
'wake_up'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <M,F,A> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_list' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> try call 'erlang':'apply' (M,F,A) of <_7> -> _7 catch <_10,_9,_8> -> let <Stacktrace> = primop 'build_stacktrace' (_8) in apply 'exit_p'/3 (_10,_9,Stacktrace)
(<_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11})-|[{'function_name',{'wake_up',3}}] )-|['compiler_generated'] ) end
'exit_p'/3 = fun (_0,_1,_2) -> case call 'erlang':'get' ('$initial_call') of <{M,F,A}> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_integer' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = apply 'make_dummy_args'/2 (A,[]) in let <MFA> = {M,F,_7} in do apply 'crash_report'/4 (_0,_1,MFA,_2) let <_9> = apply 'exit_reason'/3 (_0,_1,_2) in call 'erlang':'raise' ('exit',_9,_2)
<_15> when 'true' -> do apply 'crash_report'/4 (_0,_1,[],_2) let <_10> = apply 'exit_reason'/3 (_0,_1,_2) in call 'erlang':'raise' ('exit',_10,_2) end
'exit_reason'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'error',Reason,Stacktrace> when 'true' -> {Reason,Stacktrace}
<'exit',Reason,_X_Stacktrace> when 'true' -> Reason
<'throw',Reason,Stacktrace> when 'true' -> {{'nocatch',Reason},Stacktrace}
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'exit_reason',3}}] )-|['compiler_generated'] ) end
'start'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <M,F,A> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_list' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> apply 'start'/4 (M,F,A,'infinity')
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'start',3}}] )-|['compiler_generated'] ) end
'start'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <M,F,A,Timeout> when try let <_4> = call 'erlang':'is_atom' (M) in let <_5> = call 'erlang':'is_atom' (F) in let <_6> = call 'erlang':'is_list' (A) in let <_7> = call 'erlang':'and' (_5,_6) in call 'erlang':'and' (_4,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <_8> = apply 'spawn_mon'/3 (M,F,A) in apply 'sync_start'/2 (_8,Timeout)
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'start',4}}] )-|['compiler_generated'] ) end
'start'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <M,F,A,Timeout,SpawnOpts> when try let <_5> = call 'erlang':'is_atom' (M) in let <_6> = call 'erlang':'is_atom' (F) in let <_7> = call 'erlang':'is_list' (A) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> do case call 'lists':'member' ('monitor',SpawnOpts) of <'true'> when 'true' -> call 'erlang':'error' ('badarg',[M|[F|[A|[Timeout|[SpawnOpts|[]]]]]])
<'false'> when 'true' -> 'ok'
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end let <_10> = call 'proc_lib':'spawn_opt' (M,F,A,['monitor'|SpawnOpts]) in apply 'sync_start'/2 (_10,Timeout)
(<_15,_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12,_11})-|[{'function_name',{'start',5}}] )-|['compiler_generated'] ) end
'sync_start'/2 = fun (_0,_1) -> case <_0,_1> of <{Pid,Ref},Timeout> when 'true' -> receive <{'ack',_4,Return}> when call 'erlang':'=:=' (_4,Pid) -> do call 'erlang':'demonitor' (Ref,['flush']) Return
<{'DOWN',_5,'process',_6,Reason}> when let <_7> = call 'erlang':'=:=' (_5,Ref) in let <_8> = call 'erlang':'=:=' (_6,Pid) in call 'erlang':'and' (_7,_8) -> {'error',Reason} after Timeout -> do call 'erlang':'demonitor' (Ref,['flush']) do apply 'kill_flush'/1 (Pid) {'error','timeout'}
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'sync_start',2}}] )-|['compiler_generated'] ) end
'start_link'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <M,F,A> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_list' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> apply 'start_link'/4 (M,F,A,'infinity')
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'start_link',3}}] )-|['compiler_generated'] ) end
'start_link'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <M,F,A,Timeout> when try let <_4> = call 'erlang':'is_atom' (M) in let <_5> = call 'erlang':'is_atom' (F) in let <_6> = call 'erlang':'is_list' (A) in let <_7> = call 'erlang':'and' (_5,_6) in call 'erlang':'and' (_4,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <_8> = call 'proc_lib':'spawn_link' (M,F,A) in apply 'sync_start_link'/2 (_8,Timeout)
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'start_link',4}}] )-|['compiler_generated'] ) end
'start_link'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <M,F,A,Timeout,SpawnOpts> when try let <_5> = call 'erlang':'is_atom' (M) in let <_6> = call 'erlang':'is_atom' (F) in let <_7> = call 'erlang':'is_list' (A) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> do case call 'lists':'member' ('monitor',SpawnOpts) of <'true'> when 'true' -> call 'erlang':'error' ('badarg',[M|[F|[A|[Timeout|[SpawnOpts|[]]]]]])
<'false'> when 'true' -> 'ok'
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end let <_10> = call 'proc_lib':'spawn_opt' (M,F,A,['link'|SpawnOpts]) in apply 'sync_start_link'/2 (_10,Timeout)
(<_15,_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12,_11})-|[{'function_name',{'start_link',5}}] )-|['compiler_generated'] ) end
'sync_start_link'/2 = fun (_0,_1) -> receive <{'ack',_4,Return}> when call 'erlang':'=:=' (_4,_0) -> Return
<{'EXIT',_5,Reason}> when call 'erlang':'=:=' (_5,_0) -> {'error',Reason} after _1 -> do apply 'kill_flush'/1 (_0) {'error','timeout'}
'start_monitor'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <M,F,A> when try let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in let <_5> = call 'erlang':'is_list' (A) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> apply 'start_monitor'/4 (M,F,A,'infinity')
(<_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7})-|[{'function_name',{'start_monitor',3}}] )-|['compiler_generated'] ) end
'start_monitor'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <M,F,A,Timeout> when try let <_4> = call 'erlang':'is_atom' (M) in let <_5> = call 'erlang':'is_atom' (F) in let <_6> = call 'erlang':'is_list' (A) in let <_7> = call 'erlang':'and' (_5,_6) in call 'erlang':'and' (_4,_7) of <Try> -> Try catch <T,R> -> 'false' -> let <_8> = apply 'spawn_mon'/3 (M,F,A) in apply 'sync_start_monitor'/2 (_8,Timeout)
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'start_monitor',4}}] )-|['compiler_generated'] ) end
'start_monitor'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <M,F,A,Timeout,SpawnOpts> when try let <_5> = call 'erlang':'is_atom' (M) in let <_6> = call 'erlang':'is_atom' (F) in let <_7> = call 'erlang':'is_list' (A) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> do case call 'lists':'member' ('monitor',SpawnOpts) of <'true'> when 'true' -> call 'erlang':'error' ('badarg',[M|[F|[A|[Timeout|[SpawnOpts|[]]]]]])
<'false'> when 'true' -> 'ok'
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end let <_10> = call 'proc_lib':'spawn_opt' (M,F,A,['monitor'|SpawnOpts]) in apply 'sync_start_monitor'/2 (_10,Timeout)
(<_15,_14,_13,_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_15,_14,_13,_12,_11})-|[{'function_name',{'start_monitor',5}}] )-|['compiler_generated'] ) end
'sync_start_monitor'/2 = fun (_0,_1) -> case <_0,_1> of <{Pid,Ref},Timeout> when 'true' -> receive <{'ack',_5,Return}> when call 'erlang':'=:=' (_5,Pid) -> {Return,Ref}
<Down = {'DOWN',_6,'process',_7,Reason}> when let <_8> = call 'erlang':'=:=' (_6,Ref) in let <_9> = call 'erlang':'=:=' (_7,Pid) in call 'erlang':'and' (_8,_9) -> let <_2> = call 'erlang':'self' () in do call 'erlang':'!' (_2,Down) {{'error',Reason},Ref} after Timeout -> do apply 'kill_flush'/1 (Pid) {{'error','timeout'},Ref}
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'sync_start_monitor',2}}] )-|['compiler_generated'] ) end
'kill_flush'/1 = fun (_0) -> do call 'erlang':'unlink' (_0) do call 'erlang':'exit' (_0,'kill') do receive <{'EXIT',_2,_3}> when call 'erlang':'=:=' (_2,_0) -> 'ok' after 0 -> 'ok' 'ok'
'init_ack'/2 = fun (_0,_1) -> let <_2> = call 'erlang':'self' () in do call 'erlang':'!' (_0,{'ack',_2,_1}) 'ok'
'init_ack'/1 = fun (_0) -> case call 'erlang':'get' ('$ancestors') of <[Parent|_3]> when 'true' -> apply 'init_ack'/2 (Parent,_0)
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'initial_call'/1 = fun (_0) -> case apply 'raw_initial_call'/1 (_0) of <{M,F,A}> when 'true' -> let <_1> = apply 'make_dummy_args'/2 (A,[]) in {M,F,_1}
<'false'> when 'true' -> 'false'
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'make_dummy_args'/2 = fun (_0,_1) -> case <_0,_1> of <0,Acc> when 'true' -> Acc
<N,Acc> when 'true' -> let <_2> = call 'erlang':'integer_to_list' (N) in let <_3> = call 'erlang':'++' ([65|[114|[103|[117|[109|[101|[110|[116|[95|[95]]]]]]]]]],_2) in let <Arg> = call 'erlang':'list_to_atom' (_3) in let <_5> = call 'erlang':'-' (N,1) in apply 'make_dummy_args'/2 (_5,[Arg|Acc]) end
'translate_initial_call'/1 = fun (_0) -> case apply 'raw_initial_call'/1 (_0) of <MFA = {_3,_4,_5}> when 'true' -> MFA
<'false'> when 'true' -> {'proc_lib','init_p',5}
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'raw_initial_call'/1 = fun (_0) -> case _0 of <{X,Y,Z}> when try let <_1> = call 'erlang':'is_integer' (X) in let <_2> = call 'erlang':'is_integer' (Y) in let <_3> = call 'erlang':'is_integer' (Z) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> let <_5> = call 'c':'pid' (X,Y,Z) in apply 'raw_initial_call'/1 (_5)
<Pid> when call 'erlang':'is_pid' (_0) -> case apply 'get_process_info'/2 (Pid,'dictionary') of <{'dictionary',Dict}> when 'true' -> apply 'raw_init_call'/1 (Dict)
<_9> when 'true' -> 'false' end
<ProcInfo> when call 'erlang':'is_list' (_0) -> case call 'lists':'keyfind' ('dictionary',1,ProcInfo) of <{'dictionary',Dict}> when 'true' -> apply 'raw_init_call'/1 (Dict)
<_10> when 'true' -> 'false' end
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'raw_initial_call',1}}] )-|['compiler_generated'] ) end
'raw_init_call'/1 = fun (_0) -> case call 'lists':'keyfind' ('$initial_call',1,_0) of <{_3,MFA = {_4,_5,_6}}> when 'true' -> MFA
<_7> when 'true' -> 'false' end
'trans_init'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'gen','init_it',['gen_server'|[_9|[_10|['supervisor'|[{_11,Module,_12}|[_13|[]]]]]]]> when 'true' -> {'supervisor',Module,1}
<'gen','init_it',['gen_server'|[_14|[_15|[_16|['supervisor'|[{_17,Module,_18}|[_19|[]]]]]]]]> when 'true' -> {'supervisor',Module,1}
<'gen','init_it',['gen_server'|[_20|[_21|['supervisor_bridge'|[[Module|_22]|[_23|[]]]]]]]> when 'true' -> {'supervisor_bridge',Module,1}
<'gen','init_it',['gen_server'|[_24|[_25|[_26|['supervisor_bridge'|[[Module|_27]|[_28|[]]]]]]]]> when 'true' -> {'supervisor_bridge',Module,1}
<'gen','init_it',['gen_event'|_29]> when 'true' -> {'gen_event','init_it',6}
<'gen','init_it',[_X_GenMod|[_30|[_31|[Module|[_32|[_33|[]]]]]]]> when call 'erlang':'is_atom' (Module) -> {Module,'init',1}
<'gen','init_it',[_X_GenMod|[_34|[_35|[_36|[Module|_37]]]]]> when call 'erlang':'is_atom' (Module) -> {Module,'init',1}
<M,F,A> when let <_3> = call 'erlang':'is_atom' (M) in let <_4> = call 'erlang':'is_atom' (F) in call 'erlang':'and' (_3,_4) -> let <_5> = call 'erlang':'length' (A) in {M,F,_5}
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'trans_init',3}}] )-|['compiler_generated'] ) end
'crash_report'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <'exit','normal',_15,_16> when 'true' -> 'ok'
<'exit','shutdown',_17,_18> when 'true' -> 'ok'
<'exit',{'shutdown',_19},_20,_21> when 'true' -> 'ok'
<Class,Reason,StartF,Stacktrace> when 'true' -> case call 'logger':'allow' ('error','proc_lib') of <'true'> when 'true' -> let <_4> = apply 'my_info'/4 (Class,Reason,StartF,Stacktrace) in let <_5> = call 'erlang':'self' () in let <_6> = apply 'linked_info'/1 (_5) in let <_7> = ~{'report'=>[_4|[_6|[]]]|~{'label'=>{'proc_lib','crash'}}~}~ in call 'logger':'macro_log' (~{'file'=>[115|[114|[99|[47|[112|[114|[111|[99|[95|[108|[105|[98|[46|[101|[114|[108]]]]]]]]]]]]]]]],'line'=>525,'mfa'=>{'proc_lib','crash_report',4}}~,'error',_7,~{'domain'=>['otp'|['sasl']],'error_logger'=>~{'tag'=>'error_report','type'=>'crash_report'}~,'logger_formatter'=>~{'title'=>[67|[82|[65|[83|[72|[32|[82|[69|[80|[79|[82|[84]]]]]]]]]]]]}~,'report_cb'=>fun 'proc_lib':'report_cb'/2}~)
<'false'> when 'true' -> 'ok'
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end end
'my_info'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Class,Reason,[],Stacktrace> when 'true' -> apply 'my_info_1'/3 (Class,Reason,Stacktrace)
<Class,Reason,StartF,Stacktrace> when 'true' -> let <_4> = apply 'my_info_1'/3 (Class,Reason,Stacktrace) in [{'initial_call',StartF}|_4] end
'my_info_1'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'self' () in let <_4> = call 'erlang':'self' () in let <_5> = apply 'get_process_info'/2 (_4,'registered_name') in let <_6> = call 'erlang':'self' () in let <_7> = apply 'get_ancestors'/1 (_6) in let <_8> = call 'erlang':'self' () in let <_9> = apply 'get_process_info'/2 (_8,'message_queue_len') in let <_10> = call 'erlang':'self' () in let <_11> = apply 'get_messages'/1 (_10) in let <_12> = call 'erlang':'self' () in let <_13> = apply 'get_process_info'/2 (_12,'links') in let <_14> = call 'erlang':'self' () in let <_15> = apply 'get_cleaned_dictionary'/1 (_14) in let <_16> = call 'erlang':'self' () in let <_17> = apply 'get_process_info'/2 (_16,'trap_exit') in let <_18> = call 'erlang':'self' () in let <_19> = apply 'get_process_info'/2 (_18,'status') in let <_20> = call 'erlang':'self' () in let <_21> = apply 'get_process_info'/2 (_20,'heap_size') in let <_22> = call 'erlang':'self' () in let <_23> = apply 'get_process_info'/2 (_22,'stack_size') in let <_24> = call 'erlang':'self' () in let <_25> = apply 'get_process_info'/2 (_24,'reductions') in [{'pid',_3}|[_5|[{'error_info',{_0,_1,_2}}|[_7|[_9|[_11|[_13|[_15|[_17|[_19|[_21|[_23|[_25|[]]]]]]]]]]]]]]
'get_ancestors'/1 = fun (_0) -> case apply 'get_dictionary'/2 (_0,'$ancestors') of <{'$ancestors',Ancestors}> when 'true' -> {'ancestors',Ancestors}
<_3> when 'true' -> {'ancestors',[]} end
'get_messages'/1 = fun (_0) -> let <Messages> = apply 'get_process_messages'/1 (_0) in let <_2> = call 'error_logger':'limit_term' (Messages) in {'messages',_2}
'get_process_messages'/1 = fun (_0) -> let <Depth> = call 'error_logger':'get_format_depth' () in let <_3> = call 'erlang':'self' () in let <_5> = case <> of (<> when call 'erlang':'=/=' (_0,_3) -> 'true'-|['compiler_generated'] )
(<> when 'true' -> call 'erlang':'=:=' (Depth,'unlimited')-|['compiler_generated'] ) end in case _5 of <'true'> when 'true' -> case apply 'get_process_info'/2 (_0,'messages') of <{'messages',Messages}> when 'true' -> Messages
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<'false'> when 'true' -> apply 'receive_messages'/1 (Depth)
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
'receive_messages'/1 = fun (_0) -> case _0 of <0> when 'true' -> []
<N> when 'true' -> receive <M> when 'true' -> let <_1> = call 'erlang':'-' (N,1) in let <_2> = apply 'receive_messages'/1 (_1) in [M|_2] after 0 -> [] end
'get_cleaned_dictionary'/1 = fun (_0) -> case apply 'get_process_info'/2 (_0,'dictionary') of <{'dictionary',Dict}> when 'true' -> let <_1> = apply 'cleaned_dict'/1 (Dict) in {'dictionary',_1}
<_4> when 'true' -> {'dictionary',[]} end
'cleaned_dict'/1 = fun (_0) -> let <CleanDict> = apply 'clean_dict'/1 (_0) in call 'error_logger':'limit_term' (CleanDict)
'clean_dict'/1 = fun (_0) -> case _0 of <[{'$ancestors',_3}|Dict]> when 'true' -> apply 'clean_dict'/1 (Dict)
<[{'$initial_call',_4}|Dict]> when 'true' -> apply 'clean_dict'/1 (Dict)
<[E|Dict]> when 'true' -> let <_1> = apply 'clean_dict'/1 (Dict) in [E|_1]
<[]> when 'true' -> []
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'clean_dict',1}}] )-|['compiler_generated'] ) end
'get_dictionary'/2 = fun (_0,_1) -> case apply 'get_process_info'/2 (_0,'dictionary') of <{'dictionary',Dict}> when 'true' -> case call 'lists':'keysearch' (_1,1,Dict) of <{'value',Value}> when 'true' -> Value
<_6> when 'true' -> 'undefined' end
<_7> when 'true' -> 'undefined' end
'linked_info'/1 = fun (_0) -> let <_1> = apply 'neighbours'/1 (_0) in apply 'make_neighbour_reports1'/1 (_1)
'make_neighbour_reports1'/1 = fun (_0) -> case _0 of <[P|Ps]> when 'true' -> let <ReportBody> = apply 'make_neighbour_report'/1 (P) in case call 'lists':'member' ('undefined',ReportBody) of <'true'> when 'true' -> apply 'make_neighbour_reports1'/1 (Ps)
<'false'> when 'true' -> let <_2> = apply 'make_neighbour_reports1'/1 (Ps) in [{'neighbour',ReportBody}|_2]
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'make_neighbour_reports1',1}}] )-|['compiler_generated'] ) end
'make_neighbour_report'/1 = fun (_0) -> let <_1> = apply 'get_process_info'/2 (_0,'registered_name') in let <_2> = apply 'get_initial_call'/1 (_0) in let <_3> = apply 'get_process_info'/2 (_0,'current_function') in let <_4> = apply 'get_ancestors'/1 (_0) in let <_5> = apply 'get_process_info'/2 (_0,'message_queue_len') in let <_6> = apply 'get_process_info'/2 (_0,'links') in let <_7> = apply 'get_process_info'/2 (_0,'trap_exit') in let <_8> = apply 'get_process_info'/2 (_0,'status') in let <_9> = apply 'get_process_info'/2 (_0,'heap_size') in let <_10> = apply 'get_process_info'/2 (_0,'stack_size') in let <_11> = apply 'get_process_info'/2 (_0,'reductions') in let <_12> = apply 'get_process_info'/2 (_0,'current_stacktrace') in [{'pid',_0}|[_1|[_2|[_3|[_4|[_5|[_6|[_7|[_8|[_9|[_10|[_11|[_12|[]]]]]]]]]]]]]]
'get_initial_call'/1 = fun (_0) -> case apply 'get_dictionary'/2 (_0,'$initial_call') of <{'$initial_call',{M,F,A}}> when 'true' -> let <_1> = apply 'make_dummy_args'/2 (A,[]) in {'initial_call',{M,F,_1}}
<_4> when 'true' -> apply 'get_process_info'/2 (_0,'initial_call') end
'neighbours'/1 = fun (_0) -> let <_2> = apply 'adjacents'/1 (_0) in let <_1> = apply 'max_neighbours'/0 () in case apply 'visit'/2 (_2,{_1,[_0|[]]}) of <{_5,Visited}> when 'true' -> call 'lists':'delete' (_0,Visited)
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
'max_neighbours'/0 = fun () -> 15
'visit'/2 = fun (_0,_1) -> case <_0,_1> of <[P|Ps],NVs = {N,Vs}> when call 'erlang':'>' (N,0) -> case call 'lists':'member' (P,Vs) of <'false'> when 'true' -> let <_4> = apply 'adjacents'/1 (P) in let <_2> = call 'erlang':'-' (N,1) in let <_3> = apply 'visit'/2 (Ps,{_2,[P|Vs]}) in apply 'visit'/2 (_4,_3)
<'true'> when 'true' -> apply 'visit'/2 (Ps,NVs)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<_8,NVs = {_X_N,_X_Vs}> when 'true' -> NVs
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'visit',2}}] )-|['compiler_generated'] ) end
'adjacents'/1 = fun (_0) -> let <_1> = catch apply 'proc_info'/2 (_0,'links') in case _1 of <{'links',Links}> when 'true' -> apply 'no_trap'/1 (Links)
<_4> when 'true' -> [] end
'no_trap'/1 = fun (_0) -> case _0 of <[P|Ps]> when 'true' -> let <_1> = catch apply 'proc_info'/2 (P,'trap_exit') in case _1 of <{'trap_exit','false'}> when 'true' -> let <_2> = apply 'no_trap'/1 (Ps) in [P|_2]
<_5> when 'true' -> apply 'no_trap'/1 (Ps) end
<[]> when 'true' -> []
(<_4> when 'true' -> (primop 'match_fail' ({'function_clause',_4})-|[{'function_name',{'no_trap',1}}] )-|['compiler_generated'] ) end
'get_process_info'/2 = fun (_0,_1) -> let <_2> = catch apply 'proc_info'/2 (_0,_1) in apply 'translate_process_info'/2 (_1,_2)
'translate_process_info'/2 = fun (_0,_1) -> case <_0,_1> of <'registered_name',[]> when 'true' -> {'registered_name',[]}
<_4,{'EXIT',_5}> when 'true' -> 'undefined'
<_6,Result> when 'true' -> Result end
'get_my_name'/0 = fun () -> let <_0> = call 'erlang':'self' () in case apply 'proc_info'/2 (_0,'registered_name') of <{'registered_name',Name}> when 'true' -> Name
<_2> when 'true' -> call 'erlang':'self' () end
'get_ancestors'/0 = fun () -> case call 'erlang':'get' ('$ancestors') of <A> when call 'erlang':'is_list' (A) -> A
<_1> when 'true' -> [] end
'proc_info'/2 = fun (_0,_1) -> case <_0,_1> of <Pid,Item> when try let <_3> = call 'erlang':'node' (Pid) in let <_2> = call 'erlang':'node' () in call 'erlang':'=:=' (_3,_2) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'process_info' (Pid,Item)
<Pid,Item> when 'true' -> let <_5> = call 'erlang':'node' (Pid) in let <_4> = call 'erlang':'nodes' () in case call 'lists':'member' (_5,_4) of <'true'> when 'true' -> let <_6> = call 'erlang':'node' (Pid) in let <_7> = call 'rpc':'call' (_6,'erlang','process_info',[Pid|[Item|[]]]) in apply 'check'/1 (_7)
<_11> when 'true' -> 'hidden' end end
'check'/1 = fun (_0) -> case _0 of <{'badrpc','nodedown'}> when 'true' -> 'undefined'
<{'badrpc',Error}> when 'true' -> Error
<Res> when 'true' -> Res end
'report_cb'/2 = fun (_0,_1) -> case <_0,_1> of <~{'report':=CrashReport,'label':={'proc_lib','crash'}}~,Extra> when 'true' -> let <_3> = call 'maps':'merge' (~{'chars_limit'=>'unlimited','depth'=>'unlimited','encoding'=>'utf8','single_line'=>'false'}~,Extra) in apply 'do_format'/2 (CrashReport,_3)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'report_cb',2}}] )-|['compiler_generated'] ) end
'format'/1 = fun (_0) -> apply 'format'/2 (_0,'latin1')
'format'/2 = fun (_0,_1) -> apply 'format'/3 (_0,_1,'unlimited')
'format'/3 = fun (_0,_1,_2) -> let <_3> = ~{'depth'=>_2,'encoding'=>_1,'single_line'=>'false'|~{'chars_limit'=>'unlimited'}~}~ in apply 'do_format'/2 (_0,_3)
'do_format'/2 = fun (_0,_1) -> case <_0,_1> of <[OwnReport|[LinkReport|[]]],Extra> when 'true' -> case Extra of <~{'chars_limit':=Limit0,'encoding':=Enc,'single_line':=Single}~> when 'true' -> let <_3> = case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> []
<> when 'true' -> [32|[32]] end in let <Nl> = apply 'nl'/2 (Single,[32]) in let <_6> = apply 'report_separator'/0 () in let <Sep> = apply 'nl'/2 (Single,_6) in let <_37,_38> = case Limit0 of <'unlimited'> when 'true' -> <Limit0,Limit0>
<_36> when call 'erlang':'is_integer' (Limit0) -> let <Num> = call 'erlang':'length' (OwnReport) in let <_14> = call 'erlang':'length' (_3) in let <_15> = call 'erlang':'+' (_14,7) in let <_12> = call 'erlang':'length' (Nl) in let <_16> = call 'erlang':'+' (_15,_12) in let <_11> = call 'erlang':'length' (Sep) in let <_17> = call 'erlang':'+' (_16,_11) in let <_9> = call 'erlang':'length' (Sep) in let <_10> = call 'erlang':'*' (_9,Num) in let <HardcodedSize> = call 'erlang':'+' (_17,_10) in let <_19> = call 'erlang':'-' (Limit0,HardcodedSize) in let <Limit1> = call 'erlang':'max' (_19,1) in let <EL> = call 'erlang':'div' (Limit1,3) in let <_22> = call 'erlang':'-' (Limit1,EL) in let <PL> = call 'erlang':'div' (_22,Num) in <PL,Limit1>
(<_24> when 'true' -> primop 'match_fail' ({'case_clause',_24})-|['compiler_generated'] ) end in let <LinkFormat> = apply 'format_link_reports'/4 (LinkReport,_3,Extra,(_37-|['compiler_generated'] )) in let <LinkFormatSize> = apply 'size'/2 (Enc,LinkFormat) in let <OwnFormat> = apply 'format_own_report'/6 (OwnReport,_3,Extra,LinkFormatSize,(_37-|['compiler_generated'] ),(_38-|['compiler_generated'] )) in let <_30> = call 'erlang':'++' (Sep,[126|[116|[115]]]) in let <_31> = [126|[116|[115|_30]]] in let <_32> = call 'erlang':'++' (Nl,_31) in let <_33> = call 'erlang':'++' ([126|[115|[99|[114|[97|[115|[104|[101|[114|[58]]]]]]]]]],_32) in call 'io_lib':'format' (_33,[_3|[OwnFormat|[LinkFormat|[]]]])
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_35,_34> when 'true' -> (primop 'match_fail' ({'function_clause',_35,_34})-|[{'function_name',{'do_format',2}}] )-|['compiler_generated'] ) end
'format_own_report'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <MyIndent> = call 'erlang':'++' (_1,_1) in case apply 'separate_error_info'/1 (_0) of <{First,{Class,Reason,StackTrace},Rest}> when 'true' -> let <F> = apply 'format_report'/4 (First,MyIndent,_2,_4) in let <R> = apply 'format_report'/4 (Rest,MyIndent,_2,_4) in case _2 of <~{'encoding':=Enc,'single_line':=Single}~> when 'true' -> let <_10> = apply 'part_separator'/0 () in let <Sep> = apply 'nl'/2 (Single,_10) in let <_24> = case _5 of <'unlimited'> when 'true' -> _5
<_38> when call 'erlang':'is_integer' (_5) -> let <_18> = apply 'size'/2 (Enc,F) in let <_17> = apply 'size'/2 (Enc,R) in let <_19> = call 'erlang':'+' (_18,_17) in let <_15> = call 'erlang':'length' (Sep) in let <_13> = call 'erlang':'length' (F) in let <_12> = call 'erlang':'length' (R) in let <_14> = call 'erlang':'+' (_13,_12) in let <_16> = call 'erlang':'*' (_15,_14) in let <_20> = call 'erlang':'-' (_19,_16) in let <SizeOfOther> = call 'erlang':'+' (_20,_3) in let <_22> = call 'erlang':'-' (_5,SizeOfOther) in call 'erlang':'max' (_22,1)
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end in let <EI> = apply 'format_exception'/5 (Class,Reason,StackTrace,_2,_24) in call 'lists':'join' (Sep,[F|[EI|[R|[]]]])
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
<'no'> when 'true' -> let <_29> = case _5 of <'unlimited'> when 'true' -> _5
<_39> when call 'erlang':'is_integer' (_5) -> let <_27> = call 'erlang':'-' (_5,_3) in call 'erlang':'max' (_27,1)
(<_28> when 'true' -> primop 'match_fail' ({'case_clause',_28})-|['compiler_generated'] ) end in apply 'format_report'/4 (_0,MyIndent,_2,_29)
(<_31> when 'true' -> primop 'match_fail' ({'case_clause',_31})-|['compiler_generated'] ) end
'separate_error_info'/1 = fun (_0) -> try let <_4> = fun (_2) -> let <_1> = call 'erlang':'element' (1,_2) in call 'erlang':'=/=' (_1,'error_info') in call 'lists':'splitwith' (_4,_0) of <_5> -> case _5 of <{First,[{'error_info',ErrorInfo}|Rest]}> when 'true' -> {First,ErrorInfo,Rest}
<_11> when 'true' -> 'no' end catch <_9,_8,_7> -> 'no'
'format_link_reports'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <LinkReports,Indent,Extra,PartLimit> when call 'erlang':'is_integer' (PartLimit) -> case Extra of <~{'depth':=Depth,'encoding':=Enc,'single_line':=Single}~> when 'true' -> let <_9> = letrec 'lc$^0'/1 = fun (_7) -> case _7 of <[{'neighbour',[{'pid',P}|_28]}|_6]> when 'true' -> let <_8> = apply 'lc$^0'/1 (_6) in ([P|_8]-|['compiler_generated'] )
(<[_5|_6]> when 'true' -> apply 'lc$^0'/1 (_6)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_29> when 'true' -> (primop 'match_fail' ({'function_clause',_29})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (LinkReports) in case apply 'p'/2 (Enc,Depth) of <{P,Tl}> when 'true' -> let <_12> = case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> [48]
<> when 'true' -> [] end in let <_14> = call 'erlang':'++' (_12,P) in let <_15> = call 'erlang':'++' ([110|[101|[105|[103|[104|[98|[111|[117|[114|[115|[58|[32|[126]]]]]]]]]]]]],_14) in let <_16> = call 'erlang':'++' (Indent,_15) in call 'io_lib':'format' (_16,[_9|Tl],[{'chars_limit',PartLimit}|[]])
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<LinkReports,Indent,Extra,PartLimit> when 'true' -> case Extra of <~{'single_line':=Single}~> when 'true' -> let <MyIndent> = call 'erlang':'++' (Indent,Indent) in let <_20> = apply 'report_separator'/0 () in let <_21> = apply 'nl'/2 (Single,_20) in let <_19> = apply 'format_link_report'/4 (LinkReports,MyIndent,Extra,PartLimit) in let <LinkFormat> = call 'lists':'join' (_21,_19) in let <_23> = apply 'nl'/2 (Single,[32]) in [Indent|[[110|[101|[105|[103|[104|[98|[111|[117|[114|[115|[58]]]]]]]]]]]|[_23|[LinkFormat|[]]]]]
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end end
'format_link_report'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[Link|Reps],Indent0,Extra,PartLimit> when 'true' -> case Extra of <~{'single_line':=Single}~> when 'true' -> let <_6> = case Link of <{'neighbour',Rep0}> when 'true' -> Rep0
<_18> when 'true' -> Link end in let <_8> = case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> []
<> when 'true' -> Indent0 end in let <LinkIndent> = [[32|[32]]|[_8|[]]] in let <_11> = apply 'nl'/2 (Single,[32]) in let <_12> = apply 'format_report'/4 (_6,LinkIndent,Extra,PartLimit) in let <_13> = apply 'format_link_report'/4 (Reps,_8,Extra,PartLimit) in [[_8|[[110|[101|[105|[103|[104|[98|[111|[117|[114|[58]]]]]]]]]]|[_11|[_12|[]]]]]|_13]
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<Rep,Indent,Extra,PartLimit> when 'true' -> apply 'format_report'/4 (Rep,Indent,Extra,PartLimit) end
'format_report'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Rep,Indent,Extra,Limit> when call 'erlang':'is_list' (Rep) -> case Extra of <~{'single_line':=Single}~> when 'true' -> let <_6> = apply 'part_separator'/0 () in let <_7> = apply 'nl'/2 (Single,_6) in let <_5> = apply 'format_rep'/4 (Rep,Indent,Extra,Limit) in call 'lists':'join' (_7,_5)
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<Rep,Indent0,Extra,Limit> when 'true' -> case Extra of <~{'depth':=Depth,'encoding':=Enc,'single_line':=Single}~> when 'true' -> case apply 'p'/2 (Enc,Depth) of <{P,Tl}> when 'true' -> let <_19,_20> = case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> <[],[48]>
<> when 'true' -> <Indent0,[]> end in let <Opts> = apply 'chars_limit_opt'/1 (Limit) in let <_13> = call 'erlang':'++' ((_20-|['compiler_generated'] ),P) in let <_14> = [126|[115|[126|_13]]] in call 'io_lib':'format' (_14,[(_19-|['compiler_generated'] )|[Rep|Tl]],Opts)
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end
'format_rep'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[{'initial_call',InitialCall}|Rep],Indent,Extra,Limit> when 'true' -> let <_4> = apply 'format_mfa'/4 (Indent,InitialCall,Extra,Limit) in let <_5> = apply 'format_rep'/4 (Rep,Indent,Extra,Limit) in [_4|_5]
<[{Tag,Data}|Rep],Indent,Extra,Limit> when 'true' -> let <_6> = apply 'format_tag'/5 (Indent,Tag,Data,Extra,Limit) in let <_7> = apply 'format_rep'/4 (Rep,Indent,Extra,Limit) in [_6|_7]
<_12,_13,_X_Extra,_X_Limit> when 'true' -> [] end
'format_exception'/5 = fun (_0,_1,_2,_3,_4) -> case _3 of <~{'depth':=Depth,'encoding':=Enc,'single_line':=Single}~> when 'true' -> let <StackFun> = fun (_10,_9,_8) -> let <_7> = call 'erlang':'=:=' (_10,'erl_eval') in let <_6> = call 'erlang':'=:=' (_10,'proc_lib') in call 'erlang':'or' (_7,_6) in case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> case apply 'p'/2 (Enc,Depth) of <{P,Tl}> when 'true' -> let <Opts> = apply 'chars_limit_opt'/1 (_4) in let <_17> = call 'erlang':'atom_to_list' (_0) in let <_18> = [126|[48|P]] in let <_19> = call 'io_lib':'format' (_18,[{_1,_2}|Tl],Opts) in [_17|[[58|[32]]|[_19|[]]]]
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<> when 'true' -> let <PF> = apply 'pp_fun'/2 (_3,Enc) in let <_23> = case _4 of <'unlimited'> when 'true' -> -1
<_33> when 'true' -> _4 end in let <FE> = call 'erl_error':'format_exception' (5,_0,_1,_2,StackFun,PF,Enc,_23) in [[32|[32|[32|[32]]]]|[FE|[]]] end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'format_mfa'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Indent0,StartF = {M,F,Args},Extra,Limit> when 'true' -> case Extra of <~{'encoding':=Enc,'single_line':=Single}~> when 'true' -> let <_5> = case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> []
<> when 'true' -> Indent0 end in try let <A> = call 'erlang':'length' (Args) in let <_8> = apply 'to_string'/2 (M,Enc) in let <_9> = apply 'to_string'/2 (F,Enc) in let <_10> = call 'erlang':'integer_to_list' (A) in [_5|[[105|[110|[105|[116|[105|[97|[108|[32|[99|[97|[108|[108|[58|[32]]]]]]]]]]]]]]|[_8|[58|[_9|[47|[_10|[]]]]]]]] of <_11> -> _11 catch <_14,_13,_12> -> case <_14,_13,_12> of <('error'-|['compiler_generated'] ),_19,_20> when 'true' -> apply 'format_tag'/5 (_5,'initial_call',StartF,Extra,Limit)
(<_21,_22,_23> when 'true' -> primop 'raise' (_23,_22)-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_18,_17,_16,_15> when 'true' -> (primop 'match_fail' ({'function_clause',_18,_17,_16,_15})-|[{'function_name',{'format_mfa',4}}] )-|['compiler_generated'] ) end
'to_string'/2 = fun (_0,_1) -> case <_0,_1> of <A,'latin1'> when 'true' -> call 'io_lib':'write_atom_as_latin1' (A)
<A,_4> when 'true' -> call 'io_lib':'write_atom' (A) end
'pp_fun'/2 = fun (_0,_1) -> case _0 of <~{'depth':=Depth,'encoding':=_21,'single_line':=Single}~> when call 'erlang':'=:=' (_21,_1) -> case apply 'p'/2 (_1,Depth) of <{P,Tl}> when 'true' -> let <_4> = case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> [48]
<> when 'true' -> [] end in (fun (_15,_14,_13) -> let <_6> = call 'erlang':'integer_to_list' (_14) in let <_7> = call 'erlang':'++' (_6,P) in let <_8> = [46|_7] in let <_9> = call 'erlang':'++' (_4,_8) in let <_10> = [126|_9] in let <S> = call 'io_lib':'format' (_10,[_15|Tl],[{'chars_limit',_13}|[]]) in let <_12> = apply 'sub'/3 (_13,S,_1) in {S,_12}-|[{'id',{0,0,'-pp_fun/2-fun-0-'}}] )
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'format_tag'/5 = fun (_0,_1,_2,_3,_4) -> case _3 of <~{'depth':=Depth,'encoding':=Enc,'single_line':=Single}~> when 'true' -> case apply 'p'/2 (Enc,Depth) of <{P,Tl}> when 'true' -> let <_20,_21> = case <> of <> when (call 'erlang':'=:=' (Single,'true')-|['compiler_generated'] ) -> <[],[48]>
<> when 'true' -> <_0,[]> end in let <Opts> = apply 'chars_limit_opt'/1 (_4) in let <_10> = [46|[49|[56|P]]] in let <_11> = call 'erlang':'++' ((_21-|['compiler_generated'] ),_10) in let <_12> = [112|[58|[32|[126|_11]]]] in let <_13> = call 'erlang':'++' ((_21-|['compiler_generated'] ),_12) in let <_14> = [126|[115|[126|_13]]] in call 'io_lib':'format' (_14,[(_20-|['compiler_generated'] )|[_1|[_2|Tl]]],Opts)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'p'/2 = fun (_0,_1) -> let <_10,_11> = case _1 of <'unlimited'> when 'true' -> <[112],[]>
<_9> when 'true' -> <[80],[_1|[]]> end in let <_5> = apply 'modifier'/1 (_0) in let <P> = call 'erlang':'++' (_5,(_10-|['compiler_generated'] )) in {P,(_11-|['compiler_generated'] )}
'report_separator'/0 = fun () -> [59|[32]]
'part_separator'/0 = fun () -> [44|[32]]
'chars_limit_opt'/1 = fun (_0) -> (case <> of <> when call 'erlang':'is_integer' (_0) -> ([{'chars_limit',_0}|[]]-|['compiler_generated'] )
(<> when 'true' -> []-|['compiler_generated'] ) end-|['list_comprehension'] )
'modifier'/1 = fun (_0) -> case _0 of <'latin1'> when 'true' -> []
<_2> when 'true' -> [116] end
'nl'/2 = fun (_0,_1) -> case <_0,_1> of <'true',Else> when 'true' -> Else
<'false',_4> when 'true' -> [10]
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'nl',2}}] )-|['compiler_generated'] ) end
'sub'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <T,_7,_X_Enc> when call 'erlang':'<' (T,0) -> T
<T,E,Enc> when 'true' -> let <Sz> = apply 'size'/2 (Enc,E) in case <> of <> when call 'erlang':'>=' (T,Sz) -> call 'erlang':'-' (T,Sz)
<> when 'true' -> 0 end end
'size'/2 = fun (_0,_1) -> case <_0,_1> of <'latin1',S> when 'true' -> call 'erlang':'iolist_size' (S)
<_4,S> when 'true' -> call 'string':'length' (S) end
'stop'/1 = fun (_0) -> apply 'stop'/3 (_0,'normal','infinity')
'stop'/3 = fun (_0,_1,_2) -> let <_3> = apply 'do_stop'/2 (_0,_1) in case call 'erlang':'spawn_monitor' (_3) of <{Pid,Mref}> when 'true' -> receive <{'DOWN',_8,_9,_10,_11}> when let <_12> = call 'erlang':'=:=' (_8,Mref) in let <_13> = call 'erlang':'=:=' (_11,_1) in call 'erlang':'and' (_12,_13) -> 'ok'
<{'DOWN',_14,_15,_16,{'noproc',{'sys','terminate',_17}}}> when call 'erlang':'=:=' (_14,Mref) -> call 'erlang':'exit' ('noproc')
<{'DOWN',_18,_19,_20,CrashReason}> when call 'erlang':'=:=' (_18,Mref) -> call 'erlang':'exit' (CrashReason) after _2 -> do call 'erlang':'exit' (Pid,'kill') receive <{'DOWN',_21,_22,_23,_24}> when call 'erlang':'=:=' (_21,Mref) -> call 'erlang':'exit' ('timeout') after 'infinity' -> 'true'
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'do_stop'/2 = fun (_0,_1) -> (fun () -> let <Mref> = call 'erlang':'monitor' ('process',_0) in case call 'sys':'terminate' (_0,_1,'infinity') of <'ok'> when 'true' -> receive <{'DOWN',_6,_7,_8,ExitReason}> when call 'erlang':'=:=' (_6,Mref) -> call 'erlang':'exit' (ExitReason) after 'infinity' -> 'true'
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end-|[{'id',{0,0,'-do_stop/2-fun-0-'}}] )
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('proc_lib')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('proc_lib',_0) end