module 'edlin' ['current_chars'/1,'current_line'/1,'edit_line'/2,'edit_line1'/2,'erase_inp'/1,'erase_line'/1,'init'/0,'init'/1,'length_after'/1,'length_before'/1,'module_info'/0,'module_info'/1,'over_word'/3,'prefix_arg'/1,'prompt'/1,'redraw_line'/1,'start'/1,'start'/2] attributes [ 'file' = [{[115|[114|[99|[47|[101|[100|[108|[105|[110|[46|[101|[114|[108]]]]]]]]]]]]],1}] ] 'init'/0 = fun () -> call 'erlang':'put' ('kill_buffer',[])
'init'/1 = fun (_0) -> let <_3> = case call 'erlang':'process_info' (_0,'dictionary') of <{'dictionary',Dict}> when 'true' -> case call 'proplists':'get_value' ('kill_buffer',Dict) of <'undefined'> when 'true' -> []
<Buf> when 'true' -> Buf end
<'undefined'> when 'true' -> []
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end in call 'erlang':'put' ('kill_buffer',_3)
'start'/1 = fun (_0) -> apply 'start'/2 (_0,'none')
'start'/2 = fun (_0,_1) -> {'more_chars',{'line',_0,{[],[]},_1},[{'put_chars','unicode',_0}|[]]}
'edit_line'/2 = fun (_0,_1) -> case <_0,_1> of <Cs,{'line',P,L,{'blink',N}}> when 'true' -> apply 'edit'/5 (Cs,P,L,'none',[{'move_rel',N}|[]])
<Cs,{'line',P,L,M}> when 'true' -> apply 'edit'/5 (Cs,P,L,M,[])
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'edit_line',2}}] )-|['compiler_generated'] ) end
'edit_line1'/2 = fun (_0,_1) -> case <_0,_1> of <Cs,{'line',P,L,{'blink',N}}> when 'true' -> apply 'edit'/5 (Cs,P,L,'none',[{'move_rel',N}|[]])
<Cs,{'line',P,{[],[]},'none'}> when 'true' -> let <_2> = call 'string':'reverse' (Cs) in {'more_chars',{'line',P,{_2,[]},'none'},[{'put_chars','unicode',Cs}|[]]}
<Cs,{'line',P,L,M}> when 'true' -> apply 'edit'/5 (Cs,P,L,M,[])
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'edit_line1',2}}] )-|['compiler_generated'] ) end
'edit'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_@r0 = [C|Cs],P,Line,{'blink',_25},[_26|Rs]> when 'true' -> apply 'edit'/5 (_@r0,P,Line,'none',Rs)
<[C|Cs],P,_@r1 = {Bef,Aft},Prefix,Rs0> when 'true' -> case apply 'key_map'/2 (C,Prefix) of <'meta'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'meta',Rs0)
<'meta_o'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'meta_o',Rs0)
<'meta_csi'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'meta_csi',Rs0)
<'meta_meta'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'meta_meta',Rs0)
<Csi = {'csi',_27}> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,Csi,Rs0)
<'meta_left_sq_bracket'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'meta_left_sq_bracket',Rs0)
<'search_meta'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'search_meta',Rs0)
<'search_meta_left_sq_bracket'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'search_meta_left_sq_bracket',Rs0)
<'ctlx'> when 'true' -> apply 'edit'/5 (Cs,P,_@r1,'ctlx',Rs0)
<'new_line'> when 'true' -> let <_7> = call 'erlang':'++' (Aft,[10]) in let <_8> = apply 'get_line'/2 (Bef,_7) in let <_5> = apply 'cp_len'/1 (Aft) in let <_6> = call 'lists':'reverse' (Rs0,[{'move_rel',_5}|[{'put_chars','unicode',[10]}]]) in {'done',_8,Cs,_6}
<'redraw_line'> when 'true' -> let <Rs1> = apply 'erase'/4 (P,Bef,Aft,Rs0) in let <Rs> = apply 'redraw'/4 (P,Bef,Aft,Rs1) in apply 'edit'/5 (Cs,P,_@r1,'none',Rs)
<'tab_expand'> when 'true' -> let <_11> = call 'lists':'reverse' (Rs0) in {'expand',Bef,Cs,{'line',P,_@r1,'none'},_11}
<{'undefined',_28}> when call 'erlang':'=:=' (_28,C) -> let <_12> = call 'lists':'reverse' (Rs0) in {'undefined',{'none',Prefix,C},Cs,{'line',P,_@r1,'none'},_12}
<Op> when 'true' -> case apply 'do_op'/4 (Op,Bef,Aft,Rs0) of <{'blink',N,Line,Rs}> when 'true' -> apply 'edit'/5 (Cs,P,Line,{'blink',N},Rs)
<{Line,Rs,Mode}> when 'true' -> apply 'edit'/5 (Cs,P,Line,Mode,Rs)
<{Line,Rs}> when 'true' -> apply 'edit'/5 (Cs,P,Line,'none',Rs)
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end end
<[],P,L,_@r2 = {'blink',N},Rs> when 'true' -> let <_15> = call 'lists':'reverse' (Rs) in {'blink',{'line',P,L,_@r2},_15}
<[],P,L,Prefix,Rs> when 'true' -> let <_16> = call 'lists':'reverse' (Rs) in {'more_chars',{'line',P,L,Prefix},_16}
<'eof',_29,{Bef,Aft},_30,Rs> when 'true' -> let <_19> = apply 'get_line'/2 (Bef,Aft) in let <_17> = apply 'cp_len'/1 (Aft) in let <_18> = call 'lists':'reverse' (Rs,[{'move_rel',_17}|[]]) in {'done',_19,[],_18}
(<_24,_23,_22,_21,_20> when 'true' -> (primop 'match_fail' ({'function_clause',_24,_23,_22,_21,_20})-|[{'function_name',{'edit',5}}] )-|['compiler_generated'] ) end
'prefix_arg'/1 = fun (_0) -> case _0 of <'none'> when 'true' -> 1
<{'ctlu',N}> when 'true' -> N
<N> when 'true' -> N end
'key_map'/2 = fun (_0,_1) -> case <_0,_1> of <A,_16> when call 'erlang':'is_atom' (A) -> A
<1,'none'> when 'true' -> 'beginning_of_line'
<2,'none'> when 'true' -> 'backward_char'
<4,'none'> when 'true' -> 'forward_delete_char'
<5,'none'> when 'true' -> 'end_of_line'
<6,'none'> when 'true' -> 'forward_char'
<8,'none'> when 'true' -> 'backward_delete_char'
<9,'none'> when 'true' -> 'tab_expand'
<12,'none'> when 'true' -> 'redraw_line'
<10,'none'> when 'true' -> 'new_line'
<11,'none'> when 'true' -> 'kill_line'
<13,'none'> when 'true' -> 'new_line'
<20,'none'> when 'true' -> 'transpose_char'
<21,'none'> when 'true' -> 'ctlu'
<29,'none'> when 'true' -> 'auto_blink'
<24,'none'> when 'true' -> 'ctlx'
<25,'none'> when 'true' -> 'yank'
<23,'none'> when 'true' -> 'backward_kill_word'
<27,'none'> when 'true' -> 'meta'
<41,Prefix> when try let <_2> = call 'erlang':'=/=' (Prefix,'meta') in let <_3> = call 'erlang':'=/=' (Prefix,'search') in let <_4> = call 'erlang':'=/=' (Prefix,'search_meta') in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> {'blink',41,40}
<125,Prefix> when try let <_6> = call 'erlang':'=/=' (Prefix,'meta') in let <_7> = call 'erlang':'=/=' (Prefix,'search') in let <_8> = call 'erlang':'=/=' (Prefix,'search_meta') in let <_9> = call 'erlang':'and' (_7,_8) in call 'erlang':'and' (_6,_9) of <Try> -> Try catch <T,R> -> 'false' -> {'blink',125,123}
<93,Prefix> when try let <_10> = call 'erlang':'=/=' (Prefix,'meta') in let <_11> = call 'erlang':'=/=' (Prefix,'search') in let <_12> = call 'erlang':'=/=' (Prefix,'search_meta') in let <_13> = call 'erlang':'and' (_11,_12) in call 'erlang':'and' (_10,_13) of <Try> -> Try catch <T,R> -> 'false' -> {'blink',93,91}
<66,'meta'> when 'true' -> 'backward_word'
<68,'meta'> when 'true' -> 'kill_word'
<70,'meta'> when 'true' -> 'forward_word'
<84,'meta'> when 'true' -> 'transpose_word'
<89,'meta'> when 'true' -> 'yank_pop'
<98,'meta'> when 'true' -> 'backward_word'
<100,'meta'> when 'true' -> 'kill_word'
<102,'meta'> when 'true' -> 'forward_word'
<116,'meta'> when 'true' -> 'transpose_word'
<121,'meta'> when 'true' -> 'yank_pop'
<79,'meta'> when 'true' -> 'meta_o'
<72,'meta_o'> when 'true' -> 'beginning_of_line'
<70,'meta_o'> when 'true' -> 'end_of_line'
<127,'none'> when 'true' -> 'backward_delete_char'
<127,'meta'> when 'true' -> 'backward_kill_word'
<91,'meta'> when 'true' -> 'meta_left_sq_bracket'
<72,'meta_left_sq_bracket'> when 'true' -> 'beginning_of_line'
<70,'meta_left_sq_bracket'> when 'true' -> 'end_of_line'
<68,'meta_left_sq_bracket'> when 'true' -> 'backward_char'
<67,'meta_left_sq_bracket'> when 'true' -> 'forward_char'
<27,'meta'> when 'true' -> 'meta_meta'
<91,'meta_meta'> when 'true' -> 'meta_csi'
<67,'meta_csi'> when 'true' -> 'forward_word'
<68,'meta_csi'> when 'true' -> 'backward_word'
<49,'meta_left_sq_bracket'> when 'true' -> {'csi',[49]}
<51,'meta_left_sq_bracket'> when 'true' -> {'csi',[51]}
<53,'meta_left_sq_bracket'> when 'true' -> {'csi',[53]}
<53,{'csi',[49|[59]]}> when 'true' -> {'csi',[49|[59|[53]]]}
<126,{'csi',[51]}> when 'true' -> 'forward_delete_char'
<67,{'csi',[53]}> when 'true' -> 'forward_word'
<67,{'csi',[49|[59|[53]]]}> when 'true' -> 'forward_word'
<68,{'csi',[53]}> when 'true' -> 'backward_word'
<68,{'csi',[49|[59|[53]]]}> when 'true' -> 'backward_word'
<59,{'csi',[49]}> when 'true' -> {'csi',[49|[59]]}
<C,'none'> when call 'erlang':'>=' (C,32) -> {'insert',C}
<8,'search'> when 'true' -> {'search','backward_delete_char'}
<127,'search'> when 'true' -> {'search','backward_delete_char'}
<18,'search'> when 'true' -> {'search','skip_up'}
<19,'search'> when 'true' -> {'search','skip_down'}
<10,'search'> when 'true' -> {'search','search_found'}
<13,'search'> when 'true' -> {'search','search_found'}
<1,'search'> when 'true' -> {'search','search_quit'}
<2,'search'> when 'true' -> {'search','search_quit'}
<4,'search'> when 'true' -> {'search','search_quit'}
<5,'search'> when 'true' -> {'search','search_quit'}
<6,'search'> when 'true' -> {'search','search_quit'}
<9,'search'> when 'true' -> {'search','search_quit'}
<12,'search'> when 'true' -> {'search','search_quit'}
<20,'search'> when 'true' -> {'search','search_quit'}
<21,'search'> when 'true' -> {'search','search_quit'}
<29,'search'> when 'true' -> {'search','search_quit'}
<24,'search'> when 'true' -> {'search','search_quit'}
<25,'search'> when 'true' -> {'search','search_quit'}
<27,'search'> when 'true' -> 'search_meta'
<91,'search_meta'> when 'true' -> 'search_meta_left_sq_bracket'
<_17,'search_meta'> when 'true' -> {'search','search_quit'}
<_X_C,'search_meta_left_sq_bracket'> when 'true' -> {'search','search_quit'}
<C,'search'> when 'true' -> {'insert_search',C}
<C,_18> when 'true' -> {'undefined',C} end
'do_op'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <{'insert',C},[],[],Rs> when 'true' -> {{[C|[]],[]},[{'put_chars','unicode',[C|[]]}|Rs]}
<{'insert',C},_@r0 = [Bef|Bef0],[],Rs> when 'true' -> case call 'string':'to_graphemes' ([Bef|[C|[]]]) of <[GC|[]]> when 'true' -> {{[GC|Bef0],[]},[{'put_chars','unicode',[C|[]]}|Rs]}
<_85> when 'true' -> {{[C|_@r0],[]},[{'put_chars','unicode',[C|[]]}|Rs]} end
<{'insert',C},[],Aft,Rs> when 'true' -> {{[C|[]],Aft},[{'insert_chars','unicode',[C|[]]}|Rs]}
<{'insert',C},_@r1 = [Bef|Bef0],Aft,Rs> when 'true' -> case call 'string':'to_graphemes' ([Bef|[C|[]]]) of <[GC|[]]> when 'true' -> {{[GC|Bef0],Aft},[{'insert_chars','unicode',[C|[]]}|Rs]}
<_86> when 'true' -> {{[C|_@r1],Aft},[{'insert_chars','unicode',[C|[]]}|Rs]} end
<{'insert_search',C},Bef,[],Rs> when 'true' -> let <_7> = [C|[39|[58|[32]]]] in {{[C|Bef],[39|[58|[32]]]},[{'insert_chars','unicode',_7}|[{'delete_chars',-3}|Rs]],'search'}
<{'insert_search',C},Bef,Aft,Rs> when 'true' -> let <Offset> = apply 'cp_len'/1 (Aft) in let <_11> = [C|[39|[58|[32]]]] in let <_12> = call 'erlang':'-' (Offset) in {{[C|Bef],[39|[58|[32]]]},[{'insert_chars','unicode',_11}|[{'delete_chars',_12}|Rs]],'search'}
<{'search','backward_delete_char'},[_87|Bef],Aft,Rs> when 'true' -> let <_13> = apply 'cp_len'/1 (Aft) in let <Offset> = call 'erlang':'+' (_13,1) in let <_16> = call 'erlang':'-' (Offset) in {{Bef,[39|[58|[32]]]},[{'insert_chars','unicode',[39|[58|[32]]]}|[{'delete_chars',_16}|Rs]],'search'}
<{'search','backward_delete_char'},[],_X_Aft,Rs> when 'true' -> {{[],[39|[58|[32]]]},Rs,'search'}
<{'search','skip_up'},Bef,Aft,Rs> when 'true' -> let <Offset> = apply 'cp_len'/1 (Aft) in let <_20> = call 'erlang':'-' (Offset) in {{[18|Bef],[39|[58|[32]]]},[{'insert_chars','unicode',[39|[58|[32]]]}|[{'delete_chars',_20}|Rs]],'search'}
<{'search','skip_down'},Bef,Aft,Rs> when 'true' -> let <Offset> = apply 'cp_len'/1 (Aft) in let <_23> = call 'erlang':'-' (Offset) in {{[19|Bef],[39|[58|[32]]]},[{'insert_chars','unicode',[39|[58|[32]]]}|[{'delete_chars',_23}|Rs]],'search'}
<{'search','search_found'},_X_Bef,Aft,Rs> when 'true' -> case Aft of <[39|[58|[32|NAft]]]> when 'true' -> let <_25> = apply 'cp_len'/1 (Aft) in let <_26> = call 'erlang':'-' (_25) in {{[],NAft},[{'put_chars','unicode',[10]}|[{'move_rel',_26}|Rs]],'search_found'}
(<_24> when 'true' -> primop 'match_fail' ({'badmatch',_24})-|['compiler_generated'] ) end
<{'search','search_quit'},_X_Bef,Aft,Rs> when 'true' -> case Aft of <[39|[58|[32|NAft]]]> when 'true' -> let <_28> = apply 'cp_len'/1 (Aft) in let <_29> = call 'erlang':'-' (_28) in {{[],NAft},[{'put_chars','unicode',[10]}|[{'move_rel',_29}|Rs]],'search_quit'}
(<_27> when 'true' -> primop 'match_fail' ({'badmatch',_27})-|['compiler_generated'] ) end
<{'blink',C,M},Bef = [36|[36|_88]],Aft,Rs> when 'true' -> let <N> = apply 'over_paren'/3 (Bef,C,M) in let <_33> = call 'erlang':'+' (N,1) in let <_31> = call 'erlang':'+' (N,1) in let <_32> = call 'erlang':'-' (_31) in {'blink',_33,{[C|Bef],Aft},[{'move_rel',_32}|[{'insert_chars','unicode',[C|[]]}|Rs]]}
<{'blink',C,_89},Bef = [36|_90],Aft,Rs> when 'true' -> apply 'do_op'/4 ({'insert',C},Bef,Aft,Rs)
<{'blink',C,M},Bef,Aft,Rs> when 'true' -> case apply 'over_paren'/3 (Bef,C,M) of <'beep'> when 'true' -> {{[C|Bef],Aft},['beep'|[{'insert_chars','unicode',[C|[]]}|Rs]]}
<N> when 'true' -> let <_36> = call 'erlang':'+' (N,1) in let <_34> = call 'erlang':'+' (N,1) in let <_35> = call 'erlang':'-' (_34) in {'blink',_36,{[C|Bef],Aft},[{'move_rel',_35}|[{'insert_chars','unicode',[C|[]]}|Rs]]} end
<'auto_blink',Bef,Aft,Rs> when 'true' -> case apply 'over_paren_auto'/1 (Bef) of <{N,Paren}> when 'true' -> let <_40> = call 'erlang':'+' (N,1) in let <_38> = call 'erlang':'+' (N,1) in let <_39> = call 'erlang':'-' (_38) in {'blink',_40,{[Paren|Bef],Aft},[{'move_rel',_39}|[{'insert_chars','unicode',[Paren|[]]}|Rs]]}
<N> when 'true' -> let <_43> = call 'erlang':'+' (N,1) in let <_41> = call 'erlang':'+' (N,1) in let <_42> = call 'erlang':'-' (_41) in {'blink',_43,{Bef,Aft},[{'move_rel',_42}|Rs]} end
<'forward_delete_char',Bef,[GC|Aft],Rs> when 'true' -> let <_45> = apply 'gc_len'/1 (GC) in {{Bef,Aft},[{'delete_chars',_45}|Rs]}
<'backward_delete_char',[GC|Bef],Aft,Rs> when 'true' -> let <_46> = apply 'gc_len'/1 (GC) in let <_47> = call 'erlang':'-' (_46) in {{Bef,Aft},[{'delete_chars',_47}|Rs]}
<'transpose_char',[C1|[C2|Bef]],[],Rs> when 'true' -> let <_49> = apply 'gc_len'/1 (C1) in let <_48> = apply 'gc_len'/1 (C2) in let <Len> = call 'erlang':'+' (_49,_48) in let <_51> = call 'erlang':'-' (Len) in {{[C2|[C1|Bef]],[]},[{'put_chars','unicode',[C1|[C2|[]]]}|[{'move_rel',_51}|Rs]]}
<'transpose_char',[C2|Bef],[C1|Aft],Rs> when 'true' -> let <Len> = apply 'gc_len'/1 (C2) in let <_53> = call 'erlang':'-' (Len) in {{[C2|[C1|Bef]],Aft},[{'put_chars','unicode',[C1|[C2|[]]]}|[{'move_rel',_53}|Rs]]}
<'kill_word',Bef,Aft0,Rs> when 'true' -> case apply 'over_non_word'/3 (Aft0,[],0) of <{Aft1,Kill0,N0}> when 'true' -> case apply 'over_word'/3 (Aft1,Kill0,N0) of <{Aft,Kill,N}> when 'true' -> let <_56> = call 'lists':'reverse' (Kill) in do call 'erlang':'put' ('kill_buffer',_56) {{Bef,Aft},[{'delete_chars',N}|Rs]}
(<_55> when 'true' -> primop 'match_fail' ({'badmatch',_55})-|['compiler_generated'] ) end
(<_54> when 'true' -> primop 'match_fail' ({'badmatch',_54})-|['compiler_generated'] ) end
<'backward_kill_word',Bef0,Aft,Rs> when 'true' -> case apply 'over_non_word'/3 (Bef0,[],0) of <{Bef1,Kill0,N0}> when 'true' -> case apply 'over_word'/3 (Bef1,Kill0,N0) of <{Bef,Kill,N}> when 'true' -> do call 'erlang':'put' ('kill_buffer',Kill) let <_59> = call 'erlang':'-' (N) in {{Bef,Aft},[{'delete_chars',_59}|Rs]}
(<_58> when 'true' -> primop 'match_fail' ({'badmatch',_58})-|['compiler_generated'] ) end
(<_57> when 'true' -> primop 'match_fail' ({'badmatch',_57})-|['compiler_generated'] ) end
<'kill_line',Bef,Aft,Rs> when 'true' -> do call 'erlang':'put' ('kill_buffer',Aft) let <_60> = apply 'cp_len'/1 (Aft) in {{Bef,[]},[{'delete_chars',_60}|Rs]}
<'yank',Bef,[],Rs> when 'true' -> let <Kill> = call 'erlang':'get' ('kill_buffer') in let <_62> = call 'lists':'reverse' (Kill,Bef) in {{_62,[]},[{'put_chars','unicode',Kill}|Rs]}
<'yank',Bef,Aft,Rs> when 'true' -> let <Kill> = call 'erlang':'get' ('kill_buffer') in let <_64> = call 'lists':'reverse' (Kill,Bef) in {{_64,Aft},[{'insert_chars','unicode',Kill}|Rs]}
<'forward_char',Bef,[C|Aft],Rs> when 'true' -> let <_65> = apply 'gc_len'/1 (C) in {{[C|Bef],Aft},[{'move_rel',_65}|Rs]}
<'backward_char',[C|Bef],Aft,Rs> when 'true' -> let <_66> = apply 'gc_len'/1 (C) in let <_67> = call 'erlang':'-' (_66) in {{Bef,[C|Aft]},[{'move_rel',_67}|Rs]}
<'forward_word',Bef0,Aft0,Rs> when 'true' -> case apply 'over_non_word'/3 (Aft0,Bef0,0) of <{Aft1,Bef1,N0}> when 'true' -> case apply 'over_word'/3 (Aft1,Bef1,N0) of <{Aft,Bef,N}> when 'true' -> {{Bef,Aft},[{'move_rel',N}|Rs]}
(<_69> when 'true' -> primop 'match_fail' ({'badmatch',_69})-|['compiler_generated'] ) end
(<_68> when 'true' -> primop 'match_fail' ({'badmatch',_68})-|['compiler_generated'] ) end
<'backward_word',Bef0,Aft0,Rs> when 'true' -> case apply 'over_non_word'/3 (Bef0,Aft0,0) of <{Bef1,Aft1,N0}> when 'true' -> case apply 'over_word'/3 (Bef1,Aft1,N0) of <{Bef,Aft,N}> when 'true' -> let <_72> = call 'erlang':'-' (N) in {{Bef,Aft},[{'move_rel',_72}|Rs]}
(<_71> when 'true' -> primop 'match_fail' ({'badmatch',_71})-|['compiler_generated'] ) end
(<_70> when 'true' -> primop 'match_fail' ({'badmatch',_70})-|['compiler_generated'] ) end
<'beginning_of_line',Bef = [_91|_92],Aft,Rs> when 'true' -> let <_75> = call 'lists':'reverse' (Bef,Aft) in let <_73> = apply 'cp_len'/1 (Bef) in let <_74> = call 'erlang':'-' (_73) in {{[],_75},[{'move_rel',_74}|Rs]}
<'beginning_of_line',[],Aft,Rs> when 'true' -> {{[],Aft},Rs}
<'end_of_line',Bef,Aft = [_93|_94],Rs> when 'true' -> let <_77> = call 'lists':'reverse' (Aft,Bef) in let <_76> = apply 'cp_len'/1 (Aft) in {{_77,[]},[{'move_rel',_76}|Rs]}
<'end_of_line',Bef,[],Rs> when 'true' -> {{Bef,[]},Rs}
<'ctlu',Bef,Aft,Rs> when 'true' -> let <_78> = call 'lists':'reverse' (Bef) in do call 'erlang':'put' ('kill_buffer',_78) let <_79> = apply 'cp_len'/1 (Bef) in let <_80> = call 'erlang':'-' (_79) in {{[],Aft},[{'delete_chars',_80}|Rs]}
<'beep',Bef,Aft,Rs> when 'true' -> {{Bef,Aft},['beep'|Rs]}
<_95,Bef,Aft,Rs> when 'true' -> {{Bef,Aft},['beep'|Rs]} end
'over_word'/3 = fun (_0,_1,_2) -> let <_7> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[39|_4]> when 'true' -> let <_6> = apply 'lc$^0'/1 (_4) in ([1|_6]-|['compiler_generated'] )
(<[_3|_4]> when 'true' -> apply 'lc$^0'/1 (_4)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_13> when 'true' -> (primop 'match_fail' ({'function_clause',_13})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in let <L> = call 'erlang':'length' (_7) in case call 'erlang':'rem' (L,2) of <0> when 'true' -> apply 'over_word1'/3 (_0,_1,_2)
<1> when 'true' -> apply 'until_quote'/3 (_0,_1,_2)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
'until_quote'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[39|Cs],Stack,N> when 'true' -> let <_3> = call 'erlang':'+' (N,1) in {Cs,[39|Stack],_3}
<[C|Cs],Stack,N> when 'true' -> let <_4> = apply 'gc_len'/1 (C) in let <_5> = call 'erlang':'+' (N,_4) in apply 'until_quote'/3 (Cs,[C|Stack],_5)
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'until_quote',3}}] )-|['compiler_generated'] ) end
'over_word1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[C = 39|Cs],Stack,N> when 'true' -> let <_3> = call 'erlang':'+' (N,1) in apply 'until_quote'/3 (Cs,[C|Stack],_3)
<Cs,Stack,N> when 'true' -> apply 'over_word2'/3 (Cs,Stack,N) end
'over_word2'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_@r0 = [C|Cs],Stack,N> when 'true' -> case apply 'word_char'/1 (C) of <'true'> when 'true' -> let <_3> = apply 'gc_len'/1 (C) in let <_4> = call 'erlang':'+' (N,_3) in apply 'over_word2'/3 (Cs,[C|Stack],_4)
<'false'> when 'true' -> {_@r0,Stack,N}
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<[],Stack,N> when call 'erlang':'is_integer' (N) -> {[],Stack,N}
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'over_word2',3}}] )-|['compiler_generated'] ) end
'over_non_word'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_@r0 = [C|Cs],Stack,N> when 'true' -> case apply 'word_char'/1 (C) of <'true'> when 'true' -> {_@r0,Stack,N}
<'false'> when 'true' -> let <_3> = apply 'gc_len'/1 (C) in let <_4> = call 'erlang':'+' (N,_3) in apply 'over_non_word'/3 (Cs,[C|Stack],_4)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<[],Stack,N> when 'true' -> {[],Stack,N}
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'over_non_word',3}}] )-|['compiler_generated'] ) end
'word_char'/1 = fun (_0) -> case _0 of <C> when let <_1> = call 'erlang':'>=' (_0,65) in let <_2> = call 'erlang':'=<' (_0,90) in call 'erlang':'and' (_1,_2) -> 'true'
<C> when try let <_3> = call 'erlang':'>=' (_0,192) in let <_4> = call 'erlang':'=<' (_0,222) in let <_5> = call 'erlang':'=/=' (_0,215) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<C> when let <_7> = call 'erlang':'>=' (_0,97) in let <_8> = call 'erlang':'=<' (_0,122) in call 'erlang':'and' (_7,_8) -> 'true'
<C> when try let <_9> = call 'erlang':'>=' (_0,223) in let <_10> = call 'erlang':'=<' (_0,255) in let <_11> = call 'erlang':'=/=' (_0,247) in let <_12> = call 'erlang':'and' (_10,_11) in call 'erlang':'and' (_9,_12) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<C> when let <_13> = call 'erlang':'>=' (_0,48) in let <_14> = call 'erlang':'=<' (_0,57) in call 'erlang':'and' (_13,_14) -> 'true'
<C> when call 'erlang':'=:=' (_0,95) -> 'true'
<[_16|_17]> when 'true' -> 'true'
<_18> when 'true' -> 'false' end
'over_paren'/3 = fun (_0,_1,_2) -> apply 'over_paren'/6 (_0,_1,_2,1,1,[])
'over_paren'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[C|[36|[36|Cs]]],Paren,Match,D,N,L> when 'true' -> let <_6> = call 'erlang':'+' (N,2) in apply 'over_paren'/6 ([C|Cs],Paren,Match,D,_6,L)
<[GC|[36|Cs]],Paren,Match,D,N,L> when 'true' -> let <_8> = call 'erlang':'+' (N,1) in let <_7> = apply 'gc_len'/1 (GC) in let <_9> = call 'erlang':'+' (_8,_7) in apply 'over_paren'/6 (Cs,Paren,Match,D,_9,L)
<[Match|_28],_X_Paren,_29,1,N,_30> when call 'erlang':'=:=' (_29,Match) -> N
<[Match|Cs],Paren,_31,D,N,[_32|L]> when let <_33> = call 'erlang':'=:=' (_31,Match) in let <_34> = call 'erlang':'=:=' (_32,Match) in call 'erlang':'and' (_33,_34) -> let <_11> = call 'erlang':'-' (D,1) in let <_10> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,_11,_10,L)
<[Paren|Cs],_35,Match,D,N,L> when call 'erlang':'=:=' (_35,Paren) -> let <_13> = call 'erlang':'+' (D,1) in let <_12> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,_13,_12,[Match|L])
<[41|Cs],Paren,Match,D,N,L> when 'true' -> let <_14> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,D,_14,[40|L])
<[93|Cs],Paren,Match,D,N,L> when 'true' -> let <_15> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,D,_15,[91|L])
<[125|Cs],Paren,Match,D,N,L> when 'true' -> let <_16> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,D,_16,[123|L])
<[40|Cs],Paren,Match,D,N,[40|L]> when 'true' -> let <_17> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,D,_17,L)
<[91|Cs],Paren,Match,D,N,[91|L]> when 'true' -> let <_18> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,D,_18,L)
<[123|Cs],Paren,Match,D,N,[123|L]> when 'true' -> let <_19> = call 'erlang':'+' (N,1) in apply 'over_paren'/6 (Cs,Paren,Match,D,_19,L)
<[40|_36],_37,_38,_39,_40,_41> when 'true' -> 'beep'
<[91|_42],_43,_44,_45,_46,_47> when 'true' -> 'beep'
<[123|_48],_49,_50,_51,_52,_53> when 'true' -> 'beep'
<[GC|Cs],Paren,Match,D,N,L> when 'true' -> let <_20> = apply 'gc_len'/1 (GC) in let <_21> = call 'erlang':'+' (N,_20) in apply 'over_paren'/6 (Cs,Paren,Match,D,_21,L)
<[],_54,_55,_56,_57,_58> when 'true' -> 0
(<_27,_26,_25,_24,_23,_22> when 'true' -> (primop 'match_fail' ({'function_clause',_27,_26,_25,_24,_23,_22})-|[{'function_name',{'over_paren',6}}] )-|['compiler_generated'] ) end
'over_paren_auto'/1 = fun (_0) -> apply 'over_paren_auto'/4 (_0,1,1,[])
'over_paren_auto'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[C|[36|[36|Cs]]],D,N,L> when 'true' -> let <_4> = call 'erlang':'+' (N,2) in apply 'over_paren_auto'/4 ([C|Cs],D,_4,L)
<[GC|[36|Cs]],D,N,L> when 'true' -> let <_6> = call 'erlang':'+' (N,1) in let <_5> = apply 'gc_len'/1 (GC) in let <_7> = call 'erlang':'+' (_6,_5) in apply 'over_paren_auto'/4 (Cs,D,_7,L)
<[40|_20],_21,N,[]> when 'true' -> {N,41}
<[91|_22],_23,N,[]> when 'true' -> {N,93}
<[123|_24],_25,N,[]> when 'true' -> {N,125}
<[41|Cs],D,N,L> when 'true' -> let <_8> = call 'erlang':'+' (N,1) in apply 'over_paren_auto'/4 (Cs,D,_8,[40|L])
<[93|Cs],D,N,L> when 'true' -> let <_9> = call 'erlang':'+' (N,1) in apply 'over_paren_auto'/4 (Cs,D,_9,[91|L])
<[125|Cs],D,N,L> when 'true' -> let <_10> = call 'erlang':'+' (N,1) in apply 'over_paren_auto'/4 (Cs,D,_10,[123|L])
<[40|Cs],D,N,[40|L]> when 'true' -> let <_11> = call 'erlang':'+' (N,1) in apply 'over_paren_auto'/4 (Cs,D,_11,L)
<[91|Cs],D,N,[91|L]> when 'true' -> let <_12> = call 'erlang':'+' (N,1) in apply 'over_paren_auto'/4 (Cs,D,_12,L)
<[123|Cs],D,N,[123|L]> when 'true' -> let <_13> = call 'erlang':'+' (N,1) in apply 'over_paren_auto'/4 (Cs,D,_13,L)
<[GC|Cs],D,N,L> when 'true' -> let <_14> = apply 'gc_len'/1 (GC) in let <_15> = call 'erlang':'+' (N,_14) in apply 'over_paren_auto'/4 (Cs,D,_15,L)
<[],_26,_27,_28> when 'true' -> 0
(<_19,_18,_17,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_19,_18,_17,_16})-|[{'function_name',{'over_paren_auto',4}}] )-|['compiler_generated'] ) end
'erase_line'/1 = fun (_0) -> case _0 of <{'line',Pbs,{Bef,Aft},_3}> when 'true' -> let <_1> = apply 'erase'/4 (Pbs,Bef,Aft,[]) in call 'lists':'reverse' (_1)
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'erase_line',1}}] )-|['compiler_generated'] ) end
'erase_inp'/1 = fun (_0) -> case _0 of <{'line',_3,{Bef,Aft},_4}> when 'true' -> let <_1> = apply 'erase'/4 ([],Bef,Aft,[]) in call 'lists':'reverse' (_1)
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'erase_inp',1}}] )-|['compiler_generated'] ) end
'erase'/4 = fun (_0,_1,_2,_3) -> let <_5> = apply 'cp_len'/1 (_0) in let <_6> = call 'erlang':'-' (_5) in let <_4> = apply 'cp_len'/1 (_1) in let <_7> = call 'erlang':'-' (_6,_4) in let <_8> = apply 'cp_len'/1 (_2) in [{'delete_chars',_7}|[{'delete_chars',_8}|_3]]
'redraw_line'/1 = fun (_0) -> case _0 of <{'line',Pbs,{Bef,Aft},_3}> when 'true' -> let <_1> = apply 'redraw'/4 (Pbs,Bef,Aft,[]) in call 'lists':'reverse' (_1)
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'redraw_line',1}}] )-|['compiler_generated'] ) end
'redraw'/4 = fun (_0,_1,_2,_3) -> let <_4> = apply 'cp_len'/1 (_2) in let <_5> = call 'erlang':'-' (_4) in let <_6> = call 'lists':'reverse' (_1,_2) in [{'move_rel',_5}|[{'put_chars','unicode',_6}|[{'put_chars','unicode',_0}|_3]]]
'length_before'/1 = fun (_0) -> case _0 of <{'line',Pbs,{Bef,_X_Aft},_4}> when 'true' -> let <_2> = apply 'cp_len'/1 (Pbs) in let <_1> = apply 'cp_len'/1 (Bef) in call 'erlang':'+' (_2,_1)
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'length_before',1}}] )-|['compiler_generated'] ) end
'length_after'/1 = fun (_0) -> case _0 of <{'line',_2,{_X_Bef,Aft},_3}> when 'true' -> apply 'cp_len'/1 (Aft)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'length_after',1}}] )-|['compiler_generated'] ) end
'prompt'/1 = fun (_0) -> case _0 of <{'line',Pbs,_2,_3}> when 'true' -> Pbs
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'prompt',1}}] )-|['compiler_generated'] ) end
'current_line'/1 = fun (_0) -> case _0 of <{'line',_3,{Bef,Aft},_4}> when 'true' -> let <_1> = call 'erlang':'++' (Aft,[10]) in apply 'get_line'/2 (Bef,_1)
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'current_line',1}}] )-|['compiler_generated'] ) end
'current_chars'/1 = fun (_0) -> case _0 of <{'line',_2,{Bef,Aft},_3}> when 'true' -> apply 'get_line'/2 (Bef,Aft)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'current_chars',1}}] )-|['compiler_generated'] ) end
'get_line'/2 = fun (_0,_1) -> let <_2> = call 'lists':'reverse' (_0,_1) in call 'unicode':'characters_to_list' (_2)
'gc_len'/1 = fun (_0) -> case _0 of <CP> when call 'erlang':'is_integer' (_0) -> 1
<CPs> when call 'erlang':'is_list' (_0) -> call 'erlang':'length' (CPs)
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'gc_len',1}}] )-|['compiler_generated'] ) end
'cp_len'/1 = fun (_0) -> apply 'cp_len'/2 (_0,0)
'cp_len'/2 = fun (_0,_1) -> case <_0,_1> of <[GC|R],Len> when 'true' -> let <_2> = apply 'gc_len'/1 (GC) in let <_3> = call 'erlang':'+' (Len,_2) in apply 'cp_len'/2 (R,_3)
<[],Len> when 'true' -> Len
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'cp_len',2}}] )-|['compiler_generated'] ) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('edlin')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('edlin',_0) end