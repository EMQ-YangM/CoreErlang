module 'io_lib' ['build_text'/1,'build_text'/2,'char_list'/1,'chars_length'/1,'collect_chars'/3,'collect_chars'/4,'collect_line'/3,'collect_line'/4,'deep_char_list'/1,'deep_latin1_char_list'/1,'deep_unicode_char_list'/1,'format'/2,'format'/3,'format_prompt'/1,'format_prompt'/2,'fread'/2,'fread'/3,'fwrite'/2,'fwrite'/3,'get_until'/3,'get_until'/4,'indentation'/2,'latin1_char_list'/1,'limit_term'/2,'module_info'/0,'module_info'/1,'nl'/0,'print'/1,'print'/4,'printable_latin1_list'/1,'printable_list'/1,'printable_unicode_list'/1,'quote_atom'/2,'scan_format'/2,'unscan_format'/1,'write'/1,'write'/2,'write'/3,'write_atom'/1,'write_atom_as_latin1'/1,'write_binary'/3,'write_char'/1,'write_char_as_latin1'/1,'write_latin1_char'/1,'write_latin1_string'/1,'write_latin1_string'/2,'write_string'/1,'write_string'/2,'write_string_as_latin1'/1,'write_string_as_latin1'/2,'write_unicode_char'/1,'write_unicode_string'/1] attributes [ 'file' = [{[115|[114|[99|[47|[105|[111|[95|[108|[105|[98|[46|[101|[114|[108]]]]]]]]]]]]]],1}]
, 'export_type' = [{'chars',0}|[{'latin1_string',0}|[{'continuation',0}|[{'fread_error',0}|[{'fread_item',0}|[{'format_spec',0}|[{'chars_limit',0}]]]]]]]
, 'type' = [{'chars',{'type',97,'list',[{'type',97,'union',[{'type',97,'char',[]}|[{'user_type',97,'chars',[]}]]}]},[]}]
, 'type' = [{'latin1_string',{'type',98,'list',[{'remote_type',98,[{'atom',98,'unicode'}|[{'atom',98,'latin1_char'}|[[]]]]}]},[]}]
, 'type' = [{'depth',{'type',99,'union',[{'op',99,'-',{'integer',99,1}}|[{'type',99,'non_neg_integer',[]}]]},[]}]
, 'opaque' = [{'continuation',{'type',101,'tuple',[{'ann_type',101,[{'var',101,'Format'}|[{'type',101,'string',[]}]]}|[{'ann_type',102,[{'var',102,'Stack'}|[{'user_type',102,'chars',[]}]]}|[{'ann_type',103,[{'var',103,'Nchars'}|[{'type',103,'non_neg_integer',[]}]]}|[{'ann_type',104,[{'var',104,'Results'}|[{'type',104,'list',[{'type',104,'term',[]}]}]]}]]]]},[]}]
, 'type' = [{'fread_error',{'type',106,'union',[{'atom',106,'atom'}|[{'atom',107,'based'}|[{'atom',108,'character'}|[{'atom',109,'float'}|[{'atom',110,'format'}|[{'atom',111,'input'}|[{'atom',112,'integer'}|[{'atom',113,'string'}|[{'atom',114,'unsigned'}]]]]]]]]]},[]}]
, 'type' = [{'fread_item',{'type',116,'union',[{'type',116,'string',[]}|[{'type',116,'atom',[]}|[{'type',116,'integer',[]}|[{'type',116,'float',[]}]]]]},[]}]
, 'type' = [{'format_spec',{'type',119,'map',[{'type',120,'map_field_exact',[{'atom',120,'control_char'}|[{'type',120,'char',[]}]]}|[{'type',121,'map_field_exact',[{'atom',121,'args'}|[{'type',121,'list',[{'type',121,'any',[]}]}]]}|[{'type',122,'map_field_exact',[{'atom',122,'width'}|[{'type',122,'union',[{'atom',122,'none'}|[{'type',122,'integer',[]}]]}]]}|[{'type',123,'map_field_exact',[{'atom',123,'adjust'}|[{'type',123,'union',[{'atom',123,'left'}|[{'atom',123,'right'}]]}]]}|[{'type',124,'map_field_exact',[{'atom',124,'precision'}|[{'type',124,'union',[{'atom',124,'none'}|[{'type',124,'integer',[]}]]}]]}|[{'type',125,'map_field_exact',[{'atom',125,'pad_char'}|[{'type',125,'char',[]}]]}|[{'type',126,'map_field_exact',[{'atom',126,'encoding'}|[{'type',126,'union',[{'atom',126,'unicode'}|[{'atom',126,'latin1'}]]}]]}|[{'type',127,'map_field_exact',[{'atom',127,'strings'}|[{'type',127,'boolean',[]}]]}]]]]]]]]},[]}]
, 'spec' = [{{'fwrite',2},[{'type',134,'bounded_fun',[{'type',134,'fun',[{'type',134,'product',[{'var',134,'Format'}|[{'var',134,'Data'}]]}|[{'user_type',134,'chars',[]}]]}|[[{'type',135,'constraint',[{'atom',135,'is_subtype'}|[[{'var',135,'Format'}|[{'remote_type',135,[{'atom',135,'io'}|[{'atom',135,'format'}|[[]]]]}]]]]}|[{'type',136,'constraint',[{'atom',136,'is_subtype'}|[[{'var',136,'Data'}|[{'type',136,'list',[{'type',136,'term',[]}]}]]]]}]]]]}]}]
, 'type' = [{'chars_limit',{'type',141,'integer',[]},[]}]
, 'spec' = [{{'fwrite',3},[{'type',143,'bounded_fun',[{'type',143,'fun',[{'type',143,'product',[{'var',143,'Format'}|[{'var',143,'Data'}|[{'var',143,'Options'}]]]}|[{'user_type',143,'chars',[]}]]}|[[{'type',144,'constraint',[{'atom',144,'is_subtype'}|[[{'var',144,'Format'}|[{'remote_type',144,[{'atom',144,'io'}|[{'atom',144,'format'}|[[]]]]}]]]]}|[{'type',145,'constraint',[{'atom',145,'is_subtype'}|[[{'var',145,'Data'}|[{'type',145,'list',[{'type',145,'term',[]}]}]]]]}|[{'type',146,'constraint',[{'atom',146,'is_subtype'}|[[{'var',146,'Options'}|[{'type',146,'list',[{'var',146,'Option'}]}]]]]}|[{'type',147,'constraint',[{'atom',147,'is_subtype'}|[[{'var',147,'Option'}|[{'type',147,'tuple',[{'atom',147,'chars_limit'}|[{'var',147,'CharsLimit'}]]}]]]]}|[{'type',148,'constraint',[{'atom',148,'is_subtype'}|[[{'var',148,'CharsLimit'}|[{'user_type',148,'chars_limit',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'fread',2},[{'type',153,'bounded_fun',[{'type',153,'fun',[{'type',153,'product',[{'var',153,'Format'}|[{'var',153,'String'}]]}|[{'var',153,'Result'}]]}|[[{'type',154,'constraint',[{'atom',154,'is_subtype'}|[[{'var',154,'Format'}|[{'type',154,'string',[]}]]]]}|[{'type',155,'constraint',[{'atom',155,'is_subtype'}|[[{'var',155,'String'}|[{'type',155,'string',[]}]]]]}|[{'type',156,'constraint',[{'atom',156,'is_subtype'}|[[{'var',156,'Result'}|[{'type',156,'union',[{'type',156,'tuple',[{'atom',156,'ok'}|[{'ann_type',156,[{'var',156,'InputList'}|[{'type',156,'list',[{'user_type',156,'fread_item',[]}]}]]}|[{'ann_type',156,[{'var',156,'LeftOverChars'}|[{'type',156,'string',[]}]]}]]]}|[{'type',157,'tuple',[{'atom',157,'more'}|[{'ann_type',157,[{'var',157,'RestFormat'}|[{'type',157,'string',[]}]]}|[{'ann_type',158,[{'var',158,'Nchars'}|[{'type',158,'non_neg_integer',[]}]]}|[{'ann_type',159,[{'var',159,'InputStack'}|[{'user_type',159,'chars',[]}]]}]]]]}|[{'type',160,'tuple',[{'atom',160,'error'}|[{'type',160,'tuple',[{'atom',160,'fread'}|[{'ann_type',160,[{'var',160,'What'}|[{'user_type',160,'fread_error',[]}]]}]]}]]}]]]}]]]]}]]]]]}]}]
, 'spec' = [{{'fread',3},[{'type',165,'bounded_fun',[{'type',165,'fun',[{'type',165,'product',[{'var',165,'Continuation'}|[{'var',165,'CharSpec'}|[{'var',165,'Format'}]]]}|[{'var',165,'Return'}]]}|[[{'type',166,'constraint',[{'atom',166,'is_subtype'}|[[{'var',166,'Continuation'}|[{'type',166,'union',[{'user_type',166,'continuation',[]}|[{'type',166,'nil',[]}]]}]]]]}|[{'type',167,'constraint',[{'atom',167,'is_subtype'}|[[{'var',167,'CharSpec'}|[{'type',167,'union',[{'type',167,'string',[]}|[{'atom',167,'eof'}]]}]]]]}|[{'type',168,'constraint',[{'atom',168,'is_subtype'}|[[{'var',168,'Format'}|[{'type',168,'string',[]}]]]]}|[{'type',169,'constraint',[{'atom',169,'is_subtype'}|[[{'var',169,'Return'}|[{'type',169,'union',[{'type',169,'tuple',[{'atom',169,'more'}|[{'ann_type',169,[{'var',169,'Continuation1'}|[{'user_type',169,'continuation',[]}]]}]]}|[{'type',170,'tuple',[{'atom',170,'done'}|[{'var',170,'Result'}|[{'ann_type',170,[{'var',170,'LeftOverChars'}|[{'type',170,'string',[]}]]}]]]}]]}]]]]}|[{'type',171,'constraint',[{'atom',171,'is_subtype'}|[[{'var',171,'Result'}|[{'type',171,'union',[{'type',171,'tuple',[{'atom',171,'ok'}|[{'ann_type',171,[{'var',171,'InputList'}|[{'type',171,'list',[{'user_type',171,'fread_item',[]}]}]]}]]}|[{'atom',172,'eof'}|[{'type',173,'tuple',[{'atom',173,'error'}|[{'type',173,'tuple',[{'atom',173,'fread'}|[{'ann_type',173,[{'var',173,'What'}|[{'user_type',173,'fread_error',[]}]]}]]}]]}]]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'format',2},[{'type',178,'bounded_fun',[{'type',178,'fun',[{'type',178,'product',[{'var',178,'Format'}|[{'var',178,'Data'}]]}|[{'user_type',178,'chars',[]}]]}|[[{'type',179,'constraint',[{'atom',179,'is_subtype'}|[[{'var',179,'Format'}|[{'remote_type',179,[{'atom',179,'io'}|[{'atom',179,'format'}|[[]]]]}]]]]}|[{'type',180,'constraint',[{'atom',180,'is_subtype'}|[[{'var',180,'Data'}|[{'type',180,'list',[{'type',180,'term',[]}]}]]]]}]]]]}]}]
, 'spec' = [{{'format',3},[{'type',190,'bounded_fun',[{'type',190,'fun',[{'type',190,'product',[{'var',190,'Format'}|[{'var',190,'Data'}|[{'var',190,'Options'}]]]}|[{'user_type',190,'chars',[]}]]}|[[{'type',191,'constraint',[{'atom',191,'is_subtype'}|[[{'var',191,'Format'}|[{'remote_type',191,[{'atom',191,'io'}|[{'atom',191,'format'}|[[]]]]}]]]]}|[{'type',192,'constraint',[{'atom',192,'is_subtype'}|[[{'var',192,'Data'}|[{'type',192,'list',[{'type',192,'term',[]}]}]]]]}|[{'type',193,'constraint',[{'atom',193,'is_subtype'}|[[{'var',193,'Options'}|[{'type',193,'list',[{'var',193,'Option'}]}]]]]}|[{'type',194,'constraint',[{'atom',194,'is_subtype'}|[[{'var',194,'Option'}|[{'type',194,'tuple',[{'atom',194,'chars_limit'}|[{'var',194,'CharsLimit'}]]}]]]]}|[{'type',195,'constraint',[{'atom',195,'is_subtype'}|[[{'var',195,'CharsLimit'}|[{'user_type',195,'chars_limit',[]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'scan_format',2},[{'type',205,'bounded_fun',[{'type',205,'fun',[{'type',205,'product',[{'var',205,'Format'}|[{'var',205,'Data'}]]}|[{'var',205,'FormatList'}]]}|[[{'type',206,'constraint',[{'atom',206,'is_subtype'}|[[{'var',206,'Format'}|[{'remote_type',206,[{'atom',206,'io'}|[{'atom',206,'format'}|[[]]]]}]]]]}|[{'type',207,'constraint',[{'atom',207,'is_subtype'}|[[{'var',207,'Data'}|[{'type',207,'list',[{'type',207,'term',[]}]}]]]]}|[{'type',208,'constraint',[{'atom',208,'is_subtype'}|[[{'var',208,'FormatList'}|[{'type',208,'list',[{'type',208,'union',[{'type',208,'char',[]}|[{'user_type',208,'format_spec',[]}]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'unscan_format',1},[{'type',218,'bounded_fun',[{'type',218,'fun',[{'type',218,'product',[{'var',218,'FormatList'}]}|[{'type',218,'tuple',[{'var',218,'Format'}|[{'var',218,'Data'}]]}]]}|[[{'type',219,'constraint',[{'atom',219,'is_subtype'}|[[{'var',219,'FormatList'}|[{'type',219,'list',[{'type',219,'union',[{'type',219,'char',[]}|[{'user_type',219,'format_spec',[]}]]}]}]]]]}|[{'type',220,'constraint',[{'atom',220,'is_subtype'}|[[{'var',220,'Format'}|[{'remote_type',220,[{'atom',220,'io'}|[{'atom',220,'format'}|[[]]]]}]]]]}|[{'type',221,'constraint',[{'atom',221,'is_subtype'}|[[{'var',221,'Data'}|[{'type',221,'list',[{'type',221,'term',[]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'build_text',1},[{'type',226,'bounded_fun',[{'type',226,'fun',[{'type',226,'product',[{'var',226,'FormatList'}]}|[{'user_type',226,'chars',[]}]]}|[[{'type',227,'constraint',[{'atom',227,'is_subtype'}|[[{'var',227,'FormatList'}|[{'type',227,'list',[{'type',227,'union',[{'type',227,'char',[]}|[{'user_type',227,'format_spec',[]}]]}]}]]]]}]]]}]}]
, 'spec' = [{{'build_text',2},[{'type',237,'bounded_fun',[{'type',237,'fun',[{'type',237,'product',[{'var',237,'FormatList'}|[{'var',237,'Options'}]]}|[{'user_type',237,'chars',[]}]]}|[[{'type',238,'constraint',[{'atom',238,'is_subtype'}|[[{'var',238,'FormatList'}|[{'type',238,'list',[{'type',238,'union',[{'type',238,'char',[]}|[{'user_type',238,'format_spec',[]}]]}]}]]]]}|[{'type',239,'constraint',[{'atom',239,'is_subtype'}|[[{'var',239,'Options'}|[{'type',239,'list',[{'var',239,'Option'}]}]]]]}|[{'type',240,'constraint',[{'atom',240,'is_subtype'}|[[{'var',240,'Option'}|[{'type',240,'tuple',[{'atom',240,'chars_limit'}|[{'var',240,'CharsLimit'}]]}]]]]}|[{'type',241,'constraint',[{'atom',241,'is_subtype'}|[[{'var',241,'CharsLimit'}|[{'user_type',241,'chars_limit',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'print',1},[{'type',262,'bounded_fun',[{'type',262,'fun',[{'type',262,'product',[{'var',262,'Term'}]}|[{'user_type',262,'chars',[]}]]}|[[{'type',263,'constraint',[{'atom',263,'is_subtype'}|[[{'var',263,'Term'}|[{'type',263,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'print',4},[{'type',268,'bounded_fun',[{'type',268,'fun',[{'type',268,'product',[{'var',268,'Term'}|[{'var',268,'Column'}|[{'var',268,'LineLength'}|[{'var',268,'Depth'}]]]]}|[{'user_type',268,'chars',[]}]]}|[[{'type',269,'constraint',[{'atom',269,'is_subtype'}|[[{'var',269,'Term'}|[{'type',269,'term',[]}]]]]}|[{'type',270,'constraint',[{'atom',270,'is_subtype'}|[[{'var',270,'Column'}|[{'type',270,'non_neg_integer',[]}]]]]}|[{'type',271,'constraint',[{'atom',271,'is_subtype'}|[[{'var',271,'LineLength'}|[{'type',271,'non_neg_integer',[]}]]]]}|[{'type',272,'constraint',[{'atom',272,'is_subtype'}|[[{'var',272,'Depth'}|[{'user_type',272,'depth',[]}]]]]}]]]]]]}]}]
, 'spec' = [{{'indentation',2},[{'type',277,'bounded_fun',[{'type',277,'fun',[{'type',277,'product',[{'var',277,'String'}|[{'var',277,'StartIndent'}]]}|[{'type',277,'integer',[]}]]}|[[{'type',278,'constraint',[{'atom',278,'is_subtype'}|[[{'var',278,'String'}|[{'type',278,'string',[]}]]]]}|[{'type',279,'constraint',[{'atom',279,'is_subtype'}|[[{'var',279,'StartIndent'}|[{'type',279,'integer',[]}]]]]}]]]]}]}]
, 'spec' = [{{'format_prompt',1},[{'type',289,'fun',[{'type',289,'product',[{'type',289,'term',[]}]}|[{'user_type',289,'chars',[]}]]}]}]
, 'spec' = [{{'format_prompt',2},[{'type',294,'fun',[{'type',294,'product',[{'type',294,'term',[]}|[{'type',294,'atom',[]}]]}|[{'user_type',294,'chars',[]}]]}]}]
, 'spec' = [{{'write',1},[{'type',321,'bounded_fun',[{'type',321,'fun',[{'type',321,'product',[{'var',321,'Term'}]}|[{'user_type',321,'chars',[]}]]}|[[{'type',322,'constraint',[{'atom',322,'is_subtype'}|[[{'var',322,'Term'}|[{'type',322,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'write',3},[{'type',327,'fun',[{'type',327,'product',[{'type',327,'term',[]}|[{'user_type',327,'depth',[]}|[{'type',327,'boolean',[]}]]]}|[{'user_type',327,'chars',[]}]]}]}]
, 'spec' = [{{'write',2},[{'type',334,'bounded_fun',[{'type',334,'fun',[{'type',334,'product',[{'var',334,'Term'}|[{'var',334,'Depth'}]]}|[{'user_type',334,'chars',[]}]]}|[[{'type',335,'constraint',[{'atom',335,'is_subtype'}|[[{'var',335,'Term'}|[{'type',335,'term',[]}]]]]}|[{'type',336,'constraint',[{'atom',336,'is_subtype'}|[[{'var',336,'Depth'}|[{'user_type',336,'depth',[]}]]]]}]]]]}|[{'type',337,'bounded_fun',[{'type',337,'fun',[{'type',337,'product',[{'var',337,'Term'}|[{'var',337,'Options'}]]}|[{'user_type',337,'chars',[]}]]}|[[{'type',338,'constraint',[{'atom',338,'is_subtype'}|[[{'var',338,'Term'}|[{'type',338,'term',[]}]]]]}|[{'type',339,'constraint',[{'atom',339,'is_subtype'}|[[{'var',339,'Options'}|[{'type',339,'list',[{'var',339,'Option'}]}]]]]}|[{'type',340,'constraint',[{'atom',340,'is_subtype'}|[[{'var',340,'Option'}|[{'type',340,'union',[{'type',340,'tuple',[{'atom',340,'chars_limit'}|[{'var',340,'CharsLimit'}]]}|[{'type',341,'tuple',[{'atom',341,'depth'}|[{'var',341,'Depth'}]]}|[{'type',342,'tuple',[{'atom',342,'encoding'}|[{'type',342,'union',[{'atom',342,'latin1'}|[{'atom',342,'utf8'}|[{'atom',342,'unicode'}]]]}]]}]]]}]]]]}|[{'type',343,'constraint',[{'atom',343,'is_subtype'}|[[{'var',343,'CharsLimit'}|[{'user_type',343,'chars_limit',[]}]]]]}|[{'type',344,'constraint',[{'atom',344,'is_subtype'}|[[{'var',344,'Depth'}|[{'user_type',344,'depth',[]}]]]]}]]]]]]]}]]}]
, 'spec' = [{{'write_atom',1},[{'type',480,'bounded_fun',[{'type',480,'fun',[{'type',480,'product',[{'var',480,'Atom'}]}|[{'user_type',480,'chars',[]}]]}|[[{'type',481,'constraint',[{'atom',481,'is_subtype'}|[[{'var',481,'Atom'}|[{'type',481,'atom',[]}]]]]}]]]}]}]
, 'spec' = [{{'write_atom_as_latin1',1},[{'type',486,'bounded_fun',[{'type',486,'fun',[{'type',486,'product',[{'var',486,'Atom'}]}|[{'user_type',486,'latin1_string',[]}]]}|[[{'type',487,'constraint',[{'atom',487,'is_subtype'}|[[{'var',487,'Atom'}|[{'type',487,'atom',[]}]]]]}]]]}]}]
, 'spec' = [{{'quote_atom',2},[{'type',505,'fun',[{'type',505,'product',[{'type',505,'atom',[]}|[{'user_type',505,'chars',[]}]]}|[{'type',505,'boolean',[]}]]}]}]
, 'spec' = [{{'write_string',1},[{'type',544,'bounded_fun',[{'type',544,'fun',[{'type',544,'product',[{'var',544,'String'}]}|[{'user_type',544,'chars',[]}]]}|[[{'type',545,'constraint',[{'atom',545,'is_subtype'}|[[{'var',545,'String'}|[{'type',545,'string',[]}]]]]}]]]}]}]
, 'spec' = [{{'write_string',2},[{'type',550,'fun',[{'type',550,'product',[{'type',550,'string',[]}|[{'type',550,'char',[]}]]}|[{'user_type',550,'chars',[]}]]}]}]
, 'spec' = [{{'write_latin1_string',1},[{'type',559,'bounded_fun',[{'type',559,'fun',[{'type',559,'product',[{'var',559,'Latin1String'}]}|[{'user_type',559,'latin1_string',[]}]]}|[[{'type',560,'constraint',[{'atom',560,'is_subtype'}|[[{'var',560,'Latin1String'}|[{'user_type',560,'latin1_string',[]}]]]]}]]]}]}]
, 'spec' = [{{'write_latin1_string',2},[{'type',565,'fun',[{'type',565,'product',[{'user_type',565,'latin1_string',[]}|[{'type',565,'char',[]}]]}|[{'user_type',565,'latin1_string',[]}]]}]}]
, 'spec' = [{{'write_string_as_latin1',1},[{'type',570,'bounded_fun',[{'type',570,'fun',[{'type',570,'product',[{'var',570,'String'}]}|[{'user_type',570,'latin1_string',[]}]]}|[[{'type',571,'constraint',[{'atom',571,'is_subtype'}|[[{'var',571,'String'}|[{'type',571,'string',[]}]]]]}]]]}]}]
, 'spec' = [{{'write_string_as_latin1',2},[{'type',576,'fun',[{'type',576,'product',[{'type',576,'string',[]}|[{'type',576,'char',[]}]]}|[{'user_type',576,'latin1_string',[]}]]}]}]
, 'spec' = [{{'write_char',1},[{'type',621,'bounded_fun',[{'type',621,'fun',[{'type',621,'product',[{'var',621,'Char'}]}|[{'user_type',621,'chars',[]}]]}|[[{'type',622,'constraint',[{'atom',622,'is_subtype'}|[[{'var',622,'Char'}|[{'type',622,'char',[]}]]]]}]]]}]}]
, 'spec' = [{{'write_latin1_char',1},[{'type',632,'bounded_fun',[{'type',632,'fun',[{'type',632,'product',[{'var',632,'Latin1Char'}]}|[{'user_type',632,'latin1_string',[]}]]}|[[{'type',633,'constraint',[{'atom',633,'is_subtype'}|[[{'var',633,'Latin1Char'}|[{'remote_type',633,[{'atom',633,'unicode'}|[{'atom',633,'latin1_char'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'write_char_as_latin1',1},[{'type',638,'bounded_fun',[{'type',638,'fun',[{'type',638,'product',[{'var',638,'Char'}]}|[{'user_type',638,'latin1_string',[]}]]}|[[{'type',639,'constraint',[{'atom',639,'is_subtype'}|[[{'var',639,'Char'}|[{'type',639,'char',[]}]]]]}]]]}]}]
, 'spec' = [{{'latin1_char_list',1},[{'type',649,'bounded_fun',[{'type',649,'fun',[{'type',649,'product',[{'var',649,'Term'}]}|[{'type',649,'boolean',[]}]]}|[[{'type',650,'constraint',[{'atom',650,'is_subtype'}|[[{'var',650,'Term'}|[{'type',650,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'char_list',1},[{'type',657,'bounded_fun',[{'type',657,'fun',[{'type',657,'product',[{'var',657,'Term'}]}|[{'type',657,'boolean',[]}]]}|[[{'type',658,'constraint',[{'atom',658,'is_subtype'}|[[{'var',658,'Term'}|[{'type',658,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'deep_latin1_char_list',1},[{'type',667,'bounded_fun',[{'type',667,'fun',[{'type',667,'product',[{'var',667,'Term'}]}|[{'type',667,'boolean',[]}]]}|[[{'type',668,'constraint',[{'atom',668,'is_subtype'}|[[{'var',668,'Term'}|[{'type',668,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'deep_char_list',1},[{'type',683,'bounded_fun',[{'type',683,'fun',[{'type',683,'product',[{'var',683,'Term'}]}|[{'type',683,'boolean',[]}]]}|[[{'type',684,'constraint',[{'atom',684,'is_subtype'}|[[{'var',684,'Term'}|[{'type',684,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'printable_latin1_list',1},[{'type',709,'bounded_fun',[{'type',709,'fun',[{'type',709,'product',[{'var',709,'Term'}]}|[{'type',709,'boolean',[]}]]}|[[{'type',710,'constraint',[{'atom',710,'is_subtype'}|[[{'var',710,'Term'}|[{'type',710,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'printable_list',1},[{'type',737,'bounded_fun',[{'type',737,'fun',[{'type',737,'product',[{'var',737,'Term'}]}|[{'type',737,'boolean',[]}]]}|[[{'type',738,'constraint',[{'atom',738,'is_subtype'}|[[{'var',738,'Term'}|[{'type',738,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'printable_unicode_list',1},[{'type',750,'bounded_fun',[{'type',750,'fun',[{'type',750,'product',[{'var',750,'Term'}]}|[{'type',750,'boolean',[]}]]}|[[{'type',751,'constraint',[{'atom',751,'is_subtype'}|[[{'var',751,'Term'}|[{'type',751,'term',[]}]]]]}]]]}]}]
, 'spec' = [{{'nl',0},[{'type',773,'fun',[{'type',773,'product',[]}|[{'type',773,'string',[]}]]}]}]
, 'spec' = [{{'limit_term',2},[{'type',994,'fun',[{'type',994,'product',[{'type',994,'term',[]}|[{'type',994,'non_neg_integer',[]}]]}|[{'type',994,'term',[]}]]}]}]
, 'spec' = [{{'chars_length',1},[{'type',1123,'fun',[{'type',1123,'product',[{'user_type',1123,'chars',[]}]}|[{'type',1123,'non_neg_integer',[]}]]}]}] ] 'fwrite'/2 = fun (_0,_1) -> apply 'format'/2 (_0,_1)
'fwrite'/3 = fun (_0,_1,_2) -> apply 'format'/3 (_0,_1,_2)
'fread'/2 = fun (_0,_1) -> call 'io_lib_fread':'fread' (_0,_1)
'fread'/3 = fun (_0,_1,_2) -> call 'io_lib_fread':'fread' (_0,_1,_2)
'format'/2 = fun (_0,_1) -> try call 'io_lib_format':'fwrite' (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> let <S> = primop 'build_stacktrace' (_3) in do apply 'test_modules_loaded'/3 (_5,_4,S) call 'erlang':'error' ('badarg',[_0|[_1|[]]])
'format'/3 = fun (_0,_1,_2) -> try call 'io_lib_format':'fwrite' (_0,_1,_2) of <_3> -> _3 catch <_6,_5,_4> -> let <S> = primop 'build_stacktrace' (_4) in do apply 'test_modules_loaded'/3 (_6,_5,S) call 'erlang':'error' ('badarg',[_0|[_1|[]]])
'scan_format'/2 = fun (_0,_1) -> try call 'io_lib_format':'scan' (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> let <S> = primop 'build_stacktrace' (_3) in do apply 'test_modules_loaded'/3 (_5,_4,S) call 'erlang':'error' ('badarg',[_0|[_1|[]]])
'unscan_format'/1 = fun (_0) -> call 'io_lib_format':'unscan' (_0)
'build_text'/1 = fun (_0) -> try call 'io_lib_format':'build' (_0) of <_1> -> _1 catch <_4,_3,_2> -> let <S> = primop 'build_stacktrace' (_2) in do apply 'test_modules_loaded'/3 (_4,_3,S) call 'erlang':'error' ('badarg',[_0|[]])
'build_text'/2 = fun (_0,_1) -> try call 'io_lib_format':'build' (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> let <S> = primop 'build_stacktrace' (_3) in do apply 'test_modules_loaded'/3 (_5,_4,S) call 'erlang':'error' ('badarg',[_0|[_1|[]]])
'test_modules_loaded'/3 = fun (_0,_1,_2) -> case call 'code':'ensure_modules_loaded' (['io_lib_format'|['io_lib_pretty'|['string'|['unicode']]]]) of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> call 'erlang':'error' (Error) end
'print'/1 = fun (_0) -> call 'io_lib_pretty':'print' (_0)
'print'/4 = fun (_0,_1,_2,_3) -> call 'io_lib_pretty':'print' (_0,_1,_2,_3)
'indentation'/2 = fun (_0,_1) -> call 'io_lib_format':'indentation' (_0,_1)
'format_prompt'/1 = fun (_0) -> apply 'format_prompt'/2 (_0,'latin1')
'format_prompt'/2 = fun (_0,_1) -> case <_0,_1> of <{'format',Format,Args},_X_Encoding> when 'true' -> apply 'do_format_prompt'/2 (Format,Args)
<Prompt,Encoding> when let <_2> = call 'erlang':'is_list' (Prompt) in let <_3> = call 'erlang':'is_atom' (Prompt) in let <_4> = call 'erlang':'is_binary' (Prompt) in let <_5> = call 'erlang':'or' (_3,_4) in call 'erlang':'or' (_2,_5) -> let <_6> = apply 'add_modifier'/2 (Encoding,[115]) in apply 'do_format_prompt'/2 (_6,[Prompt|[]])
<Prompt,Encoding> when 'true' -> let <_7> = apply 'add_modifier'/2 (Encoding,[112]) in apply 'do_format_prompt'/2 (_7,[Prompt|[]]) end
'do_format_prompt'/2 = fun (_0,_1) -> let <_2> = catch apply 'format'/2 (_0,_1) in case _2 of <{'EXIT',_6}> when 'true' -> [63|[63|[63]]]
<List> when 'true' -> List end
'add_modifier'/2 = fun (_0,_1) -> case <_0,_1> of <'latin1',C> when 'true' -> [126|C]
<_4,C> when 'true' -> [126|[116|C]] end
'write'/1 = fun (_0) -> apply 'write1'/3 (_0,-1,'latin1')
'write'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Term,D,'true'> when 'true' -> call 'io_lib_pretty':'print' (Term,1,80,D)
<Term,D,'false'> when 'true' -> apply 'write'/2 (Term,D)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'write',3}}] )-|['compiler_generated'] ) end
'write'/2 = fun (_0,_1) -> case <_0,_1> of <Term,Options> when call 'erlang':'is_list' (Options) -> let <Depth> = apply 'get_option'/3 ('depth',Options,-1) in let <_4> = call 'epp':'default_encoding' () in let <Encoding> = apply 'get_option'/3 ('encoding',Options,_4) in let <CharsLimit> = apply 'get_option'/3 ('chars_limit',Options,-1) in case <> of <> when let <_8> = call 'erlang':'=:=' (Depth,0) in let <_9> = call 'erlang':'=:=' (CharsLimit,0) in call 'erlang':'or' (_8,_9) -> [46|[46|[46]]]
<> when call 'erlang':'<' (CharsLimit,0) -> apply 'write1'/3 (Term,Depth,Encoding)
<> when call 'erlang':'>' (CharsLimit,0) -> let <RecDefFun> = fun (_11,_10) -> 'no' in let <If> = call 'io_lib_pretty':'intermediate' (Term,Depth,CharsLimit,RecDefFun,Encoding,('false'-|['compiler_generated'] )) in call 'io_lib_pretty':'write' (If)
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end
<Term,Depth> when 'true' -> apply 'write'/2 (Term,[{'depth',Depth}|[{'encoding','latin1'}]]) end
'write1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_Term,0,_X_E> when 'true' -> [46|[46|[46]]]
<Term,_X_D,_X_E> when call 'erlang':'is_integer' (Term) -> call 'erlang':'integer_to_list' (Term)
<Term,_X_D,_X_E> when call 'erlang':'is_float' (Term) -> call 'io_lib_format':'fwrite_g' (Term)
<Atom,_X_D,'latin1'> when call 'erlang':'is_atom' (Atom) -> apply 'write_atom_as_latin1'/1 (Atom)
<Atom,_X_D,_X_E> when call 'erlang':'is_atom' (Atom) -> apply 'write_atom'/1 (Atom)
<Term,_X_D,_X_E> when call 'erlang':'is_port' (Term) -> apply 'write_port'/1 (Term)
<Term,_X_D,_X_E> when call 'erlang':'is_pid' (Term) -> call 'erlang':'pid_to_list' (Term)
<Term,_X_D,_X_E> when call 'erlang':'is_reference' (Term) -> apply 'write_ref'/1 (Term)
<Term = #{#<_15>('all',1,'binary',['unsigned'|['big']])}#,D,_X_E> when 'true' -> apply 'write_binary'/2 (Term,D)
<[],_X_D,_X_E> when 'true' -> [91|[93]]
<{},_X_D,_X_E> when 'true' -> [123|[125]]
<[H|T],D,E> when 'true' -> case <> of <> when call 'erlang':'=:=' (D,1) -> [91|[46|[46|[46|[93]]]]]
<> when 'true' -> let <_3> = call 'erlang':'-' (D,1) in let <_4> = apply 'write1'/3 (H,_3,E) in let <_5> = call 'erlang':'-' (D,1) in let <_6> = apply 'write_tail'/3 (T,_5,E) in [91|[[_4|_6]|[93]]] end
<F,_X_D,_X_E> when call 'erlang':'is_function' (F) -> call 'erlang':'fun_to_list' (F)
<Term,D,E> when call 'erlang':'is_map' (Term) -> apply 'write_map'/3 (Term,D,E)
<T,D,E> when call 'erlang':'is_tuple' (T) -> case <> of <> when call 'erlang':'=:=' (D,1) -> [123|[46|[46|[46|[125]]]]]
<> when 'true' -> let <_8> = call 'erlang':'element' (1,T) in let <_7> = call 'erlang':'-' (D,1) in let <_9> = apply 'write1'/3 (_8,_7,E) in let <_10> = call 'erlang':'-' (D,1) in let <_11> = apply 'write_tuple'/4 (T,2,_10,E) in [123|[[_9|_11]|[125]]] end
(<_14,_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13,_12})-|[{'function_name',{'write1',3}}] )-|['compiler_generated'] ) end
'write_tail'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[],_X_D,_X_E> when 'true' -> []
<_12,1,_X_E> when 'true' -> [124|[46|[46|[46]]]]
<[H|T],D,E> when 'true' -> let <_3> = call 'erlang':'-' (D,1) in let <_4> = apply 'write1'/3 (H,_3,E) in let <_5> = call 'erlang':'-' (D,1) in let <_6> = apply 'write_tail'/3 (T,_5,E) in [44|[_4|_6]]
<Other,D,E> when 'true' -> let <_7> = call 'erlang':'-' (D,1) in let <_8> = apply 'write1'/3 (Other,_7,E) in [124|[_8|[]]] end
'write_tuple'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <T,I,_X_D,_X_E> when try let <_4> = call 'erlang':'tuple_size' (T) in call 'erlang':'>' (I,_4) of <Try> -> Try catch <T,R> -> 'false' -> []
<_15,_X_I,1,_X_E> when 'true' -> [44|[46|[46|[46]]]]
<T,I,D,E> when 'true' -> let <_6> = call 'erlang':'element' (I,T) in let <_5> = call 'erlang':'-' (D,1) in let <_7> = apply 'write1'/3 (_6,_5,E) in let <_9> = call 'erlang':'+' (I,1) in let <_8> = call 'erlang':'-' (D,1) in let <_10> = apply 'write_tuple'/4 (T,_9,_8,E) in [44|[_7|_10]] end
'write_port'/1 = fun (_0) -> call 'erlang':'port_to_list' (_0)
'write_ref'/1 = fun (_0) -> call 'erlang':'ref_to_list' (_0)
'write_map'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_11,1,_X_E> when 'true' -> [35|[123|[125]]]
<Map,D,E> when call 'erlang':'is_integer' (D) -> let <I> = call 'maps':'iterator' (Map) in case call 'maps':'next' (I) of <{K,V,NextI}> when 'true' -> let <D0> = call 'erlang':'-' (D,1) in let <W> = apply 'write_map_assoc'/4 (K,V,D0,E) in let <_6> = apply 'write_map_body'/4 (NextI,D0,D0,E) in [35|[123|[[W|_6]|[125]]]]
<'none'> when 'true' -> [35|[123|[125]]]
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
(<_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8})-|[{'function_name',{'write_map',3}}] )-|['compiler_generated'] ) end
'write_map_body'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_12,1,_X_D0,_X_E> when 'true' -> [44|[46|[46|[46]]]]
<I,D,D0,E> when 'true' -> case call 'maps':'next' (I) of <{K,V,NextI}> when 'true' -> let <W> = apply 'write_map_assoc'/4 (K,V,D0,E) in let <_5> = call 'erlang':'-' (D,1) in let <_6> = apply 'write_map_body'/4 (NextI,_5,D0,E) in [44|[W|_6]]
<'none'> when 'true' -> []
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end end
'write_map_assoc'/4 = fun (_0,_1,_2,_3) -> let <_4> = apply 'write1'/3 (_0,_2,_3) in let <_5> = apply 'write1'/3 (_1,_2,_3) in [_4|[[32|[61|[62|[32]]]]|[_5|[]]]]
'write_binary'/2 = fun (_0,_1) -> case <_0,_1> of <B,D> when call 'erlang':'is_integer' (D) -> case apply 'write_binary'/3 (B,D,-1) of <{S,_6}> when 'true' -> S
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'write_binary',2}}] )-|['compiler_generated'] ) end
'write_binary'/3 = fun (_0,_1,_2) -> let <_3> = apply 'tsub'/2 (_2,4) in case apply 'write_binary_body'/4 (_0,_1,_3,[]) of <{S,Rest}> when 'true' -> let <_5> = call 'lists':'reverse' (S) in {[60|[60|[_5|[62|[62]]]]],Rest}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'write_binary_body'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <B = #{}#,_X_D,_X_T,Acc> when 'true' -> {Acc,B}
<B,D,T,Acc> when let <_4> = call 'erlang':'=:=' (D,1) in let <_5> = call 'erlang':'=:=' (T,0) in call 'erlang':'or' (_4,_5) -> {[[46|[46|[46]]]|Acc],B}
<#{#<X>(8,1,'integer',['unsigned'|['big']])}#,_X_D,_X_T,Acc> when 'true' -> let <_6> = call 'erlang':'integer_to_list' (X) in {[_6|Acc],#{}#}
<#{#<X>(8,1,'integer',['unsigned'|['big']]),#<Rest>('all',1,'binary',['unsigned'|['big']])}#,D,T,Acc> when 'true' -> let <S> = call 'erlang':'integer_to_list' (X) in let <_11> = call 'erlang':'-' (D,1) in let <_8> = call 'erlang':'length' (S) in let <_9> = call 'erlang':'+' (_8,1) in let <_10> = apply 'tsub'/2 (T,_9) in apply 'write_binary_body'/4 (Rest,_11,_10,[44|[S|Acc]])
<B,_X_D,_X_T,Acc> when 'true' -> let <L> = call 'erlang':'bit_size' (B) in case B of <#{#<X>(L,1,'integer',['unsigned'|['big']])}#> when 'true' -> let <_14> = call 'erlang':'integer_to_list' (L) in let <_15> = call 'erlang':'integer_to_list' (X) in {[_14|[58|[_15|Acc]]],#{}#}
(<_13> when 'true' -> primop 'match_fail' ({'badmatch',_13})-|['compiler_generated'] ) end end
'tsub'/2 = fun (_0,_1) -> case <_0,_1> of <T,_4> when call 'erlang':'<' (T,0) -> T
<T,E> when call 'erlang':'>=' (T,E) -> call 'erlang':'-' (T,E)
<_5,_6> when 'true' -> 0 end
'get_option'/3 = fun (_0,_1,_2) -> case call 'lists':'keyfind' (_0,1,_1) of <'false'> when 'true' -> _2
<{_7,Value}> when call 'erlang':'=:=' (_7,_0) -> Value
<_8> when 'true' -> _2 end
'write_atom'/1 = fun (_0) -> let <_1> = 'write_string'/2 in apply 'write_possibly_quoted_atom'/2 (_0,_1)
'write_atom_as_latin1'/1 = fun (_0) -> let <_1> = 'write_string_as_latin1'/2 in apply 'write_possibly_quoted_atom'/2 (_0,_1)
'write_possibly_quoted_atom'/2 = fun (_0,_1) -> let <Chars> = call 'erlang':'atom_to_list' (_0) in case apply 'quote_atom'/2 (_0,Chars) of <'true'> when 'true' -> apply _1 (Chars,39)
<'false'> when 'true' -> Chars
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'quote_atom'/2 = fun (_0,_1) -> case call 'erl_scan':'reserved_word' (_0) of <'true'> when 'true' -> 'true'
<'false'> when 'true' -> case _1 of <[C|Cs]> when let <_2> = call 'erlang':'>=' (C,97) in let <_3> = call 'erlang':'=<' (C,122) in call 'erlang':'and' (_2,_3) -> let <_4> = apply 'name_chars'/1 (Cs) in call 'erlang':'not' (_4)
<[C|Cs]> when try let <_5> = call 'erlang':'>=' (C,223) in let <_6> = call 'erlang':'=<' (C,255) in let <_7> = call 'erlang':'=/=' (C,247) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> let <_9> = apply 'name_chars'/1 (Cs) in call 'erlang':'not' (_9)
<_14> when 'true' -> 'true' end
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
'name_chars'/1 = fun (_0) -> case _0 of <[C|Cs]> when 'true' -> case apply 'name_char'/1 (C) of <'true'> when 'true' -> apply 'name_chars'/1 (Cs)
<'false'> when 'true' -> 'false'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
<[]> when 'true' -> 'true'
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'name_chars',1}}] )-|['compiler_generated'] ) end
'name_char'/1 = fun (_0) -> case _0 of <C> when let <_1> = call 'erlang':'>=' (_0,97) in let <_2> = call 'erlang':'=<' (_0,122) in call 'erlang':'and' (_1,_2) -> 'true'
<C> when try let <_3> = call 'erlang':'>=' (_0,223) in let <_4> = call 'erlang':'=<' (_0,255) in let <_5> = call 'erlang':'=/=' (_0,247) in let <_6> = call 'erlang':'and' (_4,_5) in call 'erlang':'and' (_3,_6) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<C> when let <_7> = call 'erlang':'>=' (_0,65) in let <_8> = call 'erlang':'=<' (_0,90) in call 'erlang':'and' (_7,_8) -> 'true'
<C> when try let <_9> = call 'erlang':'>=' (_0,192) in let <_10> = call 'erlang':'=<' (_0,222) in let <_11> = call 'erlang':'=/=' (_0,215) in let <_12> = call 'erlang':'and' (_10,_11) in call 'erlang':'and' (_9,_12) of <Try> -> Try catch <T,R> -> 'false' -> 'true'
<C> when let <_13> = call 'erlang':'>=' (_0,48) in let <_14> = call 'erlang':'=<' (_0,57) in call 'erlang':'and' (_13,_14) -> 'true'
<95> when 'true' -> 'true'
<64> when 'true' -> 'true'
<_16> when 'true' -> 'false' end
'write_string'/1 = fun (_0) -> apply 'write_string'/2 (_0,34)
'write_string'/2 = fun (_0,_1) -> let <_2> = apply 'write_string1'/3 ('unicode_as_unicode',_0,_1) in [_1|_2]
'write_unicode_string'/1 = fun (_0) -> apply 'write_string'/1 (_0)
'write_latin1_string'/1 = fun (_0) -> apply 'write_latin1_string'/2 (_0,34)
'write_latin1_string'/2 = fun (_0,_1) -> let <_2> = apply 'write_string1'/3 ('latin1',_0,_1) in [_1|_2]
'write_string_as_latin1'/1 = fun (_0) -> apply 'write_string_as_latin1'/2 (_0,34)
'write_string_as_latin1'/2 = fun (_0,_1) -> let <_2> = apply 'write_string1'/3 ('unicode_as_latin1',_0,_1) in [_1|_2]
'write_string1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_7,[],Q> when 'true' -> [Q|[]]
<Enc,[C|Cs],Q> when 'true' -> let <_3> = apply 'write_string1'/3 (Enc,Cs,Q) in apply 'string_char'/4 (Enc,C,Q,_3)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'write_string1',3}}] )-|['compiler_generated'] ) end
'string_char'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_24,Q,_25,Tail> when call 'erlang':'=:=' (_25,Q) -> [92|[Q|Tail]]
<_26,92,_27,Tail> when 'true' -> [92|[92|Tail]]
<_28,C,_29,Tail> when let <_4> = call 'erlang':'>=' (C,32) in let <_5> = call 'erlang':'=<' (C,126) in call 'erlang':'and' (_4,_5) -> [C|Tail]
<'latin1',C,_30,Tail> when let <_6> = call 'erlang':'>=' (C,160) in let <_7> = call 'erlang':'=<' (C,255) in call 'erlang':'and' (_6,_7) -> [C|Tail]
<'unicode_as_unicode',C,_31,Tail> when call 'erlang':'>=' (C,160) -> [C|Tail]
<'unicode_as_latin1',C,_32,Tail> when let <_8> = call 'erlang':'>=' (C,160) in let <_9> = call 'erlang':'=<' (C,255) in call 'erlang':'and' (_8,_9) -> [C|Tail]
<'unicode_as_latin1',C,_33,Tail> when call 'erlang':'>=' (C,255) -> let <_11> = call 'erlang':'integer_to_list' (C,16) in let <_10> = [125|Tail] in let <_12> = call 'erlang':'++' (_11,_10) in [92|[120|[123|_12]]]
<_34,10,_35,Tail> when 'true' -> [92|[110|Tail]]
<_36,13,_37,Tail> when 'true' -> [92|[114|Tail]]
<_38,9,_39,Tail> when 'true' -> [92|[116|Tail]]
<_40,11,_41,Tail> when 'true' -> [92|[118|Tail]]
<_42,8,_43,Tail> when 'true' -> [92|[98|Tail]]
<_44,12,_45,Tail> when 'true' -> [92|[102|Tail]]
<_46,27,_47,Tail> when 'true' -> [92|[101|Tail]]
<_48,127,_49,Tail> when 'true' -> [92|[100|Tail]]
<_50,C,_51,Tail> when call 'erlang':'<' (C,160) -> let <_13> = call 'erlang':'bsr' (C,6) in let <C1> = call 'erlang':'+' (_13,48) in let <_15> = call 'erlang':'bsr' (C,3) in let <_16> = call 'erlang':'band' (_15,7) in let <C2> = call 'erlang':'+' (_16,48) in let <_18> = call 'erlang':'band' (C,7) in let <C3> = call 'erlang':'+' (_18,48) in [92|[C1|[C2|[C3|Tail]]]]
(<_23,_22,_21,_20> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21,_20})-|[{'function_name',{'string_char',4}}] )-|['compiler_generated'] ) end
'write_char'/1 = fun (_0) -> case _0 of <32> when 'true' -> [36|[92|[115]]]
<C> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> let <_4> = apply 'string_char'/4 ('unicode_as_unicode',C,-1,[]) in [36|_4]
(<_5> when 'true' -> (primop 'match_fail' ({'function_clause',_5})-|[{'function_name',{'write_char',1}}] )-|['compiler_generated'] ) end
'write_unicode_char'/1 = fun (_0) -> apply 'write_char'/1 (_0)
'write_latin1_char'/1 = fun (_0) -> case _0 of <Lat1> when try let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in let <_3> = call 'erlang':'=<' (_0,255) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> let <_6> = apply 'string_char'/4 ('latin1',Lat1,-1,[]) in [36|_6]
(<_7> when 'true' -> (primop 'match_fail' ({'function_clause',_7})-|[{'function_name',{'write_latin1_char',1}}] )-|['compiler_generated'] ) end
'write_char_as_latin1'/1 = fun (_0) -> case _0 of <Uni> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> let <_4> = apply 'string_char'/4 ('unicode_as_latin1',Uni,-1,[]) in [36|_4]
(<_5> when 'true' -> (primop 'match_fail' ({'function_clause',_5})-|[{'function_name',{'write_char_as_latin1',1}}] )-|['compiler_generated'] ) end
'latin1_char_list'/1 = fun (_0) -> case _0 of <[C|Cs]> when try let <_1> = call 'erlang':'is_integer' (C) in let <_2> = call 'erlang':'>=' (C,0) in let <_3> = call 'erlang':'=<' (C,255) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> apply 'latin1_char_list'/1 (Cs)
<[]> when 'true' -> 'true'
<_6> when 'true' -> 'false' end
'char_list'/1 = fun (_0) -> case _0 of <[C|Cs]> when let <_5> = try let <_1> = call 'erlang':'is_integer' (C) in let <_2> = call 'erlang':'>=' (C,0) in let <_3> = call 'erlang':'<' (C,55296) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' in let <_10> = try let <_6> = call 'erlang':'is_integer' (C) in let <_7> = call 'erlang':'>' (C,57343) in let <_8> = call 'erlang':'<' (C,65534) in let <_9> = call 'erlang':'and' (_7,_8) in call 'erlang':'and' (_6,_9) of <Try> -> Try catch <T,R> -> 'false' in let <_15> = try let <_11> = call 'erlang':'is_integer' (C) in let <_12> = call 'erlang':'>' (C,65535) in let <_13> = call 'erlang':'=<' (C,1114111) in let <_14> = call 'erlang':'and' (_12,_13) in call 'erlang':'and' (_11,_14) of <Try> -> Try catch <T,R> -> 'false' in let <_16> = call 'erlang':'or' (_10,_15) in call 'erlang':'or' (_5,_16) -> apply 'char_list'/1 (Cs)
<[]> when 'true' -> 'true'
<_18> when 'true' -> 'false' end
'deep_latin1_char_list'/1 = fun (_0) -> apply 'deep_latin1_char_list'/2 (_0,[])
'deep_latin1_char_list'/2 = fun (_0,_1) -> case <_0,_1> of <[C|Cs],More> when call 'erlang':'is_list' (C) -> apply 'deep_latin1_char_list'/2 (C,[Cs|More])
<[C|Cs],More> when try let <_2> = call 'erlang':'is_integer' (C) in let <_3> = call 'erlang':'>=' (C,0) in let <_4> = call 'erlang':'=<' (C,255) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> apply 'deep_latin1_char_list'/2 (Cs,More)
<[],[Cs|More]> when 'true' -> apply 'deep_latin1_char_list'/2 (Cs,More)
<[],[]> when 'true' -> 'true'
<_8,_X_More> when 'true' -> 'false' end
'deep_char_list'/1 = fun (_0) -> apply 'deep_char_list'/2 (_0,[])
'deep_char_list'/2 = fun (_0,_1) -> case <_0,_1> of <[C|Cs],More> when call 'erlang':'is_list' (C) -> apply 'deep_char_list'/2 (C,[Cs|More])
<[C|Cs],More> when let <_6> = try let <_2> = call 'erlang':'is_integer' (C) in let <_3> = call 'erlang':'>=' (C,0) in let <_4> = call 'erlang':'<' (C,55296) in let <_5> = call 'erlang':'and' (_3,_4) in call 'erlang':'and' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' in let <_11> = try let <_7> = call 'erlang':'is_integer' (C) in let <_8> = call 'erlang':'>' (C,57343) in let <_9> = call 'erlang':'<' (C,65534) in let <_10> = call 'erlang':'and' (_8,_9) in call 'erlang':'and' (_7,_10) of <Try> -> Try catch <T,R> -> 'false' in let <_16> = try let <_12> = call 'erlang':'is_integer' (C) in let <_13> = call 'erlang':'>' (C,65535) in let <_14> = call 'erlang':'=<' (C,1114111) in let <_15> = call 'erlang':'and' (_13,_14) in call 'erlang':'and' (_12,_15) of <Try> -> Try catch <T,R> -> 'false' in let <_17> = call 'erlang':'or' (_11,_16) in call 'erlang':'or' (_6,_17) -> apply 'deep_char_list'/2 (Cs,More)
<[],[Cs|More]> when 'true' -> apply 'deep_char_list'/2 (Cs,More)
<[],[]> when 'true' -> 'true'
<_20,_X_More> when 'true' -> 'false' end
'deep_unicode_char_list'/1 = fun (_0) -> apply 'deep_char_list'/1 (_0)
'printable_latin1_list'/1 = fun (_0) -> case _0 of <[C|Cs]> when try let <_1> = call 'erlang':'is_integer' (C) in let <_2> = call 'erlang':'>=' (C,32) in let <_3> = call 'erlang':'=<' (C,126) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> apply 'printable_latin1_list'/1 (Cs)
<[C|Cs]> when try let <_5> = call 'erlang':'is_integer' (C) in let <_6> = call 'erlang':'>=' (C,160) in let <_7> = call 'erlang':'=<' (C,255) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' -> apply 'printable_latin1_list'/1 (Cs)
<[10|Cs]> when 'true' -> apply 'printable_latin1_list'/1 (Cs)
<[13|Cs]> when 'true' -> apply 'printable_latin1_list'/1 (Cs)
<[9|Cs]> when 'true' -> apply 'printable_latin1_list'/1 (Cs)
<[11|Cs]> when 'true' -> apply 'printable_latin1_list'/1 (Cs)
<[8|Cs]> when 'true' -> apply 'printable_latin1_list'/1 (Cs)
<[12|Cs]> when 'true' -> apply 'printable_latin1_list'/1 (Cs)
<[27|Cs]> when 'true' -> apply 'printable_latin1_list'/1 (Cs)
<[]> when 'true' -> 'true'
<_10> when 'true' -> 'false' end
'printable_list'/1 = fun (_0) -> case call 'io':'printable_range' () of <'latin1'> when 'true' -> apply 'printable_latin1_list'/1 (_0)
<'unicode'> when 'true' -> apply 'printable_unicode_list'/1 (_0)
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end
'printable_unicode_list'/1 = fun (_0) -> case _0 of <[C|Cs]> when try let <_1> = call 'erlang':'is_integer' (C) in let <_2> = call 'erlang':'>=' (C,32) in let <_3> = call 'erlang':'=<' (C,126) in let <_4> = call 'erlang':'and' (_2,_3) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> apply 'printable_unicode_list'/1 (Cs)
<[C|Cs]> when let <_9> = try let <_5> = call 'erlang':'is_integer' (C) in let <_6> = call 'erlang':'>=' (C,160) in let <_7> = call 'erlang':'<' (C,55296) in let <_8> = call 'erlang':'and' (_6,_7) in call 'erlang':'and' (_5,_8) of <Try> -> Try catch <T,R> -> 'false' in let <_14> = try let <_10> = call 'erlang':'is_integer' (C) in let <_11> = call 'erlang':'>' (C,57343) in let <_12> = call 'erlang':'<' (C,65534) in let <_13> = call 'erlang':'and' (_11,_12) in call 'erlang':'and' (_10,_13) of <Try> -> Try catch <T,R> -> 'false' in let <_19> = try let <_15> = call 'erlang':'is_integer' (C) in let <_16> = call 'erlang':'>' (C,65535) in let <_17> = call 'erlang':'=<' (C,1114111) in let <_18> = call 'erlang':'and' (_16,_17) in call 'erlang':'and' (_15,_18) of <Try> -> Try catch <T,R> -> 'false' in let <_20> = call 'erlang':'or' (_14,_19) in call 'erlang':'or' (_9,_20) -> apply 'printable_unicode_list'/1 (Cs)
<[10|Cs]> when 'true' -> apply 'printable_unicode_list'/1 (Cs)
<[13|Cs]> when 'true' -> apply 'printable_unicode_list'/1 (Cs)
<[9|Cs]> when 'true' -> apply 'printable_unicode_list'/1 (Cs)
<[11|Cs]> when 'true' -> apply 'printable_unicode_list'/1 (Cs)
<[8|Cs]> when 'true' -> apply 'printable_unicode_list'/1 (Cs)
<[12|Cs]> when 'true' -> apply 'printable_unicode_list'/1 (Cs)
<[27|Cs]> when 'true' -> apply 'printable_unicode_list'/1 (Cs)
<[]> when 'true' -> 'true'
<_22> when 'true' -> 'false' end
'nl'/0 = fun () -> [10]
'count_and_find_utf8'/2 = fun (_0,_1) -> apply 'cafu'/5 (_0,_1,0,0,'none')
'cafu'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <#{}#,_X_N,Count,_X_ByteCount,SavePos> when 'true' -> {Count,SavePos}
<#{#<_20>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,0,Count,ByteCount,_X_SavePos> when 'true' -> let <_5> = call 'erlang':'+' (Count,1) in apply 'cafu'/5 (Rest,-1,_5,0,ByteCount)
<#{#<_21>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,N,Count,_X_ByteCount,SavePos> when call 'erlang':'<' (N,0) -> let <_7> = call 'erlang':'+' (Count,1) in apply 'cafu'/5 (Rest,-1,_7,0,SavePos)
<Whole = #{#<_22>('undefined','undefined','utf8',['unsigned'|['big']]),#<Rest>('all',8,'binary',['unsigned'|['big']])}#,N,Count,ByteCount,SavePos> when 'true' -> let <_10> = call 'erlang':'byte_size' (Whole) in let <_9> = call 'erlang':'byte_size' (Rest) in let <Delta> = call 'erlang':'-' (_10,_9) in let <_14> = call 'erlang':'-' (N,1) in let <_13> = call 'erlang':'+' (Count,1) in let <_12> = call 'erlang':'+' (ByteCount,Delta) in apply 'cafu'/5 (Rest,_14,_13,_12,SavePos)
<_X_Other,_X_N,Count,_X_ByteCount,SavePos> when 'true' -> {Count,SavePos} end
'collect_chars'/3 = fun (_0,_1,_2) -> apply 'collect_chars'/4 (_0,_1,'latin1',_2)
'collect_chars'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <'start',Data,'unicode',N> when call 'erlang':'is_binary' (Data) -> case apply 'count_and_find_utf8'/2 (Data,N) of <{Size,Npos}> when 'true' -> case <> of <> when call 'erlang':'>' (Size,N) -> case call 'erlang':'split_binary' (Data,Npos) of <{B1,B2}> when 'true' -> {'stop',B1,B2}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<> when call 'erlang':'<' (Size,N) -> let <_6> = call 'erlang':'-' (N,Size) in {'binary',[Data|[]],_6}
<> when 'true' -> {'stop',Data,'eof'} end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<'start',Data,'latin1',N> when call 'erlang':'is_binary' (Data) -> let <Size> = call 'erlang':'byte_size' (Data) in case <> of <> when call 'erlang':'>' (Size,N) -> case call 'erlang':'split_binary' (Data,N) of <{B1,B2}> when 'true' -> {'stop',B1,B2}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<> when call 'erlang':'<' (Size,N) -> let <_9> = call 'erlang':'-' (N,Size) in {'binary',[Data|[]],_9}
<> when 'true' -> {'stop',Data,'eof'} end
<'start',Data,_25,N> when call 'erlang':'is_list' (Data) -> apply 'collect_chars_list'/3 ([],N,Data)
<'start','eof',_26,_27> when 'true' -> {'stop','eof','eof'}
<{'binary',Stack,_X_N},'eof',_28,_29> when 'true' -> let <_10> = apply 'binrev'/1 (Stack) in {'stop',_10,'eof'}
<{'binary',Stack,N},Data,'unicode',_30> when 'true' -> case apply 'count_and_find_utf8'/2 (Data,N) of <{Size,Npos}> when 'true' -> case <> of <> when call 'erlang':'>' (Size,N) -> case call 'erlang':'split_binary' (Data,Npos) of <{B1,B2}> when 'true' -> let <_13> = apply 'binrev'/2 (Stack,[B1|[]]) in {'stop',_13,B2}
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<> when call 'erlang':'<' (Size,N) -> let <_14> = call 'erlang':'-' (N,Size) in {'binary',[Data|Stack],_14}
<> when 'true' -> let <_15> = apply 'binrev'/2 (Stack,[Data|[]]) in {'stop',_15,'eof'} end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
<{'binary',Stack,N},Data,'latin1',_31> when 'true' -> let <Size> = call 'erlang':'byte_size' (Data) in case <> of <> when call 'erlang':'>' (Size,N) -> case call 'erlang':'split_binary' (Data,N) of <{B1,B2}> when 'true' -> let <_18> = apply 'binrev'/2 (Stack,[B1|[]]) in {'stop',_18,B2}
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end
<> when call 'erlang':'<' (Size,N) -> let <_19> = call 'erlang':'-' (N,Size) in {'binary',[Data|Stack],_19}
<> when 'true' -> let <_20> = apply 'binrev'/2 (Stack,[Data|[]]) in {'stop',_20,'eof'} end
<{'list',Stack,N},Data,_32,_33> when 'true' -> apply 'collect_chars_list'/3 (Stack,N,Data)
<[],Chars,_34,N> when 'true' -> apply 'collect_chars1'/3 (N,Chars,[])
<{Left,Sofar},Chars,_35,_X_N> when 'true' -> apply 'collect_chars1'/3 (Left,Chars,Sofar)
(<_24,_23,_22,_21> when 'true' -> (primop 'match_fail' ({'function_clause',_24,_23,_22,_21})-|[{'function_name',{'collect_chars',4}}] )-|['compiler_generated'] ) end
'collect_chars1'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <N,Chars,Stack> when call 'erlang':'=<' (N,0) -> let <_3> = call 'lists':'reverse' (Stack,[]) in {'done',_3,Chars}
<N,[C|Rest],Stack> when 'true' -> let <_4> = call 'erlang':'-' (N,1) in apply 'collect_chars1'/3 (_4,Rest,[C|Stack])
<_X_N,'eof',[]> when 'true' -> {'done','eof',[]}
<_X_N,'eof',Stack> when 'true' -> let <_5> = call 'lists':'reverse' (Stack,[]) in {'done',_5,[]}
<N,[],Stack> when 'true' -> {'more',{N,Stack}}
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'collect_chars1',3}}] )-|['compiler_generated'] ) end
'collect_chars_list'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Stack,0,Data> when 'true' -> let <_3> = call 'lists':'reverse' (Stack,[]) in {'stop',_3,Data}
<Stack,_X_N,'eof'> when 'true' -> let <_4> = call 'lists':'reverse' (Stack,[]) in {'stop',_4,'eof'}
<Stack,N,[]> when 'true' -> {'list',Stack,N}
<Stack,N,[H|T]> when 'true' -> let <_5> = call 'erlang':'-' (N,1) in apply 'collect_chars_list'/3 ([H|Stack],_5,T)
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'collect_chars_list',3}}] )-|['compiler_generated'] ) end
'collect_line'/3 = fun (_0,_1,_2) -> apply 'collect_line'/4 (_0,_1,'latin1',_2)
'collect_line'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <'start',Data,Encoding,_10> when call 'erlang':'is_binary' (Data) -> apply 'collect_line_bin'/4 (Data,Data,[],Encoding)
<'start',Data,_11,_12> when call 'erlang':'is_list' (Data) -> apply 'collect_line_list'/2 (Data,[])
<'start','eof',_13,_14> when 'true' -> {'stop','eof','eof'}
<Stack,Data,Encoding,_15> when call 'erlang':'is_binary' (Data) -> apply 'collect_line_bin'/4 (Data,Data,Stack,Encoding)
<Stack,Data,_16,_17> when call 'erlang':'is_list' (Data) -> apply 'collect_line_list'/2 (Data,Stack)
<Stack = [B|_18],'eof',_19,_20> when call 'erlang':'is_binary' (B) -> let <_4> = apply 'binrev'/1 (Stack) in {'stop',_4,'eof'}
<Stack,'eof',_21,_22> when 'true' -> let <_5> = call 'lists':'reverse' (Stack,[]) in {'stop',_5,'eof'}
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'collect_line',4}}] )-|['compiler_generated'] ) end
'collect_line_bin'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <#{#<10>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Data,Stack0,_24> when 'true' -> let <_5> = call 'erlang':'byte_size' (Data) in let <_4> = call 'erlang':'byte_size' (T) in let <N> = call 'erlang':'-' (_5,_4) in case Data of <#{#<Line>(N,8,'binary',['unsigned'|['big']]),#<_25>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> case Stack0 of <[]> when 'true' -> {'stop',Line,T}
<[#{#<13>(8,1,'integer',['unsigned'|['big']])}#|Stack]> when call 'erlang':'=:=' (N,1) -> let <_8> = apply 'binrev'/2 (Stack,[10]) in {'stop',_8,T}
<_26> when 'true' -> let <_9> = apply 'binrev'/2 (Stack0,[Line|[]]) in {'stop',_9,T} end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<#{#<13>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Data,Stack,_27> when 'true' -> let <_12> = call 'erlang':'byte_size' (Data) in let <_11> = call 'erlang':'byte_size' (T) in let <_13> = call 'erlang':'-' (_12,_11) in let <N> = call 'erlang':'-' (_13,2) in case Data of <#{#<Line>(N,8,'binary',['unsigned'|['big']]),#<_28>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_16> = apply 'binrev'/2 (Stack,[Line|[10]]) in {'stop',_16,T}
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<#{#<13>(8,1,'integer',['unsigned'|['big']])}#,Data0,Stack,_29> when 'true' -> let <_17> = call 'erlang':'byte_size' (Data0) in let <N> = call 'erlang':'-' (_17,1) in case Data0 of <#{#<Data>(N,8,'binary',['unsigned'|['big']]),#<_30>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> [#{#<13>(8,1,'integer',['unsigned'|['big']])}#|[Data|Stack]]
(<_19> when 'true' -> primop 'match_fail' ({'badmatch',_19})-|['compiler_generated'] ) end
<#{#<_31>(8,1,'integer',['unsigned'|['big']]),#<T>('all',8,'binary',['unsigned'|['big']])}#,Data,Stack,Enc> when 'true' -> apply 'collect_line_bin'/4 (T,Data,Stack,Enc)
<#{}#,Data,Stack,_32> when 'true' -> [Data|Stack]
(<_23,_22,_21,_20> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22,_21,_20})-|[{'function_name',{'collect_line_bin',4}}] )-|['compiler_generated'] ) end
'collect_line_list'/2 = fun (_0,_1) -> case <_0,_1> of <[10|T],[13|Stack]> when 'true' -> let <_2> = call 'lists':'reverse' (Stack,[10]) in {'stop',_2,T}
<[10|T],Stack> when 'true' -> let <_3> = call 'lists':'reverse' (Stack,[10]) in {'stop',_3,T}
<[H|T],Stack> when 'true' -> apply 'collect_line_list'/2 (T,[H|Stack])
<[],Stack> when 'true' -> Stack
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'collect_line_list',2}}] )-|['compiler_generated'] ) end
'get_until'/3 = fun (_0,_1,_2) -> apply 'get_until'/4 (_0,_1,'latin1',_2)
'get_until'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <'start',Data,Encoding,XtraArg> when 'true' -> apply 'get_until'/4 ([],Data,Encoding,XtraArg)
<Cont,Data,Encoding,{Mod,Func,XtraArgs}> when 'true' -> let <_6> = case <> of <> when let <_4> = call 'erlang':'is_binary' (Data) in let <_5> = call 'erlang':'=:=' (Encoding,'unicode') in call 'erlang':'and' (_4,_5) -> call 'unicode':'characters_to_list' (Data,'utf8')
<> when call 'erlang':'is_binary' (Data) -> call 'erlang':'binary_to_list' (Data)
<> when 'true' -> Data end in case call 'erlang':'apply' (Mod,Func,[Cont|[_6|XtraArgs]]) of <{'done',Result,Buf}> when 'true' -> let <_14> = case <> of <> when try let <_8> = call 'erlang':'is_binary' (Data) in let <_9> = call 'erlang':'is_list' (Result) in let <_10> = call 'erlang':'=:=' (Encoding,'unicode') in let <_11> = call 'erlang':'and' (_9,_10) in call 'erlang':'and' (_8,_11) of <Try> -> Try catch <T,R> -> 'false' -> call 'unicode':'characters_to_binary' (Result,'unicode','unicode')
<> when let <_12> = call 'erlang':'is_binary' (Data) in let <_13> = call 'erlang':'is_list' (Result) in call 'erlang':'and' (_12,_13) -> call 'erlang':'iolist_to_binary' (Result)
<> when 'true' -> Result end in {'stop',_14,Buf}
<{'more',NewCont}> when 'true' -> NewCont
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
(<_19,_18,_17,_16> when 'true' -> (primop 'match_fail' ({'function_clause',_19,_18,_17,_16})-|[{'function_name',{'get_until',4}}] )-|['compiler_generated'] ) end
'binrev'/1 = fun (_0) -> let <_1> = call 'lists':'reverse' (_0,[]) in call 'erlang':'list_to_binary' (_1)
'binrev'/2 = fun (_0,_1) -> let <_2> = call 'lists':'reverse' (_0,_1) in call 'erlang':'list_to_binary' (_2)
'limit_term'/2 = fun (_0,_1) -> try apply 'test_limit'/2 (_0,_1) of <_2> -> case _2 of <'ok'> when 'true' -> _0
(<_3> when 'true' -> primop 'match_fail' ({'try_clause',_3})-|['compiler_generated'] ) end catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),('limit'-|['compiler_generated'] ),_9> when 'true' -> apply 'limit'/2 (_0,_1)
(<_10,_11,_12> when 'true' -> primop 'raise' (_12,_11)-|['compiler_generated'] ) end
'limit'/2 = fun (_0,_1) -> case <_0,_1> of <_14,0> when 'true' -> '...'
<L = [H|T],D> when 'true' -> case <> of <> when call 'erlang':'=:=' (D,1) -> ['...']
<> when 'true' -> case apply 'printable_list'/1 (L) of <'true'> when 'true' -> L
<'false'> when 'true' -> let <_2> = call 'erlang':'-' (D,1) in let <_3> = apply 'limit'/2 (H,_2) in let <_4> = call 'erlang':'-' (D,1) in let <_5> = apply 'limit_tail'/2 (T,_4) in [_3|_5]
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end end
<Term,D> when call 'erlang':'is_map' (Term) -> apply 'limit_map'/2 (Term,D)
<T = {},_X_D> when 'true' -> T
<T,D> when call 'erlang':'is_tuple' (T) -> case <> of <> when call 'erlang':'=:=' (D,1) -> {'...'}
<> when 'true' -> let <_8> = call 'erlang':'element' (1,T) in let <_7> = call 'erlang':'-' (D,1) in let <_9> = apply 'limit'/2 (_8,_7) in let <_10> = call 'erlang':'-' (D,1) in let <_11> = apply 'limit_tuple'/3 (T,2,_10) in call 'erlang':'list_to_tuple' ([_9|_11]) end
<Term = #{#<_15>('all',1,'binary',['unsigned'|['big']])}#,D> when 'true' -> apply 'limit_bitstring'/2 (Term,D)
<Term,_X_D> when 'true' -> Term end
'limit_tail'/2 = fun (_0,_1) -> case <_0,_1> of <[],_X_D> when 'true' -> []
<_9,1> when 'true' -> ['...']
<[H|T],D> when 'true' -> let <_2> = call 'erlang':'-' (D,1) in let <_3> = apply 'limit'/2 (H,_2) in let <_4> = call 'erlang':'-' (D,1) in let <_5> = apply 'limit_tail'/2 (T,_4) in [_3|_5]
<Other,D> when 'true' -> let <_6> = call 'erlang':'-' (D,1) in apply 'limit'/2 (Other,_6) end
'limit_tuple'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <T,I,_X_D> when try let <_3> = call 'erlang':'tuple_size' (T) in call 'erlang':'>' (I,_3) of <Try> -> Try catch <T,R> -> 'false' -> []
<_13,_X_I,1> when 'true' -> ['...']
<T,I,D> when 'true' -> let <_5> = call 'erlang':'element' (I,T) in let <_4> = call 'erlang':'-' (D,1) in let <_6> = apply 'limit'/2 (_5,_4) in let <_8> = call 'erlang':'+' (I,1) in let <_7> = call 'erlang':'-' (D,1) in let <_9> = apply 'limit_tuple'/3 (T,_8,_7) in [_6|_9] end
'limit_map'/2 = fun (_0,_1) -> let <_3> = call 'maps':'iterator' (_0) in let <_2> = call 'erlang':'+' (_1,1) in apply 'limit_map_body'/4 (_3,_2,_1,[])
'limit_map_body'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_I,0,_X_D0,Acc> when 'true' -> call 'maps':'from_list' (Acc)
<I,D,D0,Acc> when 'true' -> case call 'maps':'next' (I) of <{K,V,NextI}> when 'true' -> let <_5> = call 'erlang':'-' (D,1) in let <_4> = apply 'limit_map_assoc'/3 (K,V,D0) in apply 'limit_map_body'/4 (NextI,_5,D0,[_4|Acc])
<'none'> when 'true' -> call 'maps':'from_list' (Acc)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end end
'limit_map_assoc'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'-' (_2,1) in let <_4> = apply 'limit'/2 (_1,_3) in {_0,_4}
'limit_bitstring'/2 = fun (_0,_1) -> _0
'test_limit'/2 = fun (_0,_1) -> case <_0,_1> of <_8,0> when 'true' -> call 'erlang':'throw' ('limit')
<L = [H|T],D> when call 'erlang':'is_integer' (D) -> case <> of <> when call 'erlang':'=:=' (D,1) -> call 'erlang':'throw' ('limit')
<> when 'true' -> case apply 'printable_list'/1 (L) of <'true'> when 'true' -> 'ok'
<'false'> when 'true' -> let <_2> = call 'erlang':'-' (D,1) in do apply 'test_limit'/2 (H,_2) let <_3> = call 'erlang':'-' (D,1) in apply 'test_limit_tail'/2 (T,_3)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end end
<Term,D> when call 'erlang':'is_map' (Term) -> apply 'test_limit_map'/2 (Term,D)
<{},_X_D> when 'true' -> 'ok'
<T,D> when call 'erlang':'is_tuple' (T) -> let <_5> = call 'erlang':'tuple_size' (T) in apply 'test_limit_tuple'/4 (T,1,_5,D)
<Term = #{#<_9>('all',1,'binary',['unsigned'|['big']])}#,D> when 'true' -> apply 'test_limit_bitstring'/2 (Term,D)
<_X_Term,_X_D> when 'true' -> 'ok' end
'test_limit_tail'/2 = fun (_0,_1) -> case <_0,_1> of <[],_X_D> when 'true' -> 'ok'
<_7,1> when 'true' -> call 'erlang':'throw' ('limit')
<[H|T],D> when 'true' -> let <_2> = call 'erlang':'-' (D,1) in do apply 'test_limit'/2 (H,_2) let <_3> = call 'erlang':'-' (D,1) in apply 'test_limit_tail'/2 (T,_3)
<Other,D> when 'true' -> let <_4> = call 'erlang':'-' (D,1) in apply 'test_limit'/2 (Other,_4) end
'test_limit_tuple'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_T,I,Sz,_X_D> when call 'erlang':'>' (I,Sz) -> 'ok'
<_12,_13,_14,1> when 'true' -> call 'erlang':'throw' ('limit')
<T,I,Sz,D> when 'true' -> let <_5> = call 'erlang':'element' (I,T) in let <_4> = call 'erlang':'-' (D,1) in do apply 'test_limit'/2 (_5,_4) let <_7> = call 'erlang':'+' (I,1) in let <_6> = call 'erlang':'-' (D,1) in apply 'test_limit_tuple'/4 (T,_7,Sz,_6) end
'test_limit_map'/2 = fun (_0,_1) -> let <_2> = call 'maps':'iterator' (_0) in apply 'test_limit_map_body'/2 (_2,_1)
'test_limit_map_body'/2 = fun (_0,_1) -> case <_0,_1> of <_X_I,0> when 'true' -> call 'erlang':'throw' ('limit')
<I,D> when 'true' -> case call 'maps':'next' (I) of <{K,V,NextI}> when 'true' -> do apply 'test_limit_map_assoc'/3 (K,V,D) let <_2> = call 'erlang':'-' (D,1) in apply 'test_limit_map_body'/2 (NextI,_2)
<'none'> when 'true' -> 'ok'
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end end
'test_limit_map_assoc'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'-' (_2,1) in do apply 'test_limit'/2 (_0,_3) let <_4> = call 'erlang':'-' (_2,1) in apply 'test_limit'/2 (_1,_4)
'test_limit_bitstring'/2 = fun (_0,_1) -> 'ok'
'chars_length'/1 = fun (_0) -> try call 'erlang':'iolist_size' (_0) of <_1> -> _1 catch <_4,_3,_2> -> call 'string':'length' (_0)
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('io_lib')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('io_lib',_0) end