module 'digraph_utils' ['arborescence_root'/1,'components'/1,'condensation'/1,'cyclic_strong_components'/1,'is_acyclic'/1,'is_arborescence'/1,'is_tree'/1,'loop_vertices'/1,'module_info'/0,'module_info'/1,'postorder'/1,'preorder'/1,'reachable'/2,'reachable_neighbours'/2,'reaching'/2,'reaching_neighbours'/2,'strong_components'/1,'subgraph'/2,'subgraph'/3,'topsort'/1] attributes [ 'file' = [{[115|[114|[99|[47|[100|[105|[103|[114|[97|[112|[104|[95|[117|[116|[105|[108|[115|[46|[101|[114|[108]]]]]]]]]]]]]]]]]]]]],1}]
, 'spec' = [{{'components',1},[{'type',46,'bounded_fun',[{'type',46,'fun',[{'type',46,'product',[{'var',46,'Digraph'}]}|[{'type',46,'list',[{'var',46,'Component'}]}]]}|[[{'type',47,'constraint',[{'atom',47,'is_subtype'}|[[{'var',47,'Digraph'}|[{'remote_type',47,[{'atom',47,'digraph'}|[{'atom',47,'graph'}|[[]]]]}]]]]}|[{'type',48,'constraint',[{'atom',48,'is_subtype'}|[[{'var',48,'Component'}|[{'type',48,'list',[{'remote_type',48,[{'atom',48,'digraph'}|[{'atom',48,'vertex'}|[[]]]]}]}]]]]}]]]]}]}]
, 'spec' = [{{'strong_components',1},[{'type',53,'bounded_fun',[{'type',53,'fun',[{'type',53,'product',[{'var',53,'Digraph'}]}|[{'type',53,'list',[{'var',53,'StrongComponent'}]}]]}|[[{'type',54,'constraint',[{'atom',54,'is_subtype'}|[[{'var',54,'Digraph'}|[{'remote_type',54,[{'atom',54,'digraph'}|[{'atom',54,'graph'}|[[]]]]}]]]]}|[{'type',55,'constraint',[{'atom',55,'is_subtype'}|[[{'var',55,'StrongComponent'}|[{'type',55,'list',[{'remote_type',55,[{'atom',55,'digraph'}|[{'atom',55,'vertex'}|[[]]]]}]}]]]]}]]]]}]}]
, 'spec' = [{{'cyclic_strong_components',1},[{'type',60,'bounded_fun',[{'type',60,'fun',[{'type',60,'product',[{'var',60,'Digraph'}]}|[{'type',60,'list',[{'var',60,'StrongComponent'}]}]]}|[[{'type',61,'constraint',[{'atom',61,'is_subtype'}|[[{'var',61,'Digraph'}|[{'remote_type',61,[{'atom',61,'digraph'}|[{'atom',61,'graph'}|[[]]]]}]]]]}|[{'type',62,'constraint',[{'atom',62,'is_subtype'}|[[{'var',62,'StrongComponent'}|[{'type',62,'list',[{'remote_type',62,[{'atom',62,'digraph'}|[{'atom',62,'vertex'}|[[]]]]}]}]]]]}]]]]}]}]
, 'spec' = [{{'reachable',2},[{'type',67,'bounded_fun',[{'type',67,'fun',[{'type',67,'product',[{'var',67,'Vertices'}|[{'var',67,'Digraph'}]]}|[{'var',67,'Reachable'}]]}|[[{'type',68,'constraint',[{'atom',68,'is_subtype'}|[[{'var',68,'Digraph'}|[{'remote_type',68,[{'atom',68,'digraph'}|[{'atom',68,'graph'}|[[]]]]}]]]]}|[{'type',69,'constraint',[{'atom',69,'is_subtype'}|[[{'var',69,'Vertices'}|[{'type',69,'list',[{'remote_type',69,[{'atom',69,'digraph'}|[{'atom',69,'vertex'}|[[]]]]}]}]]]]}|[{'type',70,'constraint',[{'atom',70,'is_subtype'}|[[{'var',70,'Reachable'}|[{'type',70,'list',[{'remote_type',70,[{'atom',70,'digraph'}|[{'atom',70,'vertex'}|[[]]]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'reachable_neighbours',2},[{'type',75,'bounded_fun',[{'type',75,'fun',[{'type',75,'product',[{'var',75,'Vertices'}|[{'var',75,'Digraph'}]]}|[{'var',75,'Reachable'}]]}|[[{'type',76,'constraint',[{'atom',76,'is_subtype'}|[[{'var',76,'Digraph'}|[{'remote_type',76,[{'atom',76,'digraph'}|[{'atom',76,'graph'}|[[]]]]}]]]]}|[{'type',77,'constraint',[{'atom',77,'is_subtype'}|[[{'var',77,'Vertices'}|[{'type',77,'list',[{'remote_type',77,[{'atom',77,'digraph'}|[{'atom',77,'vertex'}|[[]]]]}]}]]]]}|[{'type',78,'constraint',[{'atom',78,'is_subtype'}|[[{'var',78,'Reachable'}|[{'type',78,'list',[{'remote_type',78,[{'atom',78,'digraph'}|[{'atom',78,'vertex'}|[[]]]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'reaching',2},[{'type',83,'bounded_fun',[{'type',83,'fun',[{'type',83,'product',[{'var',83,'Vertices'}|[{'var',83,'Digraph'}]]}|[{'var',83,'Reaching'}]]}|[[{'type',84,'constraint',[{'atom',84,'is_subtype'}|[[{'var',84,'Digraph'}|[{'remote_type',84,[{'atom',84,'digraph'}|[{'atom',84,'graph'}|[[]]]]}]]]]}|[{'type',85,'constraint',[{'atom',85,'is_subtype'}|[[{'var',85,'Vertices'}|[{'type',85,'list',[{'remote_type',85,[{'atom',85,'digraph'}|[{'atom',85,'vertex'}|[[]]]]}]}]]]]}|[{'type',86,'constraint',[{'atom',86,'is_subtype'}|[[{'var',86,'Reaching'}|[{'type',86,'list',[{'remote_type',86,[{'atom',86,'digraph'}|[{'atom',86,'vertex'}|[[]]]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'reaching_neighbours',2},[{'type',91,'bounded_fun',[{'type',91,'fun',[{'type',91,'product',[{'var',91,'Vertices'}|[{'var',91,'Digraph'}]]}|[{'var',91,'Reaching'}]]}|[[{'type',92,'constraint',[{'atom',92,'is_subtype'}|[[{'var',92,'Digraph'}|[{'remote_type',92,[{'atom',92,'digraph'}|[{'atom',92,'graph'}|[[]]]]}]]]]}|[{'type',93,'constraint',[{'atom',93,'is_subtype'}|[[{'var',93,'Vertices'}|[{'type',93,'list',[{'remote_type',93,[{'atom',93,'digraph'}|[{'atom',93,'vertex'}|[[]]]]}]}]]]]}|[{'type',94,'constraint',[{'atom',94,'is_subtype'}|[[{'var',94,'Reaching'}|[{'type',94,'list',[{'remote_type',94,[{'atom',94,'digraph'}|[{'atom',94,'vertex'}|[[]]]]}]}]]]]}]]]]]}]}]
, 'spec' = [{{'topsort',1},[{'type',99,'bounded_fun',[{'type',99,'fun',[{'type',99,'product',[{'var',99,'Digraph'}]}|[{'type',99,'union',[{'var',99,'Vertices'}|[{'atom',99,'false'}]]}]]}|[[{'type',100,'constraint',[{'atom',100,'is_subtype'}|[[{'var',100,'Digraph'}|[{'remote_type',100,[{'atom',100,'digraph'}|[{'atom',100,'graph'}|[[]]]]}]]]]}|[{'type',101,'constraint',[{'atom',101,'is_subtype'}|[[{'var',101,'Vertices'}|[{'type',101,'list',[{'remote_type',101,[{'atom',101,'digraph'}|[{'atom',101,'vertex'}|[[]]]]}]}]]]]}]]]]}]}]
, 'spec' = [{{'is_acyclic',1},[{'type',110,'bounded_fun',[{'type',110,'fun',[{'type',110,'product',[{'var',110,'Digraph'}]}|[{'type',110,'boolean',[]}]]}|[[{'type',111,'constraint',[{'atom',111,'is_subtype'}|[[{'var',111,'Digraph'}|[{'remote_type',111,[{'atom',111,'digraph'}|[{'atom',111,'graph'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'arborescence_root',1},[{'type',116,'bounded_fun',[{'type',116,'fun',[{'type',116,'product',[{'var',116,'Digraph'}]}|[{'type',116,'union',[{'atom',116,'no'}|[{'type',116,'tuple',[{'atom',116,'yes'}|[{'var',116,'Root'}]]}]]}]]}|[[{'type',117,'constraint',[{'atom',117,'is_subtype'}|[[{'var',117,'Digraph'}|[{'remote_type',117,[{'atom',117,'digraph'}|[{'atom',117,'graph'}|[[]]]]}]]]]}|[{'type',118,'constraint',[{'atom',118,'is_subtype'}|[[{'var',118,'Root'}|[{'remote_type',118,[{'atom',118,'digraph'}|[{'atom',118,'vertex'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'is_arborescence',1},[{'type',139,'bounded_fun',[{'type',139,'fun',[{'type',139,'product',[{'var',139,'Digraph'}]}|[{'type',139,'boolean',[]}]]}|[[{'type',140,'constraint',[{'atom',140,'is_subtype'}|[[{'var',140,'Digraph'}|[{'remote_type',140,[{'atom',140,'digraph'}|[{'atom',140,'graph'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'is_tree',1},[{'type',145,'bounded_fun',[{'type',145,'fun',[{'type',145,'product',[{'var',145,'Digraph'}]}|[{'type',145,'boolean',[]}]]}|[[{'type',146,'constraint',[{'atom',146,'is_subtype'}|[[{'var',146,'Digraph'}|[{'remote_type',146,[{'atom',146,'digraph'}|[{'atom',146,'graph'}|[[]]]]}]]]]}]]]}]}]
, 'spec' = [{{'loop_vertices',1},[{'type',152,'bounded_fun',[{'type',152,'fun',[{'type',152,'product',[{'var',152,'Digraph'}]}|[{'var',152,'Vertices'}]]}|[[{'type',153,'constraint',[{'atom',153,'is_subtype'}|[[{'var',153,'Digraph'}|[{'remote_type',153,[{'atom',153,'digraph'}|[{'atom',153,'graph'}|[[]]]]}]]]]}|[{'type',154,'constraint',[{'atom',154,'is_subtype'}|[[{'var',154,'Vertices'}|[{'type',154,'list',[{'remote_type',154,[{'atom',154,'digraph'}|[{'atom',154,'vertex'}|[[]]]]}]}]]]]}]]]]}]}]
, 'spec' = [{{'subgraph',2},[{'type',159,'bounded_fun',[{'type',159,'fun',[{'type',159,'product',[{'var',159,'Digraph'}|[{'var',159,'Vertices'}]]}|[{'var',159,'SubGraph'}]]}|[[{'type',160,'constraint',[{'atom',160,'is_subtype'}|[[{'var',160,'Digraph'}|[{'remote_type',160,[{'atom',160,'digraph'}|[{'atom',160,'graph'}|[[]]]]}]]]]}|[{'type',161,'constraint',[{'atom',161,'is_subtype'}|[[{'var',161,'Vertices'}|[{'type',161,'list',[{'remote_type',161,[{'atom',161,'digraph'}|[{'atom',161,'vertex'}|[[]]]]}]}]]]]}|[{'type',162,'constraint',[{'atom',162,'is_subtype'}|[[{'var',162,'SubGraph'}|[{'remote_type',162,[{'atom',162,'digraph'}|[{'atom',162,'graph'}|[[]]]]}]]]]}]]]]]}]}]
, 'spec' = [{{'subgraph',3},[{'type',172,'bounded_fun',[{'type',172,'fun',[{'type',172,'product',[{'var',172,'Digraph'}|[{'var',172,'Vertices'}|[{'var',172,'Options'}]]]}|[{'var',172,'SubGraph'}]]}|[[{'type',173,'constraint',[{'atom',173,'is_subtype'}|[[{'var',173,'Digraph'}|[{'remote_type',173,[{'atom',173,'digraph'}|[{'atom',173,'graph'}|[[]]]]}]]]]}|[{'type',174,'constraint',[{'atom',174,'is_subtype'}|[[{'var',174,'SubGraph'}|[{'remote_type',174,[{'atom',174,'digraph'}|[{'atom',174,'graph'}|[[]]]]}]]]]}|[{'type',175,'constraint',[{'atom',175,'is_subtype'}|[[{'var',175,'Vertices'}|[{'type',175,'list',[{'remote_type',175,[{'atom',175,'digraph'}|[{'atom',175,'vertex'}|[[]]]]}]}]]]]}|[{'type',176,'constraint',[{'atom',176,'is_subtype'}|[[{'var',176,'Options'}|[{'type',176,'list',[{'type',176,'union',[{'type',176,'tuple',[{'atom',176,'type'}|[{'var',176,'SubgraphType'}]]}|[{'type',176,'tuple',[{'atom',176,'keep_labels'}|[{'type',176,'boolean',[]}]]}]]}]}]]]]}|[{'type',177,'constraint',[{'atom',177,'is_subtype'}|[[{'var',177,'SubgraphType'}|[{'type',177,'union',[{'atom',177,'inherit'}|[{'type',177,'list',[{'remote_type',177,[{'atom',177,'digraph'}|[{'atom',177,'d_type'}|[[]]]]}]}]]}]]]]}]]]]]]]}]}]
, 'spec' = [{{'condensation',1},[{'type',187,'bounded_fun',[{'type',187,'fun',[{'type',187,'product',[{'var',187,'Digraph'}]}|[{'var',187,'CondensedDigraph'}]]}|[[{'type',188,'constraint',[{'atom',188,'is_subtype'}|[[{'var',188,'Digraph'}|[{'remote_type',188,[{'atom',188,'digraph'}|[{'atom',188,'graph'}|[[]]]]}]]]]}|[{'type',189,'constraint',[{'atom',189,'is_subtype'}|[[{'var',189,'CondensedDigraph'}|[{'remote_type',189,[{'atom',189,'digraph'}|[{'atom',189,'graph'}|[[]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'preorder',1},[{'type',212,'bounded_fun',[{'type',212,'fun',[{'type',212,'product',[{'var',212,'Digraph'}]}|[{'var',212,'Vertices'}]]}|[[{'type',213,'constraint',[{'atom',213,'is_subtype'}|[[{'var',213,'Digraph'}|[{'remote_type',213,[{'atom',213,'digraph'}|[{'atom',213,'graph'}|[[]]]]}]]]]}|[{'type',214,'constraint',[{'atom',214,'is_subtype'}|[[{'var',214,'Vertices'}|[{'type',214,'list',[{'remote_type',214,[{'atom',214,'digraph'}|[{'atom',214,'vertex'}|[[]]]]}]}]]]]}]]]]}]}]
, 'spec' = [{{'postorder',1},[{'type',219,'bounded_fun',[{'type',219,'fun',[{'type',219,'product',[{'var',219,'Digraph'}]}|[{'var',219,'Vertices'}]]}|[[{'type',220,'constraint',[{'atom',220,'is_subtype'}|[[{'var',220,'Digraph'}|[{'remote_type',220,[{'atom',220,'digraph'}|[{'atom',220,'graph'}|[[]]]]}]]]]}|[{'type',221,'constraint',[{'atom',221,'is_subtype'}|[[{'var',221,'Vertices'}|[{'type',221,'list',[{'remote_type',221,[{'atom',221,'digraph'}|[{'atom',221,'vertex'}|[[]]]]}]}]]]]}]]]]}]}] ] 'components'/1 = fun (_0) -> let <_1> = 'inout'/3 in apply 'forest'/2 (_0,_1)
'strong_components'/1 = fun (_0) -> let <_2> = 'in'/3 in let <_1> = apply 'revpostorder'/1 (_0) in apply 'forest'/3 (_0,_2,_1)
'cyclic_strong_components'/1 = fun (_0) -> let <_1> = apply 'strong_components'/1 (_0) in apply 'remove_singletons'/3 (_1,_0,[])
'reachable'/2 = fun (_0,_1) -> case <_0,_1> of <Vs,G> when call 'erlang':'is_list' (Vs) -> let <_2> = 'out'/3 in let <_3> = apply 'forest'/4 (G,_2,Vs,'first') in call 'lists':'append' (_3)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'reachable',2}}] )-|['compiler_generated'] ) end
'reachable_neighbours'/2 = fun (_0,_1) -> case <_0,_1> of <Vs,G> when call 'erlang':'is_list' (Vs) -> let <_2> = 'out'/3 in let <_3> = apply 'forest'/4 (G,_2,Vs,'not_first') in call 'lists':'append' (_3)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'reachable_neighbours',2}}] )-|['compiler_generated'] ) end
'reaching'/2 = fun (_0,_1) -> case <_0,_1> of <Vs,G> when call 'erlang':'is_list' (Vs) -> let <_2> = 'in'/3 in let <_3> = apply 'forest'/4 (G,_2,Vs,'first') in call 'lists':'append' (_3)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'reaching',2}}] )-|['compiler_generated'] ) end
'reaching_neighbours'/2 = fun (_0,_1) -> case <_0,_1> of <Vs,G> when call 'erlang':'is_list' (Vs) -> let <_2> = 'in'/3 in let <_3> = apply 'forest'/4 (G,_2,Vs,'not_first') in call 'lists':'append' (_3)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'reaching_neighbours',2}}] )-|['compiler_generated'] ) end
'topsort'/1 = fun (_0) -> let <L> = apply 'revpostorder'/1 (_0) in let <_4> = 'in'/3 in let <_5> = apply 'forest'/3 (_0,_4,L) in let <_6> = call 'erlang':'length' (_5) in let <_2> = call 'digraph':'vertices' (_0) in let <_3> = call 'erlang':'length' (_2) in case <> of <> when call 'erlang':'=:=' (_6,_3) -> L
<> when 'true' -> 'false' end
'is_acyclic'/1 = fun (_0) -> let <_2> = apply 'loop_vertices'/1 (_0) in (case <> of (<> when call 'erlang':'=:=' (_2,[]) -> let <_3> = apply 'topsort'/1 (_0) in call 'erlang':'=/=' (_3,'false')-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end-|['compiler_generated'] )
'arborescence_root'/1 = fun (_0) -> let <_3> = call 'digraph':'no_edges' (_0) in let <_1> = call 'digraph':'no_vertices' (_0) in let <_2> = call 'erlang':'-' (_1,1) in case <> of <> when call 'erlang':'=:=' (_3,_2) -> try let <F> = fun (_6,_5) -> case call 'digraph':'in_degree' (_0,_6) of <1> when 'true' -> _5
<0> when call 'erlang':'=:=' (_5,[]) -> [_6|[]]
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in let <_10> = call 'digraph':'vertices' (_0) in case call 'lists':'foldl' (F,[],_10) of <[Root|[]]> when 'true' -> {'yes',Root}
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end of <_12> -> _12 catch <_15,_14,_13> -> 'no'
<> when 'true' -> 'no' end
'is_arborescence'/1 = fun (_0) -> let <_1> = apply 'arborescence_root'/1 (_0) in call 'erlang':'=/=' (_1,'no')
'is_tree'/1 = fun (_0) -> let <_4> = call 'digraph':'no_edges' (_0) in let <_2> = call 'digraph':'no_vertices' (_0) in let <_3> = call 'erlang':'-' (_2,1) in (case <> of (<> when call 'erlang':'=:=' (_4,_3) -> let <_5> = apply 'components'/1 (_0) in let <_6> = call 'erlang':'length' (_5) in call 'erlang':'=:=' (_6,1)-|['compiler_generated'] )
(<> when 'true' -> 'false'-|['compiler_generated'] ) end-|['compiler_generated'] )
'loop_vertices'/1 = fun (_0) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[V|_2]> when 'true' -> (case apply 'is_reflexive_vertex'/2 (V,_0) of <'true'> when 'true' -> let <_5> = apply 'lc$^0'/1 (_2) in ([V|_5]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end-|['list_comprehension'] )
<[]> when 'true' -> []
(<_8> when 'true' -> (primop 'match_fail' ({'function_clause',_8})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in let <_3> = call 'digraph':'vertices' (_0) in apply 'lc$^0'/1 (_3)-|['list_comprehension'] )
'subgraph'/2 = fun (_0,_1) -> try apply 'subgraph_opts'/3 (_0,_1,[]) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_8> when 'true' -> call 'erlang':'error' ('badarg')
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end
'subgraph'/3 = fun (_0,_1,_2) -> try apply 'subgraph_opts'/3 (_0,_1,_2) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_10> when 'true' -> call 'erlang':'error' ('badarg')
(<_11,_12,_13> when 'true' -> primop 'raise' (_13,_12)-|['compiler_generated'] ) end
'condensation'/1 = fun (_0) -> let <SCs> = apply 'strong_components'/1 (_0) in let <V2I> = call 'ets':'new' ('condensation',[]) in let <I2C> = call 'ets':'new' ('condensation',[]) in let <CFun> = fun (_10,_9) -> let <_7> = fun (_5) -> let <_19> = call 'ets':'insert' (V2I,{_5,_9}) in case _19 of <'true'> when 'true' -> (_19-|['compiler_generated'] )
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end in do call 'lists':'foreach' (_7,_10) case call 'ets':'insert' (I2C,{_9,_10}) of <'true'> when 'true' -> call 'erlang':'+' (_9,1)
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end in do call 'lists':'foldl' (CFun,1,SCs) let <SCG> = apply 'subgraph_opts'/3 (_0,[],[]) in let <_17> = fun (_15) -> apply 'condense'/5 (_15,_0,SCG,V2I,I2C) in do call 'lists':'foreach' (_17,SCs) do call 'ets':'delete' (V2I) do call 'ets':'delete' (I2C) SCG
'preorder'/1 = fun (_0) -> let <_1> = apply 'revpreorder'/1 (_0) in call 'lists':'reverse' (_1)
'postorder'/1 = fun (_0) -> let <_1> = apply 'revpostorder'/1 (_0) in call 'lists':'reverse' (_1)
'forest'/2 = fun (_0,_1) -> let <_2> = call 'digraph':'vertices' (_0) in apply 'forest'/3 (_0,_1,_2)
'forest'/3 = fun (_0,_1,_2) -> apply 'forest'/4 (_0,_1,_2,'first')
'forest'/4 = fun (_0,_1,_2,_3) -> let <T> = call 'ets':'new' ('forest',['set']) in let <F> = fun (_6,_5) -> apply 'pretraverse'/6 (_3,_6,_1,_0,T,_5) in let <LL> = call 'lists':'foldl' (F,[],_2) in do call 'ets':'delete' (T) LL
'pretraverse'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <'first',V,SF,G,T,LL> when 'true' -> apply 'ptraverse'/6 ([V|[]],SF,G,T,[],LL)
<'not_first',V,SF,G,T,LL> when 'true' -> case call 'ets':'member' (T,V) of <'false'> when 'true' -> let <_6> = apply SF (G,V,[]) in apply 'ptraverse'/6 (_6,SF,G,T,[],LL)
<'true'> when 'true' -> LL
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
(<_13,_12,_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10,_9,_8})-|[{'function_name',{'pretraverse',6}}] )-|['compiler_generated'] ) end
'ptraverse'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <[V|Vs],SF,G,T,Rs,LL> when 'true' -> case call 'ets':'member' (T,V) of <'false'> when 'true' -> do call 'ets':'insert' (T,{V}) let <_6> = apply SF (G,V,Vs) in apply 'ptraverse'/6 (_6,SF,G,T,[V|Rs],LL)
<'true'> when 'true' -> apply 'ptraverse'/6 (Vs,SF,G,T,Rs,LL)
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<[],_X_SF,_X_G,_X_T,[],LL> when 'true' -> LL
<[],_X_SF,_X_G,_X_T,Rs,LL> when 'true' -> [Rs|LL]
(<_13,_12,_11,_10,_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10,_9,_8})-|[{'function_name',{'ptraverse',6}}] )-|['compiler_generated'] ) end
'revpreorder'/1 = fun (_0) -> let <_1> = 'out'/3 in let <_2> = apply 'forest'/2 (_0,_1) in call 'lists':'append' (_2)
'revpostorder'/1 = fun (_0) -> let <T> = call 'ets':'new' ('forest',['set']) in let <_2> = call 'digraph':'vertices' (_0) in let <L> = apply 'posttraverse'/4 (_2,_0,T,[]) in do call 'ets':'delete' (T) L
'posttraverse'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[V|Vs],G,T,L> when 'true' -> let <_7> = case call 'ets':'member' (T,V) of <'false'> when 'true' -> do call 'ets':'insert' (T,{V}) let <_4> = apply 'out'/3 (G,V,[]) in let <_5> = apply 'posttraverse'/4 (_4,G,T,L) in [V|_5]
<'true'> when 'true' -> L
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end in apply 'posttraverse'/4 (Vs,G,T,_7)
<[],_X_G,_X_T,L> when 'true' -> L
(<_12,_11,_10,_9> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11,_10,_9})-|[{'function_name',{'posttraverse',4}}] )-|['compiler_generated'] ) end
'in'/3 = fun (_0,_1,_2) -> let <_3> = call 'digraph':'in_neighbours' (_0,_1) in call 'erlang':'++' (_3,_2)
'out'/3 = fun (_0,_1,_2) -> let <_3> = call 'digraph':'out_neighbours' (_0,_1) in call 'erlang':'++' (_3,_2)
'inout'/3 = fun (_0,_1,_2) -> let <_3> = apply 'out'/3 (_0,_1,_2) in apply 'in'/3 (_0,_1,_3)
'remove_singletons'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[C = [V|[]]|Cs],G,L> when 'true' -> case apply 'is_reflexive_vertex'/2 (V,G) of <'true'> when 'true' -> apply 'remove_singletons'/3 (Cs,G,[C|L])
<'false'> when 'true' -> apply 'remove_singletons'/3 (Cs,G,L)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
<[C|Cs],G,L> when 'true' -> apply 'remove_singletons'/3 (Cs,G,[C|L])
<[],_X_G,L> when 'true' -> L
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'remove_singletons',3}}] )-|['compiler_generated'] ) end
'is_reflexive_vertex'/2 = fun (_0,_1) -> let <_2> = call 'digraph':'out_neighbours' (_1,_0) in call 'lists':'member' (_0,_2)
'subgraph_opts'/3 = fun (_0,_1,_2) -> apply 'subgraph_opts'/5 (_2,'inherit','true',_0,_1)
'subgraph_opts'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[{'type',Type}|Opts],_X_Type0,Keep,G,Vs> when let <_5> = call 'erlang':'=:=' (Type,'inherit') in let <_6> = call 'erlang':'is_list' (Type) in call 'erlang':'or' (_5,_6) -> apply 'subgraph_opts'/5 (Opts,Type,Keep,G,Vs)
<[{'keep_labels',Keep}|Opts],Type,_X_Keep0,G,Vs> when call 'erlang':'is_boolean' (Keep) -> apply 'subgraph_opts'/5 (Opts,Type,Keep,G,Vs)
<[],'inherit',Keep,G,Vs> when 'true' -> let <Info> = call 'digraph':'info' (G) in case call 'lists':'keysearch' ('cyclicity',1,Info) of <{_15,{_16,Cyclicity}}> when 'true' -> case call 'lists':'keysearch' ('protection',1,Info) of <{_17,{_18,Protection}}> when 'true' -> apply 'subgraph'/4 (G,Vs,[Cyclicity|[Protection|[]]],Keep)
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<[],Type,Keep,G,Vs> when 'true' -> apply 'subgraph'/4 (G,Vs,Type,Keep)
<_19,_X_Type,_X_Keep,_X_G,_X_Vs> when 'true' -> call 'erlang':'throw' ('badarg') end
'subgraph'/4 = fun (_0,_1,_2,_3) -> try call 'digraph':'new' (_2) of <_4> -> let <_7> = fun (_5) -> apply 'subgraph_vertex'/4 (_5,_0,_4,_3) in do call 'lists':'foreach' (_7,_1) let <EFun> = fun (_12) -> let <_11> = fun (_9) -> apply 'subgraph_edge'/4 (_9,_0,_4,_3) in let <_8> = call 'digraph':'out_edges' (_0,_12) in call 'lists':'foreach' (_11,_8) in let <_15> = call 'digraph':'vertices' (_4) in do call 'lists':'foreach' (EFun,_15) _4 catch <_19,_18,_17> -> case <_19,_18,_17> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_24> when 'true' -> call 'erlang':'throw' ('badarg')
(<_29,_30,_31> when 'true' -> primop 'raise' (_31,_30)-|['compiler_generated'] ) end
'subgraph_vertex'/4 = fun (_0,_1,_2,_3) -> case call 'digraph':'vertex' (_1,_0) of <'false'> when 'true' -> 'ok'
<_10> when (call 'erlang':'=:=' (_3,'false')-|['compiler_generated'] ) -> call 'digraph':'add_vertex' (_2,_0)
<{_X_V,Label}> when (call 'erlang':'=:=' (_3,'true')-|['compiler_generated'] ) -> call 'digraph':'add_vertex' (_2,_0,Label)
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
'subgraph_edge'/4 = fun (_0,_1,_2,_3) -> case call 'digraph':'edge' (_1,_0) of <{_X_E,V1,V2,Label}> when 'true' -> case call 'digraph':'vertex' (_2,V2) of <'false'> when 'true' -> 'ok'
<_11> when (call 'erlang':'=:=' (_3,'false')-|['compiler_generated'] ) -> call 'digraph':'add_edge' (_2,_0,V1,V2,[])
<_12> when (call 'erlang':'=:=' (_3,'true')-|['compiler_generated'] ) -> call 'digraph':'add_edge' (_2,_0,V1,V2,Label)
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
'condense'/5 = fun (_0,_1,_2,_3,_4) -> let <T> = call 'ets':'new' ('condense',[]) in let <NFun> = fun (_7) -> case call 'ets':'lookup' (_3,_7) of <[{_X_V,I}|[]]> when 'true' -> call 'ets':'insert' (T,{I})
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end in let <VFun> = fun (_11) -> let <_10> = call 'digraph':'out_neighbours' (_1,_11) in call 'lists':'foreach' (NFun,_10) in do call 'lists':'foreach' (VFun,_0) do call 'digraph':'add_vertex' (_2,_0) let <_14> = call 'ets':'first' (T) in do apply 'condense'/6 (_14,T,_0,_1,_2,_4) call 'ets':'delete' (T)
'condense'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <'$end_of_table',_X_T,_X_SC,_X_G,_X_SCG,_X_I2C> when 'true' -> 'ok'
<I,T,SC,G,SCG,I2C> when 'true' -> case call 'ets':'lookup' (I2C,I) of <[{_17,C}|[]]> when 'true' -> do call 'digraph':'add_vertex' (SCG,C) do (case <> of <> when (call ('erlang'-|['result_not_wanted'] ):('=/='-|['result_not_wanted'] ) (C,SC)-|['result_not_wanted'] ) -> (call ('digraph'-|['result_not_wanted'] ):('add_edge'-|['result_not_wanted'] ) (SCG,SC,C)-|['result_not_wanted'] )
(<> when 'true' -> []-|['compiler_generated'] ) end-|['list_comprehension'] ) let <_10> = call 'ets':'next' (T,I) in apply 'condense'/6 (_10,T,SC,G,SCG,I2C)
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('digraph_utils')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('digraph_utils',_0) end