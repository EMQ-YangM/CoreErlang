module 'gen_server' ['abcast'/2,'abcast'/3,'behaviour_info'/1,'call'/2,'call'/3,'cast'/2,'check_response'/2,'enter_loop'/3,'enter_loop'/4,'enter_loop'/5,'format_log'/1,'format_log'/2,'format_status'/2,'init_it'/6,'module_info'/0,'module_info'/1,'multi_call'/2,'multi_call'/3,'multi_call'/4,'reply'/2,'send_request'/2,'start'/3,'start'/4,'start_link'/3,'start_link'/4,'start_monitor'/3,'start_monitor'/4,'stop'/1,'stop'/3,'system_code_change'/4,'system_continue'/3,'system_get_state'/1,'system_replace_state'/2,'system_terminate'/4,'wait_response'/2,'wake_hib'/6] attributes [ 'file' = [{[115|[114|[99|[47|[103|[101|[110|[95|[115|[101|[114|[118|[101|[114|[46|[101|[114|[108]]]]]]]]]]]]]]]]]],1}]
, 'file' = [{[47|[85|[115|[101|[114|[115|[47|[102|[101|[110|[103|[108|[101|[101|[47|[72|[97|[109|[108|[101|[114|[47|[111|[116|[112|[45|[79|[84|[80|[45|[50|[51|[46|[48|[45|[114|[99|[49|[47|[108|[105|[98|[47|[115|[116|[100|[108|[105|[98|[47|[46|[46|[47|[107|[101|[114|[110|[101|[108|[47|[105|[110|[99|[108|[117|[100|[101|[47|[108|[111|[103|[103|[101|[114|[46|[104|[114|[108]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],1}]
, 'file' = [{[115|[114|[99|[47|[103|[101|[110|[95|[115|[101|[114|[118|[101|[114|[46|[101|[114|[108]]]]]]]]]]]]]]]]]],121}]
, 'type' = [{'server_ref',{'type',128,'union',[{'type',128,'pid',[]}|[{'ann_type',129,[{'var',129,'LocalName'}|[{'type',129,'atom',[]}]]}|[{'type',130,'tuple',[{'ann_type',130,[{'var',130,'Name'}|[{'type',130,'atom',[]}]]}|[{'ann_type',130,[{'var',130,'Node'}|[{'type',130,'atom',[]}]]}]]}|[{'type',131,'tuple',[{'atom',131,'global'}|[{'ann_type',131,[{'var',131,'GlobalName'}|[{'type',131,'term',[]}]]}]]}|[{'type',132,'tuple',[{'atom',132,'via'}|[{'ann_type',132,[{'var',132,'RegMod'}|[{'type',132,'module',[]}]]}|[{'ann_type',132,[{'var',132,'ViaName'}|[{'type',132,'term',[]}]]}]]]}]]]]]},[]}]
, 'type' = [{'request_id',{'type',134,'term',[]},[]}]
, 'callback' = [{{'init',1},[{'type',140,'fun',[{'type',140,'product',[{'ann_type',140,[{'var',140,'Args'}|[{'type',140,'term',[]}]]}]}|[{'type',141,'union',[{'type',141,'tuple',[{'atom',141,'ok'}|[{'ann_type',141,[{'var',141,'State'}|[{'type',141,'term',[]}]]}]]}|[{'type',141,'tuple',[{'atom',141,'ok'}|[{'ann_type',141,[{'var',141,'State'}|[{'type',141,'term',[]}]]}|[{'type',141,'union',[{'type',141,'timeout',[]}|[{'atom',141,'hibernate'}|[{'type',141,'tuple',[{'atom',141,'continue'}|[{'type',141,'term',[]}]]}]]]}]]]}|[{'type',142,'tuple',[{'atom',142,'stop'}|[{'ann_type',142,[{'var',142,'Reason'}|[{'type',142,'term',[]}]]}]]}|[{'atom',142,'ignore'}]]]]}]]}]}]
, 'callback' = [{{'handle_call',3},[{'type',143,'fun',[{'type',143,'product',[{'ann_type',143,[{'var',143,'Request'}|[{'type',143,'term',[]}]]}|[{'ann_type',143,[{'var',143,'From'}|[{'type',143,'tuple',[{'type',143,'pid',[]}|[{'ann_type',143,[{'var',143,'Tag'}|[{'type',143,'term',[]}]]}]]}]]}|[{'ann_type',144,[{'var',144,'State'}|[{'type',144,'term',[]}]]}]]]}|[{'type',145,'union',[{'type',145,'tuple',[{'atom',145,'reply'}|[{'ann_type',145,[{'var',145,'Reply'}|[{'type',145,'term',[]}]]}|[{'ann_type',145,[{'var',145,'NewState'}|[{'type',145,'term',[]}]]}]]]}|[{'type',146,'tuple',[{'atom',146,'reply'}|[{'ann_type',146,[{'var',146,'Reply'}|[{'type',146,'term',[]}]]}|[{'ann_type',146,[{'var',146,'NewState'}|[{'type',146,'term',[]}]]}|[{'type',146,'union',[{'type',146,'timeout',[]}|[{'atom',146,'hibernate'}|[{'type',146,'tuple',[{'atom',146,'continue'}|[{'type',146,'term',[]}]]}]]]}]]]]}|[{'type',147,'tuple',[{'atom',147,'noreply'}|[{'ann_type',147,[{'var',147,'NewState'}|[{'type',147,'term',[]}]]}]]}|[{'type',148,'tuple',[{'atom',148,'noreply'}|[{'ann_type',148,[{'var',148,'NewState'}|[{'type',148,'term',[]}]]}|[{'type',148,'union',[{'type',148,'timeout',[]}|[{'atom',148,'hibernate'}|[{'type',148,'tuple',[{'atom',148,'continue'}|[{'type',148,'term',[]}]]}]]]}]]]}|[{'type',149,'tuple',[{'atom',149,'stop'}|[{'ann_type',149,[{'var',149,'Reason'}|[{'type',149,'term',[]}]]}|[{'ann_type',149,[{'var',149,'Reply'}|[{'type',149,'term',[]}]]}|[{'ann_type',149,[{'var',149,'NewState'}|[{'type',149,'term',[]}]]}]]]]}|[{'type',150,'tuple',[{'atom',150,'stop'}|[{'ann_type',150,[{'var',150,'Reason'}|[{'type',150,'term',[]}]]}|[{'ann_type',150,[{'var',150,'NewState'}|[{'type',150,'term',[]}]]}]]]}]]]]]]}]]}]}]
, 'callback' = [{{'handle_cast',2},[{'type',151,'fun',[{'type',151,'product',[{'ann_type',151,[{'var',151,'Request'}|[{'type',151,'term',[]}]]}|[{'ann_type',151,[{'var',151,'State'}|[{'type',151,'term',[]}]]}]]}|[{'type',152,'union',[{'type',152,'tuple',[{'atom',152,'noreply'}|[{'ann_type',152,[{'var',152,'NewState'}|[{'type',152,'term',[]}]]}]]}|[{'type',153,'tuple',[{'atom',153,'noreply'}|[{'ann_type',153,[{'var',153,'NewState'}|[{'type',153,'term',[]}]]}|[{'type',153,'union',[{'type',153,'timeout',[]}|[{'atom',153,'hibernate'}|[{'type',153,'tuple',[{'atom',153,'continue'}|[{'type',153,'term',[]}]]}]]]}]]]}|[{'type',154,'tuple',[{'atom',154,'stop'}|[{'ann_type',154,[{'var',154,'Reason'}|[{'type',154,'term',[]}]]}|[{'ann_type',154,[{'var',154,'NewState'}|[{'type',154,'term',[]}]]}]]]}]]]}]]}]}]
, 'callback' = [{{'handle_info',2},[{'type',155,'fun',[{'type',155,'product',[{'ann_type',155,[{'var',155,'Info'}|[{'type',155,'union',[{'atom',155,'timeout'}|[{'type',155,'term',[]}]]}]]}|[{'ann_type',155,[{'var',155,'State'}|[{'type',155,'term',[]}]]}]]}|[{'type',156,'union',[{'type',156,'tuple',[{'atom',156,'noreply'}|[{'ann_type',156,[{'var',156,'NewState'}|[{'type',156,'term',[]}]]}]]}|[{'type',157,'tuple',[{'atom',157,'noreply'}|[{'ann_type',157,[{'var',157,'NewState'}|[{'type',157,'term',[]}]]}|[{'type',157,'union',[{'type',157,'timeout',[]}|[{'atom',157,'hibernate'}|[{'type',157,'tuple',[{'atom',157,'continue'}|[{'type',157,'term',[]}]]}]]]}]]]}|[{'type',158,'tuple',[{'atom',158,'stop'}|[{'ann_type',158,[{'var',158,'Reason'}|[{'type',158,'term',[]}]]}|[{'ann_type',158,[{'var',158,'NewState'}|[{'type',158,'term',[]}]]}]]]}]]]}]]}]}]
, 'callback' = [{{'handle_continue',2},[{'type',159,'fun',[{'type',159,'product',[{'ann_type',159,[{'var',159,'Info'}|[{'type',159,'term',[]}]]}|[{'ann_type',159,[{'var',159,'State'}|[{'type',159,'term',[]}]]}]]}|[{'type',160,'union',[{'type',160,'tuple',[{'atom',160,'noreply'}|[{'ann_type',160,[{'var',160,'NewState'}|[{'type',160,'term',[]}]]}]]}|[{'type',161,'tuple',[{'atom',161,'noreply'}|[{'ann_type',161,[{'var',161,'NewState'}|[{'type',161,'term',[]}]]}|[{'type',161,'union',[{'type',161,'timeout',[]}|[{'atom',161,'hibernate'}|[{'type',161,'tuple',[{'atom',161,'continue'}|[{'type',161,'term',[]}]]}]]]}]]]}|[{'type',162,'tuple',[{'atom',162,'stop'}|[{'ann_type',162,[{'var',162,'Reason'}|[{'type',162,'term',[]}]]}|[{'ann_type',162,[{'var',162,'NewState'}|[{'type',162,'term',[]}]]}]]]}]]]}]]}]}]
, 'callback' = [{{'terminate',2},[{'type',163,'fun',[{'type',163,'product',[{'ann_type',163,[{'var',163,'Reason'}|[{'type',163,'union',[{'atom',163,'normal'}|[{'atom',163,'shutdown'}|[{'type',163,'tuple',[{'atom',163,'shutdown'}|[{'type',163,'term',[]}]]}|[{'type',164,'term',[]}]]]]}]]}|[{'ann_type',165,[{'var',165,'State'}|[{'type',165,'term',[]}]]}]]}|[{'type',166,'term',[]}]]}]}]
, 'callback' = [{{'code_change',3},[{'type',167,'fun',[{'type',167,'product',[{'ann_type',167,[{'var',167,'OldVsn'}|[{'type',167,'union',[{'type',167,'term',[]}|[{'type',167,'tuple',[{'atom',167,'down'}|[{'type',167,'term',[]}]]}]]}]]}|[{'ann_type',167,[{'var',167,'State'}|[{'type',167,'term',[]}]]}|[{'ann_type',168,[{'var',168,'Extra'}|[{'type',168,'term',[]}]]}]]]}|[{'type',169,'union',[{'type',169,'tuple',[{'atom',169,'ok'}|[{'ann_type',169,[{'var',169,'NewState'}|[{'type',169,'term',[]}]]}]]}|[{'type',169,'tuple',[{'atom',169,'error'}|[{'ann_type',169,[{'var',169,'Reason'}|[{'type',169,'term',[]}]]}]]}]]}]]}]}]
, 'callback' = [{{'format_status',2},[{'type',170,'bounded_fun',[{'type',170,'fun',[{'type',170,'product',[{'var',170,'Opt'}|[{'var',170,'StatusData'}]]}|[{'var',170,'Status'}]]}|[[{'type',171,'constraint',[{'atom',171,'is_subtype'}|[[{'var',171,'Opt'}|[{'type',171,'union',[{'atom',171,'normal'}|[{'atom',171,'terminate'}]]}]]]]}|[{'type',172,'constraint',[{'atom',172,'is_subtype'}|[[{'var',172,'StatusData'}|[{'type',172,'list',[{'type',172,'union',[{'var',172,'PDict'}|[{'var',172,'State'}]]}]}]]]]}|[{'type',173,'constraint',[{'atom',173,'is_subtype'}|[[{'var',173,'PDict'}|[{'type',173,'list',[{'type',173,'tuple',[{'ann_type',173,[{'var',173,'Key'}|[{'type',173,'term',[]}]]}|[{'ann_type',173,[{'var',173,'Value'}|[{'type',173,'term',[]}]]}]]}]}]]]]}|[{'type',174,'constraint',[{'atom',174,'is_subtype'}|[[{'var',174,'State'}|[{'type',174,'term',[]}]]]]}|[{'type',175,'constraint',[{'atom',175,'is_subtype'}|[[{'var',175,'Status'}|[{'type',175,'term',[]}]]]]}]]]]]]]}]}]
, 'optional_callbacks' = [{'handle_info',2}|[{'handle_continue',2}|[{'terminate',2}|[{'code_change',3}|[{'format_status',2}]]]]]
, 'spec' = [{{'send_request',2},[{'type',254,'fun',[{'type',254,'product',[{'ann_type',254,[{'var',254,'Name'}|[{'user_type',254,'server_ref',[]}]]}|[{'ann_type',254,[{'var',254,'Request'}|[{'type',254,'term',[]}]]}]]}|[{'user_type',254,'request_id',[]}]]}]}]
, 'spec' = [{{'wait_response',2},[{'type',258,'fun',[{'type',258,'product',[{'ann_type',258,[{'var',258,'RequestId'}|[{'user_type',258,'request_id',[]}]]}|[{'type',258,'timeout',[]}]]}|[{'type',259,'union',[{'type',259,'tuple',[{'atom',259,'reply'}|[{'ann_type',259,[{'var',259,'Reply'}|[{'type',259,'term',[]}]]}]]}|[{'atom',259,'timeout'}|[{'type',259,'tuple',[{'atom',259,'error'}|[{'type',259,'tuple',[{'ann_type',259,[{'var',259,'Reason'}|[{'type',259,'term',[]}]]}|[{'user_type',259,'server_ref',[]}]]}]]}]]]}]]}]}]
, 'spec' = [{{'check_response',2},[{'type',263,'fun',[{'type',263,'product',[{'ann_type',263,[{'var',263,'Msg'}|[{'type',263,'term',[]}]]}|[{'ann_type',263,[{'var',263,'RequestId'}|[{'user_type',263,'request_id',[]}]]}]]}|[{'type',264,'union',[{'type',264,'tuple',[{'atom',264,'reply'}|[{'ann_type',264,[{'var',264,'Reply'}|[{'type',264,'term',[]}]]}]]}|[{'atom',264,'no_reply'}|[{'type',264,'tuple',[{'atom',264,'error'}|[{'type',264,'tuple',[{'ann_type',264,[{'var',264,'Reason'}|[{'type',264,'term',[]}]]}|[{'user_type',264,'server_ref',[]}]]}]]}]]]}]]}]}]
, 'spec' = [{{'system_terminate',4},[{'type',833,'fun',[{'type',833,'product',[{'var',833,'_'}|[{'var',833,'_'}|[{'var',833,'_'}|[{'type',833,'list',[{'var',833,'_'}]}]]]]}|[{'type',833,'no_return',[]}]]}]}]
, 'spec' = [{{'terminate',8},[{'type',892,'fun',[{'type',892,'product',[{'var',892,'_'}|[{'var',892,'_'}|[{'var',892,'_'}|[{'var',892,'_'}|[{'var',892,'_'}|[{'var',892,'_'}|[{'var',892,'_'}|[{'var',892,'_'}]]]]]]]]}|[{'type',892,'no_return',[]}]]}]}]
, 'spec' = [{{'terminate',9},[{'type',896,'fun',[{'type',896,'product',[{'var',896,'_'}|[{'var',896,'_'}|[{'var',896,'_'}|[{'var',896,'_'}|[{'var',896,'_'}|[{'var',896,'_'}|[{'var',896,'_'}|[{'var',896,'_'}|[{'var',896,'_'}]]]]]]]]]}|[{'type',896,'no_return',[]}]]}]}]
, 'spec' = [{{'terminate',10},[{'type',901,'fun',[{'type',901,'product',[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}|[{'var',901,'_'}]]]]]]]]]]}|[{'type',901,'no_return',[]}]]}]}] ] 'start'/3 = fun (_0,_1,_2) -> call 'gen':'start' ('gen_server','nolink',_0,_1,_2)
'start'/4 = fun (_0,_1,_2,_3) -> call 'gen':'start' ('gen_server','nolink',_0,_1,_2,_3)
'start_link'/3 = fun (_0,_1,_2) -> call 'gen':'start' ('gen_server','link',_0,_1,_2)
'start_link'/4 = fun (_0,_1,_2,_3) -> call 'gen':'start' ('gen_server','link',_0,_1,_2,_3)
'start_monitor'/3 = fun (_0,_1,_2) -> call 'gen':'start' ('gen_server','monitor',_0,_1,_2)
'start_monitor'/4 = fun (_0,_1,_2,_3) -> call 'gen':'start' ('gen_server','monitor',_0,_1,_2,_3)
'stop'/1 = fun (_0) -> call 'gen':'stop' (_0)
'stop'/3 = fun (_0,_1,_2) -> call 'gen':'stop' (_0,_1,_2)
'call'/2 = fun (_0,_1) -> let <_2> = catch call 'gen':'call' (_0,'$gen_call',_1) in case _2 of <{'ok',Res}> when 'true' -> Res
<{'EXIT',Reason}> when 'true' -> call 'erlang':'exit' ({Reason,{'gen_server','call',[_0|[_1|[]]]}})
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'call'/3 = fun (_0,_1,_2) -> let <_3> = catch call 'gen':'call' (_0,'$gen_call',_1,_2) in case _3 of <{'ok',Res}> when 'true' -> Res
<{'EXIT',Reason}> when 'true' -> call 'erlang':'exit' ({Reason,{'gen_server','call',[_0|[_1|[_2|[]]]]}})
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'send_request'/2 = fun (_0,_1) -> call 'gen':'send_request' (_0,'$gen_call',_1)
'wait_response'/2 = fun (_0,_1) -> call 'gen':'wait_response' (_0,_1)
'check_response'/2 = fun (_0,_1) -> call 'gen':'check_response' (_0,_1)
'cast'/2 = fun (_0,_1) -> case <_0,_1> of <{'global',Name},Request> when 'true' -> do try let <_2> = apply 'cast_msg'/1 (Request) in call 'global':'send' (Name,_2) of <_catch_value> -> _catch_value catch <Class,Reason,Stk> -> 'ok' 'ok'
<{'via',Mod,Name},Request> when 'true' -> do try let <_3> = apply 'cast_msg'/1 (Request) in call Mod:'send' (Name,_3) of <_catch_value> -> _catch_value catch <Class,Reason,Stk> -> 'ok' 'ok'
<Dest = {Name,Node},Request> when let <_4> = call 'erlang':'is_atom' (Name) in let <_5> = call 'erlang':'is_atom' (Node) in call 'erlang':'and' (_4,_5) -> apply 'do_cast'/2 (Dest,Request)
<Dest,Request> when call 'erlang':'is_atom' (Dest) -> apply 'do_cast'/2 (Dest,Request)
<Dest,Request> when call 'erlang':'is_pid' (Dest) -> apply 'do_cast'/2 (Dest,Request)
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'cast',2}}] )-|['compiler_generated'] ) end
'do_cast'/2 = fun (_0,_1) -> let <_2> = apply 'cast_msg'/1 (_1) in do apply 'do_send'/2 (_0,_2) 'ok'
'cast_msg'/1 = fun (_0) -> {'$gen_cast',_0}
'reply'/2 = fun (_0,_1) -> case <_0,_1> of <{To,Tag},Reply> when 'true' -> do try call 'erlang':'!' (To,{Tag,Reply}) of <_catch_value> -> _catch_value catch <Class,Reason,Stk> -> 'ok' 'ok'
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'reply',2}}] )-|['compiler_generated'] ) end
'abcast'/2 = fun (_0,_1) -> case <_0,_1> of <Name,Request> when call 'erlang':'is_atom' (Name) -> let <_3> = call 'erlang':'node' () in let <_4> = call 'erlang':'nodes' () in let <_2> = apply 'cast_msg'/1 (Request) in apply 'do_abcast'/3 ([_3|_4],Name,_2)
(<_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5})-|[{'function_name',{'abcast',2}}] )-|['compiler_generated'] ) end
'abcast'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Nodes,Name,Request> when let <_3> = call 'erlang':'is_list' (Nodes) in let <_4> = call 'erlang':'is_atom' (Name) in call 'erlang':'and' (_3,_4) -> let <_5> = apply 'cast_msg'/1 (Request) in apply 'do_abcast'/3 (Nodes,Name,_5)
(<_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6})-|[{'function_name',{'abcast',3}}] )-|['compiler_generated'] ) end
'do_abcast'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <[Node|Nodes],Name,Msg> when call 'erlang':'is_atom' (Node) -> do apply 'do_send'/2 ({Name,Node},Msg) apply 'do_abcast'/3 (Nodes,Name,Msg)
<[],_6,_7> when 'true' -> 'abcast'
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'do_abcast',3}}] )-|['compiler_generated'] ) end
'multi_call'/2 = fun (_0,_1) -> case <_0,_1> of <Name,Req> when call 'erlang':'is_atom' (Name) -> let <_2> = call 'erlang':'node' () in let <_3> = call 'erlang':'nodes' () in apply 'do_multi_call'/4 ([_2|_3],Name,Req,'infinity')
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'multi_call',2}}] )-|['compiler_generated'] ) end
'multi_call'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Nodes,Name,Req> when let <_3> = call 'erlang':'is_list' (Nodes) in let <_4> = call 'erlang':'is_atom' (Name) in call 'erlang':'and' (_3,_4) -> apply 'do_multi_call'/4 (Nodes,Name,Req,'infinity')
(<_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5})-|[{'function_name',{'multi_call',3}}] )-|['compiler_generated'] ) end
'multi_call'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Nodes,Name,Req,'infinity'> when 'true' -> apply 'do_multi_call'/4 (Nodes,Name,Req,'infinity')
<Nodes,Name,Req,Timeout> when try let <_4> = call 'erlang':'is_list' (Nodes) in let <_5> = call 'erlang':'is_atom' (Name) in let <_6> = call 'erlang':'is_integer' (Timeout) in let <_7> = call 'erlang':'>=' (Timeout,0) in let <_8> = call 'erlang':'and' (_6,_7) in let <_9> = call 'erlang':'and' (_5,_8) in call 'erlang':'and' (_4,_9) of <Try> -> Try catch <T,R> -> 'false' -> apply 'do_multi_call'/4 (Nodes,Name,Req,Timeout)
(<_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12,_11,_10})-|[{'function_name',{'multi_call',4}}] )-|['compiler_generated'] ) end
'enter_loop'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'self' () in apply 'enter_loop'/5 (_0,_1,_2,_3,'infinity')
'enter_loop'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Mod,Options,State,ServerName = {Scope,_11}> when let <_4> = call 'erlang':'=:=' (Scope,'local') in let <_5> = call 'erlang':'=:=' (Scope,'global') in call 'erlang':'or' (_4,_5) -> apply 'enter_loop'/5 (Mod,Options,State,ServerName,'infinity')
<Mod,Options,State,ServerName = {'via',_12,_13}> when 'true' -> apply 'enter_loop'/5 (Mod,Options,State,ServerName,'infinity')
<Mod,Options,State,Timeout> when 'true' -> let <_6> = call 'erlang':'self' () in apply 'enter_loop'/5 (Mod,Options,State,_6,Timeout) end
'enter_loop'/5 = fun (_0,_1,_2,_3,_4) -> let <Name> = call 'gen':'get_proc_name' (_3) in let <Parent> = call 'gen':'get_parent' () in let <Debug> = call 'gen':'debug_options' (Name,_1) in let <HibernateAfterTimeout> = call 'gen':'hibernate_after' (_1) in apply 'loop'/7 (Parent,Name,_2,_0,_4,HibernateAfterTimeout,Debug)
'init_it'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <Starter,'self',Name,Mod,Args,Options> when 'true' -> let <_6> = call 'erlang':'self' () in apply 'init_it'/6 (Starter,_6,Name,Mod,Args,Options)
<Starter,Parent,Name0,Mod,Args,Options> when 'true' -> let <Name> = call 'gen':'name' (Name0) in let <Debug> = call 'gen':'debug_options' (Name,Options) in let <HibernateAfterTimeout> = call 'gen':'hibernate_after' (Options) in case apply 'init_it'/2 (Mod,Args) of <{'ok',{'ok',State}}> when 'true' -> let <_10> = call 'erlang':'self' () in do call 'proc_lib':'init_ack' (Starter,{'ok',_10}) apply 'loop'/7 (Parent,Name,State,Mod,'infinity',HibernateAfterTimeout,Debug)
<{'ok',{'ok',State,Timeout}}> when 'true' -> let <_11> = call 'erlang':'self' () in do call 'proc_lib':'init_ack' (Starter,{'ok',_11}) apply 'loop'/7 (Parent,Name,State,Mod,Timeout,HibernateAfterTimeout,Debug)
<{'ok',{'stop',Reason}}> when 'true' -> do call 'gen':'unregister_name' (Name0) do call 'proc_lib':'init_ack' (Starter,{'error',Reason}) call 'erlang':'exit' (Reason)
<{'ok','ignore'}> when 'true' -> do call 'gen':'unregister_name' (Name0) do call 'proc_lib':'init_ack' (Starter,'ignore') call 'erlang':'exit' ('normal')
<{'ok',Else}> when 'true' -> let <Error> = {'bad_return_value',Else} in do call 'proc_lib':'init_ack' (Starter,{'error',Error}) call 'erlang':'exit' (Error)
<{'EXIT',Class,Reason,Stacktrace}> when 'true' -> do call 'gen':'unregister_name' (Name0) let <_13> = apply 'terminate_reason'/3 (Class,Reason,Stacktrace) in do call 'proc_lib':'init_ack' (Starter,{'error',_13}) call 'erlang':'raise' (Class,Reason,Stacktrace)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end end
'init_it'/2 = fun (_0,_1) -> try let <_2> = call _0:'init' (_1) in {'ok',_2} of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),R,_9> when 'true' -> {'ok',R}
<Class,R,_10> when 'true' -> let <S> = primop 'build_stacktrace' (_10) in {'EXIT',Class,R,S} end
'loop'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <Parent,Name,State,Mod,Msg = {'continue',Continue},HibernateAfterTimeout,Debug> when 'true' -> let <Reply> = apply 'try_dispatch'/4 (Mod,'handle_continue',Continue,State) in case Debug of <[]> when 'true' -> apply 'handle_common_reply'/8 (Reply,Parent,Name,'undefined',Msg,Mod,HibernateAfterTimeout,State)
<_20> when 'true' -> let <_8> = 'print_event'/3 in let <Debug1> = call 'sys':'handle_debug' (Debug,_8,Name,Msg) in apply 'handle_common_reply'/9 (Reply,Parent,Name,'undefined',Msg,Mod,HibernateAfterTimeout,State,Debug1) end
<Parent,Name,State,Mod,'hibernate',HibernateAfterTimeout,Debug> when 'true' -> call 'proc_lib':'hibernate' ('gen_server','wake_hib',[Parent|[Name|[State|[Mod|[HibernateAfterTimeout|[Debug|[]]]]]]])
<Parent,Name,State,Mod,'infinity',HibernateAfterTimeout,Debug> when 'true' -> receive <Msg> when 'true' -> apply 'decode_msg'/9 (Msg,Parent,Name,State,Mod,'infinity',HibernateAfterTimeout,Debug,'false') after HibernateAfterTimeout -> apply 'loop'/7 (Parent,Name,State,Mod,'hibernate',HibernateAfterTimeout,Debug)
<Parent,Name,State,Mod,Time,HibernateAfterTimeout,Debug> when 'true' -> let <_11> = receive <Input> when 'true' -> Input after Time -> 'timeout' in apply 'decode_msg'/9 (_11,Parent,Name,State,Mod,Time,HibernateAfterTimeout,Debug,'false') end
'wake_hib'/6 = fun (_0,_1,_2,_3,_4,_5) -> let <_6> = receive <Input> when 'true' -> Input after 'infinity' -> 'true' in apply 'decode_msg'/9 (_6,_0,_1,_2,_3,'hibernate',_4,_5,'true')
'decode_msg'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> case _0 of <{'system',From,Req}> when 'true' -> call 'sys':'handle_system_msg' (Req,From,_1,'gen_server',_7,[_2|[_3|[_4|[_5|[_6|[]]]]]],_8)
<{'EXIT',_24,Reason}> when call 'erlang':'=:=' (_24,_1) -> let <_9> = call 'erlang':'self' () in let <_10> = call 'erlang':'process_info' (_9,'current_stacktrace') in let <_11> = call 'erlang':'element' (2,_10) in apply 'terminate'/8 (Reason,_11,_2,'undefined',_0,_4,_3,_7)
<_X_Msg> when call 'erlang':'=:=' (_7,[]) -> apply 'handle_msg'/6 (_0,_1,_2,_3,_4,_6)
<_X_Msg> when 'true' -> let <_12> = 'print_event'/3 in let <Debug1> = call 'sys':'handle_debug' (_7,_12,_2,{'in',_0}) in apply 'handle_msg'/7 (_0,_1,_2,_3,_4,_6,Debug1) end
'do_send'/2 = fun (_0,_1) -> do try call 'erlang':'send' (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('error'-|['compiler_generated'] ),_8,_9> when 'true' -> 'ok'
(<_10,_11,_12> when 'true' -> primop 'raise' (_12,_11)-|['compiler_generated'] ) end 'ok'
'do_multi_call'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Nodes,Name,Req,'infinity'> when 'true' -> let <Tag> = call 'erlang':'make_ref' () in let <Monitors> = apply 'send_nodes'/4 (Nodes,Name,Tag,Req) in apply 'rec_nodes'/4 (Tag,Monitors,Name,'undefined')
<Nodes,Name,Req,Timeout> when 'true' -> let <Tag> = call 'erlang':'make_ref' () in let <Caller> = call 'erlang':'self' () in let <_14> = fun () -> do call 'erlang':'process_flag' ('trap_exit','true') let <Mref> = call 'erlang':'monitor' ('process',Caller) in receive <{_22,_23}> when let <_24> = call 'erlang':'=:=' (_22,Caller) in let <_25> = call 'erlang':'=:=' (_23,Tag) in call 'erlang':'and' (_24,_25) -> let <Monitors> = apply 'send_nodes'/4 (Nodes,Name,Tag,Req) in let <_10> = call 'erlang':'self' () in let <TimerId> = call 'erlang':'start_timer' (Timeout,_10,'ok') in let <Result> = apply 'rec_nodes'/4 (Tag,Monitors,Name,TimerId) in let <_13> = call 'erlang':'self' () in call 'erlang':'exit' ({_13,Tag,Result})
<{'DOWN',_26,_27,_28,_29}> when call 'erlang':'=:=' (_26,Mref) -> call 'erlang':'exit' ('normal') after 'infinity' -> 'true' in let <Receiver> = call 'erlang':'spawn' (_14) in let <Mref> = call 'erlang':'monitor' ('process',Receiver) in let <_17> = call 'erlang':'self' () in do call 'erlang':'!' (Receiver,{_17,Tag}) receive <{'DOWN',_30,_31,_32,{_33,_34,Result}}> when let <_37> = call 'erlang':'=:=' (_30,Mref) in let <_35> = call 'erlang':'=:=' (_33,Receiver) in let <_36> = call 'erlang':'=:=' (_34,Tag) in let <_38> = call 'erlang':'and' (_35,_36) in call 'erlang':'and' (_37,_38) -> Result
<{'DOWN',_39,_40,_41,Reason}> when call 'erlang':'=:=' (_39,Mref) -> call 'erlang':'exit' (Reason) after 'infinity' -> 'true' end
'send_nodes'/4 = fun (_0,_1,_2,_3) -> apply 'send_nodes'/5 (_0,_1,_2,_3,[])
'send_nodes'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <[Node|Tail],Name,Tag,Req,Monitors> when call 'erlang':'is_atom' (Node) -> let <Monitor> = apply 'start_monitor'/2 (Node,Name) in do try let <_6> = call 'erlang':'self' () in call 'erlang':'!' ({Name,Node},{'$gen_call',{_6,{Tag,Node}},Req}) of <_catch_value> -> _catch_value catch <Class,Reason,Stk> -> 'ok' apply 'send_nodes'/5 (Tail,Name,Tag,Req,[Monitor|Monitors])
<[_X_Node|Tail],Name,Tag,Req,Monitors> when 'true' -> apply 'send_nodes'/5 (Tail,Name,Tag,Req,Monitors)
<[],_X_Name,_X_Tag,_X_Req,Monitors> when 'true' -> Monitors
(<_11,_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_11,_10,_9,_8,_7})-|[{'function_name',{'send_nodes',5}}] )-|['compiler_generated'] ) end
'rec_nodes'/4 = fun (_0,_1,_2,_3) -> apply 'rec_nodes'/7 (_0,_1,_2,[],[],2000,_3)
'rec_nodes'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <Tag,[{N,R}|Tail],Name,Badnodes,Replies,Time,TimerId> when 'true' -> receive <{'DOWN',_17,_18,_19,_20}> when call 'erlang':'=:=' (_17,R) -> apply 'rec_nodes'/7 (Tag,Tail,Name,[N|Badnodes],Replies,Time,TimerId)
<{{_21,_22},Reply}> when let <_23> = call 'erlang':'=:=' (_21,Tag) in let <_24> = call 'erlang':'=:=' (_22,N) in call 'erlang':'and' (_23,_24) -> do call 'erlang':'demonitor' (R,['flush']) apply 'rec_nodes'/7 (Tag,Tail,Name,Badnodes,[{N,Reply}|Replies],Time,TimerId)
<{'timeout',_25,_26}> when call 'erlang':'=:=' (_25,TimerId) -> do call 'erlang':'demonitor' (R,['flush']) apply 'rec_nodes_rest'/5 (Tag,Tail,Name,[N|Badnodes],Replies) after 'infinity' -> 'true'
<Tag,_@r0 = [N|Tail],Name,Badnodes,Replies,Time,TimerId> when 'true' -> receive <{'nodedown',_27}> when call 'erlang':'=:=' (_27,N) -> do call 'erlang':'monitor_node' (N,'false') apply 'rec_nodes'/7 (Tag,Tail,Name,[N|Badnodes],Replies,2000,TimerId)
<{{_28,_29},Reply}> when let <_30> = call 'erlang':'=:=' (_28,Tag) in let <_31> = call 'erlang':'=:=' (_29,N) in call 'erlang':'and' (_30,_31) -> do receive <{'nodedown',_32}> when call 'erlang':'=:=' (_32,N) -> 'ok' after 0 -> 'ok' do call 'erlang':'monitor_node' (N,'false') apply 'rec_nodes'/7 (Tag,Tail,Name,Badnodes,[{N,Reply}|Replies],2000,TimerId)
<{'timeout',_33,_34}> when call 'erlang':'=:=' (_33,TimerId) -> do receive <{'nodedown',_35}> when call 'erlang':'=:=' (_35,N) -> 'ok' after 0 -> 'ok' do call 'erlang':'monitor_node' (N,'false') apply 'rec_nodes_rest'/5 (Tag,Tail,Name,[N|Badnodes],Replies) after Time -> case call 'rpc':'call' (N,'erlang','whereis',[Name|[]]) of <Pid> when call 'erlang':'is_pid' (Pid) -> apply 'rec_nodes'/7 (Tag,_@r0,Name,Badnodes,Replies,'infinity',TimerId)
<_36> when 'true' -> do receive <{'nodedown',_37}> when call 'erlang':'=:=' (_37,N) -> 'ok' after 0 -> 'ok' do call 'erlang':'monitor_node' (N,'false') apply 'rec_nodes'/7 (Tag,Tail,Name,[N|Badnodes],Replies,2000,TimerId) end
<_38,[],_39,Badnodes,Replies,_40,TimerId> when 'true' -> let <_8> = catch call 'erlang':'cancel_timer' (TimerId) in do case _8 of <'false'> when 'true' -> receive <{'timeout',_41,_42}> when call 'erlang':'=:=' (_41,TimerId) -> 'ok' after 0 -> 'ok'
<_43> when 'true' -> 'ok' end {Replies,Badnodes}
(<_16,_15,_14,_13,_12,_11,_10> when 'true' -> (primop 'match_fail' ({'function_clause',_16,_15,_14,_13,_12,_11,_10})-|[{'function_name',{'rec_nodes',7}}] )-|['compiler_generated'] ) end
'rec_nodes_rest'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Tag,[{N,R}|Tail],Name,Badnodes,Replies> when 'true' -> receive <{'DOWN',_10,_11,_12,_13}> when call 'erlang':'=:=' (_10,R) -> apply 'rec_nodes_rest'/5 (Tag,Tail,Name,[N|Badnodes],Replies)
<{{_14,_15},Reply}> when let <_16> = call 'erlang':'=:=' (_14,Tag) in let <_17> = call 'erlang':'=:=' (_15,N) in call 'erlang':'and' (_16,_17) -> do call 'erlang':'demonitor' (R,['flush']) apply 'rec_nodes_rest'/5 (Tag,Tail,Name,Badnodes,[{N,Reply}|Replies]) after 0 -> do call 'erlang':'demonitor' (R,['flush']) apply 'rec_nodes_rest'/5 (Tag,Tail,Name,[N|Badnodes],Replies)
<Tag,[N|Tail],Name,Badnodes,Replies> when 'true' -> receive <{'nodedown',_18}> when call 'erlang':'=:=' (_18,N) -> do call 'erlang':'monitor_node' (N,'false') apply 'rec_nodes_rest'/5 (Tag,Tail,Name,[N|Badnodes],Replies)
<{{_19,_20},Reply}> when let <_21> = call 'erlang':'=:=' (_19,Tag) in let <_22> = call 'erlang':'=:=' (_20,N) in call 'erlang':'and' (_21,_22) -> do receive <{'nodedown',_23}> when call 'erlang':'=:=' (_23,N) -> 'ok' after 0 -> 'ok' do call 'erlang':'monitor_node' (N,'false') apply 'rec_nodes_rest'/5 (Tag,Tail,Name,Badnodes,[{N,Reply}|Replies]) after 0 -> do receive <{'nodedown',_24}> when call 'erlang':'=:=' (_24,N) -> 'ok' after 0 -> 'ok' do call 'erlang':'monitor_node' (N,'false') apply 'rec_nodes_rest'/5 (Tag,Tail,Name,[N|Badnodes],Replies)
<_X_Tag,[],_X_Name,Badnodes,Replies> when 'true' -> {Replies,Badnodes}
(<_9,_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6,_5})-|[{'function_name',{'rec_nodes_rest',5}}] )-|['compiler_generated'] ) end
'start_monitor'/2 = fun (_0,_1) -> case <_0,_1> of <Node,Name> when let <_2> = call 'erlang':'is_atom' (Node) in let <_3> = call 'erlang':'is_atom' (Name) in call 'erlang':'and' (_2,_3) -> case <> of <> when try let <_4> = call 'erlang':'node' () in let <_5> = call 'erlang':'=:=' (_4,'nonode@nohost') in let <_6> = call 'erlang':'=/=' (Node,'nonode@nohost') in call 'erlang':'and' (_5,_6) of <Try> -> Try catch <T,R> -> 'false' -> let <Ref> = call 'erlang':'make_ref' () in let <_8> = call 'erlang':'self' () in do call 'erlang':'!' (_8,{'DOWN',Ref,'process',{Name,Node},'noconnection'}) {Node,Ref}
<> when 'true' -> let <_9> = catch call 'erlang':'monitor' ('process',{Name,Node}) in case _9 of <{'EXIT',_13}> when 'true' -> do call 'erlang':'monitor_node' (Node,'true') Node
<Ref> when call 'erlang':'is_reference' (_9) -> {Node,Ref}
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end end
(<_12,_11> when 'true' -> (primop 'match_fail' ({'function_clause',_12,_11})-|[{'function_name',{'start_monitor',2}}] )-|['compiler_generated'] ) end
'try_dispatch'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <{'$gen_cast',Msg},Mod,State> when 'true' -> apply 'try_dispatch'/4 (Mod,'handle_cast',Msg,State)
<Info,Mod,State> when 'true' -> apply 'try_dispatch'/4 (Mod,'handle_info',Info,State) end
'try_dispatch'/4 = fun (_0,_1,_2,_3) -> try let <_4> = call _0:_1 (_2,_3) in {'ok',_4} of <_5> -> _5 catch <_8,_7,_6> -> case <_8,_7,_6> of <('throw'-|['compiler_generated'] ),R,_20> when 'true' -> {'ok',R}
<('error'-|['compiler_generated'] ),R = ('undef'-|['compiler_generated'] ),_21> when call 'erlang':'=:=' (_1,'handle_info') -> case call 'erlang':'function_exported' (_0,'handle_info',2) of <'false'> when 'true' -> do case call 'logger':'allow' ('warning','gen_server') of <'true'> when 'true' -> let <_9> = ~{'module'=>_0,'message'=>_2|~{'label'=>{'gen_server','no_handle_info'}}~}~ in call 'logger':'macro_log' (~{'file'=>[115|[114|[99|[47|[103|[101|[110|[95|[115|[101|[114|[118|[101|[114|[46|[101|[114|[108]]]]]]]]]]]]]]]]]],'line'=>687,'mfa'=>{'gen_server','try_dispatch',4}}~,'warning',_9,~{'domain'=>['otp'],'error_logger'=>~{'report_cb'=>fun 'gen_server':'format_log'/1,'tag'=>'warning_msg'}~,'report_cb'=>fun 'gen_server':'format_log'/2}~)
<'false'> when 'true' -> 'ok'
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end {'ok',{'noreply',_3}}
<'true'> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_21) in {'EXIT','error',R,Stacktrace}
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
<Class,R,_22> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_22) in {'EXIT',Class,R,Stacktrace} end
'try_handle_call'/4 = fun (_0,_1,_2,_3) -> try let <_4> = call _0:'handle_call' (_1,_2,_3) in {'ok',_4} of <_5> -> _5 catch <_8,_7,_6> -> case <_8,_7,_6> of <('throw'-|['compiler_generated'] ),R,_13> when 'true' -> {'ok',R}
<Class,R,_14> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_14) in {'EXIT',Class,R,Stacktrace} end
'try_terminate'/3 = fun (_0,_1,_2) -> case call 'erlang':'function_exported' (_0,'terminate',2) of <'true'> when 'true' -> try let <_3> = call _0:'terminate' (_1,_2) in {'ok',_3} of <_4> -> _4 catch <_7,_6,_5> -> case <_7,_6,_5> of <('throw'-|['compiler_generated'] ),R,_12> when 'true' -> {'ok',R}
<Class,R,_13> when 'true' -> let <Stacktrace> = primop 'build_stacktrace' (_13) in {'EXIT',Class,R,Stacktrace} end
<'false'> when 'true' -> {'ok','ok'}
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
'handle_msg'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <{'$gen_call',From,Msg},Parent,Name,State,Mod,HibernateAfterTimeout> when 'true' -> case apply 'try_handle_call'/4 (Mod,Msg,From,State) of <{'ok',{'reply',Reply,NState}}> when 'true' -> do apply 'reply'/2 (From,Reply) apply 'loop'/7 (Parent,Name,NState,Mod,'infinity',HibernateAfterTimeout,[])
<{'ok',{'reply',Reply,NState,Time1}}> when 'true' -> do apply 'reply'/2 (From,Reply) apply 'loop'/7 (Parent,Name,NState,Mod,Time1,HibernateAfterTimeout,[])
<{'ok',{'noreply',NState}}> when 'true' -> apply 'loop'/7 (Parent,Name,NState,Mod,'infinity',HibernateAfterTimeout,[])
<{'ok',{'noreply',NState,Time1}}> when 'true' -> apply 'loop'/7 (Parent,Name,NState,Mod,Time1,HibernateAfterTimeout,[])
<{'ok',{'stop',Reason,Reply,NState}}> when 'true' -> letrec 'after$^0'/0 = fun () -> apply 'reply'/2 (From,Reply) in try let <_7> = call 'erlang':'self' () in let <_8> = call 'erlang':'process_info' (_7,'current_stacktrace') in let <_9> = call 'erlang':'element' (2,_8) in apply 'terminate'/8 (Reason,_9,Name,From,Msg,Mod,NState,[]) of <_10> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) _10 catch <_13,_12,_11> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) primop 'raise' (_11,_12)
<Other> when 'true' -> apply 'handle_common_reply'/8 (Other,Parent,Name,From,Msg,Mod,HibernateAfterTimeout,State) end
<Msg,Parent,Name,State,Mod,HibernateAfterTimeout> when 'true' -> let <Reply> = apply 'try_dispatch'/3 (Msg,Mod,State) in apply 'handle_common_reply'/8 (Reply,Parent,Name,'undefined',Msg,Mod,HibernateAfterTimeout,State) end
'handle_msg'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <{'$gen_call',From,Msg},Parent,Name,State,Mod,HibernateAfterTimeout,Debug> when 'true' -> case apply 'try_handle_call'/4 (Mod,Msg,From,State) of <{'ok',{'reply',Reply,NState}}> when 'true' -> let <Debug1> = apply 'reply'/5 (Name,From,Reply,NState,Debug) in apply 'loop'/7 (Parent,Name,NState,Mod,'infinity',HibernateAfterTimeout,Debug1)
<{'ok',{'reply',Reply,NState,Time1}}> when 'true' -> let <Debug1> = apply 'reply'/5 (Name,From,Reply,NState,Debug) in apply 'loop'/7 (Parent,Name,NState,Mod,Time1,HibernateAfterTimeout,Debug1)
<{'ok',_@r0 = {'noreply',NState}}> when 'true' -> let <_10> = 'print_event'/3 in let <Debug1> = call 'sys':'handle_debug' (Debug,_10,Name,_@r0) in apply 'loop'/7 (Parent,Name,NState,Mod,'infinity',HibernateAfterTimeout,Debug1)
<{'ok',{'noreply',NState,Time1}}> when 'true' -> let <_12> = 'print_event'/3 in let <Debug1> = call 'sys':'handle_debug' (Debug,_12,Name,{'noreply',NState}) in apply 'loop'/7 (Parent,Name,NState,Mod,Time1,HibernateAfterTimeout,Debug1)
<{'ok',{'stop',Reason,Reply,NState}}> when 'true' -> letrec 'after$^2'/0 = fun () -> apply 'reply'/5 (Name,From,Reply,NState,Debug) in try let <_14> = call 'erlang':'self' () in let <_15> = call 'erlang':'process_info' (_14,'current_stacktrace') in let <_16> = call 'erlang':'element' (2,_15) in apply 'terminate'/8 (Reason,_16,Name,From,Msg,Mod,NState,Debug) of <_18> -> do (apply 'after$^2'/0 ()-|['compiler_generated'] ) _18 catch <_21,_20,_19> -> do (apply 'after$^2'/0 ()-|['compiler_generated'] ) primop 'raise' (_19,_20)
<Other> when 'true' -> apply 'handle_common_reply'/9 (Other,Parent,Name,From,Msg,Mod,HibernateAfterTimeout,State,Debug) end
<Msg,Parent,Name,State,Mod,HibernateAfterTimeout,Debug> when 'true' -> let <Reply> = apply 'try_dispatch'/3 (Msg,Mod,State) in apply 'handle_common_reply'/9 (Reply,Parent,Name,'undefined',Msg,Mod,HibernateAfterTimeout,State,Debug) end
'handle_common_reply'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> case _0 of <{'ok',{'noreply',NState}}> when 'true' -> apply 'loop'/7 (_1,_2,NState,_5,'infinity',_6,[])
<{'ok',{'noreply',NState,Time1}}> when 'true' -> apply 'loop'/7 (_1,_2,NState,_5,Time1,_6,[])
<{'ok',{'stop',Reason,NState}}> when 'true' -> let <_8> = call 'erlang':'self' () in let <_9> = call 'erlang':'process_info' (_8,'current_stacktrace') in let <_10> = call 'erlang':'element' (2,_9) in apply 'terminate'/8 (Reason,_10,_2,_3,_4,_5,NState,[])
<{'EXIT',Class,Reason,Stacktrace}> when 'true' -> apply 'terminate'/9 (Class,Reason,Stacktrace,_2,_3,_4,_5,_7,[])
<{'ok',BadReply}> when 'true' -> let <_11> = call 'erlang':'self' () in let <_12> = call 'erlang':'process_info' (_11,'current_stacktrace') in let <_13> = call 'erlang':'element' (2,_12) in apply 'terminate'/8 ({'bad_return_value',BadReply},_13,_2,_3,_4,_5,_7,[])
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end
'handle_common_reply'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> case _0 of <{'ok',_@r0 = {'noreply',NState}}> when 'true' -> let <_9> = 'print_event'/3 in let <Debug1> = call 'sys':'handle_debug' (_8,_9,_2,_@r0) in apply 'loop'/7 (_1,_2,NState,_5,'infinity',_6,Debug1)
<{'ok',{'noreply',NState,Time1}}> when 'true' -> let <_11> = 'print_event'/3 in let <Debug1> = call 'sys':'handle_debug' (_8,_11,_2,{'noreply',NState}) in apply 'loop'/7 (_1,_2,NState,_5,Time1,_6,Debug1)
<{'ok',{'stop',Reason,NState}}> when 'true' -> let <_13> = call 'erlang':'self' () in let <_14> = call 'erlang':'process_info' (_13,'current_stacktrace') in let <_15> = call 'erlang':'element' (2,_14) in apply 'terminate'/8 (Reason,_15,_2,_3,_4,_5,NState,_8)
<{'EXIT',Class,Reason,Stacktrace}> when 'true' -> apply 'terminate'/9 (Class,Reason,Stacktrace,_2,_3,_4,_5,_7,_8)
<{'ok',BadReply}> when 'true' -> let <_16> = call 'erlang':'self' () in let <_17> = call 'erlang':'process_info' (_16,'current_stacktrace') in let <_18> = call 'erlang':'element' (2,_17) in apply 'terminate'/8 ({'bad_return_value',BadReply},_18,_2,_3,_4,_5,_7,_8)
(<_19> when 'true' -> primop 'match_fail' ({'case_clause',_19})-|['compiler_generated'] ) end
'reply'/5 = fun (_0,_1,_2,_3,_4) -> do apply 'reply'/2 (_1,_2) let <_5> = 'print_event'/3 in call 'sys':'handle_debug' (_4,_5,_0,{'out',_2,_1,_3})
'system_continue'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Parent,Debug,[Name|[State|[Mod|[Time|[HibernateAfterTimeout|[]]]]]]> when 'true' -> apply 'loop'/7 (Parent,Name,State,Mod,Time,HibernateAfterTimeout,Debug)
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'system_continue',3}}] )-|['compiler_generated'] ) end
'system_terminate'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Reason,_X_Parent,Debug,[Name|[State|[Mod|[_X_Time|[_X_HibernateAfterTimeout|[]]]]]]> when 'true' -> let <_4> = call 'erlang':'self' () in let <_5> = call 'erlang':'process_info' (_4,'current_stacktrace') in let <_6> = call 'erlang':'element' (2,_5) in apply 'terminate'/8 (Reason,_6,Name,'undefined',[],Mod,State,Debug)
(<_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7})-|[{'function_name',{'system_terminate',4}}] )-|['compiler_generated'] ) end
'system_code_change'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[Name|[State|_@r0 = [Mod|[Time|[HibernateAfterTimeout|[]]]]]],_X_Module,OldVsn,Extra> when 'true' -> let <_4> = catch call Mod:'code_change' (OldVsn,State,Extra) in case _4 of <{'ok',NewState}> when 'true' -> {'ok',[Name|[NewState|_@r0]]}
<Else> when 'true' -> Else end
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'system_code_change',4}}] )-|['compiler_generated'] ) end
'system_get_state'/1 = fun (_0) -> case _0 of <[_X_Name|[State|[_X_Mod|[_X_Time|[_X_HibernateAfterTimeout|[]]]]]]> when 'true' -> {'ok',State}
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'system_get_state',1}}] )-|['compiler_generated'] ) end
'system_replace_state'/2 = fun (_0,_1) -> case <_0,_1> of <StateFun,[Name|[State|_@r0 = [Mod|[Time|[HibernateAfterTimeout|[]]]]]]> when 'true' -> let <NState> = apply StateFun (State) in {'ok',NState,[Name|[NState|_@r0]]}
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'system_replace_state',2}}] )-|['compiler_generated'] ) end
'print_event'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Dev,{'in',Msg},Name> when 'true' -> case Msg of <{'$gen_call',{From,_X_Tag},Call}> when 'true' -> call 'io':'format' (Dev,[42|[68|[66|[71|[42|[32|[126|[116|[112|[32|[103|[111|[116|[32|[99|[97|[108|[108|[32|[126|[116|[112|[32|[102|[114|[111|[109|[32|[126|[116|[119|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Name|[Call|[From|[]]]])
<{'$gen_cast',Cast}> when 'true' -> call 'io':'format' (Dev,[42|[68|[66|[71|[42|[32|[126|[116|[112|[32|[103|[111|[116|[32|[99|[97|[115|[116|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]],[Name|[Cast|[]]])
<_7> when 'true' -> call 'io':'format' (Dev,[42|[68|[66|[71|[42|[32|[126|[116|[112|[32|[103|[111|[116|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]],[Name|[Msg|[]]]) end
<Dev,{'out',Msg,{To,_X_Tag},State},Name> when 'true' -> call 'io':'format' (Dev,[42|[68|[66|[71|[42|[32|[126|[116|[112|[32|[115|[101|[110|[116|[32|[126|[116|[112|[32|[116|[111|[32|[126|[116|[119|[44|[32|[110|[101|[119|[32|[115|[116|[97|[116|[101|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Name|[Msg|[To|[State|[]]]]])
<Dev,{'noreply',State},Name> when 'true' -> call 'io':'format' (Dev,[42|[68|[66|[71|[42|[32|[126|[116|[112|[32|[110|[101|[119|[32|[115|[116|[97|[116|[101|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]],[Name|[State|[]]])
<Dev,Event,Name> when 'true' -> call 'io':'format' (Dev,[42|[68|[66|[71|[42|[32|[126|[116|[112|[32|[100|[98|[103|[32|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]]],[Name|[Event|[]]]) end
'terminate'/8 = fun (_0,_1,_2,_3,_4,_5,_6,_7) -> apply 'terminate'/10 ('exit',_0,_1,_0,_2,_3,_4,_5,_6,_7)
'terminate'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> let <ReportReason> = {_1,_2} in apply 'terminate'/10 (_0,_1,_2,ReportReason,_3,_4,_5,_6,_7,_8)
'terminate'/10 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8,_9) -> let <_10> = apply 'terminate_reason'/3 (_0,_1,_2) in let <Reply> = apply 'try_terminate'/3 (_7,_10,_8) in do case Reply of <{'EXIT',C,R,S}> when 'true' -> do apply 'error_info'/7 ({R,S},_4,_5,_6,_7,_8,_9) call 'erlang':'raise' (C,R,S)
<_25> when 'true' -> case <_0,_1> of <'exit','normal'> when 'true' -> 'ok'
<'exit','shutdown'> when 'true' -> 'ok'
<('exit'-|['compiler_generated'] ),({('shutdown'-|['compiler_generated'] ),_26}-|['compiler_generated'] )> when 'true' -> 'ok'
<(_29-|['compiler_generated'] ),(_30-|['compiler_generated'] )> when 'true' -> apply 'error_info'/7 (_3,_4,_5,_6,_7,_8,_9) end end case _2 of <[]> when 'true' -> call 'erlang':_0 (_1)
<_28> when 'true' -> call 'erlang':'raise' (_0,_1,_2) end
'terminate_reason'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'error',Reason,Stacktrace> when 'true' -> {Reason,Stacktrace}
<'exit',Reason,_X_Stacktrace> when 'true' -> Reason
(<_5,_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4,_3})-|[{'function_name',{'terminate_reason',3}}] )-|['compiler_generated'] ) end
'error_info'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <_X_Reason,'application_controller',_X_From,_X_Msg,_X_Mod,_X_State,_X_Debug> when 'true' -> 'ok'
<Reason,Name,From,Msg,Mod,State,Debug> when 'true' -> let <Log> = call 'sys':'get_log' (Debug) in do case call 'logger':'allow' ('error','gen_server') of <'true'> when 'true' -> let <_8> = call 'erlang':'get' () in let <_9> = apply 'format_status'/4 ('terminate',Mod,_8,State) in let <_10> = apply 'format_log_state'/2 (Mod,Log) in let <_11> = apply 'client_stacktrace'/1 (From) in let <_12> = ~{'name'=>Name,'last_message'=>Msg,'state'=>_9,'log'=>_10,'reason'=>Reason,'client_info'=>_11|~{'label'=>{'gen_server','terminate'}}~}~ in call 'logger':'macro_log' (~{'file'=>[115|[114|[99|[47|[103|[101|[110|[95|[115|[101|[114|[118|[101|[114|[46|[101|[114|[108]]]]]]]]]]]]]]]]]],'line'=>934,'mfa'=>{'gen_server','error_info',7}}~,'error',_12,~{'domain'=>['otp'],'error_logger'=>~{'report_cb'=>fun 'gen_server':'format_log'/1,'tag'=>'error'}~,'report_cb'=>fun 'gen_server':'format_log'/2}~)
<'false'> when 'true' -> 'ok'
(<_17> when 'true' -> primop 'match_fail' ({'case_clause',_17})-|['compiler_generated'] ) end 'ok' end
'client_stacktrace'/1 = fun (_0) -> case _0 of <'undefined'> when 'true' -> 'undefined'
<{From,_X_Tag}> when 'true' -> apply 'client_stacktrace'/1 (From)
<From> when try let <_1> = call 'erlang':'is_pid' (_0) in let <_3> = call 'erlang':'node' (_0) in let <_2> = call 'erlang':'node' () in let <_4> = call 'erlang':'=:=' (_3,_2) in call 'erlang':'and' (_1,_4) of <Try> -> Try catch <T,R> -> 'false' -> case call 'erlang':'process_info' (From,['current_stacktrace'|['registered_name']]) of <'undefined'> when 'true' -> {From,'dead'}
<[{'current_stacktrace',Stacktrace}|[{'registered_name',[]}]]> when 'true' -> {From,{From,Stacktrace}}
<[{'current_stacktrace',Stacktrace}|[{'registered_name',Name}|[]]]> when 'true' -> {From,{Name,Stacktrace}}
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<From> when call 'erlang':'is_pid' (_0) -> {From,'remote'}
(<_6> when 'true' -> (primop 'match_fail' ({'function_clause',_6})-|[{'function_name',{'client_stacktrace',1}}] )-|['compiler_generated'] ) end
'format_log'/1 = fun (_0) -> let <Depth> = call 'error_logger':'get_format_depth' () in let <FormatOpts> = ~{'depth'=>Depth,'single_line'=>'false','encoding'=>'utf8'|~{'chars_limit'=>'unlimited'}~}~ in let <_3> = apply 'limit_report'/2 (_0,Depth) in apply 'format_log_multi'/2 (_3,FormatOpts)
'limit_report'/2 = fun (_0,_1) -> case <_0,_1> of <Report,'unlimited'> when 'true' -> Report
<Report = ~{'reason':=Reason,'log':=Log,'label':={'gen_server','terminate'},'client_info':=Client,'state':=State,'last_message':=Msg}~,Depth> when 'true' -> let <_2> = call 'io_lib':'limit_term' (Msg,Depth) in let <_3> = call 'io_lib':'limit_term' (State,Depth) in let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[L|_5]> when 'true' -> let <_7> = call 'io_lib':'limit_term' (L,Depth) in let <_8> = apply 'lc$^0'/1 (_5) in ([_7|_8]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Log) in let <_10> = call 'io_lib':'limit_term' (Reason,Depth) in let <_11> = apply 'limit_client_report'/2 (Client,Depth) in case <> of (<> when call 'erlang':'is_map' (Report) -> ~{'last_message'=>_2,'state'=>_3,'log'=>_9,'reason'=>_10,'client_info'=>_11|Report}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Report})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
<Report = ~{'label':={'gen_server','no_handle_info'},'message':=Msg}~,Depth> when 'true' -> let <_12> = call 'io_lib':'limit_term' (Msg,Depth) in case <> of (<> when call 'erlang':'is_map' (Report) -> ~{'message'=>_12|Report}~-|['compiler_generated'] )
(<> when 'true' -> (primop 'match_fail' ({'badmap',Report})-|[{'eval_failure','badmap'}] )-|['compiler_generated'] ) end
(<_14,_13> when 'true' -> (primop 'match_fail' ({'function_clause',_14,_13})-|[{'function_name',{'limit_report',2}}] )-|['compiler_generated'] ) end
'limit_client_report'/2 = fun (_0,_1) -> case <_0,_1> of <{From,{Name,Stacktrace}},Depth> when 'true' -> let <_2> = call 'io_lib':'limit_term' (Stacktrace,Depth) in {From,{Name,_2}}
<Client,_5> when 'true' -> Client end
'format_log'/2 = fun (_0,_1) -> let <FormatOpts> = call 'maps':'merge' (~{'chars_limit'=>'unlimited','depth'=>'unlimited','encoding'=>'utf8','single_line'=>'false'}~,_1) in let <_5> = case FormatOpts of <~{'chars_limit':='unlimited'}~> when 'true' -> []
<~{'chars_limit':=Limit}~> when 'true' -> [{'chars_limit',Limit}|[]]
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in case apply 'format_log_single'/2 (_0,FormatOpts) of <{Format,Args}> when 'true' -> call 'io_lib':'format' (Format,Args,_5)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
'format_log_single'/2 = fun (_0,_1) -> case <_0,_1> of <~{'reason':=Reason,'log':=Log,'label':={'gen_server','terminate'},'client_info':=Client,'state':=State,'last_message':=Msg,'name':=Name}~,FormatOpts = ~{'depth':=Depth,'single_line':='true'}~> when 'true' -> let <P> = apply 'p'/1 (FormatOpts) in let <Format1> = call 'lists':'append' ([[71|[101|[110|[101|[114|[105|[99|[32|[115|[101|[114|[118|[101|[114|[32]]]]]]]]]]]]]]]|[P|[[32|[116|[101|[114|[109|[105|[110|[97|[116|[105|[110|[103|[46|[32|[82|[101|[97|[115|[111|[110|[58|[32]]]]]]]]]]]]]]]]]]]]]]|[P|[[46|[32|[76|[97|[115|[116|[32|[109|[101|[115|[115|[97|[103|[101|[58|[32]]]]]]]]]]]]]]]]|[P|[[46|[32|[83|[116|[97|[116|[101|[58|[32]]]]]]]]]|[P|[[46]]]]]]]]]]) in case apply 'format_server_log_single'/2 (Log,FormatOpts) of <{ServerLogFormat,ServerLogArgs}> when 'true' -> case apply 'format_client_log_single'/2 (Client,FormatOpts) of <{ClientLogFormat,ClientLogArgs}> when 'true' -> let <_9> = case Depth of <'unlimited'> when 'true' -> let <_6> = apply 'fix_reason'/1 (Reason) in [Name|[_6|[Msg|[State|[]]]]]
<_22> when 'true' -> let <_7> = apply 'fix_reason'/1 (Reason) in [Name|[Depth|[_7|[Depth|[Msg|[Depth|[State|[Depth|[]]]]]]]]] end in let <_13> = call 'erlang':'++' (ServerLogFormat,ClientLogFormat) in let <_14> = call 'erlang':'++' (Format1,_13) in let <_11> = call 'erlang':'++' (ServerLogArgs,ClientLogArgs) in let <_12> = call 'erlang':'++' (_9,_11) in {_14,_12}
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<~{'label':={'gen_server','no_handle_info'},'message':=Msg,'module':=Mod}~,FormatOpts = ~{'depth':=Depth,'single_line':='true'}~> when 'true' -> let <P> = apply 'p'/1 (FormatOpts) in let <Format> = call 'lists':'append' ([[85|[110|[100|[101|[102|[105|[110|[101|[100|[32|[104|[97|[110|[100|[108|[101|[95|[105|[110|[102|[111|[32|[105|[110|[32]]]]]]]]]]]]]]]]]]]]]]]]]|[P|[[46|[32|[85|[110|[104|[97|[110|[100|[108|[101|[100|[32|[109|[101|[115|[115|[97|[103|[101|[58|[32]]]]]]]]]]]]]]]]]]]]]|[P|[[46]]]]]]) in let <_18> = case Depth of <'unlimited'> when 'true' -> [Mod|[Msg|[]]]
<_23> when 'true' -> [Mod|[Depth|[Msg|[Depth|[]]]]] end in {Format,_18}
<Report,FormatOpts> when 'true' -> apply 'format_log_multi'/2 (Report,FormatOpts) end
'format_log_multi'/2 = fun (_0,_1) -> case <_0,_1> of <~{'reason':=Reason,'log':=Log,'label':={'gen_server','terminate'},'client_info':=Client,'state':=State,'last_message':=Msg,'name':=Name}~,FormatOpts = ~{'depth':=Depth}~> when 'true' -> let <Reason1> = apply 'fix_reason'/1 (Reason) in case apply 'format_client_log'/2 (Client,FormatOpts) of <{ClientFmt,ClientArgs}> when 'true' -> let <P> = apply 'p'/1 (FormatOpts) in let <_9> = case Log of <[]> when 'true' -> []
<_33> when 'true' -> let <_5> = call 'erlang':'length' (Log) in let <_6> = call 'lists':'duplicate' (_5,P) in let <_7> = call 'lists':'join' ([44|[126|[110|[32|[32|[32|[32]]]]]]],_6) in [[42|[42|[32|[76|[111|[103|[32|[61|[61|[126|[110|[42|[42|[32|[91]]]]]]]]]]]]]]]|call 'erlang':'++' (_7,[[93|[126|[110]]]])] end in let <_10> = [[42|[42|[32|[71|[101|[110|[101|[114|[105|[99|[32|[115|[101|[114|[118|[101|[114|[32]]]]]]]]]]]]]]]]]]|[P|[[32|[116|[101|[114|[109|[105|[110|[97|[116|[105|[110|[103|[32|[10|[42|[42|[32|[76|[97|[115|[116|[32|[109|[101|[115|[115|[97|[103|[101|[32|[105|[110|[32|[119|[97|[115|[32]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]|[P|[[126|[110|[42|[42|[32|[87|[104|[101|[110|[32|[83|[101|[114|[118|[101|[114|[32|[115|[116|[97|[116|[101|[32|[61|[61|[32]]]]]]]]]]]]]]]]]]]]]]]]]]|[P|[[126|[110|[42|[42|[32|[82|[101|[97|[115|[111|[110|[32|[102|[111|[114|[32|[116|[101|[114|[109|[105|[110|[97|[116|[105|[111|[110|[32|[61|[61|[126|[110|[42|[42|[32]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]|[P|[[126|[110]]|_9]]]]]]]]] in let <_11> = call 'lists':'append' (_10) in let <Format> = call 'erlang':'++' (_11,ClientFmt) in let <_23> = case Depth of <'unlimited'> when 'true' -> let <_14> = case Log of <[]> when 'true' -> []
<_34> when 'true' -> Log end in let <_15> = call 'erlang':'++' (_14,ClientArgs) in [Name|[Msg|[State|[Reason1|_15]]]]
<_35> when 'true' -> let <_20> = case Log of <[]> when 'true' -> []
<_36> when 'true' -> let <_18> = fun (_16) -> [_16|[Depth|[]]] in call 'lists':'flatmap' (_18,Log) end in let <_21> = call 'erlang':'++' (_20,ClientArgs) in [Name|[Depth|[Msg|[Depth|[State|[Depth|[Reason1|[Depth|_21]]]]]]]] end in {Format,_23}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<~{'label':={'gen_server','no_handle_info'},'message':=Msg,'module':=Mod}~,FormatOpts = ~{'depth':=Depth}~> when 'true' -> let <P> = apply 'p'/1 (FormatOpts) in let <_26> = call 'erlang':'++' (P,[126|[110]]) in let <Format> = call 'erlang':'++' ([42|[42|[32|[85|[110|[100|[101|[102|[105|[110|[101|[100|[32|[104|[97|[110|[100|[108|[101|[95|[105|[110|[102|[111|[32|[105|[110|[32|[126|[112|[126|[110|[42|[42|[32|[85|[110|[104|[97|[110|[100|[108|[101|[100|[32|[109|[101|[115|[115|[97|[103|[101|[58|[32]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],_26) in let <_29> = case Depth of <'unlimited'> when 'true' -> [Mod|[Msg|[]]]
<_37> when 'true' -> [Mod|[Msg|[Depth|[]]]] end in {Format,_29}
(<_32,_31> when 'true' -> (primop 'match_fail' ({'function_clause',_32,_31})-|[{'function_name',{'format_log_multi',2}}] )-|['compiler_generated'] ) end
'fix_reason'/1 = fun (_0) -> case _0 of <Reason = {'undef',_@r0 = [{M,F,A,L}|MFAs]}> when 'true' -> case call 'code':'is_loaded' (M) of <'false'> when 'true' -> {'module could not be loaded',_@r0}
<_5> when 'true' -> let <_1> = call 'erlang':'length' (A) in case call 'erlang':'function_exported' (M,F,_1) of <'true'> when 'true' -> Reason
<'false'> when 'true' -> {'function not exported',_@r0}
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end end
<Reason> when 'true' -> Reason end
'format_server_log_single'/2 = fun (_0,_1) -> case <_0,_1> of <[],_9> when 'true' -> {[],[]}
<Log,FormatOpts> when 'true' -> let <_3> = case call 'maps':'get' ('depth',FormatOpts) of <'unlimited'> when 'true' -> [Log|[]]
<Depth> when 'true' -> [Log|[Depth|[]]] end in let <_5> = apply 'p'/1 (FormatOpts) in let <_6> = call 'erlang':'++' ([32|[76|[111|[103|[58|[32]]]]]],_5) in {_6,_3} end
'format_client_log_single'/2 = fun (_0,_1) -> case <_0,_1> of <'undefined',_14> when 'true' -> {[],[]}
<{From,'dead'},_15> when 'true' -> {[32|[67|[108|[105|[101|[110|[116|[32|[126|[48|[112|[32|[105|[115|[32|[100|[101|[97|[100|[46]]]]]]]]]]]]]]]]]]]],[From|[]]}
<{From,'remote'},_16> when 'true' -> let <_2> = call 'erlang':'node' (From) in {[32|[67|[108|[105|[101|[110|[116|[32|[126|[48|[112|[32|[105|[115|[32|[114|[101|[109|[111|[116|[101|[32|[111|[110|[32|[110|[111|[100|[101|[32|[126|[48|[112|[46]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[From|[_2|[]]]}
<{_X_From,{Name,Stacktrace0}},FormatOpts> when 'true' -> let <P> = apply 'p'/1 (FormatOpts) in let <Stacktrace> = call 'lists':'sublist' (Stacktrace0,4) in let <_6> = case call 'maps':'get' ('depth',FormatOpts) of <'unlimited'> when 'true' -> [Name|[Stacktrace|[]]]
<Depth> when 'true' -> [Name|[Depth|[Stacktrace|[Depth|[]]]]] end in let <_8> = call 'erlang':'++' (P,[46]) in let <_9> = call 'erlang':'++' ([32|[115|[116|[97|[99|[107|[116|[114|[97|[99|[101|[58|[32]]]]]]]]]]]]],_8) in let <_10> = call 'erlang':'++' (P,_9) in let <_11> = call 'erlang':'++' ([32|[67|[108|[105|[101|[110|[116|[32]]]]]]]],_10) in {_11,_6}
(<_13,_12> when 'true' -> (primop 'match_fail' ({'function_clause',_13,_12})-|[{'function_name',{'format_client_log_single',2}}] )-|['compiler_generated'] ) end
'format_client_log'/2 = fun (_0,_1) -> case <_0,_1> of <'undefined',_10> when 'true' -> {[],[]}
<{From,'dead'},_11> when 'true' -> {[42|[42|[32|[67|[108|[105|[101|[110|[116|[32|[126|[112|[32|[105|[115|[32|[100|[101|[97|[100|[126|[110]]]]]]]]]]]]]]]]]]]]]],[From|[]]}
<{From,'remote'},_12> when 'true' -> let <_2> = call 'erlang':'node' (From) in {[42|[42|[32|[67|[108|[105|[101|[110|[116|[32|[126|[112|[32|[105|[115|[32|[114|[101|[109|[111|[116|[101|[32|[111|[110|[32|[110|[111|[100|[101|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[From|[_2|[]]]}
<{_X_From,{Name,Stacktrace}},FormatOpts> when 'true' -> let <P> = apply 'p'/1 (FormatOpts) in let <Format> = call 'lists':'append' ([[42|[42|[32|[67|[108|[105|[101|[110|[116|[32]]]]]]]]]]|[P|[[32|[115|[116|[97|[99|[107|[116|[114|[97|[99|[101|[126|[110]]]]]]]]]]]]]|[[42|[42|[32]]]|[P|[[126|[110]]]]]]]]) in let <_6> = case call 'maps':'get' ('depth',FormatOpts) of <'unlimited'> when 'true' -> [Name|[Stacktrace|[]]]
<Depth> when 'true' -> [Name|[Depth|[Stacktrace|[Depth|[]]]]] end in {Format,_6}
(<_9,_8> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8})-|[{'function_name',{'format_client_log',2}}] )-|['compiler_generated'] ) end
'p'/1 = fun (_0) -> case _0 of <~{'depth':=Depth,'encoding':=Enc,'single_line':=Single}~> when 'true' -> let <_4> = apply 'single'/1 (Single) in let <_2> = apply 'mod'/1 (Enc) in let <_1> = apply 'p'/1 (Depth) in let <_3> = call 'erlang':'++' (_2,_1) in let <_5> = call 'erlang':'++' (_4,_3) in [126|_5]
<'unlimited'> when 'true' -> [112]
<_X_Depth> when 'true' -> [80] end
'single'/1 = fun (_0) -> case _0 of <'true'> when 'true' -> [48]
<'false'> when 'true' -> []
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'single',1}}] )-|['compiler_generated'] ) end
'mod'/1 = fun (_0) -> case _0 of <'latin1'> when 'true' -> []
<_2> when 'true' -> [116] end
'format_status'/2 = fun (_0,_1) -> case _1 of <[PDict|[SysState|[Parent|[Debug|[[Name|[State|[Mod|[_X_Time|[_X_HibernateAfterTimeout|[]]]]]]|[]]]]]]> when 'true' -> let <Header> = call 'gen':'format_status_header' ([83|[116|[97|[116|[117|[115|[32|[102|[111|[114|[32|[103|[101|[110|[101|[114|[105|[99|[32|[115|[101|[114|[118|[101|[114]]]]]]]]]]]]]]]]]]]]]]]]],Name) in let <Log> = call 'sys':'get_log' (Debug) in let <_6> = case apply 'format_status'/4 (_0,Mod,PDict,State) of <S> when call 'erlang':'is_list' (S) -> S
<S> when 'true' -> [S|[]] end in let <_8> = apply 'format_log_state'/2 (Mod,Log) in [{'header',Header}|[{'data',[{[83|[116|[97|[116|[117|[115]]]]]],SysState}|[{[80|[97|[114|[101|[110|[116]]]]]],Parent}|[{[76|[111|[103|[103|[101|[100|[32|[101|[118|[101|[110|[116|[115]]]]]]]]]]]]],_8}|[]]]]}|_6]]
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'format_log_state'/2 = fun (_0,_1) -> (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[Event|_3]> when 'true' -> let <_10> = case Event of <{'out',Msg,From,State}> when 'true' -> let <_5> = call 'erlang':'get' () in let <_6> = apply 'format_status'/4 ('terminate',_0,_5,State) in {'out',Msg,From,_6}
<{'noreply',State}> when 'true' -> let <_7> = call 'erlang':'get' () in let <_8> = apply 'format_status'/4 ('terminate',_0,_7,State) in {'noreply',_8}
<_14> when 'true' -> Event end in let <_11> = apply 'lc$^0'/1 (_3) in ([_10|_11]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1)-|['list_comprehension'] )
'format_status'/4 = fun (_0,_1,_2,_3) -> let <_5> = case _0 of <'terminate'> when 'true' -> _3
<_14> when 'true' -> [{'data',[{[83|[116|[97|[116|[101]]]]],_3}|[]]}|[]] end in case call 'erlang':'function_exported' (_1,'format_status',2) of <'true'> when 'true' -> let <_7> = catch call _1:'format_status' (_0,[_2|[_3|[]]]) in case _7 of <{'EXIT',_15}> when 'true' -> _5
<Else> when 'true' -> Else end
<_16> when 'true' -> _5 end
'behaviour_info'/1 = fun (_0) -> case _0 of <'callbacks'> when 'true' -> [{'init',1}|[{'handle_call',3}|[{'handle_cast',2}|[{'handle_info',2}|[{'handle_continue',2}|[{'terminate',2}|[{'code_change',3}|[{'format_status',2}]]]]]]]]
<'optional_callbacks'> when 'true' -> [{'handle_info',2}|[{'handle_continue',2}|[{'terminate',2}|[{'code_change',3}|[{'format_status',2}]]]]]
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'behaviour_info',1}}] )-|['compiler_generated'] ) end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('gen_server')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('gen_server',_0) end