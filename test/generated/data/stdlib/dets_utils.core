module 'dets_utils' ['all_allocated'/1,'all_allocated_as_list'/1,'all_free'/1,'alloc'/2,'alloc_many'/4,'bad_object'/2,'cache_lookup'/4,'cache_size'/1,'cmp'/2,'code_to_type'/1,'corrupt'/2,'corrupt_file'/2,'corrupt_reason'/2,'debug_mode'/0,'disk_map_segment'/2,'disk_map_segment_p'/2,'empty_free_lists'/0,'family'/1,'file_error'/2,'find_allocated'/4,'find_next_allocated'/3,'free'/3,'fwrite'/3,'get_freelists'/1,'init_alloc'/1,'init_disk_map'/1,'ipread'/3,'is_empty_cache'/1,'list_to_tree'/1,'log2'/1,'make_zeros'/1,'mkeysearch'/3,'mkeysort'/2,'module_info'/0,'module_info'/1,'msort'/1,'new_cache'/1,'open'/2,'position'/2,'position'/3,'position_close'/3,'pread'/2,'pread'/4,'pread_close'/4,'pread_n'/3,'pwrite'/2,'pwrite'/3,'read_4'/2,'read_n'/2,'rename'/2,'reset_cache'/1,'stop_disk_map'/0,'sync'/1,'tree_to_bin'/5,'truncate'/2,'truncate'/3,'type_to_code'/1,'vformat'/2,'write'/2,'write_file'/2] attributes [ 'file' = [{[115|[114|[99|[47|[100|[101|[116|[115|[95|[117|[116|[105|[108|[115|[46|[101|[114|[108]]]]]]]]]]]]]]]]]],1}]
, 'compile' = [{'inline',[{'sz2pos',1}|[{'adjust_addr',3}]]}]
, 'compile' = [{'inline',[{'bplus_mk_leaf',1}|[{'bplus_get_size',1}|[{'bplus_get_tree',2}|[{'bplus_get_lkey',2}|[{'bplus_get_rkey',2}]]]]]}]
, 'file' = [{[115|[114|[99|[47|[100|[101|[116|[115|[46|[104|[114|[108]]]]]]]]]]]],1}]
, 'type' = [{'access',{'type',49,'union',[{'atom',49,'read'}|[{'atom',49,'read_write'}]]},[]}]
, 'type' = [{'auto_save',{'type',50,'union',[{'atom',50,'infinity'}|[{'type',50,'non_neg_integer',[]}]]},[]}]
, 'type' = [{'hash_bif',{'type',51,'union',[{'atom',51,'phash'}|[{'atom',51,'phash2'}]]},[]}]
, 'type' = [{'keypos',{'type',52,'pos_integer',[]},[]}]
, 'type' = [{'no_colls',{'type',53,'list',[{'type',53,'tuple',[{'ann_type',53,[{'var',53,'LogSize'}|[{'type',53,'non_neg_integer',[]}]]}|[{'ann_type',54,[{'var',54,'NoCollections'}|[{'type',54,'non_neg_integer',[]}]]}]]}]},[]}]
, 'type' = [{'no_slots',{'type',55,'union',[{'atom',55,'default'}|[{'type',55,'non_neg_integer',[]}]]},[]}]
, 'type' = [{'tab_name',{'type',56,'term',[]},[]}]
, 'type' = [{'type',{'type',57,'union',[{'atom',57,'bag'}|[{'atom',57,'duplicate_bag'}|[{'atom',57,'set'}]]]},[]}]
, 'type' = [{'update_mode',{'type',58,'union',[{'atom',58,'dirty'}|[{'atom',59,'new_dirty'}|[{'atom',60,'saved'}|[{'type',61,'tuple',[{'atom',61,'error'}|[{'ann_type',61,[{'var',61,'Reason'}|[{'type',61,'term',[]}]]}]]}]]]]},[]}]
, 'record' = [{'head',[{'typed_record_field',{'record_field',65,{'atom',65,'m'}},{'type',65,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',66,{'atom',66,'m2'}},{'type',66,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',67,{'atom',67,'next'}},{'type',67,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',69,{'atom',69,'fptr'}},{'remote_type',69,[{'atom',69,'file'}|[{'atom',69,'fd'}|[[]]]]}}|[{'typed_record_field',{'record_field',70,{'atom',70,'no_objects'}},{'type',70,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',71,{'atom',71,'no_keys'}},{'type',71,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',72,{'atom',72,'maxobjsize'}},{'type',72,'union',[{'atom',72,'undefined'}|[{'type',72,'non_neg_integer',[]}]]}}|[{'record_field',74,{'atom',74,'n'}}|[{'typed_record_field',{'record_field',75,{'atom',75,'type'}},{'user_type',75,'type',[]}}|[{'typed_record_field',{'record_field',76,{'atom',76,'keypos'}},{'user_type',76,'keypos',[]}}|[{'typed_record_field',{'record_field',77,{'atom',77,'freelists'}},{'type',77,'union',[{'atom',77,'undefined'}|[{'type',78,'tuple','any'}]]}}|[{'typed_record_field',{'record_field',80,{'atom',80,'freelists_p'}},{'type',80,'union',[{'atom',80,'undefined'}|[{'type',81,'non_neg_integer',[]}]]}}|[{'typed_record_field',{'record_field',82,{'atom',82,'no_collections'}},{'type',82,'union',[{'atom',82,'undefined'}|[{'user_type',83,'no_colls',[]}]]}}|[{'typed_record_field',{'record_field',85,{'atom',85,'auto_save'}},{'user_type',85,'auto_save',[]}}|[{'typed_record_field',{'record_field',86,{'atom',86,'update_mode'}},{'user_type',86,'update_mode',[]}}|[{'typed_record_field',{'record_field',87,{'atom',87,'fixed'},{'atom',87,'false'}},{'type',87,'union',[{'atom',87,'false'}|[{'type',88,'tuple',[{'type',88,'tuple',[{'type',88,'integer',[]}|[{'type',88,'integer',[]}]]}|[{'type',89,'list',[{'type',89,'tuple',[{'type',89,'pid',[]}|[{'type',90,'non_neg_integer',[]}]]}]}]]}]]}}|[{'typed_record_field',{'record_field',91,{'atom',91,'hash_bif'}},{'user_type',91,'hash_bif',[]}}|[{'typed_record_field',{'record_field',92,{'atom',92,'has_md5'}},{'type',92,'boolean',[]}}|[{'typed_record_field',{'record_field',94,{'atom',94,'min_no_slots'}},{'user_type',94,'no_slots',[]}}|[{'typed_record_field',{'record_field',95,{'atom',95,'max_no_slots'}},{'user_type',95,'no_slots',[]}}|[{'typed_record_field',{'record_field',96,{'atom',96,'cache'}},{'type',96,'union',[{'atom',96,'undefined'}|[{'user_type',96,'cache',[]}]]}}|[{'typed_record_field',{'record_field',98,{'atom',98,'filename'}},{'remote_type',98,[{'atom',98,'file'}|[{'atom',98,'name'}|[[]]]]}}|[{'typed_record_field',{'record_field',99,{'atom',99,'access'},{'atom',99,'read_write'}},{'user_type',99,'access',[]}}|[{'typed_record_field',{'record_field',100,{'atom',100,'ram_file'},{'atom',100,'false'}},{'type',100,'boolean',[]}}|[{'typed_record_field',{'record_field',101,{'atom',101,'name'}},{'user_type',101,'tab_name',[]}}|[{'typed_record_field',{'record_field',103,{'atom',103,'parent'}},{'type',103,'union',[{'atom',103,'undefined'}|[{'type',103,'pid',[]}]]}}|[{'typed_record_field',{'record_field',104,{'atom',104,'server'}},{'type',104,'union',[{'atom',104,'undefined'}|[{'type',104,'pid',[]}]]}}|[{'typed_record_field',{'record_field',106,{'atom',106,'bump'}},{'type',106,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',107,{'atom',107,'base'}},{'type',107,'non_neg_integer',[]}}]]]]]]]]]]]]]]]]]]]]]]]]]]]]]}]
, 'record' = [{'fileheader',[{'typed_record_field',{'record_field',113,{'atom',113,'freelist'}},{'type',113,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',114,{'atom',114,'fl_base'}},{'type',114,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',115,{'atom',115,'cookie'}},{'type',115,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',116,{'atom',116,'closed_properly'}},{'type',116,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',117,{'atom',117,'type'}},{'type',117,'union',[{'atom',117,'badtype'}|[{'user_type',117,'type',[]}]]}}|[{'typed_record_field',{'record_field',118,{'atom',118,'version'}},{'type',118,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',119,{'atom',119,'m'}},{'type',119,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',120,{'atom',120,'next'}},{'type',120,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',121,{'atom',121,'keypos'}},{'user_type',121,'keypos',[]}}|[{'typed_record_field',{'record_field',122,{'atom',122,'no_objects'}},{'type',122,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',123,{'atom',123,'no_keys'}},{'type',123,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',124,{'atom',124,'min_no_slots'}},{'type',124,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',125,{'atom',125,'max_no_slots'}},{'type',125,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',126,{'atom',126,'no_colls'}},{'type',126,'union',[{'atom',126,'undefined'}|[{'user_type',126,'no_colls',[]}]]}}|[{'typed_record_field',{'record_field',127,{'atom',127,'hash_method'}},{'type',127,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',128,{'atom',128,'read_md5'}},{'type',128,'binary',[]}}|[{'typed_record_field',{'record_field',129,{'atom',129,'has_md5'}},{'type',129,'boolean',[]}}|[{'typed_record_field',{'record_field',130,{'atom',130,'md5'}},{'type',130,'binary',[]}}|[{'typed_record_field',{'record_field',131,{'atom',131,'trailer'}},{'type',131,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',132,{'atom',132,'eof'}},{'type',132,'non_neg_integer',[]}}|[{'record_field',133,{'atom',133,'n'}}]]]]]]]]]]]]]]]]]]]]]}]
, 'type' = [{'delay',{'type',136,'non_neg_integer',[]},[]}]
, 'type' = [{'threshold',{'type',137,'non_neg_integer',[]},[]}]
, 'type' = [{'cache_parms',{'type',139,'tuple',[{'ann_type',139,[{'var',139,'Delay'}|[{'user_type',139,'delay',[]}]]}|[{'ann_type',141,[{'var',141,'Size'}|[{'user_type',141,'threshold',[]}]]}]]},[]}]
, 'record' = [{'cache',[{'typed_record_field',{'record_field',145,{'atom',145,'cache'}},{'type',146,'list',[{'type',146,'tuple',[{'ann_type',146,[{'var',146,'Key'}|[{'type',146,'term',[]}]]}|[{'type',147,'tuple',[{'ann_type',147,[{'var',147,'Seq'}|[{'type',147,'non_neg_integer',[]}]]}|[{'ann_type',147,[{'var',147,'Item'}|[{'type',147,'term',[]}]]}]]}]]}]}}|[{'typed_record_field',{'record_field',148,{'atom',148,'csize'}},{'type',148,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',149,{'atom',149,'inserts'}},{'type',150,'non_neg_integer',[]}}|[{'typed_record_field',{'record_field',151,{'atom',151,'wrtime'}},{'type',151,'union',[{'atom',151,'undefined'}|[{'type',151,'integer',[]}]]}}|[{'typed_record_field',{'record_field',152,{'atom',152,'tsize'}},{'user_type',152,'threshold',[]}}|[{'typed_record_field',{'record_field',153,{'atom',153,'delay'}},{'user_type',153,'delay',[]}}]]]]]]}]
, 'type' = [{'cache',{'type',156,'record',[{'atom',156,'cache'}]},[]}]
, 'file' = [{[115|[114|[99|[47|[100|[101|[116|[115|[95|[117|[116|[105|[108|[115|[46|[101|[114|[108]]]]]]]]]]]]]]]]]],59}]
, 'dialyzer' = [{'no_improper_lists',{'all_allocated_as_list',4}}] ] 'cmp'/2 = fun (_0,_1) -> case <_0,_1> of <T,_12> when call 'erlang':'=:=' (_12,T) -> 0
<[E1|T1],[E2|T2]> when 'true' -> case apply 'cmp'/2 (E1,E2) of <0> when 'true' -> apply 'cmp'/2 (T1,T2)
<R> when 'true' -> R end
<T1,T2> when try let <_4> = call 'erlang':'tuple_size' (T1) in let <_3> = call 'erlang':'tuple_size' (T2) in call 'erlang':'=:=' (_4,_3) of <Try> -> Try catch <T,R> -> 'false' -> let <_5> = call 'erlang':'tuple_size' (T1) in apply 'tcmp'/4 (T1,T2,1,_5)
<I,F> when let <_6> = call 'erlang':'is_integer' (I) in let <_7> = call 'erlang':'is_float' (F) in call 'erlang':'and' (_6,_7) -> -1
<F,I> when let <_8> = call 'erlang':'is_float' (F) in let <_9> = call 'erlang':'is_integer' (I) in call 'erlang':'and' (_8,_9) -> 1
<T1,T2> when call 'erlang':'<' (T1,T2) -> -1
<_X_T1,_X_T2> when 'true' -> 1 end
'tcmp'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <T1,T2,I,_14> when call 'erlang':'=:=' (_14,I) -> let <_5> = call 'erlang':'element' (I,T1) in let <_4> = call 'erlang':'element' (I,T2) in apply 'cmp'/2 (_5,_4)
<T1,T2,I,N> when 'true' -> let <_7> = call 'erlang':'element' (I,T1) in let <_6> = call 'erlang':'element' (I,T2) in case apply 'cmp'/2 (_7,_6) of <0> when 'true' -> let <_8> = call 'erlang':'+' (I,1) in apply 'tcmp'/4 (T1,T2,_8,N)
<R> when 'true' -> R end end
'msort'/1 = fun (_0) -> let <F> = fun (_3,_2) -> let <_1> = apply 'cmp'/2 (_3,_2) in call 'erlang':'=<' (_1,0) in let <_7> = call 'lists':'sort' (_0) in call 'lists':'sort' (F,_7)
'mkeysort'/2 = fun (_0,_1) -> let <F> = fun (_6,_5) -> let <_3> = call 'erlang':'element' (_0,_6) in let <_2> = call 'erlang':'element' (_0,_5) in let <_4> = apply 'cmp'/2 (_3,_2) in call 'erlang':'=<' (_4,0) in let <_10> = call 'lists':'keysort' (_0,_1) in call 'lists':'sort' (F,_10)
'mkeysearch'/3 = fun (_0,_1,_2) -> case call 'lists':'keysearch' (_0,_1,_2) of <Reply = {'value',Value}> when try let <_3> = call 'erlang':'element' (_1,Value) in call 'erlang':'=:=' (_3,_0) of <Try> -> Try catch <T,R> -> 'false' -> Reply
<'false'> when 'true' -> 'false'
<_8> when 'true' -> apply 'mkeysearch2'/3 (_0,_1,_2) end
'mkeysearch2'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_Key,_X_I,[]> when 'true' -> 'false'
<Key,I,[E|_X_L]> when try let <_3> = call 'erlang':'element' (I,E) in call 'erlang':'=:=' (_3,Key) of <Try> -> Try catch <T,R> -> 'false' -> {'value',E}
<Key,I,[_7|L]> when 'true' -> apply 'mkeysearch2'/3 (Key,I,L)
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'mkeysearch2',3}}] )-|['compiler_generated'] ) end
'family'/1 = fun (_0) -> case _0 of <[]> when 'true' -> []
<L> when 'true' -> case apply 'mkeysort'/2 (1,L) of <[{K,V}|KVL]> when 'true' -> apply 'per_key'/4 (KVL,K,[V|[]],[])
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end end
'per_key'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],K,Vs,KVs> when 'true' -> let <_4> = apply 'msort'/1 (Vs) in call 'lists':'reverse' (KVs,[{K,_4}|[]])
<[{K,V}|L],_10,Vs,KVs> when call 'erlang':'=:=' (_10,K) -> apply 'per_key'/4 (L,K,[V|Vs],KVs)
<[{K1,V}|L],K,Vs,KVs> when 'true' -> let <_5> = apply 'msort'/1 (Vs) in apply 'per_key'/4 (L,K1,[V|[]],[{K,_5}|KVs])
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'per_key',4}}] )-|['compiler_generated'] ) end
'rename'/2 = fun (_0,_1) -> case call 'file':'rename' (_0,_1) of <'ok'> when 'true' -> 'ok'
<{'error',Reason}> when 'true' -> {'error',{'file_error',{_0,_1},Reason}}
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'pread'/2 = fun (_0,_1) -> (case _1 of (<({'head',_20,_21,_22,_rec0,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47}-|['compiler_generated'] )> when 'true' -> let <_14> = case call 'file':'pread' (_rec0,_0) of <_@r0 = {'ok',Bins}> when 'true' -> case call 'lists':'member' ('eof',Bins) of <'true'> when 'true' -> (case _1 of (<({'head',_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_rec1,_70,_71,_72,_73,_74,_75,_76}-|['compiler_generated'] )> when 'true' -> {'error',{'premature_eof',_rec1}}-|['compiler_generated'] )
(<_77> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'false'> when 'true' -> _@r0
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<{'error',Reason}> when let <_7> = call 'erlang':'=:=' ('enomem',Reason) in let <_8> = call 'erlang':'=:=' ('einval',Reason) in call 'erlang':'or' (_7,_8) -> (case _1 of (<({'head',_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_rec2,_99,_100,_101,_102,_103,_104,_105}-|['compiler_generated'] )> when 'true' -> {'error',{'bad_object_header',_rec2}}-|['compiler_generated'] )
(<_106> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<{'error',Reason}> when 'true' -> (case _1 of (<({'head',_107,_108,_109,_110,_111,_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127,_rec3,_128,_129,_130,_131,_132,_133,_134}-|['compiler_generated'] )> when 'true' -> {'file_error',_rec3,Reason}-|['compiler_generated'] )
(<_135> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end in case _14 of <{'ok',_X_Bins}> when 'true' -> _14
<Error> when 'true' -> let <_16> = apply 'corrupt'/2 (_1,Error) in call 'erlang':'throw' (_16) end-|['compiler_generated'] )
(<_48> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'pread'/4 = fun (_0,_1,_2,_3) -> (case _0 of (<({'head',_25,_26,_27,_rec4,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52}-|['compiler_generated'] )> when 'true' -> let <_4> = call 'erlang':'+' (_2,_3) in let <_17> = case call 'file':'pread' (_rec4,_1,_4) of <{'error',Reason}> when let <_7> = call 'erlang':'=:=' ('enomem',Reason) in let <_8> = call 'erlang':'=:=' ('einval',Reason) in call 'erlang':'or' (_7,_8) -> (case _0 of (<({'head',_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72,_73,_74,_rec5,_75,_76,_77,_78,_79,_80,_81}-|['compiler_generated'] )> when 'true' -> {'error',{'bad_object_header',_rec5}}-|['compiler_generated'] )
(<_82> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<{'error',Reason}> when 'true' -> (case _0 of (<({'head',_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102,_103,_rec6,_104,_105,_106,_107,_108,_109,_110}-|['compiler_generated'] )> when 'true' -> {'file_error',_rec6,Reason}-|['compiler_generated'] )
(<_111> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<{'ok',Bin}> when try let <_13> = call 'erlang':'byte_size' (Bin) in call 'erlang':'<' (_13,_2) of <Try> -> Try catch <T,R> -> 'false' -> (case _0 of (<({'head',_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127,_128,_129,_130,_131,_132,_rec7,_133,_134,_135,_136,_137,_138,_139}-|['compiler_generated'] )> when 'true' -> {'error',{'premature_eof',_rec7}}-|['compiler_generated'] )
(<_140> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<OK> when 'true' -> OK end in case _17 of <{'ok',_X_Bin}> when 'true' -> _17
<Error> when 'true' -> let <_19> = apply 'corrupt'/2 (_0,Error) in call 'erlang':'throw' (_19) end-|['compiler_generated'] )
(<_53> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'ipread'/3 = fun (_0,_1,_2) -> do try apply 'disk_map_pread'/1 (_1) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),Bad,_14> when 'true' -> let <_7> = apply 'corrupt_reason'/2 (_0,{'disk_map',Bad}) in call 'erlang':'throw' (_7)
(<_44,_45,_46> when 'true' -> primop 'raise' (_46,_45)-|['compiler_generated'] ) end (case _0 of (<({'head',_15,_16,_17,_rec8,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42}-|['compiler_generated'] )> when 'true' -> case call 'file':'ipread_s32bu_p32bu' (_rec8,_1,_2) of <{'ok',{0,0,'eof'}}> when 'true' -> []
<_@r0 = {'ok',Reply}> when 'true' -> _@r0
<_X_Else> when 'true' -> 'eof' end-|['compiler_generated'] )
(<_43> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'pwrite'/2 = fun (_0,_1) -> case <_0,_1> of <Head,[]> when 'true' -> {Head,'ok'}
<Head,Bins> when 'true' -> do try apply 'disk_map'/1 (Bins) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Bad,_12> when 'true' -> let <_6> = apply 'corrupt_reason'/2 (Head,{'disk_map',Bad,Bins}) in call 'erlang':'throw' (_6)
(<_42,_43,_44> when 'true' -> primop 'raise' (_44,_43)-|['compiler_generated'] ) end (case Head of (<({'head',_13,_14,_15,_rec9,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40}-|['compiler_generated'] )> when 'true' -> case call 'file':'pwrite' (_rec9,Bins) of <'ok'> when 'true' -> {Head,'ok'}
<Error> when 'true' -> apply 'corrupt_file'/2 (Head,Error) end-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'write'/2 = fun (_0,_1) -> case <_0,_1> of <_X_Head,[]> when 'true' -> 'ok'
<Head,Bins> when 'true' -> (case Head of (<({'head',_7,_8,_9,_rec10,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34}-|['compiler_generated'] )> when 'true' -> case call 'file':'write' (_rec10,Bins) of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> apply 'corrupt_file'/2 (Head,Error) end-|['compiler_generated'] )
(<_35> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'write_file'/2 = fun (_0,_1) -> (case _0 of (<({'head',_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_rec11,_35,_36,_37,_38,_39,_40,_41}-|['compiler_generated'] )> when 'true' -> let <_9> = case call 'file':'open' (_rec11,['binary'|['raw'|['write']]]) of <{'ok',Fd}> when 'true' -> let <R1> = call 'file':'write' (Fd,_1) in let <R2> = call 'file':'sync' (Fd) in let <R3> = call 'file':'close' (Fd) in case <R1,R2,R3> of <('ok'-|['compiler_generated'] ),('ok'-|['compiler_generated'] ),_43> when call 'erlang':'=:=' (_43,R3) -> R3
<('ok'-|['compiler_generated'] ),_44,_45> when call 'erlang':'=:=' (_44,R2) -> R2
<_46,_47,_48> when call 'erlang':'=:=' (_46,R1) -> R1
(<(_49-|['compiler_generated'] ),(_50-|['compiler_generated'] ),(_51-|['compiler_generated'] )> when 'true' -> let <_7> = {(_49-|['compiler_generated'] ),(_50-|['compiler_generated'] ),(_51-|['compiler_generated'] )} in primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end
<Else> when 'true' -> Else end in case _9 of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> apply 'corrupt_file'/2 (_0,Error) end-|['compiler_generated'] )
(<_42> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'truncate'/2 = fun (_0,_1) -> let <_6> = catch (case _0 of (<({'head',_11,_12,_13,_rec12,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38}-|['compiler_generated'] )> when 'true' -> (case _0 of (<({'head',_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_rec13,_61,_62,_63,_64,_65,_66,_67}-|['compiler_generated'] )> when 'true' -> apply 'truncate'/3 (_rec12,_rec13,_1)-|['compiler_generated'] )
(<_68> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_39> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) in case _6 of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> let <_7> = apply 'corrupt'/2 (_0,Error) in call 'erlang':'throw' (_7) end
'position'/2 = fun (_0,_1) -> (case _0 of (<({'head',_7,_8,_9,_rec14,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34}-|['compiler_generated'] )> when 'true' -> case call 'file':'position' (_rec14,_1) of <Error = {'error',_X_Reason}> when 'true' -> apply 'corrupt_file'/2 (_0,Error)
<OK> when 'true' -> OK end-|['compiler_generated'] )
(<_35> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'sync'/1 = fun (_0) -> (case _0 of (<({'head',_5,_6,_7,_rec15,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32}-|['compiler_generated'] )> when 'true' -> case call 'file':'sync' (_rec15) of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> apply 'corrupt_file'/2 (_0,Error) end-|['compiler_generated'] )
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'open'/2 = fun (_0,_1) -> case call 'file':'open' (_0,_1) of <_@r0 = {'ok',Fd}> when 'true' -> _@r0
<Error> when 'true' -> apply 'file_error'/2 (_0,Error) end
'truncate'/3 = fun (_0,_1,_2) -> do (case <> of <> when (call ('erlang'-|['result_not_wanted'] ):('=/='-|['result_not_wanted'] ) (_2,('cur'-|['result_not_wanted'] ))-|['result_not_wanted'] ) -> apply 'position'/3 (_0,_1,_2)
(<> when 'true' -> []-|['compiler_generated'] ) end-|['list_comprehension'] ) case call 'file':'truncate' (_0) of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> apply 'file_error'/2 (_1,{'error',Error}) end
'fwrite'/3 = fun (_0,_1,_2) -> case call 'file':'write' (_0,_2) of <'ok'> when 'true' -> 'ok'
<Error> when 'true' -> apply 'file_error_close'/3 (_0,_1,Error) end
'position'/3 = fun (_0,_1,_2) -> case call 'file':'position' (_0,_2) of <_@r0 = {'error',Error}> when 'true' -> apply 'file_error'/2 (_1,_@r0)
<OK> when 'true' -> OK end
'position_close'/3 = fun (_0,_1,_2) -> case call 'file':'position' (_0,_2) of <_@r0 = {'error',Error}> when 'true' -> apply 'file_error_close'/3 (_0,_1,_@r0)
<OK> when 'true' -> OK end
'pwrite'/3 = fun (_0,_1,_2) -> case call 'file':'pwrite' (_0,_2) of <'ok'> when 'true' -> 'ok'
<{'error',{_X_NoWrites,Reason}}> when 'true' -> apply 'file_error'/2 (_1,{'error',Reason})
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'pread_close'/4 = fun (_0,_1,_2,_3) -> case call 'file':'pread' (_0,_2,_3) of <_@r0 = {'error',Error}> when 'true' -> apply 'file_error_close'/3 (_0,_1,_@r0)
<{'ok',Bin}> when try let <_4> = call 'erlang':'byte_size' (Bin) in call 'erlang':'<' (_4,_3) of <Try> -> Try catch <T,R> -> 'false' -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (_0)-|['result_not_wanted'] ) call 'erlang':'throw' ({'error',{'tooshort',_1}})
<'eof'> when 'true' -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (_0)-|['result_not_wanted'] ) call 'erlang':'throw' ({'error',{'tooshort',_1}})
<OK> when 'true' -> OK end
'file_error'/2 = fun (_0,_1) -> case <_0,_1> of <FileName,{'error',Reason}> when 'true' -> call 'erlang':'throw' ({'error',{'file_error',FileName,Reason}})
(<_3,_2> when 'true' -> (primop 'match_fail' ({'function_clause',_3,_2})-|[{'function_name',{'file_error',2}}] )-|['compiler_generated'] ) end
'file_error_close'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Fd,FileName,{'error',Reason}> when 'true' -> do (call ('file'-|['result_not_wanted'] ):('close'-|['result_not_wanted'] ) (Fd)-|['result_not_wanted'] ) call 'erlang':'throw' ({'error',{'file_error',FileName,Reason}})
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'file_error_close',3}}] )-|['compiler_generated'] ) end
'debug_mode'/0 = fun () -> let <_0> = call 'os':'getenv' ([68|[69|[84|[83|[95|[68|[69|[66|[85|[71]]]]]]]]]]) in call 'erlang':'=:=' (_0,[116|[114|[117|[101]]]])
'bad_object'/2 = fun (_0,_1) -> case apply 'debug_mode'/0 () of <'true'> when 'true' -> {'bad_object',_0,_1}
<'false'> when 'true' -> {'bad_object',_0}
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
'read_n'/2 = fun (_0,_1) -> case call 'file':'read' (_0,_1) of <{'ok',Bin}> when 'true' -> Bin
<_X_Else> when 'true' -> 'eof' end
'pread_n'/3 = fun (_0,_1,_2) -> case call 'file':'pread' (_0,_1,_2) of <{'ok',Bin}> when 'true' -> Bin
<_7> when 'true' -> 'eof' end
'read_4'/2 = fun (_0,_1) -> case call 'file':'position' (_0,_1) of <{'ok',_6}> when 'true' -> case call 'dets_utils':'read_n' (_0,4) of <#{#<Four>(32,1,'integer',['unsigned'|['big']])}#> when 'true' -> Four
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
'corrupt_file'/2 = fun (_0,_1) -> case <_0,_1> of <Head,{'error',Reason}> when 'true' -> (case Head of (<({'head',_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_rec16,_29,_30,_31,_32,_33,_34,_35}-|['compiler_generated'] )> when 'true' -> let <Error> = {'error',{'file_error',_rec16,Reason}} in let <_5> = apply 'corrupt'/2 (Head,Error) in call 'erlang':'throw' (_5)-|['compiler_generated'] )
(<_36> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6})-|[{'function_name',{'corrupt_file',2}}] )-|['compiler_generated'] ) end
'corrupt_reason'/2 = fun (_0,_1) -> let <_6> = case apply 'get_disk_map'/0 () of <'no_disk_map'> when 'true' -> _1
<DM> when 'true' -> let <_2> = call 'erlang':'self' () in case call 'erlang':'process_info' (_2,'current_stacktrace') of <{'current_stacktrace',ST}> when 'true' -> let <PD> = call 'erlang':'get' () in {_1,ST,PD,DM}
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end end in (case _0 of (<({'head',_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_rec17,_34,_35,_36,_37,_38,_39,_40}-|['compiler_generated'] )> when 'true' -> let <Error> = {'error',{_6,_rec17}} in apply 'corrupt'/2 (_0,Error)-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'corrupt'/2 = fun (_0,_1) -> do case call 'erlang':'get' ('verbose') of <'yes'> when 'true' -> (case _0 of (<({'head',_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_rec18,_37,_38,_39,_40}-|['compiler_generated'] )> when 'true' -> call 'error_logger':'format' ([42|[42|[32|[100|[101|[116|[115|[58|[32|[67|[111|[114|[114|[117|[112|[116|[32|[116|[97|[98|[108|[101|[32|[126|[116|[112|[58|[32|[126|[116|[112|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_rec18|[_1|[]]])-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<_42> when 'true' -> 'ok' end (case _0 of (<({'head',_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_rec19,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70}-|['compiler_generated'] )> when 'true' -> case _rec19 of <{'error',_72}> when 'true' -> {_0,_1}
<_73> when 'true' -> case _0 of <{'head',_74,_75,_76,_77,_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102}> when 'true' -> let <_9> = call 'erlang':'setelement' (16,_0,_1) in {_9,_1}
(<_103> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end end-|['compiler_generated'] )
(<_71> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'vformat'/2 = fun (_0,_1) -> case call 'erlang':'get' ('verbose') of <'yes'> when 'true' -> call 'error_logger':'format' (_0,_1)
<_5> when 'true' -> 'ok' end
'code_to_type'/1 = fun (_0) -> case _0 of <1> when 'true' -> 'set'
<2> when 'true' -> 'bag'
<3> when 'true' -> 'duplicate_bag'
<_X_Type> when 'true' -> 'badtype' end
'type_to_code'/1 = fun (_0) -> case _0 of <'set'> when 'true' -> 1
<'bag'> when 'true' -> 2
<'duplicate_bag'> when 'true' -> 3
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'type_to_code',1}}] )-|['compiler_generated'] ) end
'cache_size'/1 = fun (_0) -> (case _0 of (<({'cache',_6,_7,_8,_9,_10,_rec21}-|['compiler_generated'] )> when 'true' -> (case _0 of (<({'cache',_12,_13,_14,_15,_rec22,_16}-|['compiler_generated'] )> when 'true' -> {_rec21,_rec22}-|['compiler_generated'] )
(<_17> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','cache'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_11> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','cache'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'cache_lookup'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Type,[Key|Keys],CL,LU> when 'true' -> case apply 'mkeysearch'/3 (Key,1,CL) of <{'value',{_9,{_X_Seq,{'insert',Object}}}}> when let <_10> = call 'erlang':'=:=' (_9,Key) in let <_11> = call 'erlang':'=:=' (Type,'set') in call 'erlang':'and' (_10,_11) -> apply 'cache_lookup'/4 (Type,Keys,CL,[Object|LU])
<{'value',{_12,{_X_Seq,'delete_key'}}}> when call 'erlang':'=:=' (_12,Key) -> apply 'cache_lookup'/4 (Type,Keys,CL,LU)
<_13> when 'true' -> 'false' end
<_X_Type,[],_X_CL,LU> when 'true' -> LU
(<_8,_7,_6,_5> when 'true' -> (primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|[{'function_name',{'cache_lookup',4}}] )-|['compiler_generated'] ) end
'reset_cache'/1 = fun (_0) -> (case _0 of (<({'cache',_16,_17,_18,_rec23,_19,_20}-|['compiler_generated'] )> when 'true' -> let <_4> = case <> of <> when call 'erlang':'=:=' (_rec23,'undefined') -> _rec23
<> when 'true' -> call 'erlang':'monotonic_time' (1000000) end in (case _0 of (<({'cache',_rec24,_22,_23,_24,_25,_26}-|['compiler_generated'] )> when 'true' -> let <PK> = apply 'family'/1 (_rec24) in case _0 of <{'cache',_rec26,_rec27,_rec28,_rec29,_rec30,_rec31}> when 'true' -> let <_11> = {'cache',[],0,0,_4,_rec30,_rec31} in (case _0 of (<({'cache',_29,_30,_rec32,_31,_32,_33}-|['compiler_generated'] )> when 'true' -> {_11,_rec32,PK}-|['compiler_generated'] )
(<_34> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','cache'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_28> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','cache'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_27> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','cache'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )
(<_21> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','cache'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'is_empty_cache'/1 = fun (_0) -> (case _0 of (<({'cache',_rec33,_4,_5,_6,_7,_8}-|['compiler_generated'] )> when 'true' -> call 'erlang':'=:=' (_rec33,[])-|['compiler_generated'] )
(<_9> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','cache'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'new_cache'/1 = fun (_0) -> case _0 of <{Delay,Size}> when 'true' -> {'cache',[],0,0,'undefined',Size,Delay}
(<_1> when 'true' -> (primop 'match_fail' ({'function_clause',_1})-|[{'function_name',{'new_cache',1}}] )-|['compiler_generated'] ) end
'init_alloc'/1 = fun (_0) -> let <Ftab> = apply 'empty_free_lists'/0 () in let <Empty> = apply 'bplus_empty_tree'/0 () in let <_3> = apply 'bplus_insert'/2 (Empty,_0) in call 'erlang':'setelement' (32,Ftab,_3)
'empty_free_lists'/0 = fun () -> let <Empty> = apply 'bplus_empty_tree'/0 () in call 'erlang':'make_tuple' (32,Empty)
'alloc_many'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Head,_X_Sz,0,_X_A0> when 'true' -> Head
<Head,Sz,N,A0> when 'true' -> (case Head of (<({'head',_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_rec34,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42}-|['compiler_generated'] )> when 'true' -> let <_7> = call 'erlang':'*' (Sz,N) in let <_rec35> = apply 'alloc_many1'/5 (_rec34,1,_7,A0,Head) in case Head of <{'head',_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72}> when 'true' -> call 'erlang':'setelement' (12,Head,_rec35)
(<_73> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_43> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'alloc_many1'/5 = fun (_0,_1,_2,_3,_4) -> case apply 'find_first_free'/4 (_0,_1,_1,_4) of <{FPos,Addr}> when 'true' -> case call 'erlang':'>=' (Addr,_3) of <'true'> when 'true' -> case <> of <> when try let <_7> = call 'erlang':'-' (FPos,1) in let <_8> = call 'erlang':'bsl' (1,_7) in call 'erlang':'>=' (_8,_2) of <Try> -> Try catch <T,R> -> 'false' -> (case _2 of (<N> when (call ('erlang'-|['compiler_generated'] ):('>'-|['compiler_generated'] ) (_2,(0-|['compiler_generated'] ))-|['compiler_generated'] ) -> (let <_20> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (N,(1-|['compiler_generated'] )) in (let <_21> = apply 'log2'/1 (_20) in let <_9> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_21) in apply 'alloc_many2'/5 (_0,_9,_2,_3,_4)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_22> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_22}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<> when 'true' -> let <NewFtab> = apply 'reserve_buddy'/4 (_0,FPos,FPos,Addr) in let <_11> = call 'erlang':'-' (FPos,1) in let <_12> = call 'erlang':'bsl' (1,_11) in let <NSize> = call 'erlang':'-' (_2,_12) in apply 'alloc_many1'/5 (NewFtab,FPos,NSize,Addr,_4) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
'alloc_many2'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Ftab,_X_Pos,0,_X_A0,_X_H> when 'true' -> Ftab
<Ftab,Pos,Size,A0,H> when try let <_5> = call 'erlang':'-' (Pos,1) in let <_6> = call 'erlang':'bsl' (1,_5) in let <_7> = call 'erlang':'band' (Size,_6) in call 'erlang':'>' (_7,0) of <Try> -> Try catch <T,R> -> 'false' -> case apply 'find_first_free'/4 (Ftab,Pos,Pos,H) of <{FPos,Addr}> when 'true' -> case call 'erlang':'>=' (Addr,A0) of <'true'> when 'true' -> let <NewFtab> = apply 'reserve_buddy'/4 (Ftab,FPos,Pos,Addr) in let <_11> = call 'erlang':'-' (Pos,1) in let <_12> = call 'erlang':'bsl' (1,_11) in let <NSize> = call 'erlang':'-' (Size,_12) in let <_14> = call 'erlang':'-' (Pos,1) in apply 'alloc_many2'/5 (NewFtab,_14,NSize,Addr,H)
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<Ftab,Pos,Size,A0,H> when 'true' -> let <_15> = call 'erlang':'-' (Pos,1) in apply 'alloc_many2'/5 (Ftab,_15,Size,A0,H) end
'alloc'/2 = fun (_0,_1) -> case <_0,_1> of <Head = {'head',_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67},Sz> when (try let <_6> = call 'erlang':'element' (17,Head) in call 'erlang':'=/=' (_6,'false') of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case Sz of (<N> when (call ('erlang'-|['compiler_generated'] ):('>'-|['compiler_generated'] ) (Sz,(0-|['compiler_generated'] ))-|['compiler_generated'] ) -> (let <_245> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (N,(1-|['compiler_generated'] )) in (let <_2> = apply 'log2'/1 (_245) in let <Pos> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_2) in (case Head of (<({'head',_68,_69,_70,_71,_72,_73,_74,_75,_76,_77,_rec37,_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95}-|['compiler_generated'] )> when 'true' -> case _rec37 of <{Frozen,Ftab}> when 'true' -> case apply 'find_first_free'/4 (Frozen,Pos,Pos,Head) of <{FPos,Addr}> when 'true' -> let <NewFrozen> = apply 'reserve_buddy'/4 (Frozen,FPos,Pos,Addr) in (case Head of (<({'head',_97,_98,_99,_100,_101,_102,_103,_104,_105,_106,_107,_108,_109,_110,_111,_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_rec38}-|['compiler_generated'] )> when 'true' -> let <Ftab1> = apply 'undo_free'/4 (Ftab,FPos,Addr,_rec38) in let <NewFtab> = apply 'move_down'/4 (Ftab1,FPos,Pos,Addr) in let <NewFreelists> = {NewFrozen,NewFtab} in case Head of <{'head',_126,_127,_128,_129,_130,_131,_132,_133,_134,_135,_136,_137,_138,_139,_140,_141,_142,_143,_144,_145,_146,_147,_148,_149,_150,_151,_152,_153,_154}> when 'true' -> let <_21> = call 'erlang':'setelement' (12,Head,NewFreelists) in {_21,Addr,Pos}
(<_155> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_125> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_96> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Head = {'head',_156,_157,_158,_159,_160,_161,_162,_163,_164,_165,_166,_167,_168,_169,_170,_171,_172,_173,_174,_175,_176,_177,_178,_179,_180,_181,_182,_183,_184},Sz> when (try let <_26> = call 'erlang':'element' (17,Head) in call 'erlang':'=:=' (_26,'false') of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case Sz of (<N> when (call ('erlang'-|['compiler_generated'] ):('>'-|['compiler_generated'] ) (Sz,(0-|['compiler_generated'] ))-|['compiler_generated'] ) -> (let <_247> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (N,(1-|['compiler_generated'] )) in (let <_2> = apply 'log2'/1 (_247) in let <Pos> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_2) in (case Head of (<({'head',_185,_186,_187,_188,_189,_190,_191,_192,_193,_194,_rec40,_195,_196,_197,_198,_199,_200,_201,_202,_203,_204,_205,_206,_207,_208,_209,_210,_211,_212}-|['compiler_generated'] )> when 'true' -> case apply 'find_first_free'/4 (_rec40,Pos,Pos,Head) of <{FPos,Addr}> when 'true' -> let <NewFtab> = apply 'reserve_buddy'/4 (_rec40,FPos,Pos,Addr) in case Head of <{'head',_214,_215,_216,_217,_218,_219,_220,_221,_222,_223,_224,_225,_226,_227,_228,_229,_230,_231,_232,_233,_234,_235,_236,_237,_238,_239,_240,_241,_242}> when 'true' -> let <_36> = call 'erlang':'setelement' (12,Head,NewFtab) in {_36,Addr,Pos}
(<_243> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_32> when 'true' -> primop 'match_fail' ({'badmatch',_32})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_213> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_38,_37> when 'true' -> (primop 'match_fail' ({'function_clause',_38,_37})-|[{'function_name',{'alloc',2}}] )-|['compiler_generated'] ) end
'find_first_free'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_Ftab,Pos,_X_Pos0,Head> when call 'erlang':'>' (Pos,32) -> (case Head of (<({'head',_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_rec42,_42,_43,_44,_45,_46,_47,_48}-|['compiler_generated'] )> when 'true' -> call 'erlang':'throw' ({'error',{'no_more_space_on_file',_rec42}})-|['compiler_generated'] )
(<_49> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Ftab,Pos,Pos0,Head> when 'true' -> let <PosTab> = call 'erlang':'element' (Pos,Ftab) in case apply 'bplus_lookup_first'/1 (PosTab) of <'undefined'> when 'true' -> let <_7> = call 'erlang':'+' (Pos,1) in apply 'find_first_free'/4 (Ftab,_7,Pos0,Head)
<{'ok',Addr}> when try let <_11> = call 'erlang':'-' (Pos0,1) in let <_12> = call 'erlang':'bsl' (1,_11) in let <_13> = call 'erlang':'+' (Addr,_12) in call 'erlang':'>' (_13,2097483648) of <Try> -> Try catch <T,R> -> 'false' -> (case Head of (<({'head',_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_rec43,_71,_72,_73,_74,_75,_76,_77}-|['compiler_generated'] )> when 'true' -> call 'erlang':'throw' ({'error',{'no_more_space_on_file',_rec43}})-|['compiler_generated'] )
(<_78> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<{'ok',Addr}> when 'true' -> {Pos,Addr}
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end end
'undo_free'/4 = fun (_0,_1,_2,_3) -> let <PosTab> = call 'erlang':'element' (_1,_0) in case apply 'bplus_lookup'/2 (PosTab,_2) of <'undefined'> when 'true' -> let <_5> = call 'erlang':'-' (_1,1) in let <_6> = call 'erlang':'bsl' (1,_5) in case apply 'my_buddy'/3 (_2,_6,_3) of <{BuddyAddr,MoveUpAddr}> when 'true' -> let <_8> = apply 'bplus_insert'/2 (PosTab,BuddyAddr) in let <NewFtab> = call 'erlang':'setelement' (_1,_0,_8) in let <_10> = call 'erlang':'+' (_1,1) in apply 'undo_free'/4 (NewFtab,_10,MoveUpAddr,_3)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<{'ok',_17}> when call 'erlang':'=:=' (_17,_2) -> let <NewPosTab> = apply 'bplus_delete'/2 (PosTab,_2) in call 'erlang':'setelement' (_1,_0,NewPosTab)
(<_12> when 'true' -> primop 'match_fail' ({'case_clause',_12})-|['compiler_generated'] ) end
'reserve_buddy'/4 = fun (_0,_1,_2,_3) -> let <PosTab> = call 'erlang':'element' (_1,_0) in let <NewPosTab> = apply 'bplus_delete'/2 (PosTab,_3) in let <NewFtab> = call 'erlang':'setelement' (_1,_0,NewPosTab) in apply 'move_down'/4 (NewFtab,_1,_2,_3)
'move_down'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Ftab,Pos,_15,_X_Addr> when call 'erlang':'=:=' (_15,Pos) -> Ftab
<Ftab,Pos,Pos0,Addr> when 'true' -> let <Pos_1> = call 'erlang':'-' (Pos,1) in let <Size> = call 'erlang':'bsl' (1,Pos_1) in let <_6> = call 'erlang':'bsr' (Size,1) in let <HighBuddy> = call 'erlang':'+' (Addr,_6) in let <_8> = call 'erlang':'element' (Pos_1,Ftab) in let <NewPosTab_1> = apply 'bplus_insert'/2 (_8,HighBuddy) in let <NewFtab> = call 'erlang':'setelement' (Pos_1,Ftab,NewPosTab_1) in apply 'move_down'/4 (NewFtab,Pos_1,Pos0,Addr) end
'free'/3 = fun (_0,_1,_2) -> let <Ftab> = apply 'get_freelists'/1 (_0) in (case _2 of (<N> when (call ('erlang'-|['compiler_generated'] ):('>'-|['compiler_generated'] ) (_2,(0-|['compiler_generated'] ))-|['compiler_generated'] ) -> (let <_42> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (N,(1-|['compiler_generated'] )) in (let <_43> = apply 'log2'/1 (_42) in let <Pos> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_43) in (case _0 of (<({'head',_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_rec44}-|['compiler_generated'] )> when 'true' -> let <_7> = apply 'free_in_pos'/4 (Ftab,_1,Pos,_rec44) in let <_8> = apply 'set_freelists'/2 (_0,_7) in {_8,Pos}-|['compiler_generated'] )
(<_40> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('function_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'free_in_pos'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Ftab,_X_Addr,Pos,_X_Base> when call 'erlang':'>' (Pos,32) -> Ftab
<Ftab,Addr,Pos,Base> when 'true' -> let <PosTab> = call 'erlang':'element' (Pos,Ftab) in let <_5> = call 'erlang':'-' (Pos,1) in let <_6> = call 'erlang':'bsl' (1,_5) in case apply 'my_buddy'/3 (Addr,_6,Base) of <{BuddyAddr,MoveUpAddr}> when 'true' -> case apply 'bplus_lookup'/2 (PosTab,BuddyAddr) of <'undefined'> when 'true' -> let <_8> = apply 'bplus_insert'/2 (PosTab,Addr) in call 'erlang':'setelement' (Pos,Ftab,_8)
<{'ok',_18}> when call 'erlang':'=:=' (_18,BuddyAddr) -> let <PosTab1> = apply 'bplus_delete'/2 (PosTab,Addr) in let <PosTab2> = apply 'bplus_delete'/2 (PosTab1,BuddyAddr) in let <NewFtab> = call 'erlang':'setelement' (Pos,Ftab,PosTab2) in let <_12> = call 'erlang':'+' (Pos,1) in apply 'free_in_pos'/4 (NewFtab,MoveUpAddr,_12,Base)
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end end
'get_freelists'/1 = fun (_0) -> case _0 of <Head = {'head',_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46}> when (try let <_5> = call 'erlang':'element' (17,Head) in call 'erlang':'=:=' (_5,'false') of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case Head of (<({'head',_47,_48,_49,_50,_51,_52,_53,_54,_55,_56,_rec45,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72,_73,_74}-|['compiler_generated'] )> when 'true' -> _rec45-|['compiler_generated'] )
(<_75> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<Head = {'head',_76,_77,_78,_79,_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102,_103,_104}> when (try let <_12> = call 'erlang':'element' (17,Head) in call 'erlang':'=/=' (_12,'false') of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case Head of (<({'head',_105,_106,_107,_108,_109,_110,_111,_112,_113,_114,_rec46,_115,_116,_117,_118,_119,_120,_121,_122,_123,_124,_125,_126,_127,_128,_129,_130,_131,_132}-|['compiler_generated'] )> when 'true' -> case _rec46 of <{_X_Frozen,Current}> when 'true' -> Current
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_133> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_17> when 'true' -> (primop 'match_fail' ({'function_clause',_17})-|[{'function_name',{'get_freelists',1}}] )-|['compiler_generated'] ) end
'set_freelists'/2 = fun (_0,_1) -> case <_0,_1> of <Head = {'head',_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,_50,_51,_52},Ftab> when (try let <_6> = call 'erlang':'element' (17,Head) in call 'erlang':'=:=' (_6,'false') of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> case Head of <{'head',_53,_54,_55,_56,_57,_58,_59,_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,_70,_71,_72,_73,_74,_75,_76,_77,_78,_79,_80,_81}> when 'true' -> call 'erlang':'setelement' (12,Head,Ftab)
(<_82> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<Head = {'head',_83,_84,_85,_86,_87,_88,_89,_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,_100,_101,_102,_103,_104,_105,_106,_107,_108,_109,_110,_111},Ftab> when (try let <_14> = call 'erlang':'element' (17,Head) in call 'erlang':'=/=' (_14,'false') of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case Head of (<({'head',_112,_113,_114,_115,_116,_117,_118,_119,_120,_121,_rec48,_122,_123,_124,_125,_126,_127,_128,_129,_130,_131,_132,_133,_134,_135,_136,_137,_138,_139}-|['compiler_generated'] )> when 'true' -> case _rec48 of <{Frozen,_141}> when 'true' -> let <_rec49> = {Frozen,Ftab} in case Head of <{'head',_142,_143,_144,_145,_146,_147,_148,_149,_150,_151,_152,_153,_154,_155,_156,_157,_158,_159,_160,_161,_162,_163,_164,_165,_166,_167,_168,_169,_170}> when 'true' -> call 'erlang':'setelement' (12,Head,_rec49)
(<_171> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_18> when 'true' -> primop 'match_fail' ({'badmatch',_18})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_140> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_23,_22> when 'true' -> (primop 'match_fail' ({'function_clause',_23,_22})-|[{'function_name',{'set_freelists',2}}] )-|['compiler_generated'] ) end
'sz2pos'/1 = fun (_0) -> case _0 of <N> when call 'erlang':'>' (_0,0) -> let <_1> = call 'erlang':'+' (N,1) in let <_2> = apply 'log2'/1 (_1) in call 'erlang':'+' (1,_2)
(<_3> when 'true' -> (primop 'match_fail' ({'function_clause',_3})-|[{'function_name',{'sz2pos',1}}] )-|['compiler_generated'] ) end
'log2'/1 = fun (_0) -> case _0 of <N> when let <_1> = call 'erlang':'is_integer' (_0) in let <_2> = call 'erlang':'>=' (_0,0) in call 'erlang':'and' (_1,_2) -> case <> of <> when call 'erlang':'>' (N,256) -> case <> of <> when call 'erlang':'>' (N,1024) -> case <> of <> when call 'erlang':'>' (N,2048) -> case <> of <> when call 'erlang':'>' (N,4096) -> let <_13> = case <> of <> when try let <_9> = call 'erlang':'band' (N,4095) in call 'erlang':'=:=' (_9,0) of <Try> -> Try catch <T,R> -> 'false' -> let <_10> = call 'erlang':'bsr' (N,12) in apply 'log2'/1 (_10)
<> when 'true' -> let <_11> = call 'erlang':'bsr' (N,12) in let <_12> = call 'erlang':'+' (1,_11) in apply 'log2'/1 (_12) end in call 'erlang':'+' (12,_13)
<> when 'true' -> 12 end
<> when 'true' -> 11 end
<> when call 'erlang':'>' (N,512) -> 10
<> when 'true' -> 9 end
<> when call 'erlang':'>' (N,16) -> case <> of <> when call 'erlang':'>' (N,64) -> case <> of <> when call 'erlang':'>' (N,128) -> 8
<> when 'true' -> 7 end
<> when call 'erlang':'>' (N,32) -> 6
<> when 'true' -> 5 end
<> when call 'erlang':'>' (N,4) -> case <> of <> when call 'erlang':'>' (N,8) -> 4
<> when 'true' -> 3 end
<> when call 'erlang':'>' (N,2) -> 2
<> when call 'erlang':'>=' (N,1) -> 1
<> when 'true' -> 0 end
(<_23> when 'true' -> (primop 'match_fail' ({'function_clause',_23})-|[{'function_name',{'log2',1}}] )-|['compiler_generated'] ) end
'make_zeros'/1 = fun (_0) -> case _0 of <0> when 'true' -> []
<N> when try let <_1> = call 'erlang':'rem' (_0,2) in call 'erlang':'=:=' (_1,0) of <Try> -> Try catch <T,R> -> 'false' -> let <_2> = call 'erlang':'div' (N,2) in let <P> = apply 'make_zeros'/1 (_2) in [P|P]
<N> when 'true' -> let <_4> = call 'erlang':'div' (N,2) in let <P> = apply 'make_zeros'/1 (_4) in [0|[P|P]] end
'my_buddy'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'-' (_0,_2) in case call 'erlang':'band' (_3,_1) of <0> when 'true' -> let <_4> = call 'erlang':'+' (_0,_1) in {_4,_0}
<_10> when 'true' -> let <T> = call 'erlang':'-' (_0,_1) in {T,T} end
'all_free'/1 = fun (_0) -> let <Tab> = apply 'get_freelists'/1 (_0) in (case _0 of (<({'head',_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_34,_35,_rec51}-|['compiler_generated'] )> when 'true' -> let <_5> = apply 'all'/1 (Tab) in case apply 'all_free'/4 (_5,_rec51,_rec51,[]) of <[{_37,_38}|L]> when let <_39> = call 'erlang':'=:=' (_37,_rec51) in let <_40> = call 'erlang':'=:=' (_38,_rec51) in call 'erlang':'and' (_39,_40) -> L
<L> when 'true' -> L end-|['compiler_generated'] )
(<_36> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'all_free'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],X0,Y0,F> when 'true' -> call 'lists':'reverse' ([{X0,Y0}|F])
<[{X,Y}|L],X0,Y0,F> when call 'erlang':'=:=' (Y0,X) -> apply 'all_free'/4 (L,X0,Y,F)
<[{X,Y}|L],X0,Y0,F> when call 'erlang':'<' (Y0,X) -> apply 'all_free'/4 (L,X,Y,[{X0,Y0}|F])
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'all_free',4}}] )-|['compiler_generated'] ) end
'all_allocated'/1 = fun (_0) -> let <_3> = apply 'get_freelists'/1 (_0) in let <_4> = apply 'all'/1 (_3) in (case _0 of (<({'head',_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_rec52}-|['compiler_generated'] )> when 'true' -> apply 'all_allocated'/4 (_4,0,_rec52,[])-|['compiler_generated'] )
(<_34> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'all_allocated'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],_X_X0,_X_Y0,[]> when 'true' -> #{}#
<[],_X_X0,_X_Y0,A0> when 'true' -> case call 'lists':'reverse' (A0) of <[#{#<From>(32,1,'integer',['unsigned'|['big']]),#<To>(32,1,'integer',['unsigned'|['big']])}#|A]> when 'true' -> let <_5> = call 'erlang':'list_to_binary' (A) in {From,To,_5}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<[{X,Y}|L],X0,Y0,A> when call 'erlang':'=:=' (Y0,X) -> apply 'all_allocated'/4 (L,X0,Y,A)
<[{X,Y}|L],_X_X0,Y0,A> when call 'erlang':'<' (Y0,X) -> let <_6> = #{#<Y0>(32,1,'integer',['unsigned'|['big']]),#<X>(32,1,'integer',['unsigned'|['big']])}# in apply 'all_allocated'/4 (L,X,Y,[_6|A])
(<_10,_9,_8,_7> when 'true' -> (primop 'match_fail' ({'function_clause',_10,_9,_8,_7})-|[{'function_name',{'all_allocated',4}}] )-|['compiler_generated'] ) end
'all_allocated_as_list'/1 = fun (_0) -> let <_3> = apply 'get_freelists'/1 (_0) in let <_4> = apply 'all'/1 (_3) in (case _0 of (<({'head',_6,_7,_8,_9,_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,_30,_31,_32,_33,_rec53}-|['compiler_generated'] )> when 'true' -> apply 'all_allocated_as_list'/4 (_4,0,_rec53,[])-|['compiler_generated'] )
(<_34> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','head'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'all_allocated_as_list'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],_X_X0,_X_Y0,[]> when 'true' -> []
<[],_X_X0,_X_Y0,A> when 'true' -> call 'lists':'reverse' (A)
<[{X,Y}|L],X0,Y0,A> when call 'erlang':'=:=' (Y0,X) -> apply 'all_allocated_as_list'/4 (L,X0,Y,A)
<[{X,Y}|L],_X_X0,Y0,A> when call 'erlang':'<' (Y0,X) -> apply 'all_allocated_as_list'/4 (L,X,Y,[[Y0|X]|A])
(<_7,_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_7,_6,_5,_4})-|[{'function_name',{'all_allocated_as_list',4}}] )-|['compiler_generated'] ) end
'all'/1 = fun (_0) -> let <_1> = call 'erlang':'tuple_size' (_0) in apply 'all'/3 (_0,_1,[])
'all'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_Tab,0,L> when 'true' -> call 'lists':'sort' (L)
<Tab,I,L> when 'true' -> let <_3> = call 'erlang':'element' (I,Tab) in let <LL> = apply 'collect_tree'/3 (_3,I,L) in let <_5> = call 'erlang':'-' (I,1) in apply 'all'/3 (Tab,_5,LL) end
'find_allocated'/4 = fun (_0,_1,_2,_3) -> let <MaxAddr> = call 'erlang':'+' (_1,_2) in let <Ints> = apply 'collect_all_interval'/4 (_0,_1,MaxAddr,_3) in apply 'allocated'/5 (Ints,_1,MaxAddr,_0,_3)
'allocated'/5 = fun (_0,_1,_2,_3,_4) -> case apply 'allocated1'/4 (_0,_1,_2,[]) of <[]> when 'true' -> case apply 'find_next_allocated'/3 (_3,_1,_4) of <{From,_13}> when 'true' -> apply 'find_allocated'/4 (_3,From,8192,_4)
<'none'> when 'true' -> #{}#
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<L> when 'true' -> let <_6> = call 'lists':'reverse' (L) in call 'erlang':'list_to_binary' (_6) end
'allocated1'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],Y0,Max,A> when call 'erlang':'<' (Y0,Max) -> let <_4> = #{#<Y0>(32,1,'integer',['unsigned'|['big']]),#<Max>(32,1,'integer',['unsigned'|['big']])}# in [_4|A]
<[],_X_Y0,_X_Max,A> when 'true' -> A
<[{X,Y}|L],Y0,Max,A> when call 'erlang':'>=' (Y0,X) -> apply 'allocated1'/4 (L,Y,Max,A)
<[{X,Y}|L],Y0,Max,A> when 'true' -> let <_5> = #{#<Y0>(32,1,'integer',['unsigned'|['big']]),#<X>(32,1,'integer',['unsigned'|['big']])}# in apply 'allocated1'/4 (L,Y,Max,[_5|A])
(<_9,_8,_7,_6> when 'true' -> (primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|[{'function_name',{'allocated1',4}}] )-|['compiler_generated'] ) end
'find_next_allocated'/3 = fun (_0,_1,_2) -> case apply 'find_next_free'/3 (_0,_1,_2) of <'none'> when 'true' -> 'none'
<{Addr1,Pos}> when call 'erlang':'=<' (Addr1,_1) -> let <_3> = call 'erlang':'-' (Pos,1) in let <_4> = call 'erlang':'bsl' (1,_3) in let <_5> = call 'erlang':'+' (Addr1,_4) in apply 'find_next_allocated'/3 (_0,_5,_2)
<{Next,_X_Pos}> when 'true' -> {_1,Next}
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
'find_next_free'/3 = fun (_0,_1,_2) -> let <MaxBud> = call 'erlang':'tuple_size' (_0) in apply 'find_next_free'/7 (_0,_1,1,MaxBud,-1,-1,_2)
'find_next_free'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <Ftab,Addr0,Pos,MaxBud,Next,PosN,Base> when call 'erlang':'=<' (Pos,MaxBud) -> (let <_30> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (Pos,(1-|['compiler_generated'] )) in (let <Pow> = call ('erlang'-|['compiler_generated'] ):('bsl'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_30) in (let <_31> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (Addr0,Base) in (let <Rem> = call ('erlang'-|['compiler_generated'] ):('rem'-|['compiler_generated'] ) (_31,Pow) in let <Addr> = case <> of (<> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (Rem,(0-|['compiler_generated'] ))-|['compiler_generated'] ) -> Addr0-|['compiler_generated'] )
(<> when (call ('erlang'-|['compiler_generated'] ):('<'-|['compiler_generated'] ) (Addr0,Pow)-|['compiler_generated'] ) -> Addr0-|['compiler_generated'] )
(<> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (Addr0,Rem)-|['compiler_generated'] )-|['compiler_generated'] ) end in let <PosTab> = call 'erlang':'element' (Pos,Ftab) in let <_9> = call 'erlang':'-' (Addr,1) in case apply 'bplus_lookup_next'/2 (PosTab,_9) of <'undefined'> when 'true' -> let <_10> = call 'erlang':'+' (Pos,1) in apply 'find_next_free'/7 (Ftab,Addr0,_10,MaxBud,Next,PosN,Base)
<{'ok',Next1}> when let <_12> = call 'erlang':'=:=' (PosN,-1) in let <_13> = call 'erlang':'<' (Next1,Next) in call 'erlang':'or' (_12,_13) -> let <_14> = call 'erlang':'+' (Pos,1) in apply 'find_next_free'/7 (Ftab,Addr0,_14,MaxBud,Next1,Pos,Base)
<{'ok',_24}> when 'true' -> let <_15> = call 'erlang':'+' (Pos,1) in apply 'find_next_free'/7 (Ftab,Addr0,_15,MaxBud,Next,PosN,Base)
(<_16> when 'true' -> primop 'match_fail' ({'case_clause',_16})-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
<_X_Ftab,_X_Addr,_X_Pos,_X_MaxBud,-1,_X_PosN,_X_Base> when 'true' -> 'none'
<_X_Ftab,_X_Addr,_X_Pos,_X_MaxBud,Next,PosN,_X_Base> when 'true' -> {Next,PosN} end
'collect_all_interval'/4 = fun (_0,_1,_2,_3) -> let <MaxBud> = call 'erlang':'tuple_size' (_0) in apply 'collect_all_interval'/7 (_0,_1,_2,1,MaxBud,_3,[])
'collect_all_interval'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <Ftab,L0,U,Pos,MaxBud,Base,Acc0> when call 'erlang':'=<' (Pos,MaxBud) -> let <PosTab> = call 'erlang':'element' (Pos,Ftab) in (let <_23> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (Pos,(1-|['compiler_generated'] )) in (let <Pow> = call ('erlang'-|['compiler_generated'] ):('bsl'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_23) in (let <_24> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (L0,Base) in (let <Rem> = call ('erlang'-|['compiler_generated'] ):('rem'-|['compiler_generated'] ) (_24,Pow) in let <L> = case <> of (<> when (call ('erlang'-|['compiler_generated'] ):('=:='-|['compiler_generated'] ) (Rem,(0-|['compiler_generated'] ))-|['compiler_generated'] ) -> L0-|['compiler_generated'] )
(<> when (call ('erlang'-|['compiler_generated'] ):('<'-|['compiler_generated'] ) (L0,Pow)-|['compiler_generated'] ) -> L0-|['compiler_generated'] )
(<> when ('true'-|['compiler_generated'] ) -> (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (L0,Rem)-|['compiler_generated'] )-|['compiler_generated'] ) end in let <Acc> = apply 'collect_interval'/5 (PosTab,Pos,L,U,Acc0) in let <_10> = call 'erlang':'+' (Pos,1) in apply 'collect_all_interval'/7 (Ftab,L0,U,_10,MaxBud,Base,Acc)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
<_X_Ftab,_X_L,_X_U,_X_Pos,_X_MaxBud,_X_Base,Acc> when 'true' -> call 'lists':'sort' (Acc) end
'adjust_addr'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'-' (_1,1) in let <Pow> = call 'erlang':'bsl' (1,_3) in let <_5> = call 'erlang':'-' (_0,_2) in let <Rem> = call 'erlang':'rem' (_5,Pow) in case <> of <> when call 'erlang':'=:=' (Rem,0) -> _0
<> when call 'erlang':'<' (_0,Pow) -> _0
<> when 'true' -> call 'erlang':'-' (_0,Rem) end
'get_disk_map'/0 = fun () -> case call 'erlang':'get' ('disk_map') of <'undefined'> when 'true' -> 'no_disk_map'
<T> when 'true' -> let <_0> = call 'ets':'tab2list' (T) in {'disk_map',_0} end
'init_disk_map'/1 = fun (_0) -> do call 'error_logger':'info_msg' ([42|[42|[32|[100|[101|[116|[115|[58|[32|[40|[100|[101|[98|[117|[103|[41|[32|[117|[115|[105|[110|[103|[32|[100|[105|[115|[107|[32|[109|[97|[112|[32|[102|[111|[114|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_0|[]]) let <_1> = call 'ets':'new' ('any',['ordered_set']) in call 'erlang':'put' ('disk_map',_1)
'stop_disk_map'/0 = fun () -> catch let <_0> = call 'erlang':'erase' ('disk_map') in call 'ets':'delete' (_0)
'disk_map_segment_p'/2 = fun (_0,_1) -> case call 'erlang':'get' ('disk_map') of <'undefined'> when 'true' -> 'ok'
<_X_T> when 'true' -> let <_3> = apply 'pread_n'/3 (_0,_1,2048) in apply 'disk_map_segment'/2 (_1,_3) end
'disk_map_segment'/2 = fun (_0,_1) -> case call 'erlang':'get' ('disk_map') of <'undefined'> when 'true' -> 'ok'
<T> when 'true' -> let <_2> = call 'erlang':'iolist_to_binary' (_1) in let <Ps> = apply 'segment_fragment_to_pointers'/2 (_0,_2) in let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{_X_P1,#{#<Sz>(32,1,'integer',['unsigned'|['big']]),#<X>(32,1,'integer',['unsigned'|['big']])}#}|_5]> when call 'erlang':'>' (X,0) -> let <_7> = #{#<Sz>(32,1,'integer',['unsigned'|['big']]),#<305419896>(32,1,'integer',['unsigned'|['big']])}# in let <_8> = apply 'lc$^0'/1 (_5) in ([{X,_7}|_8]-|['compiler_generated'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_15> when 'true' -> (primop 'match_fail' ({'function_clause',_15})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Ps) in let <_11> = call 'erlang':'++' (Ps,_9) in apply 'dm'/2 (_11,T) end
'disk_map_pread'/1 = fun (_0) -> case call 'erlang':'get' ('disk_map') of <'undefined'> when 'true' -> 'ok'
<T> when 'true' -> case call 'ets':'lookup' (T,_0) of <[]> when 'true' -> call 'erlang':'throw' ({'pread',_0,8})
<[{_5,{'pointer',0,0}}|[]]> when call 'erlang':'=:=' (_5,_0) -> 'ok'
<[{_6,{'pointer',Pointer,Sz}}|[]]> when call 'erlang':'=:=' (_6,_0) -> case call 'ets':'lookup' (T,Pointer) of <[{_7,{'slot',_X_P,_8}}|[]]> when let <_9> = call 'erlang':'=:=' (_7,Pointer) in let <_10> = call 'erlang':'=:=' (_8,Sz) in call 'erlang':'and' (_9,_10) -> 'ok'
<Got> when 'true' -> call 'erlang':'throw' ({'pread',_0,Pointer,Got}) end
<Got> when 'true' -> call 'erlang':'throw' ({'pread',_0,Got}) end end
'disk_map'/1 = fun (_0) -> case call 'erlang':'get' ('disk_map') of <'undefined'> when 'true' -> 'ok'
<T> when 'true' -> let <_6> = letrec 'lc$^0'/1 = fun (_3) -> case _3 of <[{P,Io}|_2]> when 'true' -> let <_4> = call 'erlang':'iolist_to_binary' (Io) in let <_5> = apply 'lc$^0'/1 (_2) in ([{P,_4}|_5]-|['compiler_generated'] )
(<[_1|_2]> when 'true' -> apply 'lc$^0'/1 (_2)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> (primop 'match_fail' ({'function_clause',_10})-|[{'function_name',{'lc$^0',1}}] )-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in apply 'dm'/2 (_6,T) end
'dm'/2 = fun (_0,_1) -> case <_0,_1> of <[{P,_X_Header}|Bs],T> when call 'erlang':'<' (P,1336) -> apply 'dm'/2 (Bs,T)
<[{P0,#{#<61591023>(32,1,'integer',['unsigned'|['big']])}#}|Bs],T> when 'true' -> let <P> = call 'erlang':'-' (P0,4) in do case call 'ets':'lookup' (T,P) of <[]> when 'true' -> call 'erlang':'throw' ({'free',P0})
<[{_34,_X_OldSz}|[]]> when call 'erlang':'=:=' (_34,P) -> case call 'ets':'delete' (T,P) of <'true'> when 'true' -> 'ok'
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end apply 'dm'/2 (Bs,T)
<[{SlotP,#{#<Sz>(32,1,'integer',['unsigned'|['big']]),#<305419896>(32,1,'integer',['unsigned'|['big']]),#<_36>('all',8,'binary',['unsigned'|['big']])}#}|Bs],T> when 'true' -> case call 'ets':'lookup' (T,{'pointer',SlotP}) of <[{{'pointer',_37},Pointer}|[]]> when call 'erlang':'=:=' (_37,SlotP) -> case call 'ets':'lookup' (T,Pointer) of <[{_38,{'pointer',_39,Sz2}}|[]]> when let <_40> = call 'erlang':'=:=' (_38,Pointer) in let <_41> = call 'erlang':'=:=' (_39,SlotP) in call 'erlang':'and' (_40,_41) -> let <_6> = apply 'log2'/1 (Sz) in let <_5> = apply 'log2'/1 (Sz2) in case <> of <> when call 'erlang':'=:=' (_6,_5) -> case call 'ets':'insert' (T,{SlotP,{'slot',Pointer,Sz}}) of <'true'> when 'true' -> apply 'dm'/2 (Bs,T)
(<_12> when 'true' -> primop 'match_fail' ({'badmatch',_12})-|['compiler_generated'] ) end
<> when 'true' -> call 'erlang':'throw' ({'active',SlotP,Sz,Pointer,Sz2}) end
<Got> when 'true' -> call 'erlang':'throw' ({'active',SlotP,Sz,Got}) end
<[]> when 'true' -> call 'erlang':'throw' ({'active',SlotP,Sz})
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<[{P,#{#<Sz>(32,1,'integer',['unsigned'|['big']]),#<X>(32,1,'integer',['unsigned'|['big']])}#}|Bs],T> when 'true' -> do case apply 'prev'/2 (P,T) of <{Prev,PrevSz}> when 'true' -> call 'erlang':'throw' ({'prev',P,Sz,X,Prev,PrevSz})
<'ok'> when 'true' -> 'ok'
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end do case apply 'next'/3 (P,8,T) of <{'next',Next}> when 'true' -> call 'erlang':'throw' ({'next',P,Sz,X,Next})
<'ok'> when 'true' -> 'ok'
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end case call 'ets':'insert' (T,{P,{'pointer',X,Sz}}) of <'true'> when 'true' -> do case <> of <> when call 'erlang':'=:=' (Sz,0) -> case <> of <> when call 'erlang':'=:=' ((0-|['compiler_generated'] ),X) -> 'ok'
(<> when 'true' -> primop 'match_fail' ({'badmatch',0})-|['compiler_generated'] ) end
<> when 'true' -> case call 'ets':'insert' (T,{{'pointer',X},P}) of <'true'> when 'true' -> 'ok'
(<_17> when 'true' -> primop 'match_fail' ({'badmatch',_17})-|['compiler_generated'] ) end end apply 'dm'/2 (Bs,T)
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<[{P,#{#<X>(32,1,'integer',['unsigned'|['big']])}#}|Bs],T> when 'true' -> do case call 'ets':'lookup' (T,X) of <[]> when 'true' -> call 'erlang':'throw' ({'segment',P,X})
<[{_44,{'pointer',0,0}}|[]]> when call 'erlang':'=:=' (_44,X) -> 'ok'
<[{_45,{'pointer',_46,_47}}|[]]> when let <_50> = call 'erlang':'=:=' (_45,X) in let <_48> = call 'erlang':'=:=' (_46,P) in let <_49> = call 'erlang':'=:=' (_47,X) in let <_51> = call 'erlang':'and' (_48,_49) in call 'erlang':'and' (_50,_51) -> 'ok'
(<_18> when 'true' -> primop 'match_fail' ({'case_clause',_18})-|['compiler_generated'] ) end apply 'dm'/2 (Bs,T)
<[{P,B = #{#<_X_Sz>(32,1,'integer',['unsigned'|['big']]),#<B0>('all',8,'binary',['unsigned'|['big']])}#}|Bs],T> when 'true' -> let <_19> = catch call 'erlang':'binary_to_term' (B0) in let <_24> = case _19 of <{'EXIT',_52}> when 'true' -> case B0 of <#{#<_X_Sz1>(32,1,'integer',['unsigned'|['big']]),#<B1>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_21> = catch call 'erlang':'binary_to_term' (B1) in case _21 of <{'EXIT',_53}> when 'true' -> 'false'
<_54> when 'true' -> 'true' end
(<_20> when 'true' -> primop 'match_fail' ({'badmatch',_20})-|['compiler_generated'] ) end
<_55> when 'true' -> 'true' end in case <> of <> when (call 'erlang':'=:=' (_24,'true')-|['compiler_generated'] ) -> let <_29> = call 'erlang':'-' (P,8) in let <_26> = call 'erlang':'byte_size' (B) in let <_27> = call 'erlang':'+' (_26,8) in let <_28> = #{#<_27>(32,1,'integer',['unsigned'|['big']]),#<305419896>(32,1,'integer',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}# in apply 'dm'/2 ([{_29,_28}|Bs],T)
<> when 'true' -> let <_30> = apply 'segment_fragment_to_pointers'/2 (P,B) in let <_31> = call 'erlang':'++' (_30,Bs) in apply 'dm'/2 (_31,T) end
<[],_X_T> when 'true' -> 'ok'
(<_33,_32> when 'true' -> (primop 'match_fail' ({'function_clause',_33,_32})-|[{'function_name',{'dm',2}}] )-|['compiler_generated'] ) end
'segment_fragment_to_pointers'/2 = fun (_0,_1) -> case <_0,_1> of <_X_P,#{}#> when 'true' -> []
<P,#{#<SzP>(8,8,'binary',['unsigned'|['big']]),#<B>('all',8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_2> = call 'erlang':'+' (P,8) in let <_3> = apply 'segment_fragment_to_pointers'/2 (_2,B) in [{P,SzP}|_3]
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'segment_fragment_to_pointers',2}}] )-|['compiler_generated'] ) end
'prev'/2 = fun (_0,_1) -> case call 'ets':'prev' (_1,_0) of <'$end_of_table'> when 'true' -> 'ok'
<Prev> when 'true' -> case call 'ets':'lookup' (_1,Prev) of <[{_8,{'pointer',_X_Ptr,_9}}|[]]> when let <_10> = call 'erlang':'=:=' (_8,Prev) in let <_11> = try let <_2> = call 'erlang':'+' (Prev,8) in call 'erlang':'>' (_2,_0) of <Try> -> Try catch <T,R> -> 'false' in call 'erlang':'and' (_10,_11) -> {Prev,8}
<[{_12,{'slot',_13,Sz}}|[]]> when let <_14> = call 'erlang':'=:=' (_12,Prev) in let <_15> = try let <_3> = call 'erlang':'+' (Prev,Sz) in call 'erlang':'>' (_3,_0) of <Try> -> Try catch <T,R> -> 'false' in call 'erlang':'and' (_14,_15) -> {Prev,Sz}
<_16> when 'true' -> 'ok' end end
'next'/3 = fun (_0,_1,_2) -> case call 'ets':'next' (_2,_0) of <'$end_of_table'> when 'true' -> 'ok'
<Next> when try let <_3> = call 'erlang':'+' (_0,_1) in call 'erlang':'>' (_3,Next) of <Try> -> Try catch <T,R> -> 'false' -> {'next',Next}
<_8> when 'true' -> 'ok' end
'collect_tree'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <'v',_X_TI,Acc> when 'true' -> Acc
<T,TI,Acc> when 'true' -> let <_3> = call 'erlang':'-' (TI,1) in let <Pow> = call 'erlang':'bsl' (1,_3) in apply 'collect_tree2'/3 (T,Pow,Acc) end
'collect_tree2'/3 = fun (_0,_1,_2) -> let <S> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_10> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_10,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_11> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_11,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case call 'erlang':'element' (1,_0) of <'l'> when 'true' -> apply 'collect_leaf'/4 (_0,S,_1,_2)
<'n'> when 'true' -> apply 'collect_node'/4 (_0,S,_1,_2)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end
'collect_leaf'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_Leaf,0,_X_Pow,Acc> when 'true' -> Acc
<Leaf,I,Pow,Acc> when 'true' -> let <_4> = call 'erlang':'+' (I,1) in let <Key> = call 'erlang':'element' (_4,Leaf) in let <_6> = call 'erlang':'+' (Key,Pow) in let <V> = {Key,_6} in let <_8> = call 'erlang':'-' (I,1) in apply 'collect_leaf'/4 (Leaf,_8,Pow,[V|Acc]) end
'collect_node'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <_X_Node,0,_X_Pow,Acc> when 'true' -> Acc
<Node,I,Pow,Acc> when 'true' -> (let <_13> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (I,(2-|['compiler_generated'] )) in let <_4> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_13,Node) in let <Acc1> = apply 'collect_tree2'/3 (_4,Pow,Acc) in let <_6> = call 'erlang':'-' (I,1) in apply 'collect_node'/4 (Node,_6,Pow,Acc1)-|['compiler_generated'] ) end
'tree_to_bin'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <'v',_X_F,_X_Max,Ws,WsSz> when 'true' -> {Ws,WsSz}
<T,F,Max,Ws,WsSz> when 'true' -> case apply 'tree_to_bin2'/7 (T,F,Max,0,[],Ws,WsSz) of <{N,L1,Ws1,WsSz1}> when 'true' -> let <_6> = call 'lists':'reverse' (L1) in case apply F (N,_6,Ws1,WsSz1) of <{N1,L2,Ws2,WsSz2}> when 'true' -> case apply F (N1,L2,Ws2,WsSz2) of <{0,[],NWs,NWsSz}> when 'true' -> {NWs,NWsSz}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end end
'tree_to_bin2'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <Tree,F,Max,N,Acc,Ws,WsSz> when call 'erlang':'>=' (N,Max) -> let <_7> = call 'lists':'reverse' (Acc) in case apply F (N,_7,Ws,WsSz) of <{NN,NAcc,NWs,NWsSz}> when 'true' -> let <_9> = call 'lists':'reverse' (NAcc) in apply 'tree_to_bin2'/7 (Tree,F,Max,NN,_9,NWs,NWsSz)
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<Tree,F,Max,N,Acc,Ws,WsSz> when 'true' -> let <S> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),Tree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_24> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_24,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_25> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_25,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_26> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_26}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case call 'erlang':'element' (1,Tree) of <'l'> when 'true' -> let <_13> = call 'erlang':'+' (N,S) in let <_11> = apply 'bplus_leaf_to_list'/1 (Tree) in let <_12> = apply 'leaf_to_bin'/2 (_11,Acc) in {_13,_12,Ws,WsSz}
<'n'> when 'true' -> apply 'node_to_bin'/9 (Tree,F,Max,N,Acc,1,S,Ws,WsSz)
(<_14> when 'true' -> primop 'match_fail' ({'case_clause',_14})-|['compiler_generated'] ) end end
'node_to_bin'/9 = fun (_0,_1,_2,_3,_4,_5,_6,_7,_8) -> case <_0,_1,_2,_3,_4,_5,_6,_7,_8> of <_X_Node,_X_F,_X_Max,N,Acc,I,S,Ws,WsSz> when call 'erlang':'>' (I,S) -> {N,Acc,Ws,WsSz}
<Node,F,Max,N,Acc,I,S,Ws,WsSz> when 'true' -> (let <_23> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (I,(2-|['compiler_generated'] )) in let <_9> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_23,Node) in case apply 'tree_to_bin2'/7 (_9,F,Max,N,Acc,Ws,WsSz) of <{N1,Acc1,Ws1,WsSz1}> when 'true' -> let <_11> = call 'erlang':'+' (I,1) in apply 'node_to_bin'/9 (Node,F,Max,N1,Acc1,_11,S,Ws1,WsSz1)
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end-|['compiler_generated'] ) end
'leaf_to_bin'/2 = fun (_0,_1) -> case <_0,_1> of <[N|L],Acc> when 'true' -> let <_2> = #{#<N>(32,1,'integer',['unsigned'|['big']])}# in apply 'leaf_to_bin'/2 (L,[_2|Acc])
<[],Acc> when 'true' -> Acc
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'leaf_to_bin',2}}] )-|['compiler_generated'] ) end
'list_to_tree'/1 = fun (_0) -> let <_2> = call 'erlang':'length' (_0) in let <_1> = 'bplus_mk_leaf'/1 in apply 'leafs_to_nodes'/4 (_0,_2,_1,[])
'leafs_to_nodes'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <[],0,_X_F,[T|[]]> when 'true' -> T
<[],0,_X_F,L> when 'true' -> let <_6> = call 'lists':'reverse' (L) in let <_5> = call 'erlang':'length' (L) in let <_4> = 'mk_node'/1 in apply 'leafs_to_nodes'/4 (_6,_5,_4,[])
<Ls,Sz,F,L> when 'true' -> let <_7> = case <> of <> when call 'erlang':'=<' (Sz,16) -> Sz
<> when call 'erlang':'=<' (Sz,32) -> call 'erlang':'div' (Sz,2)
<> when 'true' -> 12 end in case apply 'split_list'/3 (Ls,_7,[]) of <{L1,R}> when 'true' -> let <N> = apply F (L1) in let <Sz1> = call 'erlang':'-' (Sz,_7) in apply 'leafs_to_nodes'/4 (R,Sz1,F,[N|L])
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end end
'mk_node'/1 = fun (_0) -> case _0 of <[E|Es]> when 'true' -> let <_6> = fun (_3,_2) -> let <_1> = apply 'get_first_key'/1 (_3) in [_1|[_3|_2]] in let <_7> = call 'lists':'foldr' (_6,[],Es) in let <NL> = [E|_7] in apply 'bplus_mk_node'/1 (NL)
(<_9> when 'true' -> (primop 'match_fail' ({'function_clause',_9})-|[{'function_name',{'mk_node',1}}] )-|['compiler_generated'] ) end
'split_list'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <L,0,SL> when 'true' -> {SL,L}
<[E|Es],I,SL> when 'true' -> let <_3> = call 'erlang':'-' (I,1) in apply 'split_list'/3 (Es,_3,[E|SL])
(<_6,_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_6,_5,_4})-|[{'function_name',{'split_list',3}}] )-|['compiler_generated'] ) end
'get_first_key'/1 = fun (_0) -> case call 'erlang':'element' (1,_0) of <'l'> when 'true' -> call 'erlang':'element' (2,_0)
<'n'> when 'true' -> let <_9> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((2-|['compiler_generated'] ),_0) in apply 'get_first_key'/1 (_9)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'collect_interval'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <'v',_X_TI,_X_L,_X_U,Acc> when 'true' -> Acc
<T,TI,L,U,Acc> when 'true' -> let <_5> = call 'erlang':'-' (TI,1) in let <Pow> = call 'erlang':'bsl' (1,_5) in apply 'collect_interval2'/5 (T,Pow,L,U,Acc) end
'collect_interval2'/5 = fun (_0,_1,_2,_3,_4) -> let <S> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_18> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_18,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_19> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_19,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_20> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_20}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case call 'erlang':'element' (1,_0) of <'l'> when 'true' -> apply 'collect_leaf_interval'/6 (_0,S,_1,_2,_3,_4)
<'n'> when 'true' -> case apply 'bplus_select_sub_tree'/2 (_0,_3) of <{Max,_14}> when 'true' -> case apply 'bplus_select_sub_tree_2'/3 (_0,_2,Max) of <{Min,_15}> when 'true' -> apply 'collect_node_interval'/7 (_0,Min,Max,_1,_2,_3,_4)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
'collect_leaf_interval'/6 = fun (_0,_1,_2,_3,_4,_5) -> case <_0,_1,_2,_3,_4,_5> of <_X_Leaf,0,_X_Pow,_X_L,_X_U,Acc> when 'true' -> Acc
<Leaf,I,Pow,L,U,Acc> when 'true' -> let <_6> = call 'erlang':'+' (I,1) in let <Key> = call 'erlang':'element' (_6,Leaf) in case <> of <> when call 'erlang':'<' (Key,L) -> Acc
<> when call 'erlang':'>' (Key,U) -> let <_8> = call 'erlang':'-' (I,1) in apply 'collect_leaf_interval'/6 (Leaf,_8,Pow,L,U,Acc)
<> when 'true' -> let <_10> = call 'erlang':'-' (I,1) in let <_9> = call 'erlang':'+' (Key,Pow) in apply 'collect_leaf_interval'/6 (Leaf,_10,Pow,L,U,[{Key,_9}|Acc]) end end
'collect_node_interval'/7 = fun (_0,_1,_2,_3,_4,_5,_6) -> case <_0,_1,_2,_3,_4,_5,_6> of <_X_Node,I,UP,_X_Pow,_X_L,_X_U,Acc> when call 'erlang':'>' (I,UP) -> Acc
<Node,I,UP,Pow,L,U,Acc> when 'true' -> (let <_19> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (I,(2-|['compiler_generated'] )) in let <_7> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_19,Node) in let <Acc1> = apply 'collect_interval2'/5 (_7,Pow,L,U,Acc) in let <_9> = call 'erlang':'+' (I,1) in apply 'collect_node_interval'/7 (Node,_9,UP,Pow,L,U,Acc1)-|['compiler_generated'] ) end
'bplus_empty_tree'/0 = fun () -> 'v'
'bplus_lookup'/2 = fun (_0,_1) -> case <_0,_1> of <'v',_X_Key> when 'true' -> 'undefined'
<Tree,Key> when 'true' -> case call 'erlang':'element' (1,Tree) of <'l'> when 'true' -> apply 'bplus_lookup_leaf'/2 (Key,Tree)
<'n'> when 'true' -> case apply 'bplus_select_sub_tree'/2 (Tree,Key) of <{_6,SubTree}> when 'true' -> apply 'bplus_lookup'/2 (SubTree,Key)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end end
'bplus_lookup_leaf'/2 = fun (_0,_1) -> let <_2> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_1)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_6> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_1) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_6,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_1) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'bplus_lookup_leaf_2'/3 (_0,_1,_2)
'bplus_lookup_leaf_2'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_9,_10,0> when 'true' -> 'undefined'
<Key,Leaf,N> when 'true' -> let <_3> = call 'erlang':'+' (N,1) in case call 'erlang':'element' (_3,Leaf) of <_11> when call 'erlang':'=:=' (_11,Key) -> {'ok',Key}
<_12> when 'true' -> let <_4> = call 'erlang':'-' (N,1) in apply 'bplus_lookup_leaf_2'/3 (Key,Leaf,_4) end end
'bplus_lookup_first'/1 = fun (_0) -> case _0 of <'v'> when 'true' -> 'undefined'
<Tree> when 'true' -> case call 'erlang':'element' (1,Tree) of <'l'> when 'true' -> let <_2> = call 'erlang':'element' (2,Tree) in {'ok',_2}
<'n'> when 'true' -> let <_3> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((2-|['compiler_generated'] ),Tree) in apply 'bplus_lookup_first'/1 (_3)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end end
'bplus_lookup_next'/2 = fun (_0,_1) -> case <_0,_1> of <'v',_10> when 'true' -> 'undefined'
<Tree,Key> when 'true' -> case call 'erlang':'element' (1,Tree) of <'l'> when 'true' -> apply 'lookup_next_leaf'/2 (Key,Tree)
<'n'> when 'true' -> case apply 'bplus_select_sub_tree'/2 (Tree,Key) of <{Pos,SubTree}> when 'true' -> case apply 'bplus_lookup_next'/2 (SubTree,Key) of <'undefined'> when 'true' -> let <S> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),Tree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_13> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_13,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>' (S,Pos) -> let <_4> = call 'erlang':'+' (Pos,1) in (let <_2> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_4,(2-|['compiler_generated'] )) in let <_5> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_2,Tree) in apply 'bplus_lookup_first'/1 (_5)-|['compiler_generated'] )
<> when 'true' -> 'undefined' end
<Result> when 'true' -> Result end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_7> when 'true' -> primop 'match_fail' ({'case_clause',_7})-|['compiler_generated'] ) end end
'lookup_next_leaf'/2 = fun (_0,_1) -> let <_2> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_1)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_6> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_1) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_6,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_1) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'lookup_next_leaf_2'/4 (_0,_1,_2,1)
'lookup_next_leaf_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Key,Leaf,Size,_20> when call 'erlang':'=:=' (_20,Size) -> let <_4> = call 'erlang':'+' (Size,1) in let <K> = call 'erlang':'element' (_4,Leaf) in case <> of <> when call 'erlang':'>' (K,Key) -> let <_6> = call 'erlang':'+' (Size,1) in let <_7> = call 'erlang':'element' (_6,Leaf) in {'ok',_7}
<> when 'true' -> 'undefined' end
<Key,Leaf,Size,N> when 'true' -> let <_8> = call 'erlang':'+' (N,1) in let <K> = call 'erlang':'element' (_8,Leaf) in case <> of <> when call 'erlang':'<' (K,Key) -> let <_10> = call 'erlang':'+' (N,1) in apply 'lookup_next_leaf_2'/4 (Key,Leaf,Size,_10)
<> when call 'erlang':'==' (Key,K) -> let <_11> = call 'erlang':'+' (N,1) in let <_12> = call 'erlang':'+' (_11,1) in let <_13> = call 'erlang':'element' (_12,Leaf) in {'ok',_13}
<> when 'true' -> let <_14> = call 'erlang':'+' (N,1) in let <_15> = call 'erlang':'element' (_14,Leaf) in {'ok',_15} end end
'bplus_insert'/2 = fun (_0,_1) -> case <_0,_1> of <'v',Key> when 'true' -> let <_10> = [Key|([]-|['compiler_generated'] )] in (call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|_10]-|['compiler_generated'] ))-|['compiler_generated'] )
<Tree,Key> when 'true' -> let <NewTree> = apply 'bplus_insert_in'/2 (Tree,Key) in let <_3> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),NewTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_14> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_14,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>' (_3,16) -> let <_5> = case call 'erlang':'element' (1,NewTree) of <'l'> when 'true' -> apply 'bplus_split_leaf'/1 (NewTree)
<'n'> when 'true' -> apply 'bplus_split_node'/1 (NewTree)
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in case _5 of <{LTree,DKey,RTree}> when 'true' -> apply 'bplus_mk_node'/1 ([LTree|[DKey|[RTree|[]]]])
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<> when 'true' -> NewTree end end
'bplus_delete'/2 = fun (_0,_1) -> case <_0,_1> of <'v',_X_Key> when 'true' -> 'v'
<Tree,Key> when 'true' -> let <NewTree> = apply 'bplus_delete_in'/2 (Tree,Key) in let <S> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),NewTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_9> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_9,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case call 'erlang':'element' (1,NewTree) of <'l'> when 'true' -> case <> of <> when call 'erlang':'=:=' (S,0) -> 'v'
<> when 'true' -> NewTree end
<'n'> when 'true' -> case <> of <> when call 'erlang':'=:=' (S,1) -> (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((2-|['compiler_generated'] ),NewTree)-|['compiler_generated'] )
<> when 'true' -> NewTree end
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end end
'bplus_insert_in'/2 = fun (_0,_1) -> case call 'erlang':'element' (1,_0) of <'l'> when 'true' -> apply 'bplus_insert_in_leaf'/2 (_0,_1)
<'n'> when 'true' -> case apply 'bplus_select_sub_tree'/2 (_0,_1) of <{Pos,SubTree}> when 'true' -> let <NewSubTree> = apply 'bplus_insert_in'/2 (SubTree,_1) in let <_4> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),NewSubTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_16> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewSubTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_16,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewSubTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>' (_4,16) -> case apply 'bplus_reorganize_tree_ins'/3 (_0,NewSubTree,Pos) of <{'left',{LeftT,DKey,MiddleT}}> when 'true' -> let <_6> = apply 'bplus_put_lkey'/3 (_0,DKey,Pos) in let <_5> = call 'erlang':'-' (Pos,1) in apply 'bplus_put_subtree'/2 (_6,[LeftT|[_5|[MiddleT|[Pos|[]]]]])
<{'right',{MiddleT,DKey,RightT}}> when 'true' -> let <_8> = apply 'bplus_put_rkey'/3 (_0,DKey,Pos) in let <_7> = call 'erlang':'+' (Pos,1) in apply 'bplus_put_subtree'/2 (_8,[MiddleT|[Pos|[RightT|[_7|[]]]]])
<{'split',_@r0 = {LeftT,DKey,RightT}}> when 'true' -> apply 'bplus_extend_tree'/3 (_0,_@r0,Pos)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<> when 'true' -> apply 'bplus_put_subtree'/2 (_0,[NewSubTree|[Pos|[]]]) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
'bplus_insert_in_leaf'/2 = fun (_0,_1) -> let <_2> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_6> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_6,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'bplus_insert_in_leaf_2'/4 (_0,_1,_2,[])
'bplus_insert_in_leaf_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Leaf,Key,0,Accum> when 'true' -> apply 'bplus_insert_in_leaf_3'/3 (Leaf,0,[Key|Accum])
<Leaf,Key,N,Accum> when 'true' -> let <_4> = call 'erlang':'+' (N,1) in let <K> = call 'erlang':'element' (_4,Leaf) in case <> of <> when call 'erlang':'<' (Key,K) -> let <_6> = call 'erlang':'-' (N,1) in apply 'bplus_insert_in_leaf_2'/4 (Leaf,Key,_6,[K|Accum])
<> when call 'erlang':'<' (K,Key) -> let <_7> = call 'erlang':'-' (N,1) in apply 'bplus_insert_in_leaf_3'/3 (Leaf,_7,[K|[Key|Accum]])
<> when call 'erlang':'==' (K,Key) -> let <_8> = call 'erlang':'-' (N,1) in apply 'bplus_insert_in_leaf_3'/3 (Leaf,_8,[Key|Accum])
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end end
'bplus_insert_in_leaf_3'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_Leaf,0,LeafList> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|LeafList]-|['compiler_generated'] ))-|['compiler_generated'] )
<Leaf,N,LeafList> when 'true' -> let <_5> = call 'erlang':'-' (N,1) in let <_3> = call 'erlang':'+' (N,1) in let <_4> = call 'erlang':'element' (_3,Leaf) in apply 'bplus_insert_in_leaf_3'/3 (Leaf,_5,[_4|LeafList]) end
'bplus_delete_in'/2 = fun (_0,_1) -> case call 'erlang':'element' (1,_0) of <'l'> when 'true' -> apply 'bplus_delete_in_leaf'/2 (_0,_1)
<'n'> when 'true' -> case apply 'bplus_select_sub_tree'/2 (_0,_1) of <{Pos,SubTree}> when 'true' -> let <NewSubTree> = apply 'bplus_delete_in'/2 (SubTree,_1) in let <_4> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),NewSubTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_16> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewSubTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_16,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (NewSubTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'<' (_4,8) -> case apply 'bplus_reorganize_tree_del'/3 (_0,NewSubTree,Pos) of <{'left',{LeftT,DKey,MiddleT}}> when 'true' -> let <_6> = apply 'bplus_put_lkey'/3 (_0,DKey,Pos) in let <_5> = call 'erlang':'-' (Pos,1) in apply 'bplus_put_subtree'/2 (_6,[LeftT|[_5|[MiddleT|[Pos|[]]]]])
<{'right',{MiddleT,DKey,RightT}}> when 'true' -> let <_8> = apply 'bplus_put_rkey'/3 (_0,DKey,Pos) in let <_7> = call 'erlang':'+' (Pos,1) in apply 'bplus_put_subtree'/2 (_8,[MiddleT|[Pos|[RightT|[_7|[]]]]])
<{'join_left',JoinedTree}> when 'true' -> apply 'bplus_joinleft_tree'/3 (_0,JoinedTree,Pos)
<{'join_right',JoinedTree}> when 'true' -> apply 'bplus_joinright_tree'/3 (_0,JoinedTree,Pos)
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end
<> when 'true' -> apply 'bplus_put_subtree'/2 (_0,[NewSubTree|[Pos|[]]]) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
'bplus_delete_in_leaf'/2 = fun (_0,_1) -> let <_2> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_6> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_6,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'bplus_delete_in_leaf_2'/4 (_0,_1,_2,[])
'bplus_delete_in_leaf_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Leaf,_12,0,_13> when 'true' -> Leaf
<Leaf,Key,N,Accum> when 'true' -> let <_4> = call 'erlang':'+' (N,1) in let <K> = call 'erlang':'element' (_4,Leaf) in case <> of <> when call 'erlang':'==' (Key,K) -> let <_6> = call 'erlang':'-' (N,1) in apply 'bplus_delete_in_leaf_3'/3 (Leaf,_6,Accum)
<> when 'true' -> let <_7> = call 'erlang':'-' (N,1) in apply 'bplus_delete_in_leaf_2'/4 (Leaf,Key,_7,[K|Accum]) end end
'bplus_delete_in_leaf_3'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_Leaf,0,LeafList> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|LeafList]-|['compiler_generated'] ))-|['compiler_generated'] )
<Leaf,N,LeafList> when 'true' -> let <_5> = call 'erlang':'-' (N,1) in let <_3> = call 'erlang':'+' (N,1) in let <_4> = call 'erlang':'element' (_3,Leaf) in apply 'bplus_delete_in_leaf_3'/3 (Leaf,_5,[_4|LeafList]) end
'bplus_select_sub_tree'/2 = fun (_0,_1) -> let <_2> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_7> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_7,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'bplus_select_sub_tree_2'/3 (_0,_1,_2)
'bplus_select_sub_tree_2'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Tree,_X_Key,1> when 'true' -> let <_3> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((2-|['compiler_generated'] ),Tree) in {1,_3}
<Tree,Key,N> when 'true' -> (let <_19> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in (let <_3> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_19,(1-|['compiler_generated'] )) in let <K> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_3,Tree) in case <> of <> when call 'erlang':'>' (K,Key) -> let <_5> = call 'erlang':'-' (N,1) in apply 'bplus_select_sub_tree_2'/3 (Tree,Key,_5)
<> when call 'erlang':'=<' (K,Key) -> (let <_25> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in let <_6> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_25,Tree) in {N,_6}-|['compiler_generated'] )
(<> when 'true' -> primop 'match_fail' ('if_clause')-|['compiler_generated'] ) end-|['compiler_generated'] )-|['compiler_generated'] ) end
'bplus_reorganize_tree_ins'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Tree,NewSubTree,1> when 'true' -> let <RTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((4-|['compiler_generated'] ),Tree) in let <_4> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),RTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_30> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_30,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_31> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_31,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>=' (_4,16) -> apply 'bplus_reorganize_tree_s'/1 (NewSubTree)
<> when 'true' -> apply 'bplus_reorganize_tree_r'/4 (Tree,NewSubTree,1,RTree) end
<Tree,NewSubTree,Pos> when 'true' -> let <Size> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),Tree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_35> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_35,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_36> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_36,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'==' (Pos,Size) -> let <_7> = call 'erlang':'-' (Pos,1) in (let <_42> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_7,(2-|['compiler_generated'] )) in let <LTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_42,Tree) in let <_9> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),LTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_47> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_47,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_48> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_48,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>=' (_9,16) -> apply 'bplus_reorganize_tree_s'/1 (NewSubTree)
<> when 'true' -> apply 'bplus_reorganize_tree_l'/4 (Tree,NewSubTree,Pos,LTree) end-|['compiler_generated'] )
<> when 'true' -> let <_11> = call 'erlang':'-' (Pos,1) in (let <_54> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_11,(2-|['compiler_generated'] )) in let <LTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_54,Tree) in let <_13> = call 'erlang':'+' (Pos,1) in (let <_61> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_13,(2-|['compiler_generated'] )) in let <RTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_61,Tree) in let <SL> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),LTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_66> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_66,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_67> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_67,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <SR> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),RTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_71> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_71,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_72> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_72,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>' (SL,SR) -> apply 'bplus_reorganize_tree_r'/4 (Tree,NewSubTree,Pos,RTree)
<> when call 'erlang':'<' (SL,SR) -> apply 'bplus_reorganize_tree_l'/4 (Tree,NewSubTree,Pos,LTree)
<> when 'true' -> let <_17> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),LTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_76> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_76,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_77> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_77,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>=' (_17,16) -> apply 'bplus_reorganize_tree_s'/1 (NewSubTree)
<> when 'true' -> apply 'bplus_reorganize_tree_l'/4 (Tree,NewSubTree,Pos,LTree) end end-|['compiler_generated'] )-|['compiler_generated'] ) end end
'bplus_reorganize_tree_del'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <Tree,NewSubTree,1> when 'true' -> let <RTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((4-|['compiler_generated'] ),Tree) in let <_4> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),RTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_30> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_30,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_31> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_31,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'=<' (_4,8) -> apply 'bplus_reorganize_tree_jr'/4 (Tree,NewSubTree,1,RTree)
<> when 'true' -> apply 'bplus_reorganize_tree_r'/4 (Tree,NewSubTree,1,RTree) end
<Tree,NewSubTree,Pos> when 'true' -> let <Size> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),Tree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_35> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_35,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_36> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (Tree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_36,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'==' (Pos,Size) -> let <_7> = call 'erlang':'-' (Pos,1) in (let <_42> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_7,(2-|['compiler_generated'] )) in let <LTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_42,Tree) in let <_9> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),LTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_47> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_47,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_48> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_48,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'=<' (_9,8) -> apply 'bplus_reorganize_tree_jl'/4 (Tree,NewSubTree,Pos,LTree)
<> when 'true' -> apply 'bplus_reorganize_tree_l'/4 (Tree,NewSubTree,Pos,LTree) end-|['compiler_generated'] )
<> when 'true' -> let <_11> = call 'erlang':'-' (Pos,1) in (let <_54> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_11,(2-|['compiler_generated'] )) in let <LTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_54,Tree) in let <_13> = call 'erlang':'+' (Pos,1) in (let <_61> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_13,(2-|['compiler_generated'] )) in let <RTree> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_61,Tree) in let <SL> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),LTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_66> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_66,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_67> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_67,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <SR> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),RTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_71> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_71,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_72> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (RTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_72,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'>' (SL,SR) -> apply 'bplus_reorganize_tree_l'/4 (Tree,NewSubTree,Pos,LTree)
<> when call 'erlang':'<' (SL,SR) -> apply 'bplus_reorganize_tree_r'/4 (Tree,NewSubTree,Pos,RTree)
<> when 'true' -> let <_17> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),LTree)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_76> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_76,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_77> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (LTree) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_77,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in case <> of <> when call 'erlang':'=<' (_17,8) -> apply 'bplus_reorganize_tree_jl'/4 (Tree,NewSubTree,Pos,LTree)
<> when 'true' -> apply 'bplus_reorganize_tree_l'/4 (Tree,NewSubTree,Pos,LTree) end end-|['compiler_generated'] )-|['compiler_generated'] ) end end
'bplus_reorganize_tree_l'/4 = fun (_0,_1,_2,_3) -> case call 'erlang':'element' (1,_1) of <'l'> when 'true' -> let <_5> = apply 'bplus_leaf_to_list'/1 (_3) in let <_4> = apply 'bplus_leaf_to_list'/1 (_1) in let <_6> = call 'lists':'append' (_5,_4) in let <_7> = call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|_6]-|['compiler_generated'] )) in let <_8> = apply 'bplus_split_leaf'/1 (_7) in {'left',_8}
<'n'> when 'true' -> let <_9> = apply 'bplus_node_to_list'/1 (_3) in (let <_26> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] )) in (let <_27> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_26,(1-|['compiler_generated'] )) in let <_10> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_27,_0) in let <_11> = apply 'bplus_node_to_list'/1 (_1) in let <_12> = call 'lists':'append' ([_9|[[_10|[]]|[_11|[]]]]) in let <_13> = apply 'bplus_mk_node'/1 (_12) in let <_14> = apply 'bplus_split_node'/1 (_13) in {'left',_14}-|['compiler_generated'] )-|['compiler_generated'] )
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
'bplus_reorganize_tree_r'/4 = fun (_0,_1,_2,_3) -> case call 'erlang':'element' (1,_1) of <'l'> when 'true' -> let <_4> = apply 'bplus_leaf_to_list'/1 (_1) in let <_5> = apply 'bplus_leaf_to_list'/1 (_3) in let <_6> = call 'lists':'append' ([_4|[_5|[]]]) in let <_7> = call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|_6]-|['compiler_generated'] )) in let <_8> = apply 'bplus_split_leaf'/1 (_7) in {'right',_8}
<'n'> when 'true' -> let <_9> = apply 'bplus_node_to_list'/1 (_1) in (let <_26> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] )) in (let <_27> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (_26,(1-|['compiler_generated'] )) in let <_10> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_27,_0) in let <_11> = apply 'bplus_node_to_list'/1 (_3) in let <_12> = call 'lists':'append' ([_9|[[_10|[]]|[_11|[]]]]) in let <_13> = apply 'bplus_mk_node'/1 (_12) in let <_14> = apply 'bplus_split_node'/1 (_13) in {'right',_14}-|['compiler_generated'] )-|['compiler_generated'] )
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end
'bplus_reorganize_tree_s'/1 = fun (_0) -> case call 'erlang':'element' (1,_0) of <'l'> when 'true' -> let <_1> = apply 'bplus_split_leaf'/1 (_0) in {'split',_1}
<'n'> when 'true' -> let <_2> = apply 'bplus_split_node'/1 (_0) in {'split',_2}
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'bplus_reorganize_tree_jl'/4 = fun (_0,_1,_2,_3) -> case call 'erlang':'element' (1,_1) of <'l'> when 'true' -> let <_4> = apply 'bplus_leaf_to_list'/1 (_3) in let <_5> = apply 'bplus_leaf_to_list'/1 (_1) in let <_6> = call 'lists':'append' ([_4|[_5|[]]]) in let <_7> = call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|_6]-|['compiler_generated'] )) in {'join_left',_7}
<'n'> when 'true' -> let <_8> = apply 'bplus_node_to_list'/1 (_3) in (let <_24> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] )) in (let <_25> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_24,(1-|['compiler_generated'] )) in let <_9> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_25,_0) in let <_10> = apply 'bplus_node_to_list'/1 (_1) in let <_11> = call 'lists':'append' ([_8|[[_9|[]]|[_10|[]]]]) in let <_12> = apply 'bplus_mk_node'/1 (_11) in {'join_left',_12}-|['compiler_generated'] )-|['compiler_generated'] )
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
'bplus_reorganize_tree_jr'/4 = fun (_0,_1,_2,_3) -> case call 'erlang':'element' (1,_1) of <'l'> when 'true' -> let <_4> = apply 'bplus_leaf_to_list'/1 (_1) in let <_5> = apply 'bplus_leaf_to_list'/1 (_3) in let <_6> = call 'lists':'append' ([_4|[_5|[]]]) in let <_7> = call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|_6]-|['compiler_generated'] )) in {'join_right',_7}
<'n'> when 'true' -> let <_8> = apply 'bplus_node_to_list'/1 (_1) in (let <_24> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] )) in (let <_25> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (_24,(1-|['compiler_generated'] )) in let <_9> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_25,_0) in let <_10> = apply 'bplus_node_to_list'/1 (_3) in let <_11> = call 'lists':'append' ([_8|[[_9|[]]|[_10|[]]]]) in let <_12> = apply 'bplus_mk_node'/1 (_11) in {'join_right',_12}-|['compiler_generated'] )-|['compiler_generated'] )
(<_13> when 'true' -> primop 'match_fail' ({'case_clause',_13})-|['compiler_generated'] ) end
'bplus_split_leaf'/1 = fun (_0) -> let <S> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_1> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_1,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_2> = call 'erlang':'div' (S,2) in apply 'bplus_split_leaf_2'/4 (_0,S,_2,[])
'bplus_split_leaf_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Leaf,Pos,1,Accum> when 'true' -> let <_4> = call 'erlang':'+' (Pos,1) in let <K> = call 'erlang':'element' (_4,Leaf) in let <_6> = call 'erlang':'-' (Pos,1) in apply 'bplus_split_leaf_3'/5 (Leaf,_6,[],K,[K|Accum])
<Leaf,Pos,N,Accum> when 'true' -> let <_10> = call 'erlang':'-' (Pos,1) in let <_9> = call 'erlang':'-' (N,1) in let <_7> = call 'erlang':'+' (Pos,1) in let <_8> = call 'erlang':'element' (_7,Leaf) in apply 'bplus_split_leaf_2'/4 (Leaf,_10,_9,[_8|Accum]) end
'bplus_split_leaf_3'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <_15,0,LeftAcc,DKey,RightAcc> when 'true' -> let <_6> = call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|LeftAcc]-|['compiler_generated'] )) in let <_5> = call ('erlang'-|['compiler_generated'] ):('list_to_tuple'-|['compiler_generated'] ) (([('l'-|['compiler_generated'] )|RightAcc]-|['compiler_generated'] )) in {_6,DKey,_5}
<Leaf,Pos,LeftAcc,DKey,RightAcc> when 'true' -> let <_9> = call 'erlang':'-' (Pos,1) in let <_7> = call 'erlang':'+' (Pos,1) in let <_8> = call 'erlang':'element' (_7,Leaf) in apply 'bplus_split_leaf_3'/5 (Leaf,_9,[_8|LeftAcc],DKey,RightAcc) end
'bplus_split_node'/1 = fun (_0) -> let <S> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_1> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_1,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_2> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_2,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in let <_2> = call 'erlang':'div' (S,2) in apply 'bplus_split_node_2'/4 (_0,S,_2,[])
'bplus_split_node_2'/4 = fun (_0,_1,_2,_3) -> case <_0,_1,_2,_3> of <Node,Pos,1,Accum> when 'true' -> let <_6> = call 'erlang':'-' (Pos,1) in (let <_18> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in (let <_19> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_18,(1-|['compiler_generated'] )) in let <_5> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_19,Node) in (let <_25> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in let <_4> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_25,Node) in apply 'bplus_split_node_3'/5 (Node,_6,[],_5,[_4|Accum])-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
<Node,Pos,N,Accum> when 'true' -> let <_10> = call 'erlang':'-' (Pos,1) in let <_9> = call 'erlang':'-' (N,1) in (let <_31> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in (let <_32> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_31,(1-|['compiler_generated'] )) in let <_7> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_32,Node) in (let <_38> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in let <_8> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_38,Node) in apply 'bplus_split_node_2'/4 (Node,_10,_9,[_7|[_8|Accum]])-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end
'bplus_split_node_3'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Node,1,LeftAcc,DKey,RightAcc> when 'true' -> let <_6> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((2-|['compiler_generated'] ),Node) in let <_7> = apply 'bplus_mk_node'/1 ([_6|LeftAcc]) in let <_5> = apply 'bplus_mk_node'/1 (RightAcc) in {_7,DKey,_5}
<Node,Pos,LeftAcc,DKey,RightAcc> when 'true' -> let <_10> = call 'erlang':'-' (Pos,1) in (let <_24> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in (let <_25> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_24,(1-|['compiler_generated'] )) in let <_8> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_25,Node) in (let <_31> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in let <_9> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_31,Node) in apply 'bplus_split_node_3'/5 (Node,_10,[_8|[_9|LeftAcc]],DKey,RightAcc)-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end
'bplus_joinleft_tree'/3 = fun (_0,_1,_2) -> let <_3> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_9> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_9,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_10> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_10,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'bplus_join_tree_2'/5 (_0,_1,_2,_3,[])
'bplus_joinright_tree'/3 = fun (_0,_1,_2) -> let <_4> = call 'erlang':'+' (_2,1) in let <_3> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_10> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_10,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_11> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_11,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'bplus_join_tree_2'/5 (_0,_1,_4,_3,[])
'bplus_join_tree_2'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Tree,JoinedTree,Pos,_14,Accum> when call 'erlang':'=:=' (_14,Pos) -> let <_5> = call 'erlang':'-' (Pos,2) in apply 'bplus_join_tree_3'/3 (Tree,_5,[JoinedTree|Accum])
<Tree,JoinedTree,Pos,N,Accum> when 'true' -> let <_8> = call 'erlang':'-' (N,1) in (let <_19> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in (let <_20> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_19,(1-|['compiler_generated'] )) in let <_6> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_20,Tree) in (let <_27> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in let <_7> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_27,Tree) in apply 'bplus_join_tree_2'/5 (Tree,JoinedTree,Pos,_8,[_6|[_7|Accum]])-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end
'bplus_join_tree_3'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_X_Tree,0,Accum> when 'true' -> apply 'bplus_mk_node'/1 (Accum)
<Tree,Pos,Accum> when 'true' -> let <_5> = call 'erlang':'-' (Pos,1) in (let <_13> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in let <_3> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_13,Tree) in (let <_20> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (Pos,(2-|['compiler_generated'] )) in (let <_21> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (_20,(1-|['compiler_generated'] )) in let <_4> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_21,Tree) in apply 'bplus_join_tree_3'/3 (Tree,_5,[_3|[_4|Accum]])-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end
'bplus_mk_node'/1 = fun (_0) -> call 'erlang':'list_to_tuple' (['n'|_0])
'bplus_node_to_list'/1 = fun (_0) -> case call 'erlang':'tuple_to_list' (_0) of <[_3|NodeList]> when 'true' -> NodeList
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'bplus_mk_leaf'/1 = fun (_0) -> call 'erlang':'list_to_tuple' (['l'|_0])
'bplus_leaf_to_list'/1 = fun (_0) -> case call 'erlang':'tuple_to_list' (_0) of <[_3|LeafList]> when 'true' -> LeafList
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end
'bplus_put_subtree'/2 = fun (_0,_1) -> case <_0,_1> of <Tree,[]> when 'true' -> Tree
<Tree,[NewSubTree|[Pos|Rest]]> when 'true' -> let <_2> = call 'erlang':'*' (Pos,2) in let <_3> = call 'erlang':'setelement' (_2,Tree,NewSubTree) in apply 'bplus_put_subtree'/2 (_3,Rest)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'bplus_put_subtree',2}}] )-|['compiler_generated'] ) end
'bplus_extend_tree'/3 = fun (_0,_1,_2) -> let <_3> = case (call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) ((1-|['compiler_generated'] ),_0)-|['compiler_generated'] ) of (<('l'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_9> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_9,(1-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<('n'-|['compiler_generated'] )> when ('true'-|['compiler_generated'] ) -> (let <_10> = call ('erlang'-|['compiler_generated'] ):('tuple_size'-|['compiler_generated'] ) (_0) in (call ('erlang'-|['compiler_generated'] ):('div'-|['compiler_generated'] ) (_10,(2-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] )
(<_3> when ('true'-|['compiler_generated'] ) -> (primop ('match_fail'-|['compiler_generated'] ) (({('case_clause'-|['compiler_generated'] ),_3}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end in apply 'bplus_extend_tree_2'/5 (_0,_1,_2,_3,[])
'bplus_extend_tree_2'/5 = fun (_0,_1,_2,_3,_4) -> case <_0,_1,_2,_3,_4> of <Tree,{T1,DKey,T2},Pos,_14,Accum> when call 'erlang':'=:=' (_14,Pos) -> let <_5> = call 'erlang':'-' (Pos,1) in apply 'bplus_extend_tree_3'/3 (Tree,_5,[T1|[DKey|[T2|Accum]]])
<Tree,Inserts,Pos,N,Accum> when 'true' -> let <_8> = call 'erlang':'-' (N,1) in (let <_19> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in (let <_20> = call ('erlang'-|['compiler_generated'] ):('-'-|['compiler_generated'] ) (_19,(1-|['compiler_generated'] )) in let <_6> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_20,Tree) in (let <_27> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in let <_7> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_27,Tree) in apply 'bplus_extend_tree_2'/5 (Tree,Inserts,Pos,_8,[_6|[_7|Accum]])-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end
'bplus_extend_tree_3'/3 = fun (_0,_1,_2) -> case <_0,_1,_2> of <_9,0,Accum> when 'true' -> apply 'bplus_mk_node'/1 (Accum)
<Tree,N,Accum> when 'true' -> let <_5> = call 'erlang':'-' (N,1) in (let <_13> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in let <_3> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_13,Tree) in (let <_19> = call ('erlang'-|['compiler_generated'] ):('*'-|['compiler_generated'] ) (N,(2-|['compiler_generated'] )) in (let <_20> = call ('erlang'-|['compiler_generated'] ):('+'-|['compiler_generated'] ) (_19,(1-|['compiler_generated'] )) in let <_4> = call ('erlang'-|['compiler_generated'] ):('element'-|['compiler_generated'] ) (_20,Tree) in apply 'bplus_extend_tree_3'/3 (Tree,_5,[_3|[_4|Accum]])-|['compiler_generated'] )-|['compiler_generated'] )-|['compiler_generated'] ) end
'bplus_put_lkey'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'*' (_2,2) in let <_4> = call 'erlang':'-' (_3,1) in call 'erlang':'setelement' (_4,_0,_1)
'bplus_put_rkey'/3 = fun (_0,_1,_2) -> let <_3> = call 'erlang':'*' (_2,2) in let <_4> = call 'erlang':'+' (_3,1) in call 'erlang':'setelement' (_4,_0,_1)
'bplus_get_size'/1 = fun (_0) -> case call 'erlang':'element' (1,_0) of <'l'> when 'true' -> let <_1> = call 'erlang':'tuple_size' (_0) in call 'erlang':'-' (_1,1)
<'n'> when 'true' -> let <_2> = call 'erlang':'tuple_size' (_0) in call 'erlang':'div' (_2,2)
(<_3> when 'true' -> primop 'match_fail' ({'case_clause',_3})-|['compiler_generated'] ) end
'bplus_get_tree'/2 = fun (_0,_1) -> let <_2> = call 'erlang':'*' (_1,2) in call 'erlang':'element' (_2,_0)
'bplus_get_lkey'/2 = fun (_0,_1) -> let <_2> = call 'erlang':'*' (_1,2) in let <_3> = call 'erlang':'-' (_2,1) in call 'erlang':'element' (_3,_0)
'bplus_get_rkey'/2 = fun (_0,_1) -> let <_2> = call 'erlang':'*' (_1,2) in let <_3> = call 'erlang':'+' (_2,1) in call 'erlang':'element' (_3,_0)
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('dets_utils')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('dets_utils',_0) end