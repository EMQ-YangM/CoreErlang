module 'beam_lib' ['all_chunks'/1,'build_module'/1,'chunks'/2,'chunks'/3,'clear_crypto_key_fun'/0,'cmp'/2,'cmp_dirs'/2,'code_change'/3,'crypto_key_fun'/1,'diff_dirs'/2,'format_error'/1,'get_crypto_key'/1,'handle_call'/3,'handle_cast'/2,'handle_info'/2,'info'/1,'init'/1,'make_crypto_key'/2,'md5'/1,'module_info'/0,'module_info'/1,'significant_chunks'/0,'strip'/1,'strip'/2,'strip_files'/1,'strip_files'/2,'strip_release'/1,'strip_release'/2,'terminate'/2,'version'/1] attributes [ 'file' = [{[115|[114|[99|[47|[98|[101|[97|[109|[95|[108|[105|[98|[46|[101|[114|[108]]]]]]]]]]]]]]]],1}]
, 'behaviour' = ['gen_server']
, 'compile' = [{'no_auto_import',[{'error',1}]}]
, 'compile' = [{'no_auto_import',[{'error',2}]}]
, 'export_type' = [{'attrib_entry',0}|[{'compinfo_entry',0}|[{'labeled_entry',0}|[{'label',0}]]]]
, 'type' = [{'beam',{'type',60,'union',[{'remote_type',60,[{'atom',60,'file'}|[{'atom',60,'filename'}|[[]]]]}|[{'type',60,'binary',[]}]]},[]}]
, 'type' = [{'debug_info',{'type',61,'union',[{'type',61,'tuple',[{'ann_type',61,[{'var',61,'DbgiVersion'}|[{'type',61,'atom',[]}]]}|[{'ann_type',61,[{'var',61,'Backend'}|[{'type',61,'module',[]}]]}|[{'ann_type',61,[{'var',61,'Data'}|[{'type',61,'term',[]}]]}]]]}|[{'atom',61,'no_debug_info'}]]},[]}]
, 'type' = [{'forms',{'type',63,'list',[{'type',63,'union',[{'remote_type',63,[{'atom',63,'erl_parse'}|[{'atom',63,'abstract_form'}|[[]]]]}|[{'remote_type',63,[{'atom',63,'erl_parse'}|[{'atom',63,'form_info'}|[[]]]]}]]}]},[]}]
, 'type' = [{'abst_code',{'type',65,'union',[{'type',65,'tuple',[{'ann_type',65,[{'var',65,'AbstVersion'}|[{'type',65,'atom',[]}]]}|[{'user_type',65,'forms',[]}]]}|[{'atom',65,'no_abstract_code'}]]},[]}]
, 'type' = [{'dataB',{'type',66,'binary',[]},[]}]
, 'type' = [{'index',{'type',67,'non_neg_integer',[]},[]}]
, 'type' = [{'label',{'type',68,'integer',[]},[]}]
, 'type' = [{'chunkid',{'type',70,'nonempty_string',[]},[]}]
, 'type' = [{'chunkname',{'type',72,'union',[{'atom',72,'abstract_code'}|[{'atom',72,'debug_info'}|[{'atom',73,'attributes'}|[{'atom',73,'compile_info'}|[{'atom',74,'exports'}|[{'atom',74,'labeled_exports'}|[{'atom',75,'imports'}|[{'atom',75,'indexed_imports'}|[{'atom',76,'locals'}|[{'atom',76,'labeled_locals'}|[{'atom',77,'atoms'}]]]]]]]]]]]},[]}]
, 'type' = [{'chunkref',{'type',78,'union',[{'user_type',78,'chunkname',[]}|[{'user_type',78,'chunkid',[]}]]},[]}]
, 'type' = [{'attrib_entry',{'type',80,'tuple',[{'ann_type',80,[{'var',80,'Attribute'}|[{'type',80,'atom',[]}]]}|[{'type',80,'list',[{'ann_type',80,[{'var',80,'AttributeValue'}|[{'type',80,'term',[]}]]}]}]]},[]}]
, 'type' = [{'compinfo_entry',{'type',81,'tuple',[{'ann_type',81,[{'var',81,'InfoKey'}|[{'type',81,'atom',[]}]]}|[{'type',81,'term',[]}]]},[]}]
, 'type' = [{'labeled_entry',{'type',82,'tuple',[{'ann_type',82,[{'var',82,'Function'}|[{'type',82,'atom',[]}]]}|[{'type',82,'arity',[]}|[{'user_type',82,'label',[]}]]]},[]}]
, 'type' = [{'chunkdata',{'type',84,'union',[{'type',84,'tuple',[{'user_type',84,'chunkid',[]}|[{'user_type',84,'dataB',[]}]]}|[{'type',85,'tuple',[{'atom',85,'abstract_code'}|[{'user_type',85,'abst_code',[]}]]}|[{'type',86,'tuple',[{'atom',86,'debug_info'}|[{'user_type',86,'debug_info',[]}]]}|[{'type',87,'tuple',[{'atom',87,'attributes'}|[{'type',87,'list',[{'user_type',87,'attrib_entry',[]}]}]]}|[{'type',88,'tuple',[{'atom',88,'compile_info'}|[{'type',88,'list',[{'user_type',88,'compinfo_entry',[]}]}]]}|[{'type',89,'tuple',[{'atom',89,'exports'}|[{'type',89,'list',[{'type',89,'tuple',[{'type',89,'atom',[]}|[{'type',89,'arity',[]}]]}]}]]}|[{'type',90,'tuple',[{'atom',90,'labeled_exports'}|[{'type',90,'list',[{'user_type',90,'labeled_entry',[]}]}]]}|[{'type',91,'tuple',[{'atom',91,'imports'}|[{'type',91,'list',[{'type',91,'mfa',[]}]}]]}|[{'type',92,'tuple',[{'atom',92,'indexed_imports'}|[{'type',92,'list',[{'type',92,'tuple',[{'user_type',92,'index',[]}|[{'type',92,'module',[]}|[{'ann_type',92,[{'var',92,'Function'}|[{'type',92,'atom',[]}]]}|[{'type',92,'arity',[]}]]]]}]}]]}|[{'type',93,'tuple',[{'atom',93,'locals'}|[{'type',93,'list',[{'type',93,'tuple',[{'type',93,'atom',[]}|[{'type',93,'arity',[]}]]}]}]]}|[{'type',94,'tuple',[{'atom',94,'labeled_locals'}|[{'type',94,'list',[{'user_type',94,'labeled_entry',[]}]}]]}|[{'type',95,'tuple',[{'atom',95,'atoms'}|[{'type',95,'list',[{'type',95,'tuple',[{'type',95,'integer',[]}|[{'type',95,'atom',[]}]]}]}]]}]]]]]]]]]]]]},[]}]
, 'type' = [{'info_rsn',{'type',98,'union',[{'type',98,'tuple',[{'atom',98,'chunk_too_big'}|[{'remote_type',98,[{'atom',98,'file'}|[{'atom',98,'filename'}|[[]]]]}|[{'user_type',99,'chunkid',[]}|[{'ann_type',99,[{'var',99,'ChunkSize'}|[{'type',99,'non_neg_integer',[]}]]}|[{'ann_type',100,[{'var',100,'FileSize'}|[{'type',100,'non_neg_integer',[]}]]}]]]]]}|[{'type',101,'tuple',[{'atom',101,'invalid_beam_file'}|[{'remote_type',101,[{'atom',101,'file'}|[{'atom',101,'filename'}|[[]]]]}|[{'ann_type',102,[{'var',102,'Position'}|[{'type',102,'non_neg_integer',[]}]]}]]]}|[{'type',103,'tuple',[{'atom',103,'invalid_chunk'}|[{'remote_type',103,[{'atom',103,'file'}|[{'atom',103,'filename'}|[[]]]]}|[{'user_type',103,'chunkid',[]}]]]}|[{'type',104,'tuple',[{'atom',104,'missing_chunk'}|[{'remote_type',104,[{'atom',104,'file'}|[{'atom',104,'filename'}|[[]]]]}|[{'user_type',104,'chunkid',[]}]]]}|[{'type',105,'tuple',[{'atom',105,'not_a_beam_file'}|[{'remote_type',105,[{'atom',105,'file'}|[{'atom',105,'filename'}|[[]]]]}]]}|[{'type',106,'tuple',[{'atom',106,'file_error'}|[{'remote_type',106,[{'atom',106,'file'}|[{'atom',106,'filename'}|[[]]]]}|[{'remote_type',106,[{'atom',106,'file'}|[{'atom',106,'posix'}|[[]]]]}]]]}]]]]]]},[]}]
, 'type' = [{'chnk_rsn',{'type',107,'union',[{'type',107,'tuple',[{'atom',107,'unknown_chunk'}|[{'remote_type',107,[{'atom',107,'file'}|[{'atom',107,'filename'}|[[]]]]}|[{'type',107,'atom',[]}]]]}|[{'type',108,'tuple',[{'atom',108,'key_missing_or_invalid'}|[{'remote_type',108,[{'atom',108,'file'}|[{'atom',108,'filename'}|[[]]]]}|[{'type',109,'union',[{'atom',109,'abstract_code'}|[{'atom',109,'debug_info'}]]}]]]}|[{'user_type',110,'info_rsn',[]}]]]},[]}]
, 'type' = [{'cmp_rsn',{'type',111,'union',[{'type',111,'tuple',[{'atom',111,'modules_different'}|[{'type',111,'module',[]}|[{'type',111,'module',[]}]]]}|[{'type',112,'tuple',[{'atom',112,'chunks_different'}|[{'user_type',112,'chunkid',[]}]]}|[{'atom',113,'different_chunks'}|[{'user_type',114,'info_rsn',[]}]]]]},[]}]
, 'spec' = [{{'info',1},[{'type',122,'bounded_fun',[{'type',122,'fun',[{'type',122,'product',[{'var',122,'Beam'}]}|[{'type',122,'union',[{'type',122,'list',[{'var',122,'InfoPair'}]}|[{'type',122,'tuple',[{'atom',122,'error'}|[{'atom',122,'beam_lib'}|[{'user_type',122,'info_rsn',[]}]]]}]]}]]}|[[{'type',123,'constraint',[{'atom',123,'is_subtype'}|[[{'var',123,'Beam'}|[{'user_type',123,'beam',[]}]]]]}|[{'type',124,'constraint',[{'atom',124,'is_subtype'}|[[{'var',124,'InfoPair'}|[{'type',124,'union',[{'type',124,'tuple',[{'atom',124,'file'}|[{'ann_type',124,[{'var',124,'Filename'}|[{'remote_type',124,[{'atom',124,'file'}|[{'atom',124,'filename'}|[[]]]]}]]}]]}|[{'type',125,'tuple',[{'atom',125,'binary'}|[{'ann_type',125,[{'var',125,'Binary'}|[{'type',125,'binary',[]}]]}]]}|[{'type',126,'tuple',[{'atom',126,'module'}|[{'ann_type',126,[{'var',126,'Module'}|[{'type',126,'module',[]}]]}]]}|[{'type',127,'tuple',[{'atom',127,'chunks'}|[{'type',127,'list',[{'type',127,'tuple',[{'ann_type',127,[{'var',127,'ChunkId'}|[{'user_type',127,'chunkid',[]}]]}|[{'ann_type',128,[{'var',128,'Pos'}|[{'type',128,'non_neg_integer',[]}]]}|[{'ann_type',129,[{'var',129,'Size'}|[{'type',129,'non_neg_integer',[]}]]}]]]}]}]]}]]]]}]]]]}]]]]}]}]
, 'spec' = [{{'chunks',2},[{'type',134,'bounded_fun',[{'type',134,'fun',[{'type',134,'product',[{'var',134,'Beam'}|[{'var',134,'ChunkRefs'}]]}|[{'type',135,'union',[{'type',135,'tuple',[{'atom',135,'ok'}|[{'type',135,'tuple',[{'type',135,'module',[]}|[{'type',135,'list',[{'user_type',135,'chunkdata',[]}]}]]}]]}|[{'type',136,'tuple',[{'atom',136,'error'}|[{'atom',136,'beam_lib'}|[{'user_type',136,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',137,'constraint',[{'atom',137,'is_subtype'}|[[{'var',137,'Beam'}|[{'user_type',137,'beam',[]}]]]]}|[{'type',138,'constraint',[{'atom',138,'is_subtype'}|[[{'var',138,'ChunkRefs'}|[{'type',138,'list',[{'user_type',138,'chunkref',[]}]}]]]]}]]]]}]}]
, 'spec' = [{{'chunks',3},[{'type',143,'bounded_fun',[{'type',143,'fun',[{'type',143,'product',[{'var',143,'Beam'}|[{'var',143,'ChunkRefs'}|[{'var',143,'Options'}]]]}|[{'type',144,'union',[{'type',144,'tuple',[{'atom',144,'ok'}|[{'type',144,'tuple',[{'type',144,'module',[]}|[{'type',144,'list',[{'var',144,'ChunkResult'}]}]]}]]}|[{'type',145,'tuple',[{'atom',145,'error'}|[{'atom',145,'beam_lib'}|[{'user_type',145,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',146,'constraint',[{'atom',146,'is_subtype'}|[[{'var',146,'Beam'}|[{'user_type',146,'beam',[]}]]]]}|[{'type',147,'constraint',[{'atom',147,'is_subtype'}|[[{'var',147,'ChunkRefs'}|[{'type',147,'list',[{'user_type',147,'chunkref',[]}]}]]]]}|[{'type',148,'constraint',[{'atom',148,'is_subtype'}|[[{'var',148,'Options'}|[{'type',148,'list',[{'atom',148,'allow_missing_chunks'}]}]]]]}|[{'type',149,'constraint',[{'atom',149,'is_subtype'}|[[{'var',149,'ChunkResult'}|[{'type',149,'union',[{'user_type',149,'chunkdata',[]}|[{'type',149,'tuple',[{'ann_type',149,[{'var',149,'ChunkRef'}|[{'user_type',149,'chunkref',[]}]]}|[{'atom',149,'missing_chunk'}]]}]]}]]]]}]]]]]]}]}]
, 'spec' = [{{'all_chunks',1},[{'type',155,'fun',[{'type',155,'product',[{'user_type',155,'beam',[]}]}|[{'type',156,'union',[{'type',156,'tuple',[{'atom',156,'ok'}|[{'atom',156,'beam_lib'}|[{'type',156,'list',[{'type',156,'tuple',[{'user_type',156,'chunkid',[]}|[{'user_type',156,'dataB',[]}]]}]}]]]}|[{'type',156,'tuple',[{'atom',156,'error'}|[{'atom',156,'beam_lib'}|[{'user_type',156,'info_rsn',[]}]]]}]]}]]}]}]
, 'spec' = [{{'cmp',2},[{'type',161,'bounded_fun',[{'type',161,'fun',[{'type',161,'product',[{'var',161,'Beam1'}|[{'var',161,'Beam2'}]]}|[{'type',161,'union',[{'atom',161,'ok'}|[{'type',161,'tuple',[{'atom',161,'error'}|[{'atom',161,'beam_lib'}|[{'user_type',161,'cmp_rsn',[]}]]]}]]}]]}|[[{'type',162,'constraint',[{'atom',162,'is_subtype'}|[[{'var',162,'Beam1'}|[{'user_type',162,'beam',[]}]]]]}|[{'type',163,'constraint',[{'atom',163,'is_subtype'}|[[{'var',163,'Beam2'}|[{'user_type',163,'beam',[]}]]]]}]]]]}]}]
, 'spec' = [{{'cmp_dirs',2},[{'type',169,'bounded_fun',[{'type',169,'fun',[{'type',169,'product',[{'var',169,'Dir1'}|[{'var',169,'Dir2'}]]}|[{'type',170,'union',[{'type',170,'tuple',[{'var',170,'Only1'}|[{'var',170,'Only2'}|[{'var',170,'Different'}]]]}|[{'type',170,'tuple',[{'atom',170,'error'}|[{'atom',170,'beam_lib'}|[{'var',170,'Reason'}]]]}]]}]]}|[[{'type',171,'constraint',[{'atom',171,'is_subtype'}|[[{'var',171,'Dir1'}|[{'type',171,'union',[{'type',171,'atom',[]}|[{'remote_type',171,[{'atom',171,'file'}|[{'atom',171,'filename'}|[[]]]]}]]}]]]]}|[{'type',172,'constraint',[{'atom',172,'is_subtype'}|[[{'var',172,'Dir2'}|[{'type',172,'union',[{'type',172,'atom',[]}|[{'remote_type',172,[{'atom',172,'file'}|[{'atom',172,'filename'}|[[]]]]}]]}]]]]}|[{'type',173,'constraint',[{'atom',173,'is_subtype'}|[[{'var',173,'Only1'}|[{'type',173,'list',[{'remote_type',173,[{'atom',173,'file'}|[{'atom',173,'filename'}|[[]]]]}]}]]]]}|[{'type',174,'constraint',[{'atom',174,'is_subtype'}|[[{'var',174,'Only2'}|[{'type',174,'list',[{'remote_type',174,[{'atom',174,'file'}|[{'atom',174,'filename'}|[[]]]]}]}]]]]}|[{'type',175,'constraint',[{'atom',175,'is_subtype'}|[[{'var',175,'Different'}|[{'type',175,'list',[{'type',175,'tuple',[{'ann_type',175,[{'var',175,'Filename1'}|[{'remote_type',175,[{'atom',175,'file'}|[{'atom',175,'filename'}|[[]]]]}]]}|[{'ann_type',175,[{'var',175,'Filename2'}|[{'remote_type',175,[{'atom',175,'file'}|[{'atom',175,'filename'}|[[]]]]}]]}]]}]}]]]]}|[{'type',176,'constraint',[{'atom',176,'is_subtype'}|[[{'var',176,'Reason'}|[{'type',176,'union',[{'type',176,'tuple',[{'atom',176,'not_a_directory'}|[{'type',176,'term',[]}]]}|[{'user_type',176,'info_rsn',[]}]]}]]]]}]]]]]]]]}]}]
, 'spec' = [{{'diff_dirs',2},[{'type',181,'bounded_fun',[{'type',181,'fun',[{'type',181,'product',[{'var',181,'Dir1'}|[{'var',181,'Dir2'}]]}|[{'type',181,'union',[{'atom',181,'ok'}|[{'type',181,'tuple',[{'atom',181,'error'}|[{'atom',181,'beam_lib'}|[{'var',181,'Reason'}]]]}]]}]]}|[[{'type',182,'constraint',[{'atom',182,'is_subtype'}|[[{'var',182,'Dir1'}|[{'type',182,'union',[{'type',182,'atom',[]}|[{'remote_type',182,[{'atom',182,'file'}|[{'atom',182,'filename'}|[[]]]]}]]}]]]]}|[{'type',183,'constraint',[{'atom',183,'is_subtype'}|[[{'var',183,'Dir2'}|[{'type',183,'union',[{'type',183,'atom',[]}|[{'remote_type',183,[{'atom',183,'file'}|[{'atom',183,'filename'}|[[]]]]}]]}]]]]}|[{'type',184,'constraint',[{'atom',184,'is_subtype'}|[[{'var',184,'Reason'}|[{'type',184,'union',[{'type',184,'tuple',[{'atom',184,'not_a_directory'}|[{'type',184,'term',[]}]]}|[{'user_type',184,'info_rsn',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'strip',1},[{'type',189,'bounded_fun',[{'type',189,'fun',[{'type',189,'product',[{'var',189,'Beam1'}]}|[{'type',190,'union',[{'type',190,'tuple',[{'atom',190,'ok'}|[{'type',190,'tuple',[{'type',190,'module',[]}|[{'var',190,'Beam2'}]]}]]}|[{'type',190,'tuple',[{'atom',190,'error'}|[{'atom',190,'beam_lib'}|[{'user_type',190,'info_rsn',[]}]]]}]]}]]}|[[{'type',191,'constraint',[{'atom',191,'is_subtype'}|[[{'var',191,'Beam1'}|[{'user_type',191,'beam',[]}]]]]}|[{'type',192,'constraint',[{'atom',192,'is_subtype'}|[[{'var',192,'Beam2'}|[{'user_type',192,'beam',[]}]]]]}]]]]}]}]
, 'spec' = [{{'strip',2},[{'type',197,'bounded_fun',[{'type',197,'fun',[{'type',197,'product',[{'var',197,'Beam1'}|[{'var',197,'AdditionalChunks'}]]}|[{'type',198,'union',[{'type',198,'tuple',[{'atom',198,'ok'}|[{'type',198,'tuple',[{'type',198,'module',[]}|[{'var',198,'Beam2'}]]}]]}|[{'type',198,'tuple',[{'atom',198,'error'}|[{'atom',198,'beam_lib'}|[{'user_type',198,'info_rsn',[]}]]]}]]}]]}|[[{'type',199,'constraint',[{'atom',199,'is_subtype'}|[[{'var',199,'Beam1'}|[{'user_type',199,'beam',[]}]]]]}|[{'type',200,'constraint',[{'atom',200,'is_subtype'}|[[{'var',200,'AdditionalChunks'}|[{'type',200,'list',[{'user_type',200,'chunkid',[]}]}]]]]}|[{'type',201,'constraint',[{'atom',201,'is_subtype'}|[[{'var',201,'Beam2'}|[{'user_type',201,'beam',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'strip_files',1},[{'type',207,'bounded_fun',[{'type',207,'fun',[{'type',207,'product',[{'var',207,'Files'}]}|[{'type',208,'union',[{'type',208,'tuple',[{'atom',208,'ok'}|[{'type',208,'list',[{'type',208,'tuple',[{'type',208,'module',[]}|[{'var',208,'Beam'}]]}]}]]}|[{'type',208,'tuple',[{'atom',208,'error'}|[{'atom',208,'beam_lib'}|[{'user_type',208,'info_rsn',[]}]]]}]]}]]}|[[{'type',209,'constraint',[{'atom',209,'is_subtype'}|[[{'var',209,'Files'}|[{'type',209,'list',[{'user_type',209,'beam',[]}]}]]]]}|[{'type',210,'constraint',[{'atom',210,'is_subtype'}|[[{'var',210,'Beam'}|[{'user_type',210,'beam',[]}]]]]}]]]]}]}]
, 'spec' = [{{'strip_files',2},[{'type',215,'bounded_fun',[{'type',215,'fun',[{'type',215,'product',[{'var',215,'Files'}|[{'var',215,'AdditionalChunks'}]]}|[{'type',216,'union',[{'type',216,'tuple',[{'atom',216,'ok'}|[{'type',216,'list',[{'type',216,'tuple',[{'type',216,'module',[]}|[{'var',216,'Beam'}]]}]}]]}|[{'type',216,'tuple',[{'atom',216,'error'}|[{'atom',216,'beam_lib'}|[{'user_type',216,'info_rsn',[]}]]]}]]}]]}|[[{'type',217,'constraint',[{'atom',217,'is_subtype'}|[[{'var',217,'Files'}|[{'type',217,'list',[{'user_type',217,'beam',[]}]}]]]]}|[{'type',218,'constraint',[{'atom',218,'is_subtype'}|[[{'var',218,'AdditionalChunks'}|[{'type',218,'list',[{'user_type',218,'chunkid',[]}]}]]]]}|[{'type',219,'constraint',[{'atom',219,'is_subtype'}|[[{'var',219,'Beam'}|[{'user_type',219,'beam',[]}]]]]}]]]]]}]}]
, 'spec' = [{{'strip_release',1},[{'type',225,'bounded_fun',[{'type',225,'fun',[{'type',225,'product',[{'var',225,'Dir'}]}|[{'type',226,'union',[{'type',226,'tuple',[{'atom',226,'ok'}|[{'type',226,'list',[{'type',226,'tuple',[{'type',226,'module',[]}|[{'remote_type',226,[{'atom',226,'file'}|[{'atom',226,'filename'}|[[]]]]}]]}]}]]}|[{'type',227,'tuple',[{'atom',227,'error'}|[{'atom',227,'beam_lib'}|[{'var',227,'Reason'}]]]}]]}]]}|[[{'type',228,'constraint',[{'atom',228,'is_subtype'}|[[{'var',228,'Dir'}|[{'type',228,'union',[{'type',228,'atom',[]}|[{'remote_type',228,[{'atom',228,'file'}|[{'atom',228,'filename'}|[[]]]]}]]}]]]]}|[{'type',229,'constraint',[{'atom',229,'is_subtype'}|[[{'var',229,'Reason'}|[{'type',229,'union',[{'type',229,'tuple',[{'atom',229,'not_a_directory'}|[{'type',229,'term',[]}]]}|[{'user_type',229,'info_rsn',[]}]]}]]]]}]]]]}]}]
, 'spec' = [{{'strip_release',2},[{'type',234,'bounded_fun',[{'type',234,'fun',[{'type',234,'product',[{'var',234,'Dir'}|[{'var',234,'AdditionalChunks'}]]}|[{'type',235,'union',[{'type',235,'tuple',[{'atom',235,'ok'}|[{'type',235,'list',[{'type',235,'tuple',[{'type',235,'module',[]}|[{'remote_type',235,[{'atom',235,'file'}|[{'atom',235,'filename'}|[[]]]]}]]}]}]]}|[{'type',236,'tuple',[{'atom',236,'error'}|[{'atom',236,'beam_lib'}|[{'var',236,'Reason'}]]]}]]}]]}|[[{'type',237,'constraint',[{'atom',237,'is_subtype'}|[[{'var',237,'Dir'}|[{'type',237,'union',[{'type',237,'atom',[]}|[{'remote_type',237,[{'atom',237,'file'}|[{'atom',237,'filename'}|[[]]]]}]]}]]]]}|[{'type',238,'constraint',[{'atom',238,'is_subtype'}|[[{'var',238,'AdditionalChunks'}|[{'type',238,'list',[{'user_type',238,'chunkid',[]}]}]]]]}|[{'type',239,'constraint',[{'atom',239,'is_subtype'}|[[{'var',239,'Reason'}|[{'type',239,'union',[{'type',239,'tuple',[{'atom',239,'not_a_directory'}|[{'type',239,'term',[]}]]}|[{'user_type',239,'info_rsn',[]}]]}]]]]}]]]]]}]}]
, 'spec' = [{{'version',1},[{'type',244,'bounded_fun',[{'type',244,'fun',[{'type',244,'product',[{'var',244,'Beam'}]}|[{'type',245,'union',[{'type',245,'tuple',[{'atom',245,'ok'}|[{'type',245,'tuple',[{'type',245,'module',[]}|[{'type',245,'list',[{'ann_type',245,[{'var',245,'Version'}|[{'type',245,'term',[]}]]}]}]]}]]}|[{'type',246,'tuple',[{'atom',246,'error'}|[{'atom',246,'beam_lib'}|[{'user_type',246,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',247,'constraint',[{'atom',247,'is_subtype'}|[[{'var',247,'Beam'}|[{'user_type',247,'beam',[]}]]]]}]]]}]}]
, 'spec' = [{{'md5',1},[{'type',258,'bounded_fun',[{'type',258,'fun',[{'type',258,'product',[{'var',258,'Beam'}]}|[{'type',259,'union',[{'type',259,'tuple',[{'atom',259,'ok'}|[{'type',259,'tuple',[{'type',259,'module',[]}|[{'var',259,'MD5'}]]}]]}|[{'type',259,'tuple',[{'atom',259,'error'}|[{'atom',259,'beam_lib'}|[{'user_type',259,'chnk_rsn',[]}]]]}]]}]]}|[[{'type',260,'constraint',[{'atom',260,'is_subtype'}|[[{'var',260,'Beam'}|[{'user_type',260,'beam',[]}]]]]}|[{'type',261,'constraint',[{'atom',261,'is_subtype'}|[[{'var',261,'MD5'}|[{'type',261,'binary',[]}]]]]}]]]]}]}]
, 'spec' = [{{'format_error',1},[{'type',272,'bounded_fun',[{'type',272,'fun',[{'type',272,'product',[{'var',272,'Reason'}]}|[{'remote_type',272,[{'atom',272,'io_lib'}|[{'atom',272,'chars'}|[[]]]]}]]}|[[{'type',273,'constraint',[{'atom',273,'is_subtype'}|[[{'var',273,'Reason'}|[{'type',273,'term',[]}]]]]}]]]}]}]
, 'type' = [{'mode',{'atom',320,'des3_cbc'},[]}]
, 'type' = [{'crypto_fun_arg',{'type',321,'union',[{'atom',321,'init'}|[{'atom',322,'clear'}|[{'type',323,'tuple',[{'atom',323,'debug_info'}|[{'user_type',323,'mode',[]}|[{'type',323,'module',[]}|[{'remote_type',323,[{'atom',323,'file'}|[{'atom',323,'filename'}|[[]]]]}]]]]}]]]},[]}]
, 'type' = [{'crypto_fun',{'type',324,'fun',[{'type',324,'product',[{'user_type',324,'crypto_fun_arg',[]}]}|[{'type',324,'term',[]}]]},[]}]
, 'spec' = [{{'crypto_key_fun',1},[{'type',326,'bounded_fun',[{'type',326,'fun',[{'type',326,'product',[{'var',326,'CryptoKeyFun'}]}|[{'type',326,'union',[{'atom',326,'ok'}|[{'type',326,'tuple',[{'atom',326,'error'}|[{'var',326,'Reason'}]]}]]}]]}|[[{'type',327,'constraint',[{'atom',327,'is_subtype'}|[[{'var',327,'CryptoKeyFun'}|[{'user_type',327,'crypto_fun',[]}]]]]}|[{'type',328,'constraint',[{'atom',328,'is_subtype'}|[[{'var',328,'Reason'}|[{'type',328,'union',[{'atom',328,'badfun'}|[{'atom',328,'exists'}|[{'type',328,'term',[]}]]]}]]]]}]]]]}]}]
, 'spec' = [{{'clear_crypto_key_fun',0},[{'type',333,'bounded_fun',[{'type',333,'fun',[{'type',333,'product',[]}|[{'type',333,'union',[{'atom',333,'undefined'}|[{'type',333,'tuple',[{'atom',333,'ok'}|[{'var',333,'Result'}]]}]]}]]}|[[{'type',334,'constraint',[{'atom',334,'is_subtype'}|[[{'var',334,'Result'}|[{'type',334,'union',[{'atom',334,'undefined'}|[{'type',334,'term',[]}]]}]]]]}]]]}]}]
, 'spec' = [{{'make_crypto_key',2},[{'type',339,'fun',[{'type',339,'product',[{'user_type',339,'mode',[]}|[{'type',339,'string',[]}]]}|[{'type',340,'tuple',[{'user_type',340,'mode',[]}|[{'type',340,'list',[{'type',340,'binary',[]}]}|[{'type',340,'binary',[]}|[{'type',340,'integer',[]}]]]]}]]}]}]
, 'spec' = [{{'build_module',1},[{'type',347,'bounded_fun',[{'type',347,'fun',[{'type',347,'product',[{'var',347,'Chunks'}]}|[{'type',347,'tuple',[{'atom',347,'ok'}|[{'var',347,'Binary'}]]}]]}|[[{'type',348,'constraint',[{'atom',348,'is_subtype'}|[[{'var',348,'Chunks'}|[{'type',348,'list',[{'type',348,'tuple',[{'user_type',348,'chunkid',[]}|[{'user_type',348,'dataB',[]}]]}]}]]]]}|[{'type',349,'constraint',[{'atom',349,'is_subtype'}|[[{'var',349,'Binary'}|[{'type',349,'binary',[]}]]]]}]]]]}]}]
, 'record' = [{'bb',[{'typed_record_field',{'record_field',855,{'atom',855,'pos'},{'integer',855,0}},{'type',855,'integer',[]}}|[{'typed_record_field',{'record_field',856,{'atom',856,'bin'}},{'type',856,'binary',[]}}|[{'typed_record_field',{'record_field',857,{'atom',857,'source'}},{'type',857,'union',[{'type',857,'binary',[]}|[{'type',857,'string',[]}]]}}]]]}]
, 'spec' = [{{'file_error',2},[{'type',932,'fun',[{'type',932,'product',[{'remote_type',932,[{'atom',932,'file'}|[{'atom',932,'filename'}|[[]]]]}|[{'type',932,'tuple',[{'atom',932,'error'}|[{'type',932,'atom',[]}]]}]]}|[{'type',932,'no_return',[]}]]}]}]
, 'spec' = [{{'error',1},[{'type',937,'fun',[{'type',937,'product',[{'type',937,'term',[]}]}|[{'type',937,'no_return',[]}]]}]}]
, 'record' = [{'state',[{'typed_record_field',{'record_field',967,{'atom',967,'crypto_key_f'}},{'type',967,'union',[{'user_type',967,'crypto_fun',[]}|[{'atom',967,'undefined'}]]}}]}]
, 'spec' = [{{'init',1},[{'type',1042,'fun',[{'type',1042,'product',[{'type',1042,'nil',[]}]}|[{'type',1042,'tuple',[{'atom',1042,'ok'}|[{'type',1042,'record',[{'atom',1042,'state'}]}]]}]]}]}]
, 'type' = [{'calls',{'type',1047,'union',[{'atom',1047,'clear_crypto_key_fun'}|[{'type',1048,'tuple',[{'atom',1048,'crypto_key_fun'}|[{'var',1048,'_'}]]}|[{'type',1049,'tuple',[{'atom',1049,'get_crypto_key'}|[{'var',1049,'_'}]]}]]]},[]}]
, 'spec' = [{{'handle_call',3},[{'type',1051,'fun',[{'type',1051,'product',[{'user_type',1051,'calls',[]}|[{'type',1051,'tuple',[{'type',1051,'pid',[]}|[{'type',1051,'term',[]}]]}|[{'type',1051,'record',[{'atom',1051,'state'}]}]]]}|[{'type',1052,'union',[{'type',1052,'tuple',[{'atom',1052,'noreply'}|[{'type',1052,'record',[{'atom',1052,'state'}]}]]}|[{'type',1053,'tuple',[{'atom',1053,'reply'}|[{'type',1053,'union',[{'atom',1053,'error'}|[{'type',1053,'tuple',[{'atom',1053,'error'}|[{'type',1053,'union',[{'atom',1053,'badfun'}|[{'atom',1053,'exists'}]]}]]}]]}|[{'type',1053,'record',[{'atom',1053,'state'}]}]]]}|[{'type',1054,'tuple',[{'atom',1054,'stop'}|[{'atom',1054,'normal'}|[{'type',1054,'union',[{'atom',1054,'undefined'}|[{'type',1054,'tuple',[{'atom',1054,'ok'}|[{'type',1054,'term',[]}]]}]]}|[{'type',1054,'record',[{'atom',1054,'state'}]}]]]]}]]]}]]}]}]
, 'spec' = [{{'handle_cast',2},[{'type',1121,'fun',[{'type',1121,'product',[{'type',1121,'term',[]}|[{'type',1121,'record',[{'atom',1121,'state'}]}]]}|[{'type',1121,'tuple',[{'atom',1121,'noreply'}|[{'type',1121,'record',[{'atom',1121,'state'}]}]]}]]}]}]
, 'spec' = [{{'handle_info',2},[{'type',1126,'fun',[{'type',1126,'product',[{'type',1126,'term',[]}|[{'type',1126,'record',[{'atom',1126,'state'}]}]]}|[{'type',1126,'tuple',[{'atom',1126,'noreply'}|[{'type',1126,'record',[{'atom',1126,'state'}]}]]}]]}]}]
, 'spec' = [{{'code_change',3},[{'type',1131,'fun',[{'type',1131,'product',[{'type',1131,'term',[]}|[{'type',1131,'record',[{'atom',1131,'state'}]}|[{'type',1131,'term',[]}]]]}|[{'type',1131,'tuple',[{'atom',1131,'ok'}|[{'type',1131,'record',[{'atom',1131,'state'}]}]]}]]}]}]
, 'spec' = [{{'terminate',2},[{'type',1136,'fun',[{'type',1136,'product',[{'type',1136,'term',[]}|[{'type',1136,'record',[{'atom',1136,'state'}]}]]}|[{'atom',1136,'ok'}]]}]}] ] 'info'/1 = (fun (_0) -> let <_1> = apply 'beam_filename'/1 ((_0-|[{'function',{'info',1}}] )) in apply 'read_info'/1 (_1)-|[{'function',{'info',1}}] )
'chunks'/2 = (fun (_0,_1) -> apply 'read_chunk_data'/2 (_0,_1)-|[{'function',{'chunks',2}}] )
'chunks'/3 = (fun (_0,_1,_2) -> try apply 'read_chunk_data'/3 (_0,_1,_2) of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),Error,_10> when 'true' -> Error
(<_11,_12,_13> when 'true' -> primop 'raise' (_13,_12)-|['compiler_generated'] ) end-|[{'function',{'chunks',3}}] )
'all_chunks'/1 = (fun (_0) -> apply 'read_all_chunks'/1 ((_0-|[{'function',{'all_chunks',1}}] ))-|[{'function',{'all_chunks',1}}] )
'cmp'/2 = (fun (_0,_1) -> try apply 'cmp_files'/2 (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end-|[{'function',{'cmp',2}}] )
'cmp_dirs'/2 = (fun (_0,_1) -> catch apply 'compare_dirs'/2 (_0,_1)-|[{'function',{'cmp_dirs',2}}] )
'diff_dirs'/2 = (fun (_0,_1) -> catch apply 'diff_directories'/2 (_0,_1)-|[{'function',{'diff_dirs',2}}] )
'strip'/1 = (fun (_0) -> apply 'strip'/2 ((_0-|[{'function',{'strip',1}}] ),[])-|[{'function',{'strip',1}}] )
'strip'/2 = (fun (_0,_1) -> try apply 'strip_file'/2 (_0,_1) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end-|[{'function',{'strip',2}}] )
'strip_files'/1 = (fun (_0) -> apply 'strip_files'/2 ((_0-|[{'function',{'strip_files',1}}] ),[])-|[{'function',{'strip_files',1}}] )
'strip_files'/2 = (fun (_0,_1) -> (case <_0,_1> of <Files,AdditionalChunks> when call 'erlang':'is_list' (Files) -> try apply 'strip_fils'/2 (Files,AdditionalChunks) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end
(<_7,_6> when 'true' -> primop 'match_fail' ({'function_clause',_7,_6})-|['compiler_generated'] ) end-|[{'function',{'strip_files',2}}] )-|[{'function',{'strip_files',2}}] )
'strip_release'/1 = (fun (_0) -> apply 'strip_release'/2 ((_0-|[{'function',{'strip_release',1}}] ),[])-|[{'function',{'strip_release',1}}] )
'strip_release'/2 = (fun (_0,_1) -> catch apply 'strip_rel'/2 (_0,_1)-|[{'function',{'strip_release',2}}] )
'version'/1 = (fun (_0) -> let <_1> = catch apply 'read_chunk_data'/2 ((_0-|[{'function',{'version',1}}] ),['attributes']) in case _1 of <{'ok',{Module,[{'attributes',Attrs}|[]]}}> when 'true' -> case call 'lists':'keyfind' ('vsn',1,Attrs) of <{'vsn',Version}> when 'true' -> {'ok',{Module,Version}}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<Error> when 'true' -> Error end-|[{'function',{'version',1}}] )
'md5'/1 = (fun (_0) -> let <_2> = catch let <_1> = apply 'md5_chunks'/0 () in apply 'read_significant_chunks'/2 ((_0-|[{'function',{'md5',1}}] ),_1) in case _2 of <{'ok',{Module,Chunks0}}> when 'true' -> let <Chunks> = apply 'filter_funtab'/1 (Chunks0) in let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[{_X_Id,C}|_5]> when 'true' -> let <_8> = apply 'lc$^0'/1 (_5) in ([C|_8]-|['compiler_generated'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> primop 'match_fail' ({'function_clause',_7})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Chunks) in let <_10> = call 'erlang':'md5' (_9) in {'ok',{Module,_10}}
<Error> when 'true' -> Error end-|[{'function',{'md5',1}}] )
'format_error'/1 = (fun (_0) -> (case (_0-|[{'function',{'format_error',1}}] ) of <{'error',Error}> when 'true' -> apply 'format_error'/1 (Error)
<{'error',Module,Error}> when 'true' -> call Module:'format_error' (Error)
<{'unknown_chunk',File,ChunkName}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[67|[97|[110|[110|[111|[116|[32|[102|[105|[110|[100|[32|[99|[104|[117|[110|[107|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkName|[]]])
<{'invalid_chunk',File,ChunkId}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[73|[110|[118|[97|[108|[105|[100|[32|[99|[111|[110|[116|[101|[110|[116|[115|[32|[111|[102|[32|[99|[104|[117|[110|[107|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[]]])
<{'not_a_beam_file',File}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[78|[111|[116|[32|[97|[32|[66|[69|[65|[77|[32|[102|[105|[108|[101|[126|[110]]]]]]]]]]]]]]]]]]]]]],[File|[]])
<{'file_error',File,Reason}> when 'true' -> let <_1> = call 'file':'format_error' (Reason) in call 'io_lib':'format' ([126|[116|[112|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]],[File|[_1|[]]])
<{'missing_chunk',File,ChunkId}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[78|[111|[116|[32|[97|[32|[66|[69|[65|[77|[32|[102|[105|[108|[101|[58|[32|[110|[111|[32|[73|[70|[70|[32|[34|[126|[115|[34|[32|[99|[104|[117|[110|[107|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[]]])
<{'invalid_beam_file',File,Pos}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[73|[110|[118|[97|[108|[105|[100|[32|[102|[111|[114|[109|[97|[116|[32|[111|[102|[32|[66|[69|[65|[77|[32|[102|[105|[108|[101|[32|[110|[101|[97|[114|[32|[98|[121|[116|[101|[32|[110|[117|[109|[98|[101|[114|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[Pos|[]]])
<{'chunk_too_big',File,ChunkId,Size,Len}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[83|[105|[122|[101|[32|[111|[102|[32|[99|[104|[117|[110|[107|[32|[34|[126|[115|[34|[32|[105|[115|[32|[126|[112|[32|[98|[121|[116|[101|[115|[44|[32|[98|[117|[116|[32|[111|[110|[108|[121|[32|[126|[112|[32|[98|[121|[116|[101|[115|[32|[99|[111|[117|[108|[100|[32|[98|[101|[32|[114|[101|[97|[100|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[Size|[Len|[]]]]])
<{'chunks_different',Id}> when 'true' -> call 'io_lib':'format' ([67|[104|[117|[110|[107|[32|[34|[126|[115|[34|[32|[100|[105|[102|[102|[101|[114|[115|[32|[105|[110|[32|[116|[104|[101|[32|[116|[119|[111|[32|[102|[105|[108|[101|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Id|[]])
<'different_chunks'> when 'true' -> [84|[104|[101|[32|[116|[119|[111|[32|[102|[105|[108|[101|[115|[32|[104|[97|[118|[101|[32|[100|[105|[102|[102|[101|[114|[101|[110|[116|[32|[99|[104|[117|[110|[107|[115|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
<{'modules_different',Module1,Module2}> when 'true' -> call 'io_lib':'format' ([77|[111|[100|[117|[108|[101|[32|[110|[97|[109|[101|[115|[32|[126|[112|[32|[97|[110|[100|[32|[126|[112|[32|[100|[105|[102|[102|[101|[114|[32|[105|[110|[32|[116|[104|[101|[32|[116|[119|[111|[32|[102|[105|[108|[101|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[Module1|[Module2|[]]])
<{'not_a_directory',Name}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[78|[111|[116|[32|[97|[32|[100|[105|[114|[101|[99|[116|[111|[114|[121|[126|[110]]]]]]]]]]]]]]]]]]]]]],[Name|[]])
<{'key_missing_or_invalid',File,ChunkId}> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[58|[32|[67|[97|[110|[110|[111|[116|[32|[100|[101|[99|[114|[121|[112|[116|[32|[126|[116|[115|[32|[98|[101|[99|[97|[117|[115|[101|[32|[107|[101|[121|[32|[105|[115|[32|[109|[105|[115|[115|[105|[110|[103|[32|[111|[114|[32|[105|[110|[118|[97|[108|[105|[100]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[File|[ChunkId|[]]])
<'badfun'> when 'true' -> [110|[111|[116|[32|[97|[32|[102|[117|[110|[32|[111|[114|[32|[116|[104|[101|[32|[102|[117|[110|[32|[104|[97|[115|[32|[116|[104|[101|[32|[119|[114|[111|[110|[103|[32|[97|[114|[105|[116|[121]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
<'exists'> when 'true' -> [97|[32|[102|[117|[110|[32|[104|[97|[115|[32|[97|[108|[114|[101|[97|[100|[121|[32|[98|[101|[101|[110|[32|[105|[110|[115|[116|[97|[108|[108|[101|[100]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
<E> when 'true' -> call 'io_lib':'format' ([126|[116|[112|[126|[110]]]]],[E|[]]) end-|[{'function',{'format_error',1}}] )-|[{'function',{'format_error',1}}] )
'crypto_key_fun'/1 = (fun (_0) -> apply 'call_crypto_server'/1 ({'crypto_key_fun',(_0-|[{'function',{'crypto_key_fun',1}}] )})-|[{'function',{'crypto_key_fun',1}}] )
'clear_crypto_key_fun'/0 = (fun () -> apply 'call_crypto_server'/1 ('clear_crypto_key_fun')-|[{'function',{'clear_crypto_key_fun',0}}] )
'make_crypto_key'/2 = (fun (_0,_1) -> (case <_0,_1> of <Type = 'des3_cbc',String> when 'true' -> let <First> = call 'erlang':'md5' (String) in case First of <#{#<K1>(8,8,'binary',['unsigned'|['big']]),#<K2>(8,8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_3> = call 'lists':'reverse' (String) in case call 'erlang':'md5' ([First|_3]) of <#{#<K3>(8,8,'binary',['unsigned'|['big']]),#<IVec>(8,8,'binary',['unsigned'|['big']])}#> when 'true' -> {Type,[K1|[K2|[K3|[]]]],IVec,8}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_6,_5> when 'true' -> primop 'match_fail' ({'function_clause',_6,_5})-|['compiler_generated'] ) end-|[{'function',{'make_crypto_key',2}}] )-|[{'function',{'make_crypto_key',2}}] )
'build_module'/1 = (fun (_0) -> let <_1> = apply 'build_chunks'/1 ((_0-|[{'function',{'build_module',1}}] )) in let <Chunks> = call 'erlang':'list_to_binary' (_1) in let <Size> = call 'erlang':'byte_size' (Chunks) in case call 'erlang':'rem' (Size,4) of <0> when 'true' -> let <_5> = call 'erlang':'+' (Size,4) in let <_6> = #{#<1179603505>(32,1,'integer',['unsigned'|['big']]),#<_5>(32,1,'integer',['unsigned'|['big']]),#<1111834957>(32,1,'integer',['unsigned'|['big']]),#<Chunks>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}# in {'ok',_6}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end-|[{'function',{'build_module',1}}] )
'read_info'/1 = (fun (_0) -> try case apply 'scan_beam'/2 ((_0-|[{'function',{'read_info',1}}] ),'info') of <{'ok',Module,Data}> when 'true' -> let <_2> = case <> of <> when call 'erlang':'is_binary' ((_0-|[{'function',{'read_info',1}}] )) -> {'binary',(_0-|[{'function',{'read_info',1}}] )}
<> when 'true' -> {'file',(_0-|[{'function',{'read_info',1}}] )} end in [_2|[{'module',Module}|[{'chunks',Data}|[]]]]
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end of <_3> -> _3 catch <_6,_5,_4> -> case <_6,_5,_4> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end-|[{'function',{'read_info',1}}] )
'diff_directories'/2 = (fun (_0,_1) -> case apply 'compare_dirs'/2 (_0,_1) of <{OnlyDir1,OnlyDir2,Diff}> when 'true' -> do apply 'diff_only'/2 (_0,OnlyDir1) do apply 'diff_only'/2 (_1,OnlyDir2) let <_5> = fun (_3) -> call 'io':'format' ([42|[42|[32|[100|[105|[102|[102|[101|[114|[101|[110|[116|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]]],[_3|[]]) in do call 'lists':'foreach' (_5,Diff) 'ok'
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end-|[{'function',{'diff_directories',2}}] )
'diff_only'/2 = (fun (_0,_1) -> (case <_0,_1> of <_X_Dir,[]> when 'true' -> 'ok'
<Dir,Only> when 'true' -> call 'io':'format' ([79|[110|[108|[121|[32|[105|[110|[32|[126|[116|[112|[58|[32|[126|[116|[112|[126|[110]]]]]]]]]]]]]]]]]],[Dir|[Only|[]]]) end-|[{'function',{'diff_only',2}}] )-|[{'function',{'diff_only',2}}] )
'compare_dirs'/2 = (fun (_0,_1) -> let <_2> = apply 'beam_files'/1 (_0) in let <R1> = call 'sofs':'relation' (_2) in let <_4> = apply 'beam_files'/1 (_1) in let <R2> = call 'sofs':'relation' (_4) in let <F1> = call 'sofs':'domain' (R1) in let <F2> = call 'sofs':'domain' (R2) in case call 'sofs':'symmetric_partition' (F1,F2) of <{O1,Both,O2}> when 'true' -> let <OnlyL1> = call 'sofs':'image' (R1,O1) in let <OnlyL2> = call 'sofs':'image' (R2,O2) in let <_11> = call 'sofs':'restriction' (R1,Both) in let <B1> = call 'sofs':'to_external' (_11) in let <_13> = call 'sofs':'restriction' (R2,Both) in let <B2> = call 'sofs':'to_external' (_13) in let <Diff> = apply 'compare_files'/3 (B1,B2,[]) in let <_17> = call 'sofs':'to_external' (OnlyL1) in let <_16> = call 'sofs':'to_external' (OnlyL2) in {_17,_16,Diff}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end-|[{'function',{'compare_dirs',2}}] )
'compare_files'/3 = (fun (_0,_1,_2) -> (case <_0,_1,_2> of <[],[],Acc> when 'true' -> call 'lists':'reverse' (Acc)
<[{_10,F1}|R1],[{_11,F2}|R2],Acc> when 'true' -> let <_3> = catch apply 'cmp_files'/2 (F1,F2) in let <_5> = case _3 of <{'error',_X_Mod,_X_Reason}> when 'true' -> [{F1,F2}|Acc]
<'ok'> when 'true' -> Acc
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end in apply 'compare_files'/3 (R1,R2,_5)
(<_9,_8,_7> when 'true' -> primop 'match_fail' ({'function_clause',_9,_8,_7})-|['compiler_generated'] ) end-|[{'function',{'compare_files',3}}] )-|[{'function',{'compare_files',3}}] )
'beam_files'/1 = (fun (_0) -> case apply 'assert_directory'/1 ((_0-|[{'function',{'beam_files',1}}] )) of <'ok'> when 'true' -> let <_2> = call 'filename':'join' ((_0-|[{'function',{'beam_files',1}}] ),[42|[46|[98|[101|[97|[109]]]]]]) in let <L> = call 'filelib':'wildcard' (_2) in (letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[Path|_5]> when 'true' -> let <_8> = call 'filename':'basename' (Path) in let <_9> = apply 'lc$^0'/1 (_5) in ([{_8,Path}|_9]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_7> when 'true' -> primop 'match_fail' ({'function_clause',_7})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (L)-|['list_comprehension'] )
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end-|[{'function',{'beam_files',1}}] )
'cmp_files'/2 = (fun (_0,_1) -> case apply 'read_all_but_useless_chunks'/1 (_0) of <{'ok',{M1,L1}}> when 'true' -> case apply 'read_all_but_useless_chunks'/1 (_1) of <{'ok',{M2,L2}}> when 'true' -> case <> of <> when call 'erlang':'=:=' (M1,M2) -> apply 'cmp_lists'/2 (L1,L2)
<> when 'true' -> apply 'error'/1 ({'modules_different',M1,M2}) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end-|[{'function',{'cmp_files',2}}] )
'cmp_lists'/2 = (fun (_0,_1) -> (case <_0,_1> of <[],[]> when 'true' -> 'ok'
<[{Id,C1}|R1],[{_4,C2}|R2]> when call 'erlang':'=:=' (_4,Id) -> case <> of <> when call 'erlang':'=:=' (C1,C2) -> apply 'cmp_lists'/2 (R1,R2)
<> when 'true' -> apply 'error'/1 ({'chunks_different',Id}) end
<_5,_6> when 'true' -> apply 'error'/1 ('different_chunks') end-|[{'function',{'cmp_lists',2}}] )-|[{'function',{'cmp_lists',2}}] )
'strip_rel'/2 = (fun (_0,_1) -> case apply 'assert_directory'/1 (_0) of <'ok'> when 'true' -> let <_3> = call 'filename':'join' (_0,[108|[105|[98|[47|[42|[47|[101|[98|[105|[110|[47|[42|[46|[98|[101|[97|[109]]]]]]]]]]]]]]]]]) in let <_4> = call 'filelib':'wildcard' (_3) in apply 'strip_fils'/2 (_4,_1)
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end-|[{'function',{'strip_rel',2}}] )
'strip_fils'/2 = (fun (_0,_1) -> let <_8> = letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[F|_3]> when 'true' -> case apply 'strip_file'/2 (F,_1) of <{'ok',Reply}> when 'true' -> let <_7> = apply 'lc$^0'/1 (_3) in ([Reply|_7]-|['compiler_generated'] )
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
<[]> when 'true' -> []
(<_5> when 'true' -> primop 'match_fail' ({'function_clause',_5})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_0) in {'ok',_8}-|[{'function',{'strip_fils',2}}] )
'strip_file'/2 = (fun (_0,_1) -> let <_2> = apply 'significant_chunks'/0 () in let <_3> = call 'erlang':'++' (_1,_2) in case apply 'read_significant_chunks'/2 (_0,_3) of <{'ok',{Mod,Chunks}}> when 'true' -> case apply 'build_module'/1 (Chunks) of <{'ok',Stripped0}> when 'true' -> let <Stripped> = apply 'compress'/1 (Stripped0) in case _0 of <_15> when call 'erlang':'is_binary' (_0) -> {'ok',{Mod,Stripped}}
<_16> when 'true' -> let <FileName> = apply 'beam_filename'/1 (_0) in case call 'file':'open' (FileName,['raw'|['binary'|['write']]]) of <{'ok',Fd}> when 'true' -> case call 'file':'write' (Fd,Stripped) of <'ok'> when 'true' -> case call 'file':'close' (Fd) of <'ok'> when 'true' -> {'ok',{Mod,FileName}}
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<Error> when 'true' -> case call 'file':'close' (Fd) of <'ok'> when 'true' -> apply 'file_error'/2 (FileName,Error)
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end end
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end-|[{'function',{'strip_file',2}}] )
'build_chunks'/1 = (fun (_0) -> (case (_0-|[{'function',{'build_chunks',1}}] ) of <[{Id,Data}|Chunks]> when 'true' -> let <BId> = call 'erlang':'list_to_binary' (Id) in let <Size> = call 'erlang':'byte_size' (Data) in let <_3> = #{#<BId>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']]),#<Size>(32,1,'integer',['unsigned'|['big']])}# in let <_4> = apply 'pad'/1 (Size) in let <Chunk> = [_3|[Data|_4]] in let <_6> = apply 'build_chunks'/1 (Chunks) in [Chunk|_6]
<[]> when 'true' -> []
(<_7> when 'true' -> primop 'match_fail' ({'function_clause',_7})-|['compiler_generated'] ) end-|[{'function',{'build_chunks',1}}] )-|[{'function',{'build_chunks',1}}] )
'pad'/1 = (fun (_0) -> case call 'erlang':'rem' ((_0-|[{'function',{'pad',1}}] ),4) of <0> when 'true' -> []
<Rem> when 'true' -> let <_1> = call 'erlang':'-' (4,Rem) in call 'lists':'duplicate' (_1,0) end-|[{'function',{'pad',1}}] )
'read_all_but_useless_chunks'/1 = (fun (_0) -> (case (_0-|[{'function',{'read_all_but_useless_chunks',1}}] ) of <File0> when let <_1> = call 'erlang':'is_atom' ((_0-|[{'function',{'read_all_but_useless_chunks',1}}] )) in let <_2> = call 'erlang':'is_list' ((_0-|[{'function',{'read_all_but_useless_chunks',1}}] )) in let <_3> = call 'erlang':'is_binary' ((_0-|[{'function',{'read_all_but_useless_chunks',1}}] )) in let <_4> = call 'erlang':'or' (_2,_3) in call 'erlang':'or' (_1,_4) -> let <File> = apply 'beam_filename'/1 (File0) in case apply 'scan_beam'/2 (File,'info') of <{'ok',Module,ChunkIds0}> when 'true' -> let <_14> = letrec 'lc$^0'/1 = fun (_10) -> case _10 of <[{Name,_19,_20}|_8]> when 'true' -> (case apply 'is_useless_chunk'/1 (Name) of <'false'> when 'true' -> let <_12> = apply 'lc$^0'/1 (_8) in ([Name|_12]-|['compiler_generated'] )
(<'true'> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
(<_cor_variable> when 'true' -> call 'erlang':'error' ('badarg')-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_11> when 'true' -> primop 'match_fail' ({'function_clause',_11})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (ChunkIds0) in case apply 'scan_beam'/2 (File,_14) of <{'ok',_21,Chunks}> when call 'erlang':'=:=' (_21,Module) -> let <_17> = call 'lists':'reverse' (Chunks) in {'ok',{Module,_17}}
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_18> when 'true' -> primop 'match_fail' ({'function_clause',_18})-|['compiler_generated'] ) end-|[{'function',{'read_all_but_useless_chunks',1}}] )-|[{'function',{'read_all_but_useless_chunks',1}}] )
'is_useless_chunk'/1 = (fun (_0) -> (case (_0-|[{'function',{'is_useless_chunk',1}}] ) of <[67|[73|[110|[102]]]]> when 'true' -> 'true'
<_2> when 'true' -> 'false' end-|[{'function',{'is_useless_chunk',1}}] )-|[{'function',{'is_useless_chunk',1}}] )
'read_significant_chunks'/2 = (fun (_0,_1) -> case apply 'read_chunk_data'/3 (_0,_1,['allow_missing_chunks']) of <{'ok',{Module,Chunks0}}> when 'true' -> let <Mandatory> = apply 'mandatory_chunks'/0 () in let <Chunks> = apply 'filter_significant_chunks'/4 (Chunks0,Mandatory,_0,Module) in {'ok',{Module,Chunks}}
(<_4> when 'true' -> primop 'match_fail' ({'case_clause',_4})-|['compiler_generated'] ) end-|[{'function',{'read_significant_chunks',2}}] )
'filter_significant_chunks'/4 = (fun (_0,_1,_2,_3) -> (case <_0,_1,_2,_3> of <[Pair = {_10,Data}|Cs],Mandatory,File,Mod> when call 'erlang':'is_binary' (Data) -> let <_4> = apply 'filter_significant_chunks'/4 (Cs,Mandatory,File,Mod) in [Pair|_4]
<[{Id,'missing_chunk'}|Cs],Mandatory,File,Mod> when 'true' -> case call 'lists':'member' (Id,Mandatory) of <'false'> when 'true' -> apply 'filter_significant_chunks'/4 (Cs,Mandatory,File,Mod)
<'true'> when 'true' -> apply 'error'/1 ({'missing_chunk',File,Id})
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end
<[],_11,_12,_13> when 'true' -> []
(<_9,_8,_7,_6> when 'true' -> primop 'match_fail' ({'function_clause',_9,_8,_7,_6})-|['compiler_generated'] ) end-|[{'function',{'filter_significant_chunks',4}}] )-|[{'function',{'filter_significant_chunks',4}}] )
'filter_funtab'/1 = (fun (_0) -> (case (_0-|[{'function',{'filter_funtab',1}}] ) of <[{Tag = [70|[117|[110|[84]]]],#{#<L>(4,8,'binary',['unsigned'|['big']]),#<Data0>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#}|Cs]> when 'true' -> let <Data> = apply 'filter_funtab_1'/2 (Data0,#{#<0>(8,1,'integer',['unsigned'|['big']]),#<0>(8,1,'integer',['unsigned'|['big']]),#<0>(8,1,'integer',['unsigned'|['big']]),#<0>(8,1,'integer',['unsigned'|['big']])}#) in let <_2> = call 'erlang':'iolist_to_binary' (Data) in let <Funtab> = #{#<L>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']]),#<_2>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}# in let <_4> = apply 'filter_funtab'/1 (Cs) in [{Tag,Funtab}|_4]
<[H|T]> when 'true' -> let <_5> = apply 'filter_funtab'/1 (T) in [H|_5]
<[]> when 'true' -> []
(<_6> when 'true' -> primop 'match_fail' ({'function_clause',_6})-|['compiler_generated'] ) end-|[{'function',{'filter_funtab',1}}] )-|[{'function',{'filter_funtab',1}}] )
'filter_funtab_1'/2 = (fun (_0,_1) -> (case <_0,_1> of <#{#<Important>(20,8,'binary',['unsigned'|['big']]),#<_X_OldUniq>(4,8,'binary',['unsigned'|['big']]),#<T>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#,Zero> when 'true' -> let <_2> = apply 'filter_funtab_1'/2 (T,Zero) in [Important|[Zero|_2]]
<Tail,_5> when call 'erlang':'is_binary' (Tail) -> [Tail|[]]
(<_4,_3> when 'true' -> primop 'match_fail' ({'function_clause',_4,_3})-|['compiler_generated'] ) end-|[{'function',{'filter_funtab_1',2}}] )-|[{'function',{'filter_funtab_1',2}}] )
'read_all_chunks'/1 = (fun (_0) -> (case (_0-|[{'function',{'read_all_chunks',1}}] ) of <File0> when let <_1> = call 'erlang':'is_atom' ((_0-|[{'function',{'read_all_chunks',1}}] )) in let <_2> = call 'erlang':'is_list' ((_0-|[{'function',{'read_all_chunks',1}}] )) in let <_3> = call 'erlang':'is_binary' ((_0-|[{'function',{'read_all_chunks',1}}] )) in let <_4> = call 'erlang':'or' (_2,_3) in call 'erlang':'or' (_1,_4) -> try let <File> = apply 'beam_filename'/1 (File0) in case apply 'scan_beam'/2 (File,'info') of <{'ok',Module,ChunkIds0}> when 'true' -> let <_12> = letrec 'lc$^0'/1 = fun (_9) -> case _9 of <[{Name,_21,_22}|_8]> when 'true' -> let <_11> = apply 'lc$^0'/1 (_8) in ([Name|_11]-|['compiler_generated'] )
(<[_7|_8]> when 'true' -> apply 'lc$^0'/1 (_8)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_10> when 'true' -> primop 'match_fail' ({'function_clause',_10})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (ChunkIds0) in case apply 'scan_beam'/2 (File,_12) of <{'ok',_23,Chunks}> when call 'erlang':'=:=' (_23,Module) -> let <_15> = call 'lists':'reverse' (Chunks) in {'ok',Module,_15}
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end of <_16> -> _16 catch <_19,_18,_17> -> case <_19,_18,_17> of <('throw'-|['compiler_generated'] ),Error,_24> when 'true' -> Error
(<_25,_26,_27> when 'true' -> primop 'raise' (_27,_26)-|['compiler_generated'] ) end
(<_20> when 'true' -> primop 'match_fail' ({'function_clause',_20})-|['compiler_generated'] ) end-|[{'function',{'read_all_chunks',1}}] )-|[{'function',{'read_all_chunks',1}}] )
'read_chunk_data'/2 = (fun (_0,_1) -> try apply 'read_chunk_data'/3 (_0,_1,[]) of <_2> -> _2 catch <_5,_4,_3> -> case <_5,_4,_3> of <('throw'-|['compiler_generated'] ),Error,_8> when 'true' -> Error
(<_9,_10,_11> when 'true' -> primop 'raise' (_11,_10)-|['compiler_generated'] ) end-|[{'function',{'read_chunk_data',2}}] )
'read_chunk_data'/3 = (fun (_0,_1,_2) -> (case <_0,_1,_2> of <File0,ChunkNames0,Options> when let <_3> = call 'erlang':'is_atom' (File0) in let <_4> = call 'erlang':'is_list' (File0) in let <_5> = call 'erlang':'is_binary' (File0) in let <_6> = call 'erlang':'or' (_4,_5) in call 'erlang':'or' (_3,_6) -> let <File> = apply 'beam_filename'/1 (File0) in case apply 'check_chunks'/5 (ChunkNames0,File,[],[],[]) of <{ChunkIds,Names,Optional}> when 'true' -> let <AllowMissingChunks> = call 'lists':'member' ('allow_missing_chunks',Options) in case apply 'scan_beam'/4 (File,ChunkIds,AllowMissingChunks,Optional) of <{'ok',Module,Chunks}> when 'true' -> let <AT> = call 'ets':'new' ('beam_symbols',[]) in let <T> = {'empty',AT} in letrec 'after$^0'/0 = fun () -> call 'ets':'delete' (AT) in try apply 'chunks_to_data'/7 (Names,Chunks,File,Chunks,Module,T,[]) of <_13> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) _13 catch <_16,_15,_14> -> do (apply 'after$^0'/0 ()-|['compiler_generated'] ) primop 'raise' (_14,_15)
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
(<_19,_18,_17> when 'true' -> primop 'match_fail' ({'function_clause',_19,_18,_17})-|['compiler_generated'] ) end-|[{'function',{'read_chunk_data',3}}] )-|[{'function',{'read_chunk_data',3}}] )
'check_chunks'/5 = (fun (_0,_1,_2,_3,_4) -> (case <_0,_1,_2,_3,_4> of <['atoms'|Ids],File,IL,L,O> when 'true' -> apply 'check_chunks'/5 (Ids,File,[[65|[116|[111|[109]]]]|[[65|[116|[85|[56]]]]|IL]],[{'atom_chunk','atoms'}|L],[[65|[116|[111|[109]]]]|[[65|[116|[85|[56]]]]|O]])
<['abstract_code'|Ids],File,IL,L,O> when 'true' -> apply 'check_chunks'/5 (Ids,File,[[65|[98|[115|[116]]]]|[[68|[98|[103|[105]]]]|IL]],[{'abst_chunk','abstract_code'}|L],[[65|[98|[115|[116]]]]|[[68|[98|[103|[105]]]]|O]])
<[ChunkName|Ids],File,IL,L,O> when call 'erlang':'is_atom' (ChunkName) -> let <ChunkId> = apply 'chunk_name_to_id'/2 (ChunkName,File) in apply 'check_chunks'/5 (Ids,File,[ChunkId|IL],[{ChunkId,ChunkName}|L],O)
<[ChunkId|Ids],File,IL,L,O> when 'true' -> apply 'check_chunks'/5 (Ids,File,[ChunkId|IL],[{ChunkId,ChunkId}|L],O)
<[],_X_File,IL,L,O> when 'true' -> let <_7> = call 'lists':'usort' (IL) in let <_6> = call 'lists':'reverse' (L) in {_7,_6,O}
(<_12,_11,_10,_9,_8> when 'true' -> primop 'match_fail' ({'function_clause',_12,_11,_10,_9,_8})-|['compiler_generated'] ) end-|[{'function',{'check_chunks',5}}] )-|[{'function',{'check_chunks',5}}] )
'scan_beam'/2 = (fun (_0,_1) -> apply 'scan_beam'/4 (_0,_1,'false',[])-|[{'function',{'scan_beam',2}}] )
'scan_beam'/4 = (fun (_0,_1,_2,_3) -> case apply 'scan_beam1'/2 (_0,_1) of <{'missing',_X_FD,Mod,Data,What}> when (call 'erlang':'=:=' (_2,'true')-|['compiler_generated'] ) -> let <_9> = letrec 'lc$^0'/1 = fun (_6) -> case _6 of <[Id|_5]> when 'true' -> let <_8> = apply 'lc$^0'/1 (_5) in ([{Id,'missing_chunk'}|_8]-|['compiler_generated'] )
<[]> when 'true' -> Data
(<_7> when 'true' -> primop 'match_fail' ({'function_clause',_7})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (What) in {'ok',Mod,_9}
<{'missing',FD,Mod,Data,What}> when 'true' -> case call 'erlang':'--' (What,_3) of <[]> when 'true' -> {'ok',Mod,Data}
<[Missing|_17]> when 'true' -> let <_10> = apply 'filename'/1 (FD) in apply 'error'/1 ({'missing_chunk',_10,Missing})
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end
<R> when 'true' -> R end-|[{'function',{'scan_beam',4}}] )
'scan_beam1'/2 = (fun (_0,_1) -> let <FD> = apply 'open_file'/1 (_0) in let <_3> = catch apply 'scan_beam2'/2 (FD,_1) in case _3 of <Error> when try let <_4> = call 'erlang':'element' (1,_3) in call 'erlang':'=:=' ('error',_4) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'throw' (Error)
<R> when 'true' -> R end-|[{'function',{'scan_beam1',2}}] )
'scan_beam2'/2 = (fun (_0,_1) -> case apply 'pread'/3 (_0,0,12) of <{NFD,{'ok',#{#<70>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<49>(8,1,'integer',['unsigned'|['big']]),#<_X_Size>(32,1,'integer',['unsigned'|['big']]),#<66>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<65>(8,1,'integer',['unsigned'|['big']]),#<77>(8,1,'integer',['unsigned'|['big']])}#}}> when 'true' -> apply 'scan_beam'/5 (NFD,12,_1,17,[])
<_X_Error> when 'true' -> let <_3> = apply 'filename'/1 (_0) in apply 'error'/1 ({'not_a_beam_file',_3}) end-|[{'function',{'scan_beam2',2}}] )
'scan_beam'/5 = (fun (_0,_1,_2,_3,_4) -> (case <_0,_1,_2,_3,_4> of <_X_FD,_X_Pos,[],Mod,Data> when call 'erlang':'=/=' (Mod,17) -> {'ok',Mod,Data}
<FD,Pos,What,Mod,Data> when 'true' -> case apply 'pread'/3 (FD,Pos,8) of <{_X_NFD,'eof'}> when call 'erlang':'=:=' (Mod,17) -> let <_5> = apply 'filename'/1 (FD) in apply 'error'/1 ({'missing_chunk',_5,[65|[116|[111|[109]]]]})
<{_X_NFD,'eof'}> when call 'erlang':'=:=' (What,'info') -> let <_6> = call 'lists':'reverse' (Data) in {'ok',Mod,_6}
<{NFD,'eof'}> when 'true' -> {'missing',NFD,Mod,Data,What}
<{NFD,{'ok',#{#<IdL>(4,8,'binary',['unsigned'|['big']]),#<Sz>(32,1,'integer',['unsigned'|['big']])}#}}> when 'true' -> let <Id> = call 'erlang':'binary_to_list' (IdL) in let <Pos1> = call 'erlang':'+' (Pos,8) in let <_9> = call 'erlang':'+' (Sz,3) in let <_10> = call 'erlang':'/' (_9,4) in let <_11> = call 'erlang':'trunc' (_10) in let <_12> = call 'erlang':'*' (4,_11) in let <Pos2> = call 'erlang':'+' (_12,Pos1) in apply 'get_data'/8 (What,Id,NFD,Sz,Pos1,Pos2,Mod,Data)
<{_X_NFD,{'ok',_X_ChunkHead}}> when 'true' -> let <_14> = apply 'filename'/1 (FD) in apply 'error'/1 ({'invalid_beam_file',_14,Pos})
(<_15> when 'true' -> primop 'match_fail' ({'case_clause',_15})-|['compiler_generated'] ) end end-|[{'function',{'scan_beam',5}}] )-|[{'function',{'scan_beam',5}}] )
'get_atom_data'/8 = (fun (_0,_1,_2,_3,_4,_5,_6,_7) -> let <NewCs> = apply 'del_chunk'/2 (_1,_0) in case apply 'get_chunk'/4 (_1,_4,_3,_2) of <{NFD,Chunk}> when 'true' -> case Chunk of <#{#<_X_Num>(32,1,'integer',['unsigned'|['big']]),#<Chunk2>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#> when 'true' -> case apply 'extract_atom'/2 (Chunk2,_7) of <{Module,_23}> when 'true' -> let <_13> = case _0 of <'info'> when 'true' -> {_1,_4,_3}
<_24> when 'true' -> {_1,Chunk} end in apply 'scan_beam'/5 (NFD,_5,NewCs,Module,[_13|_6])
(<_11> when 'true' -> primop 'match_fail' ({'badmatch',_11})-|['compiler_generated'] ) end
(<_10> when 'true' -> primop 'match_fail' ({'badmatch',_10})-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'badmatch',_9})-|['compiler_generated'] ) end-|[{'function',{'get_atom_data',8}}] )
'get_data'/8 = (fun (_0,_1,_2,_3,_4,_5,_6,_7) -> (case <_0,_1,_2,_3,_4,_5,_6,_7> of <Cs,Id = [65|[116|[111|[109]]]],FD,Size,Pos,Pos2,_X_Mod,Data> when 'true' -> apply 'get_atom_data'/8 (Cs,Id,FD,Size,Pos,Pos2,Data,'latin1')
<Cs,Id = [65|[116|[85|[56]]]],FD,Size,Pos,Pos2,_X_Mod,Data> when 'true' -> apply 'get_atom_data'/8 (Cs,Id,FD,Size,Pos,Pos2,Data,'utf8')
<'info',Id,FD,Size,Pos,Pos2,Mod,Data> when 'true' -> apply 'scan_beam'/5 (FD,Pos2,'info',Mod,[{Id,Pos,Size}|Data])
<Chunks,Id,FD,Size,Pos,Pos2,Mod,Data> when 'true' -> let <_21,_22> = case call 'lists':'member' (Id,Chunks) of <'true'> when 'true' -> case apply 'get_chunk'/4 (Id,Pos,Size,FD) of <{FD1,Chunk}> when 'true' -> <FD1,[{Id,Chunk}|Data]>
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end
<'false'> when 'true' -> <FD,Data>
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end in let <NewChunks> = apply 'del_chunk'/2 (Id,Chunks) in apply 'scan_beam'/5 ((_21-|['compiler_generated'] ),Pos2,NewChunks,Mod,(_22-|['compiler_generated'] )) end-|[{'function',{'get_data',8}}] )-|[{'function',{'get_data',8}}] )
'del_chunk'/2 = (fun (_0,_1) -> (case <_0,_1> of <_X_Id,'info'> when 'true' -> 'info'
<Id,Chunks> when 'true' -> call 'lists':'delete' (Id,Chunks) end-|[{'function',{'del_chunk',2}}] )-|[{'function',{'del_chunk',2}}] )
'get_chunk'/4 = (fun (_0,_1,_2,_3) -> case apply 'pread'/3 (_3,_1,_2) of <{NFD,'eof'}> when call 'erlang':'=:=' (_2,0) -> {NFD,#{}#}
<{_X_NFD,'eof'}> when call 'erlang':'>' (_2,0) -> let <_4> = apply 'filename'/1 (_3) in apply 'error'/1 ({'chunk_too_big',_4,_0,_2,0})
<{_X_NFD,{'ok',Chunk}}> when try let <_5> = call 'erlang':'byte_size' (Chunk) in call 'erlang':'>' (_2,_5) of <Try> -> Try catch <T,R> -> 'false' -> let <_7> = apply 'filename'/1 (_3) in let <_6> = call 'erlang':'byte_size' (Chunk) in apply 'error'/1 ({'chunk_too_big',_7,_0,_2,_6})
<{NFD,{'ok',Chunk}}> when 'true' -> {NFD,Chunk}
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end-|[{'function',{'get_chunk',4}}] )
'chunks_to_data'/7 = (fun (_0,_1,_2,_3,_4,_5,_6) -> (case <_0,_1,_2,_3,_4,_5,_6> of <[{'atom_chunk',Name}|CNs],Chunks,File,Cs,Module,Atoms,L> when 'true' -> case apply 'chunk_to_data'/6 (Name,#{}#,File,Cs,Atoms,Module) of <{NewAtoms,Ret}> when 'true' -> apply 'chunks_to_data'/7 (CNs,Chunks,File,Cs,Module,NewAtoms,[Ret|L])
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<[{'abst_chunk',Name}|CNs],Chunks,File,Cs,Module,Atoms,L> when 'true' -> let <DbgiChunk> = call 'proplists':'get_value' ([68|[98|[103|[105]]]],Chunks,#{}#) in let <_9> = catch apply 'chunk_to_data'/6 ('debug_info',DbgiChunk,File,Cs,Atoms,Module) in let <_13> = case _9 of <{DbgiAtoms,{'debug_info',{'debug_info_v1',Backend,Metadata}}}> when 'true' -> case call Backend:'debug_info' ('erlang_v1',Module,Metadata,[]) of <{'ok',Code}> when 'true' -> {DbgiAtoms,{'abstract_code',{'raw_abstract_v1',Code}}}
<{'error',_25}> when 'true' -> {DbgiAtoms,{'abstract_code','no_abstract_code'}}
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
<{'error','beam_lib',{'key_missing_or_invalid',Path,'debug_info'}}> when 'true' -> apply 'error'/1 ({'key_missing_or_invalid',Path,'abstract_code'})
<_26> when 'true' -> let <AbstChunk> = call 'proplists':'get_value' ([65|[98|[115|[116]]]],Chunks,#{}#) in apply 'chunk_to_data'/6 (Name,AbstChunk,File,Cs,Atoms,Module) end in case _13 of <{NewAtoms,Ret}> when 'true' -> apply 'chunks_to_data'/7 (CNs,Chunks,File,Cs,Module,NewAtoms,[Ret|L])
(<_14> when 'true' -> primop 'match_fail' ({'badmatch',_14})-|['compiler_generated'] ) end
<[{Id,Name}|CNs],Chunks,File,Cs,Module,Atoms,L> when 'true' -> case call 'lists':'keyfind' (Id,1,Chunks) of <{_X_Id,Chunk}> when 'true' -> case apply 'chunk_to_data'/6 (Name,Chunk,File,Cs,Atoms,Module) of <{NewAtoms,Ret}> when 'true' -> apply 'chunks_to_data'/7 (CNs,Chunks,File,Cs,Module,NewAtoms,[Ret|L])
(<_16> when 'true' -> primop 'match_fail' ({'badmatch',_16})-|['compiler_generated'] ) end
(<_15> when 'true' -> primop 'match_fail' ({'badmatch',_15})-|['compiler_generated'] ) end
<[],_X_Chunks,_X_File,_X_Cs,Module,_X_Atoms,L> when 'true' -> let <_17> = call 'lists':'reverse' (L) in {'ok',{Module,_17}}
(<_24,_23,_22,_21,_20,_19,_18> when 'true' -> primop 'match_fail' ({'function_clause',_24,_23,_22,_21,_20,_19,_18})-|['compiler_generated'] ) end-|[{'function',{'chunks_to_data',7}}] )-|[{'function',{'chunks_to_data',7}}] )
'chunk_to_data'/6 = (fun (_0,_1,_2,_3,_4,_5) -> (case <_0,_1,_2,_3,_4,_5> of <Id = 'attributes',Chunk,File,_X_Cs,AtomTable,_X_Mod> when 'true' -> try let <Term> = call 'erlang':'binary_to_term' (Chunk) in let <_7> = apply 'attributes'/1 (Term) in {AtomTable,{Id,_7}} of <_8> -> _8 catch <_11,_10,_9> -> case <_11,_10,_9> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_52> when 'true' -> let <_12> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_12})
(<_68,_69,_70> when 'true' -> primop 'raise' (_70,_69)-|['compiler_generated'] ) end
<Id = 'compile_info',Chunk,File,_X_Cs,AtomTable,_X_Mod> when 'true' -> try let <_13> = call 'erlang':'binary_to_term' (Chunk) in {AtomTable,{Id,_13}} of <_14> -> _14 catch <_17,_16,_15> -> case <_17,_16,_15> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_53> when 'true' -> let <_18> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_18})
(<_71,_72,_73> when 'true' -> primop 'raise' (_73,_72)-|['compiler_generated'] ) end
<Id = 'debug_info',Chunk,File,_X_Cs,AtomTable,Mod> when 'true' -> (letrec 'label^0'/0 = (fun () -> let <_22> = catch call 'erlang':'binary_to_term' (Chunk) in case _22 of <{'EXIT',_55}> when 'true' -> let <_23> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_23})
<Term> when 'true' -> let <_24> = apply 'anno_from_term'/1 (Term) in {AtomTable,{Id,_24}} end-|['compiler_generated'] ) in case Chunk of <#{}#> when 'true' -> {AtomTable,{Id,'no_debug_info'}}
<#{#<0>(8,1,'integer',['unsigned'|['big']]),#<N>(8,1,'integer',['unsigned'|['big']]),#<_62>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> case _62 of <#{#<Mode0>(N,8,'binary',['unsigned'|['big']]),#<Rest>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Mode> = call 'erlang':'binary_to_atom' (Mode0,'utf8') in let <Term> = apply 'decrypt_chunk'/5 (Mode,Mod,File,Id,Rest) in let <_21> = apply 'anno_from_term'/1 (Term) in {AtomTable,{Id,_21}}
(<_63> when 'true' -> (apply 'label^0'/0 ()-|['compiler_generated'] )-|['dialyzer_ignore','compiler_generated'] ) end
(<_64> when 'true' -> (apply 'label^0'/0 ()-|['compiler_generated'] )-|['dialyzer_ignore','compiler_generated'] ) end-|['letrec_goto'] )
<Id = 'abstract_code',Chunk,File,_X_Cs,AtomTable,Mod> when 'true' -> (letrec 'label^1'/0 = (fun () -> let <_30> = catch call 'erlang':'binary_to_term' (Chunk) in case _30 of <{'EXIT',_57}> when 'true' -> let <_31> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_31})
<Term> when 'true' -> try let <_32> = apply 'old_anno_from_term'/1 (Term) in {AtomTable,{Id,_32}} of <_33> -> _33 catch <_36,_35,_34> -> let <_37> = apply 'chunk_name_to_id'/2 (Id,File) in apply 'error'/1 ({'invalid_chunk',File,_37}) end-|['compiler_generated'] ) in case Chunk of <#{}#> when 'true' -> {AtomTable,{Id,'no_abstract_code'}}
<#{#<0>(8,1,'integer',['unsigned'|['big']]),#<N>(8,1,'integer',['unsigned'|['big']]),#<_65>('all',1,'binary',['unsigned'|['big']])}#> when 'true' -> case _65 of <#{#<Mode0>(N,8,'binary',['unsigned'|['big']]),#<Rest>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#> when 'true' -> let <Mode> = call 'erlang':'binary_to_atom' (Mode0,'utf8') in let <Term> = apply 'decrypt_chunk'/5 (Mode,Mod,File,Id,Rest) in let <_29> = apply 'old_anno_from_term'/1 (Term) in {AtomTable,{Id,_29}}
(<_66> when 'true' -> (apply 'label^1'/0 ()-|['compiler_generated'] )-|['dialyzer_ignore','compiler_generated'] ) end
(<_67> when 'true' -> (apply 'label^1'/0 ()-|['compiler_generated'] )-|['dialyzer_ignore','compiler_generated'] ) end-|['letrec_goto'] )
<Id = 'atoms',_X_Chunk,_X_File,Cs,AtomTable0,_X_Mod> when 'true' -> let <AtomTable> = apply 'ensure_atoms'/2 (AtomTable0,Cs) in let <Atoms> = call 'ets':'tab2list' (AtomTable) in let <_42> = call 'lists':'sort' (Atoms) in {AtomTable,{Id,_42}}
<ChunkName,Chunk,File,Cs,AtomTable,_X_Mod> when call 'erlang':'is_atom' (ChunkName) -> let <_43> = catch apply 'symbols'/4 (Chunk,AtomTable,Cs,ChunkName) in case _43 of <{'ok',NewAtomTable,S}> when 'true' -> {NewAtomTable,{ChunkName,S}}
<{'EXIT',_61}> when 'true' -> let <_44> = apply 'chunk_name_to_id'/2 (ChunkName,File) in apply 'error'/1 ({'invalid_chunk',File,_44})
(<_45> when 'true' -> primop 'match_fail' ({'case_clause',_45})-|['compiler_generated'] ) end
<ChunkId,Chunk,_X_File,_X_Cs,AtomTable,_X_Module> when call 'erlang':'is_list' (ChunkId) -> {AtomTable,{ChunkId,Chunk}}
(<_51,_50,_49,_48,_47,_46> when 'true' -> primop 'match_fail' ({'function_clause',_51,_50,_49,_48,_47,_46})-|['compiler_generated'] ) end-|[{'function',{'chunk_to_data',6}}] )-|[{'function',{'chunk_to_data',6}}] )
'chunk_name_to_id'/2 = (fun (_0,_1) -> (case <_0,_1> of <'indexed_imports',_4> when 'true' -> [73|[109|[112|[84]]]]
<'imports',_5> when 'true' -> [73|[109|[112|[84]]]]
<'exports',_6> when 'true' -> [69|[120|[112|[84]]]]
<'labeled_exports',_7> when 'true' -> [69|[120|[112|[84]]]]
<'locals',_8> when 'true' -> [76|[111|[99|[84]]]]
<'labeled_locals',_9> when 'true' -> [76|[111|[99|[84]]]]
<'attributes',_10> when 'true' -> [65|[116|[116|[114]]]]
<'abstract_code',_11> when 'true' -> [65|[98|[115|[116]]]]
<'debug_info',_12> when 'true' -> [68|[98|[103|[105]]]]
<'compile_info',_13> when 'true' -> [67|[73|[110|[102]]]]
<Other,File> when 'true' -> apply 'error'/1 ({'unknown_chunk',File,Other}) end-|[{'function',{'chunk_name_to_id',2}}] )-|[{'function',{'chunk_name_to_id',2}}] )
'attributes'/1 = (fun (_0) -> let <_1> = call 'lists':'keysort' (1,(_0-|[{'function',{'attributes',1}}] )) in apply 'attributes'/2 (_1,[])-|[{'function',{'attributes',1}}] )
'attributes'/2 = (fun (_0,_1) -> (case <_0,_1> of <[],R> when 'true' -> call 'lists':'reverse' (R)
<L,R> when 'true' -> let <_2> = call 'erlang':'hd' (L) in let <K> = call 'erlang':'element' (1,_2) in let <_7> = fun (_5) -> let <_4> = call 'erlang':'element' (1,_5) in call 'erlang':'=:=' (_4,K) in case call 'lists':'splitwith' (_7,L) of <{L1,L2}> when 'true' -> let <_14> = letrec 'lc$^1'/1 = fun (_11) -> case _11 of <[{_18,A}|_10]> when 'true' -> let <_13> = apply 'lc$^1'/1 (_10) in ([A|_13]-|['compiler_generated'] )
(<[_9|_10]> when 'true' -> apply 'lc$^1'/1 (_10)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_12> when 'true' -> primop 'match_fail' ({'function_clause',_12})-|['compiler_generated'] ) end in apply 'lc$^1'/1 (L1) in let <V> = call 'lists':'append' (_14) in apply 'attributes'/2 (L2,[{K,V}|R])
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end-|[{'function',{'attributes',2}}] )-|[{'function',{'attributes',2}}] )
'symbols'/4 = (fun (_0,_1,_2,_3) -> (case <_0,_1,_2,_3> of <#{#<_X_Num>(32,1,'integer',['unsigned'|['big']]),#<B>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#,AT0,Cs,Name> when 'true' -> let <AT> = apply 'ensure_atoms'/2 (AT0,Cs) in apply 'symbols1'/5 (B,AT,Name,[],1)
(<_8,_7,_6,_5> when 'true' -> primop 'match_fail' ({'function_clause',_8,_7,_6,_5})-|['compiler_generated'] ) end-|[{'function',{'symbols',4}}] )-|[{'function',{'symbols',4}}] )
'symbols1'/5 = (fun (_0,_1,_2,_3,_4) -> (case <_0,_1,_2,_3,_4> of <#{#<I1>(32,1,'integer',['unsigned'|['big']]),#<I2>(32,1,'integer',['unsigned'|['big']]),#<I3>(32,1,'integer',['unsigned'|['big']]),#<B>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#,AT,Name,S,Cnt> when 'true' -> let <Symbol> = apply 'symbol'/6 (Name,AT,I1,I2,I3,Cnt) in let <_6> = call 'erlang':'+' (Cnt,1) in apply 'symbols1'/5 (B,AT,Name,[Symbol|S],_6)
<#{}#,AT,_X_Name,S,_X_Cnt> when 'true' -> let <_7> = call 'lists':'sort' (S) in {'ok',AT,_7}
(<_12,_11,_10,_9,_8> when 'true' -> primop 'match_fail' ({'function_clause',_12,_11,_10,_9,_8})-|['compiler_generated'] ) end-|[{'function',{'symbols1',5}}] )-|[{'function',{'symbols1',5}}] )
'symbol'/6 = (fun (_0,_1,_2,_3,_4,_5) -> (case <_0,_1,_2,_3,_4,_5> of <'indexed_imports',AT,I1,I2,I3,Cnt> when 'true' -> let <_7> = apply 'atm'/2 (AT,I1) in let <_6> = apply 'atm'/2 (AT,I2) in {Cnt,_7,_6,I3}
<'imports',AT,I1,I2,I3,_X_Cnt> when 'true' -> let <_9> = apply 'atm'/2 (AT,I1) in let <_8> = apply 'atm'/2 (AT,I2) in {_9,_8,I3}
<'labeled_exports',AT,I1,I2,I3,_X_Cnt> when 'true' -> let <_10> = apply 'atm'/2 (AT,I1) in {_10,I2,I3}
<'labeled_locals',AT,I1,I2,I3,_X_Cnt> when 'true' -> let <_11> = apply 'atm'/2 (AT,I1) in {_11,I2,I3}
<_19,AT,I1,I2,_X_I3,_X_Cnt> when 'true' -> let <_12> = apply 'atm'/2 (AT,I1) in {_12,I2} end-|[{'function',{'symbol',6}}] )-|[{'function',{'symbol',6}}] )
'atm'/2 = (fun (_0,_1) -> case call 'ets':'lookup' (_0,_1) of <[{_X_N,S}|[]]> when 'true' -> S
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end-|[{'function',{'atm',2}}] )
'ensure_atoms'/2 = (fun (_0,_1) -> (case <_0,_1> of <{'empty',AT},Cs> when 'true' -> do case call 'lists':'keyfind' ([65|[116|[85|[56]]]],1,Cs) of <{_X_Id,AtomChunk}> when call 'erlang':'is_binary' (AtomChunk) -> apply 'extract_atoms'/3 (AtomChunk,AT,'utf8')
<_6> when 'true' -> case call 'lists':'keyfind' ([65|[116|[111|[109]]]],1,Cs) of <{_X_Id,AtomChunk}> when 'true' -> apply 'extract_atoms'/3 (AtomChunk,AT,'latin1')
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end end AT
<AT,_X_Cs> when 'true' -> AT end-|[{'function',{'ensure_atoms',2}}] )-|[{'function',{'ensure_atoms',2}}] )
'extract_atoms'/3 = (fun (_0,_1,_2) -> (case <_0,_1,_2> of <#{#<_X_Num>(32,1,'integer',['unsigned'|['big']]),#<B>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#,AT,Encoding> when 'true' -> apply 'extract_atoms'/4 (B,1,AT,Encoding)
(<_5,_4,_3> when 'true' -> primop 'match_fail' ({'function_clause',_5,_4,_3})-|['compiler_generated'] ) end-|[{'function',{'extract_atoms',3}}] )-|[{'function',{'extract_atoms',3}}] )
'extract_atoms'/4 = (fun (_0,_1,_2,_3) -> (case <_0,_1,_2,_3> of <#{}#,_X_I,_X_AT,_X_Encoding> when 'true' -> 'true'
<B,I,AT,Encoding> when 'true' -> case apply 'extract_atom'/2 (B,Encoding) of <{Atom,B1}> when 'true' -> case call 'ets':'insert' (AT,{I,Atom}) of <'true'> when 'true' -> let <_6> = call 'erlang':'+' (I,1) in apply 'extract_atoms'/4 (B1,_6,AT,Encoding)
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end end-|[{'function',{'extract_atoms',4}}] )-|[{'function',{'extract_atoms',4}}] )
'extract_atom'/2 = (fun (_0,_1) -> (case <_0,_1> of <#{#<Len>(8,1,'integer',['unsigned'|['big']]),#<B>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#,Encoding> when 'true' -> case B of <#{#<SB>(Len,8,'binary',['unsigned'|['big']]),#<Tail>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_3> = call 'erlang':'binary_to_atom' (SB,Encoding) in {_3,Tail}
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_5,_4> when 'true' -> primop 'match_fail' ({'function_clause',_5,_4})-|['compiler_generated'] ) end-|[{'function',{'extract_atom',2}}] )-|[{'function',{'extract_atom',2}}] )
'open_file'/1 = (fun (_0) -> (case (_0-|[{'function',{'open_file',1}}] ) of <Binary = #{#<70>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<49>(8,1,'integer',['unsigned'|['big']]),#<_4>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#> when 'true' -> {'bb',0,Binary,Binary}
<Binary0> when call 'erlang':'is_binary' ((_0-|[{'function',{'open_file',1}}] )) -> let <Binary> = apply 'uncompress'/1 (Binary0) in {'bb',0,Binary,Binary}
<FileName> when 'true' -> case call 'file':'open' (FileName,['read'|['raw'|['binary']]]) of <{'ok',Fd}> when 'true' -> apply 'read_all'/3 (Fd,FileName,[])
<Error> when 'true' -> apply 'file_error'/2 (FileName,Error) end end-|[{'function',{'open_file',1}}] )-|[{'function',{'open_file',1}}] )
'read_all'/3 = (fun (_0,_1,_2) -> case call 'file':'read' (_0,262144) of <{'ok',Bin}> when 'true' -> apply 'read_all'/3 (_0,_1,[Bin|_2])
<'eof'> when 'true' -> case call 'file':'close' (_0) of <'ok'> when 'true' -> let <_5> = call 'lists':'reverse' (_2) in let <_6> = apply 'uncompress'/1 (_5) in {'bb',0,_6,_1}
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<Error> when 'true' -> case call 'file':'close' (_0) of <'ok'> when 'true' -> apply 'file_error'/2 (_1,Error)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end end-|[{'function',{'read_all',3}}] )
'pread'/3 = (fun (_0,_1,_2) -> case _0 of <{'bb',Pos,Binary,_21}> when 'true' -> let <Skip> = call 'erlang':'-' (_1,Pos) in case Binary of <#{#<_22>(Skip,8,'binary',['unsigned'|['big']]),#<B>(_2,8,'binary',['unsigned'|['big']]),#<Bin>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#> when 'true' -> let <_rec0> = call 'erlang':'+' (_1,_2) in case _0 of <{'bb',_rec2,_rec3,_rec4}> when 'true' -> let <_8> = {'bb',_rec0,Bin,_rec4} in {_8,{'ok',B}}
(<_23> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<#{#<_24>(Skip,8,'binary',['unsigned'|['big']]),#<Bin>(('all'-|['compiler_generated'] ),8,'binary',['unsigned'|['big']])}#> when try let <_10> = call 'erlang':'byte_size' (Bin) in call 'erlang':'>' (_10,0) of <Try> -> Try catch <T,R> -> 'false' -> let <_11> = call 'erlang':'byte_size' (Bin) in let <_rec5> = call 'erlang':'+' (_1,_11) in case _0 of <{'bb',_rec7,_rec8,_rec9}> when 'true' -> let <_15> = {'bb',_rec5,#{}#,_rec9} in {_15,{'ok',Bin}}
(<_25> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<_26> when 'true' -> {_0,'eof'} end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end-|[{'function',{'pread',3}}] )
'filename'/1 = (fun (_0) -> (case (_0-|[{'function',{'filename',1}}] ) of <BB = {'bb',_11,_12,_13}> when (try let <_5> = call 'erlang':'element' (4,BB) in let <_6> = call 'erlang':'is_binary' (_5) in (call ('erlang'-|['compiler_generated'] ):('and'-|['compiler_generated'] ) (('true'-|['compiler_generated'] ),_6)-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false'-|['compiler_generated'] ) -> (case BB of (<({'bb',_14,_15,_rec10}-|['compiler_generated'] )> when 'true' -> _rec10-|['compiler_generated'] )
(<_16> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<BB> when 'true' -> (case BB of (<({'bb',_17,_18,_rec11}-|['compiler_generated'] )> when 'true' -> call 'erlang':'list_to_atom' (_rec11)-|['compiler_generated'] )
(<_19> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','bb'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] ) end-|[{'function',{'filename',1}}] )-|[{'function',{'filename',1}}] )
'beam_filename'/1 = (fun (_0) -> (case (_0-|[{'function',{'beam_filename',1}}] ) of <Bin> when call 'erlang':'is_binary' ((_0-|[{'function',{'beam_filename',1}}] )) -> Bin
<File> when 'true' -> let <_1> = call 'filename':'rootname' (File,[46|[98|[101|[97|[109]]]]]) in call 'erlang':'++' (_1,[46|[98|[101|[97|[109]]]]]) end-|[{'function',{'beam_filename',1}}] )-|[{'function',{'beam_filename',1}}] )
'uncompress'/1 = (fun (_0) -> case call 'ram_file':'open' ((_0-|[{'function',{'uncompress',1}}] ),['write'|['binary']]) of <{'ok',Fd}> when 'true' -> case call 'ram_file':'uncompress' (Fd) of <{'ok',_6}> when 'true' -> case call 'ram_file':'get_file' (Fd) of <{'ok',Binary}> when 'true' -> case call 'ram_file':'close' (Fd) of <'ok'> when 'true' -> Binary
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end-|[{'function',{'uncompress',1}}] )
'compress'/1 = (fun (_0) -> case call 'ram_file':'open' ((_0-|[{'function',{'compress',1}}] ),['write'|['binary']]) of <{'ok',Fd}> when 'true' -> case call 'ram_file':'compress' (Fd) of <{'ok',_6}> when 'true' -> case call 'ram_file':'get_file' (Fd) of <{'ok',Binary}> when 'true' -> case call 'ram_file':'close' (Fd) of <'ok'> when 'true' -> Binary
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end-|[{'function',{'compress',1}}] )
'assert_directory'/1 = (fun (_0) -> case call 'filelib':'is_dir' ((_0-|[{'function',{'assert_directory',1}}] )) of <'true'> when 'true' -> 'ok'
<'false'> when 'true' -> apply 'error'/1 ({'not_a_directory',(_0-|[{'function',{'assert_directory',1}}] )})
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end-|[{'function',{'assert_directory',1}}] )
'file_error'/2 = (fun (_0,_1) -> (case <_0,_1> of <FileName,{'error',Reason}> when 'true' -> apply 'error'/1 ({'file_error',FileName,Reason})
(<_3,_2> when 'true' -> primop 'match_fail' ({'function_clause',_3,_2})-|['compiler_generated'] ) end-|[{'function',{'file_error',2}}] )-|[{'function',{'file_error',2}}] )
'error'/1 = (fun (_0) -> call 'erlang':'throw' ({'error','beam_lib',(_0-|[{'function',{'error',1}}] )})-|[{'function',{'error',1}}] )
'significant_chunks'/0 = (fun () -> let <_0> = apply 'md5_chunks'/0 () in [[76|[105|[110|[101]]]]|_0]-|[{'function',{'significant_chunks',0}}] )
'md5_chunks'/0 = (fun () -> [[65|[116|[111|[109]]]]|[[65|[116|[85|[56]]]]|[[67|[111|[100|[101]]]]|[[83|[116|[114|[84]]]]|[[73|[109|[112|[84]]]]|[[69|[120|[112|[84]]]]|[[70|[117|[110|[84]]]]|[[76|[105|[116|[84]]]]]]]]]]]]-|[{'function',{'md5_chunks',0}}] )
'mandatory_chunks'/0 = (fun () -> [[67|[111|[100|[101]]]]|[[69|[120|[112|[84]]]]|[[73|[109|[112|[84]]]]|[[83|[116|[114|[84]]]]]]]]-|[{'function',{'mandatory_chunks',0}}] )
'decrypt_chunk'/5 = (fun (_0,_1,_2,_3,_4) -> try let <KeyString> = apply 'get_crypto_key'/1 ({'debug_info',_0,_1,_2}) in case apply 'make_crypto_key'/2 (_0,KeyString) of <{_18,Key,IVec,_X_BlockSize}> when call 'erlang':'=:=' (_18,_0) -> case apply 'start_crypto'/0 () of <'ok'> when 'true' -> let <NewBin> = call 'crypto':'crypto_one_time' ('des_ede3_cbc',Key,IVec,_4,'false') in call 'erlang':'binary_to_term' (NewBin)
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end of <_9> -> _9 catch <_12,_11,_10> -> apply 'error'/1 ({'key_missing_or_invalid',_2,_3})-|[{'function',{'decrypt_chunk',5}}] )
'old_anno_from_term'/1 = (fun (_0) -> (case (_0-|[{'function',{'old_anno_from_term',1}}] ) of <{'raw_abstract_v1',Forms}> when 'true' -> let <_1> = apply 'anno_from_forms'/1 (Forms) in {'raw_abstract_v1',_1}
<_@r0 = {Tag,Forms}> when let <_2> = call 'erlang':'=:=' (Tag,'abstract_v1') in let <_3> = call 'erlang':'=:=' (Tag,'abstract_v2') in call 'erlang':'or' (_2,_3) -> try let <_4> = apply 'anno_from_forms'/1 (Forms) in {Tag,_4} of <_5> -> _5 catch <_8,_7,_6> -> _@r0
<T> when 'true' -> T end-|[{'function',{'old_anno_from_term',1}}] )-|[{'function',{'old_anno_from_term',1}}] )
'anno_from_term'/1 = (fun (_0) -> (case (_0-|[{'function',{'anno_from_term',1}}] ) of <_@r0 = {Tag1 = 'debug_info_v1',Tag2 = 'erl_abstract_code',{Forms,Opts}}> when 'true' -> try let <_1> = apply 'anno_from_forms'/1 (Forms) in {Tag1,Tag2,{_1,Opts}} of <_2> -> _2 catch <_5,_4,_3> -> _@r0
<T> when 'true' -> T end-|[{'function',{'anno_from_term',1}}] )-|[{'function',{'anno_from_term',1}}] )
'anno_from_forms'/1 = (fun (_0) -> let <Forms> = call 'epp':'restore_typed_record_fields' ((_0-|[{'function',{'anno_from_forms',1}}] )) in (letrec 'lc$^0'/1 = fun (_4) -> case _4 of <[Form|_3]> when 'true' -> let <_6> = call 'erl_parse':'anno_from_term' (Form) in let <_7> = apply 'lc$^0'/1 (_3) in ([_6|_7]-|['compiler_generated'] )
<[]> when 'true' -> []
(<_5> when 'true' -> primop 'match_fail' ({'function_clause',_5})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (Forms)-|['list_comprehension'] )-|[{'function',{'anno_from_forms',1}}] )
'start_crypto'/0 = (fun () -> case call 'crypto':'start' () of <{'error',{'already_started',_1}}> when 'true' -> 'ok'
<'ok'> when 'true' -> 'ok'
(<_0> when 'true' -> primop 'match_fail' ({'case_clause',_0})-|['compiler_generated'] ) end-|[{'function',{'start_crypto',0}}] )
'get_crypto_key'/1 = (fun (_0) -> apply 'call_crypto_server'/1 ({'get_crypto_key',(_0-|[{'function',{'get_crypto_key',1}}] )})-|[{'function',{'get_crypto_key',1}}] )
'call_crypto_server'/1 = (fun (_0) -> try call 'gen_server':'call' ('beam_lib__crypto_key_server',(_0-|[{'function',{'call_crypto_server',1}}] ),'infinity') of <_1> -> _1 catch <_4,_3,_2> -> case <_4,_3,_2> of <('exit'-|['compiler_generated'] ),({('noproc'-|['compiler_generated'] ),_6}-|['compiler_generated'] ),_7> when 'true' -> apply 'call_crypto_server_1'/1 ((_0-|[{'function',{'call_crypto_server',1}}] ))
<('exit'-|['compiler_generated'] ),({('normal'-|['compiler_generated'] ),_8}-|['compiler_generated'] ),_9> when 'true' -> apply 'call_crypto_server_1'/1 ((_0-|[{'function',{'call_crypto_server',1}}] ))
(<_10,_11,_12> when 'true' -> primop 'raise' (_12,_11)-|['compiler_generated'] ) end-|[{'function',{'call_crypto_server',1}}] )
'call_crypto_server_1'/1 = (fun (_0) -> do case call 'gen_server':'start' ({'local','beam_lib__crypto_key_server'},'beam_lib',[],[]) of <{'ok',_3}> when 'true' -> 'ok'
<{'error',{'already_started',_4}}> when 'true' -> 'ok'
(<_1> when 'true' -> primop 'match_fail' ({'case_clause',_1})-|['compiler_generated'] ) end do call 'erlang':'yield' () apply 'call_crypto_server'/1 ((_0-|[{'function',{'call_crypto_server_1',1}}] ))-|[{'function',{'call_crypto_server_1',1}}] )
'init'/1 = (fun (_0) -> (case (_0-|[{'function',{'init',1}}] ) of <[]> when 'true' -> {'ok',{'state','undefined'}}
(<_1> when 'true' -> primop 'match_fail' ({'function_clause',_1})-|['compiler_generated'] ) end-|[{'function',{'init',1}}] )-|[{'function',{'init',1}}] )
'handle_call'/3 = (fun (_0,_1,_2) -> (case <_0,_1,_2> of <R = {'get_crypto_key',_34},From,S = {'state','undefined'}> when 'true' -> case apply 'crypto_key_fun_from_file'/0 () of <'error'> when 'true' -> {'reply','error',S}
<F> when call 'erlang':'is_function' (F) -> case S of <{'state',_rec13}> when 'true' -> let <_5> = {'state',F} in apply 'handle_call'/3 (R,From,_5)
(<_35> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
<{'get_crypto_key',What},From,S = {'state',F}> when 'true' -> try let <Result> = apply F (What) in do call 'gen_server':'reply' (From,Result) do call 'erlang':'garbage_collect' () {'noreply',S} of <_8> -> _8 catch <_11,_10,_9> -> {'reply','error',S}
<{'crypto_key_fun',F},From = {_39,_40},S> when 'true' -> (case S of (<({'state',_rec14}-|['compiler_generated'] )> when 'true' -> case _rec14 of <'undefined'> when 'true' -> case <> of <> when try let <_14> = call 'erlang':'is_function' (F,1) in (call 'erlang':'=:=' (_14,'true')-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> let <_15> = catch apply F ('init') in let <_47,_48,_49> = case _15 of <'ok'> when 'true' -> <'true',F,'ok'>
<{'ok',F1}> when call 'erlang':'is_function' (F1) -> case <> of <> when try let <_16> = call 'erlang':'is_function' (F1,1) in (call 'erlang':'=:=' (_16,'true')-|['compiler_generated'] ) of <Try> -> Try catch <T,R> -> 'false' -> <'true',F1,'ok'>
<> when 'true' -> <'false','undefined',{'error','badfun'}> end
<_@r0 = {'error',Reason}> when 'true' -> <'false','undefined',_@r0>
<{'EXIT',Reason}> when 'true' -> <'false','undefined',{'error',Reason}>
(<_17> when 'true' -> primop 'match_fail' ({'case_clause',_17})-|['compiler_generated'] ) end in do call 'gen_server':'reply' (From,(_49-|['compiler_generated'] )) do call 'erlang':'garbage_collect' () let <_23> = case (_47-|['compiler_generated'] ) of <'true'> when 'true' -> case S of <{'state',_rec16}> when 'true' -> {'state',(_48-|['compiler_generated'] )}
(<_42> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<'false'> when 'true' -> S
(<_22> when 'true' -> primop 'match_fail' ({'case_clause',_22})-|['compiler_generated'] ) end in {'noreply',_23}
<> when 'true' -> {'reply',{'error','badfun'},S} end
<OtherF> when call 'erlang':'is_function' (_rec14) -> {'reply',{'error','exists'},S}
(<_25> when 'true' -> primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_41> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
<'clear_crypto_key_fun',_X_From,S> when 'true' -> (case S of (<({'state',_rec17}-|['compiler_generated'] )> when 'true' -> case _rec17 of <'undefined'> when 'true' -> {'stop','normal','undefined',S}
<F> when 'true' -> let <_28> = catch apply F ('clear') in {'stop','normal',{'ok',_28},S} end-|['compiler_generated'] )
(<_43> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','state'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_33,_32,_31> when 'true' -> primop 'match_fail' ({'function_clause',_33,_32,_31})-|['compiler_generated'] ) end-|[{'function',{'handle_call',3}}] )-|[{'function',{'handle_call',3}}] )
'handle_cast'/2 = (fun (_0,_1) -> {'noreply',_1}-|[{'function',{'handle_cast',2}}] )
'handle_info'/2 = (fun (_0,_1) -> {'noreply',_1}-|[{'function',{'handle_info',2}}] )
'code_change'/3 = (fun (_0,_1,_2) -> {'ok',_1}-|[{'function',{'code_change',3}}] )
'terminate'/2 = (fun (_0,_1) -> 'ok'-|[{'function',{'terminate',2}}] )
'crypto_key_fun_from_file'/0 = (fun () -> case call 'init':'get_argument' ('home') of <{'ok',[_@r0 = [Home|[]]|[]]}> when 'true' -> apply 'crypto_key_fun_from_file_1'/1 ([[46]|_@r0])
<_1> when 'true' -> apply 'crypto_key_fun_from_file_1'/1 ([[46]]) end-|[{'function',{'crypto_key_fun_from_file',0}}] )
'crypto_key_fun_from_file_1'/1 = (fun (_0) -> case apply 'f_p_s'/2 ((_0-|[{'function',{'crypto_key_fun_from_file_1',1}}] ),[46|[101|[114|[108|[97|[110|[103|[46|[99|[114|[121|[112|[116]]]]]]]]]]]]]) of <{'ok',KeyInfo,_3}> when 'true' -> apply 'try_load_crypto_fun'/1 (KeyInfo)
<_4> when 'true' -> 'error' end-|[{'function',{'crypto_key_fun_from_file_1',1}}] )
'f_p_s'/2 = (fun (_0,_1) -> case call 'file':'path_script' (_0,_1) of <{'error','enoent'}> when 'true' -> {'error','enoent'}
<{'error',E = {Line,_X_Mod,_X_Term}}> when 'true' -> let <_2> = call 'file':'format_error' (E) in do apply 'error'/2 ([102|[105|[108|[101|[58|[112|[97|[116|[104|[95|[115|[99|[114|[105|[112|[116|[40|[126|[116|[112|[44|[126|[116|[112|[41|[58|[32|[101|[114|[114|[111|[114|[32|[111|[110|[32|[108|[105|[110|[101|[32|[126|[112|[58|[32|[126|[116|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_0|[_1|[Line|[_2|[]]]]]) 'ok'
<{'error',E}> when call 'erlang':'is_atom' (E) -> let <_3> = call 'file':'format_error' (E) in do apply 'error'/2 ([102|[105|[108|[101|[58|[112|[97|[116|[104|[95|[115|[99|[114|[105|[112|[116|[40|[126|[116|[112|[44|[126|[116|[112|[41|[58|[32|[126|[116|[115|[126|[110]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[_0|[_1|[_3|[]]]]) 'ok'
<Other> when 'true' -> Other end-|[{'function',{'f_p_s',2}}] )
'try_load_crypto_fun'/1 = (fun (_0) -> (case (_0-|[{'function',{'try_load_crypto_fun',1}}] ) of <KeyInfo> when call 'erlang':'is_list' ((_0-|[{'function',{'try_load_crypto_fun',1}}] )) -> let <T> = call 'ets':'new' ('keys',['private'|['set']]) in let <_4> = fun (_2) -> case _2 of <{'debug_info',Mode,M,Key}> when call 'erlang':'is_atom' (M) -> call 'ets':'insert' (T,{{'debug_info',Mode,M,[]},Key})
<{'debug_info',Mode,[],Key}> when 'true' -> call 'ets':'insert' (T,{{'debug_info',Mode,[],[]},Key})
<Other> when 'true' -> apply 'error'/2 ([117|[110|[107|[110|[111|[119|[110|[32|[107|[101|[121|[58|[32|[126|[112|[126|[110]]]]]]]]]]]]]]]]],[Other|[]]) end in do call 'lists':'foreach' (_4,KeyInfo) (fun (_5) -> case _5 of <_@r0 = {'debug_info',Mode,M,F}> when 'true' -> apply 'alt_lookup_key'/2 ([_@r0|[{'debug_info',Mode,M,[]}|[{'debug_info',Mode,[],[]}|[]]]],T)
<'clear'> when 'true' -> call 'ets':'delete' (T)
<_8> when 'true' -> 'error' end-|[{'id',{0,0,'-try_load_crypto_fun/1-fun-1-'}}] )
<KeyInfo> when 'true' -> apply 'error'/2 ([117|[110|[114|[101|[99|[111|[103|[110|[105|[122|[101|[100|[32|[99|[114|[121|[112|[116|[111|[32|[107|[101|[121|[32|[105|[110|[102|[111|[58|[32|[126|[112|[10]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],[KeyInfo|[]]) end-|[{'function',{'try_load_crypto_fun',1}}] )-|[{'function',{'try_load_crypto_fun',1}}] )
'alt_lookup_key'/2 = (fun (_0,_1) -> (case <_0,_1> of <[H|T],Tab> when 'true' -> case call 'ets':'lookup' (Tab,H) of <[]> when 'true' -> apply 'alt_lookup_key'/2 (T,Tab)
<[{_5,Val}|[]]> when 'true' -> Val
(<_2> when 'true' -> primop 'match_fail' ({'case_clause',_2})-|['compiler_generated'] ) end
<[],_6> when 'true' -> 'error'
(<_4,_3> when 'true' -> primop 'match_fail' ({'function_clause',_4,_3})-|['compiler_generated'] ) end-|[{'function',{'alt_lookup_key',2}}] )-|[{'function',{'alt_lookup_key',2}}] )
'error'/2 = (fun (_0,_1) -> do call 'error_logger':'error_msg' (_0,_1) 'error'-|[{'function',{'error',2}}] )
'module_info'/0 = (fun () -> call 'erlang':'get_module_info' ('beam_lib')-|[{'function',{'module_info',0}}] )
'module_info'/1 = (fun (_0) -> call 'erlang':'get_module_info' ('beam_lib',(_0-|[{'function',{'module_info',1}}] ))-|[{'function',{'module_info',1}}] ) end