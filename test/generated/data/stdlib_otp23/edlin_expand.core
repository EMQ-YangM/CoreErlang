module 'edlin_expand' ['expand'/1,'format_matches'/1,'module_info'/0,'module_info'/1] attributes [ 'file' = [{[115|[114|[99|[47|[101|[100|[108|[105|[110|[95|[101|[120|[112|[97|[110|[100|[46|[101|[114|[108]]]]]]]]]]]]]]]]]]]],1}] ] 'expand'/1 = (fun (_0) -> case call 'edlin':'over_word' ((_0-|[{'function',{'expand',1}}] ),[],0) of <{Bef1,Word,_12}> when 'true' -> case apply 'over_white'/3 (Bef1,[],0) of <{[44|Bef2],_X_White,_X_Nwh}> when 'true' -> case apply 'over_white'/3 (Bef2,[],0) of <{Bef3,_X_White1,_X_Nwh1}> when 'true' -> case call 'edlin':'over_word' (Bef3,[],0) of <{Bef4,Mod,_X_Nm}> when 'true' -> case apply 'expand_function'/1 (Bef4) of <'help'> when 'true' -> apply 'expand_function_name'/3 (Mod,Word,[44])
<_13> when 'true' -> apply 'expand_module_name'/2 (Word,[44]) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end
<{[58|Bef2],_X_White,_X_Nwh}> when 'true' -> case apply 'over_white'/3 (Bef2,[],0) of <{Bef3,_X_White1,_X_Nwh1}> when 'true' -> case call 'edlin':'over_word' (Bef3,[],0) of <{_14,Mod,_X_Nm}> when 'true' -> apply 'expand_function_name'/3 (Mod,Word,[40])
(<_6> when 'true' -> primop 'match_fail' ({'badmatch',_6})-|['compiler_generated'] ) end
(<_5> when 'true' -> primop 'match_fail' ({'badmatch',_5})-|['compiler_generated'] ) end
<{_15,_16,_17}> when 'true' -> let <_8> = case apply 'expand_function'/1 (Bef1) of <'help'> when 'true' -> [44]
<_18> when 'true' -> [58] end in apply 'expand_module_name'/2 (Word,_8)
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end
(<_1> when 'true' -> primop 'match_fail' ({'badmatch',_1})-|['compiler_generated'] ) end-|[{'function',{'expand',1}}] )
'expand_function'/1 = (fun (_0) -> (case (_0-|[{'function',{'expand_function',1}}] ) of <[40|Str]> when 'true' -> case call 'edlin':'over_word' (Str,[],0) of <{_3,[104],_4}> when 'true' -> 'help'
<{_5,[104|[116]],_6}> when 'true' -> 'help_type'
<_7> when 'true' -> 'module' end
<_8> when 'true' -> 'module' end-|[{'function',{'expand_function',1}}] )-|[{'function',{'expand_function',1}}] )
'expand_module_name'/2 = (fun (_0,_1) -> (case <_0,_1> of <[],_12> when 'true' -> {'no',[],[]}
<Prefix,CompleteChar> when 'true' -> let <_9> = letrec 'lc$^0'/1 = fun (_5) -> case _5 of <[{M,P,_13}|_3]> when 'true' -> let <_7> = call 'erlang':'list_to_atom' (M) in let <_8> = apply 'lc$^0'/1 (_3) in ([{_7,P}|_8]-|['compiler_generated'] )
(<[_2|_3]> when 'true' -> apply 'lc$^0'/1 (_3)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_6> when 'true' -> primop 'match_fail' ({'function_clause',_6})-|['compiler_generated'] ) end in let <_4> = call 'code':'all_available' () in apply 'lc$^0'/1 (_4) in apply 'match'/3 (Prefix,_9,CompleteChar) end-|[{'function',{'expand_module_name',2}}] )-|[{'function',{'expand_module_name',2}}] )
'expand_function_name'/3 = (fun (_0,_1,_2) -> case apply 'to_atom'/1 (_0) of <{'ok',Mod}> when 'true' -> let <_6> = case call 'erlang':'module_loaded' (Mod) of <'true'> when 'true' -> call Mod:'module_info' ('exports')
<'false'> when 'true' -> let <_3> = call 'code':'which' (Mod) in case call 'beam_lib':'chunks' (_3,['exports']) of <{'ok',{_13,[{'exports',E}|[]]}}> when call 'erlang':'=:=' (_13,Mod) -> E
<_14> when 'true' -> {'no',[],[]} end
(<_5> when 'true' -> primop 'match_fail' ({'case_clause',_5})-|['compiler_generated'] ) end in case _6 of <{'no',[],[]}> when 'true' -> {'no',[],[]}
<_15> when call 'erlang':'=:=' (_6,_6) -> apply 'match'/3 (_1,_6,_2)
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end
<'error'> when 'true' -> {'no',[],[]}
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end-|[{'function',{'expand_function_name',3}}] )
'to_atom'/1 = (fun (_0) -> case call 'erl_scan':'string' ((_0-|[{'function',{'to_atom',1}}] )) of <{'ok',[{'atom',_3,A}|[]],_4}> when 'true' -> {'ok',A}
<_5> when 'true' -> 'error' end-|[{'function',{'to_atom',1}}] )
'match'/3 = (fun (_0,_1,_2) -> let <Len> = call 'string':'length' (_0) in let <_12> = letrec 'lc$^0'/1 = fun (_8) -> case _8 of <[{H,A}|_5]> when 'true' -> let <_7> = apply 'flat_write'/1 (H) in (case call 'lists':'prefix' (_0,_7) of <'true'> when 'true' -> let <_10> = apply 'lc$^0'/1 (_5) in ([{_7,A}|_10]-|['compiler_generated'] )
(<'false'> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
(<_11> when 'true' -> primop 'match_fail' ({'case_clause',_11})-|['compiler_generated'] ) end-|['list_comprehension'] )
(<[_4|_5]> when 'true' -> apply 'lc$^0'/1 (_5)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_9> when 'true' -> primop 'match_fail' ({'function_clause',_9})-|['compiler_generated'] ) end in apply 'lc$^0'/1 (_1) in let <Matches> = call 'lists':'sort' (_12) in let <_19> = letrec 'lc$^1'/1 = fun (_16) -> case _16 of <[{N,_30}|_15]> when 'true' -> let <_18> = apply 'lc$^1'/1 (_15) in ([N|_18]-|['compiler_generated'] )
(<[_14|_15]> when 'true' -> apply 'lc$^1'/1 (_15)-|['compiler_generated'] )
<[]> when 'true' -> []
(<_17> when 'true' -> primop 'match_fail' ({'function_clause',_17})-|['compiler_generated'] ) end in apply 'lc$^1'/1 (Matches) in case apply 'longest_common_head'/1 (_19) of <{'partial',[]}> when 'true' -> {'no',[],Matches}
<{'partial',Str}> when 'true' -> case call 'string':'slice' (Str,Len) of <[]> when 'true' -> {'yes',[],Matches}
<Remain> when 'true' -> {'yes',Remain,[]} end
<{'complete',Str}> when 'true' -> let <_22> = case <_2,Matches> of <([40]-|['compiler_generated'] ),([({_31,(0-|['compiler_generated'] )}-|['compiler_generated'] )|([]-|['compiler_generated'] )]-|['compiler_generated'] )> when call 'erlang':'=:=' (_31,Str) -> [40|[41]]
<_32,_33> when 'true' -> _2 end in let <_24> = call 'string':'slice' (Str,Len) in let <_25> = call 'erlang':'++' (_24,_22) in {'yes',_25,[]}
<'no'> when 'true' -> {'no',[],[]}
(<_26> when 'true' -> primop 'match_fail' ({'case_clause',_26})-|['compiler_generated'] ) end-|[{'function',{'match',3}}] )
'flat_write'/1 = (fun (_0) -> (case (_0-|[{'function',{'flat_write',1}}] ) of <T> when call 'erlang':'is_atom' ((_0-|[{'function',{'flat_write',1}}] )) -> let <_1> = call 'io_lib':'fwrite' ([126|[116|[119]]],[T|[]]) in call 'lists':'flatten' (_1)
<S> when 'true' -> S end-|[{'function',{'flat_write',1}}] )-|[{'function',{'flat_write',1}}] )
'format_matches'/1 = (fun (_0) -> let <_1> = call 'lists':'sort' ((_0-|[{'function',{'format_matches',1}}] )) in case apply 'format_col'/2 (_1,[]) of <{S1,Dots}> when 'true' -> let <_11> = case Dots of <'true'> when 'true' -> let <_3> = apply 'vals'/1 ((_0-|[{'function',{'format_matches',1}}] )) in case apply 'longest_common_head'/1 (_3) of <{_14,Prefix}> when 'true' -> let <PrefixLen> = call 'string':'length' (Prefix) in case call 'erlang':'=<' (PrefixLen,3) of <'true'> when 'true' -> S1
<'false'> when 'true' -> let <LeadingDotsL> = apply 'leading_dots'/2 ((_0-|[{'function',{'format_matches',1}}] ),PrefixLen) in let <_7> = call 'lists':'sort' (LeadingDotsL) in case apply 'format_col'/2 (_7,[]) of <{S2,_15}> when 'true' -> S2
(<_8> when 'true' -> primop 'match_fail' ({'badmatch',_8})-|['compiler_generated'] ) end end
(<_4> when 'true' -> primop 'match_fail' ({'badmatch',_4})-|['compiler_generated'] ) end
<'false'> when 'true' -> S1
(<_10> when 'true' -> primop 'match_fail' ({'case_clause',_10})-|['compiler_generated'] ) end in [[10]|_11]
(<_2> when 'true' -> primop 'match_fail' ({'badmatch',_2})-|['compiler_generated'] ) end-|[{'function',{'format_matches',1}}] )
'format_col'/2 = (fun (_0,_1) -> (case <_0,_1> of <[],_6> when 'true' -> []
<L,Acc> when 'true' -> let <_3> = apply 'field_width'/2 (L,79) in apply 'format_col'/6 (L,_3,0,Acc,79,'false') end-|[{'function',{'format_col',2}}] )-|[{'function',{'format_col',2}}] )
'format_col'/6 = (fun (_0,_1,_2,_3,_4,_5) -> (case <_0,_1,_2,_3,_4,_5> of <X,Width,Len,Acc,LL,Dots> when try let <_6> = call 'erlang':'+' (Width,Len) in call 'erlang':'>' (_6,LL) of <Try> -> Try catch <T,R> -> 'false' -> apply 'format_col'/6 (X,Width,0,[[10]|Acc],LL,Dots)
<[A|T],Width,Len,Acc0,LL,Dots> when 'true' -> case apply 'format_val'/1 (A) of <{H0,R}> when 'true' -> let <_8> = call 'erlang':'length' (R) in let <Hmax> = call 'erlang':'-' (LL,_8) in let <_10> = call 'string':'length' (H0) in let <_30,_31> = case call 'erlang':'>' (_10,Hmax) of <'true'> when 'true' -> let <_11> = call 'erlang':'-' (Hmax,3) in let <_12> = call 'io_lib':'format' ([126|[45|[42|[116|[115]]]]],[_11|[H0|[]]]) in let <_13> = call 'erlang':'++' (_12,[46|[46|[46]]]) in <_13,'true'>
<'false'> when 'true' -> <H0,Dots> end in let <_17> = call 'erlang':'++' ((_30-|['compiler_generated'] ),R) in let <_18> = call 'io_lib':'format' ([126|[45|[42|[116|[115]]]]],[Width|[_17|[]]]) in let <Acc> = [_18|Acc0] in let <_20> = call 'erlang':'+' (Len,Width) in apply 'format_col'/6 (T,Width,_20,Acc,LL,(_31-|['compiler_generated'] ))
(<_7> when 'true' -> primop 'match_fail' ({'badmatch',_7})-|['compiler_generated'] ) end
<[],_28,_29,Acc,_X_LL,Dots> when 'true' -> let <_21> = call 'lists':'reverse' (Acc,[10]) in {_21,Dots}
(<_27,_26,_25,_24,_23,_22> when 'true' -> primop 'match_fail' ({'function_clause',_27,_26,_25,_24,_23,_22})-|['compiler_generated'] ) end-|[{'function',{'format_col',6}}] )-|[{'function',{'format_col',6}}] )
'format_val'/1 = (fun (_0) -> (case (_0-|[{'function',{'format_val',1}}] ) of <{H,I}> when call 'erlang':'is_integer' (I) -> let <_1> = call 'erlang':'integer_to_list' (I) in let <_2> = [47|_1] in {H,_2}
<{H,_4}> when 'true' -> {H,[]}
<H> when 'true' -> {H,[]} end-|[{'function',{'format_val',1}}] )-|[{'function',{'format_val',1}}] )
'field_width'/2 = (fun (_0,_1) -> apply 'field_width'/3 (_0,0,_1)-|[{'function',{'field_width',2}}] )
'field_width'/3 = (fun (_0,_1,_2) -> (case <_0,_1,_2> of <[{H,_9}|T],W,LL> when 'true' -> case call 'string':'length' (H) of <L> when call 'erlang':'>' (L,W) -> apply 'field_width'/3 (T,L,LL)
<_10> when 'true' -> apply 'field_width'/3 (T,W,LL) end
<[H|T],W,LL> when 'true' -> case call 'string':'length' (H) of <L> when call 'erlang':'>' (L,W) -> apply 'field_width'/3 (T,L,LL)
<_11> when 'true' -> apply 'field_width'/3 (T,W,LL) end
<[],W,LL> when try let <_5> = call 'erlang':'-' (LL,3) in call 'erlang':'<' (W,_5) of <Try> -> Try catch <T,R> -> 'false' -> call 'erlang':'+' (W,4)
<[],_12,LL> when 'true' -> LL
(<_8,_7,_6> when 'true' -> primop 'match_fail' ({'function_clause',_8,_7,_6})-|['compiler_generated'] ) end-|[{'function',{'field_width',3}}] )-|[{'function',{'field_width',3}}] )
'vals'/1 = (fun (_0) -> (case (_0-|[{'function',{'vals',1}}] ) of <[]> when 'true' -> []
<[{S,_4}|L]> when 'true' -> let <_1> = apply 'vals'/1 (L) in [S|_1]
<[S|L]> when 'true' -> let <_2> = apply 'vals'/1 (L) in [S|_2]
(<_3> when 'true' -> primop 'match_fail' ({'function_clause',_3})-|['compiler_generated'] ) end-|[{'function',{'vals',1}}] )-|[{'function',{'vals',1}}] )
'leading_dots'/2 = (fun (_0,_1) -> (case <_0,_1> of <[],_X_Len> when 'true' -> []
<[{H,I}|L],Len> when 'true' -> let <_2> = call 'string':'slice' (H,Len) in let <_3> = [46|[46|[46|_2]]] in let <_4> = apply 'leading_dots'/2 (L,Len) in [{_3,I}|_4]
<[H|L],Len> when 'true' -> let <_5> = call 'string':'slice' (H,Len) in let <_6> = [46|[46|[46|_5]]] in let <_7> = apply 'leading_dots'/2 (L,Len) in [_6|_7]
(<_9,_8> when 'true' -> primop 'match_fail' ({'function_clause',_9,_8})-|['compiler_generated'] ) end-|[{'function',{'leading_dots',2}}] )-|[{'function',{'leading_dots',2}}] )
'longest_common_head'/1 = (fun (_0) -> (case (_0-|[{'function',{'longest_common_head',1}}] ) of <[]> when 'true' -> 'no'
<LL> when 'true' -> apply 'longest_common_head'/2 (LL,[]) end-|[{'function',{'longest_common_head',1}}] )-|[{'function',{'longest_common_head',1}}] )
'longest_common_head'/2 = (fun (_0,_1) -> (case <_0,_1> of <[[]|_11],L> when 'true' -> let <_2> = call 'lists':'reverse' (L) in {'partial',_2}
<LL,L> when 'true' -> case apply 'same_head'/1 (LL) of <'true'> when 'true' -> case LL of <[[H|_12]|_13]> when 'true' -> let <LL1> = apply 'all_tails'/1 (LL) in case apply 'all_nil'/1 (LL1) of <'false'> when 'true' -> apply 'longest_common_head'/2 (LL1,[H|L])
<'true'> when 'true' -> let <_5> = call 'lists':'reverse' ([H|L]) in {'complete',_5}
(<_6> when 'true' -> primop 'match_fail' ({'case_clause',_6})-|['compiler_generated'] ) end
(<_3> when 'true' -> primop 'match_fail' ({'badmatch',_3})-|['compiler_generated'] ) end
<'false'> when 'true' -> let <_7> = call 'lists':'reverse' (L) in {'partial',_7}
(<_8> when 'true' -> primop 'match_fail' ({'case_clause',_8})-|['compiler_generated'] ) end end-|[{'function',{'longest_common_head',2}}] )-|[{'function',{'longest_common_head',2}}] )
'same_head'/1 = (fun (_0) -> (case (_0-|[{'function',{'same_head',1}}] ) of <[[H|_2]|T1]> when 'true' -> apply 'same_head'/2 (H,T1)
(<_1> when 'true' -> primop 'match_fail' ({'function_clause',_1})-|['compiler_generated'] ) end-|[{'function',{'same_head',1}}] )-|[{'function',{'same_head',1}}] )
'same_head'/2 = (fun (_0,_1) -> (case <_0,_1> of <H,[[_4|_5]|T]> when call 'erlang':'=:=' (_4,H) -> apply 'same_head'/2 (H,T)
<_6,[]> when 'true' -> 'true'
<_7,_8> when 'true' -> 'false' end-|[{'function',{'same_head',2}}] )-|[{'function',{'same_head',2}}] )
'all_tails'/1 = (fun (_0) -> apply 'all_tails'/2 ((_0-|[{'function',{'all_tails',1}}] ),[])-|[{'function',{'all_tails',1}}] )
'all_tails'/2 = (fun (_0,_1) -> (case <_0,_1> of <[[_4|T]|T1],L> when 'true' -> apply 'all_tails'/2 (T1,[T|L])
<[],L> when 'true' -> L
(<_3,_2> when 'true' -> primop 'match_fail' ({'function_clause',_3,_2})-|['compiler_generated'] ) end-|[{'function',{'all_tails',2}}] )-|[{'function',{'all_tails',2}}] )
'all_nil'/1 = (fun (_0) -> (case (_0-|[{'function',{'all_nil',1}}] ) of <[]> when 'true' -> 'true'
<[[]|Rest]> when 'true' -> apply 'all_nil'/1 (Rest)
<_2> when 'true' -> 'false' end-|[{'function',{'all_nil',1}}] )-|[{'function',{'all_nil',1}}] )
'over_white'/3 = (fun (_0,_1,_2) -> (case <_0,_1,_2> of <[32|Cs],Stack,N> when 'true' -> let <_3> = call 'erlang':'+' (N,1) in apply 'over_white'/3 (Cs,[32|Stack],_3)
<[9|Cs],Stack,N> when 'true' -> let <_4> = call 'erlang':'+' (N,1) in apply 'over_white'/3 (Cs,[9|Stack],_4)
<Cs,Stack,N> when call 'erlang':'is_list' (Cs) -> {Cs,Stack,N}
(<_7,_6,_5> when 'true' -> primop 'match_fail' ({'function_clause',_7,_6,_5})-|['compiler_generated'] ) end-|[{'function',{'over_white',3}}] )-|[{'function',{'over_white',3}}] )
'module_info'/0 = (fun () -> call 'erlang':'get_module_info' ('edlin_expand')-|[{'function',{'module_info',0}}] )
'module_info'/1 = (fun (_0) -> call 'erlang':'get_module_info' ('edlin_expand',(_0-|[{'function',{'module_info',1}}] ))-|[{'function',{'module_info',1}}] ) end