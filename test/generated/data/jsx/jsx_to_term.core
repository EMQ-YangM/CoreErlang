module 'jsx_to_term' ['finish'/1,'get_key'/1,'get_value'/1,'handle_event'/2,'init'/1,'insert'/2,'module_info'/0,'module_info'/1,'start_array'/1,'start_object'/1,'start_term'/1,'to_term'/2] attributes [ 'file' = [{[106|[115|[120|[95|[116|[111|[95|[116|[101|[114|[109|[46|[101|[114|[108]]]]]]]]]]]]]]],1}]
, 'record' = [{'config',[{'record_field',40,{'atom',40,'labels'},{'atom',40,'binary'}}|[{'record_field',41,{'atom',41,'return_maps'},{'atom',41,'false'}}]]}]
, 'type' = [{'config',{'type',44,'list',[]},[]}]
, 'export_type' = [{'config',0}]
, 'type' = [{'json_value',{'type',48,'union',[{'type',48,'list',[{'user_type',48,'json_value',[]}]}|[{'type',49,'list',[{'type',49,'tuple',[{'type',49,'union',[{'type',49,'binary',[]}|[{'type',49,'atom',[]}]]}|[{'user_type',49,'json_value',[]}]]}]}|[{'type',49,'nonempty_list',[{'type',49,'tuple',[]}]}|[{'atom',50,'true'}|[{'atom',51,'false'}|[{'atom',52,'null'}|[{'type',53,'integer',[]}|[{'type',54,'float',[]}|[{'type',55,'binary',[]}]]]]]]]]]},[]}]
, 'spec' = [{{'to_term',2},[{'type',71,'fun',[{'type',71,'product',[{'ann_type',71,[{'var',71,'Source'}|[{'type',71,'binary',[]}]]}|[{'ann_type',71,[{'var',71,'Config'}|[{'user_type',71,'config',[]}]]}]]}|[{'user_type',71,'json_value',[]}]]}]}]
, 'type' = [{'state',{'type',108,'tuple',[{'type',108,'list',[]}|[{'type',108,'record',[{'atom',108,'config'}]}]]},[]}]
, 'spec' = [{{'init',1},[{'type',109,'fun',[{'type',109,'product',[{'ann_type',109,[{'var',109,'Config'}|[{'remote_type',109,[{'atom',109,'proplists'}|[{'atom',109,'proplist'}|[[]]]]}]]}]}|[{'user_type',109,'state',[]}]]}]}]
, 'spec' = [{{'handle_event',2},[{'type',113,'fun',[{'type',113,'product',[{'ann_type',113,[{'var',113,'Event'}|[{'type',113,'any',[]}]]}|[{'ann_type',113,[{'var',113,'State'}|[{'user_type',113,'state',[]}]]}]]}|[{'user_type',113,'state',[]}]]}]}] ] 'to_term'/2 = fun (_0,_1) -> case <_0,_1> of <Source,Config> when call 'erlang':'is_list' (Config) -> let <_2> = call 'jsx_config':'extract_config' (Config) in let <_3> = call 'jsx':'decoder' ('jsx_to_term',Config,_2) in apply _3 (Source)
(<_5,_4> when 'true' -> (primop 'match_fail' ({'function_clause',_5,_4})-|[{'function_name',{'to_term',2}}] )-|['compiler_generated'] ) end
'parse_config'/1 = fun (_0) -> apply 'parse_config'/2 (_0,{'config','binary','false'})
'parse_config'/2 = fun (_0,_1) -> case <_0,_1> of <[{'labels',Val}|Rest],Config> when let <_2> = call 'erlang':'=:=' (Val,'binary') in let <_3> = call 'erlang':'=:=' (Val,'atom') in let <_4> = call 'erlang':'=:=' (Val,'existing_atom') in let <_5> = call 'erlang':'=:=' (Val,'attempt_atom') in let <_6> = call 'erlang':'or' (_4,_5) in let <_7> = call 'erlang':'or' (_3,_6) in call 'erlang':'or' (_2,_7) -> case Config of <{'config',_28,_29}> when 'true' -> let <_10> = call 'erlang':'setelement' (2,Config,Val) in apply 'parse_config'/2 (Rest,_10)
(<_30> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','config'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<['labels'|Rest],Config> when 'true' -> case Config of <{'config',_31,_32}> when 'true' -> let <_13> = call 'erlang':'setelement' (2,Config,'binary') in apply 'parse_config'/2 (Rest,_13)
(<_33> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','config'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<[{'return_maps',Val}|Rest],Config> when let <_14> = call 'erlang':'=:=' (Val,'true') in let <_15> = call 'erlang':'=:=' (Val,'false') in call 'erlang':'or' (_14,_15) -> case Config of <{'config',_34,_35}> when 'true' -> let <_18> = call 'erlang':'setelement' (3,Config,Val) in apply 'parse_config'/2 (Rest,_18)
(<_36> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','config'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<['return_maps'|Rest],Config> when 'true' -> case Config of <{'config',_37,_38}> when 'true' -> let <_21> = call 'erlang':'setelement' (3,Config,'true') in apply 'parse_config'/2 (Rest,_21)
(<_39> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','config'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end
<Options = [{K,_40}|Rest],Config> when 'true' -> let <_22> = call 'jsx_config':'valid_flags' () in case call 'lists':'member' (K,_22) of <'true'> when 'true' -> apply 'parse_config'/2 (Rest,Config)
<'false'> when 'true' -> call 'erlang':'error' ('badarg',[Options|[Config|[]]])
(<_23> when 'true' -> primop 'match_fail' ({'case_clause',_23})-|['compiler_generated'] ) end
<Options = [K|Rest],Config> when 'true' -> let <_24> = call 'jsx_config':'valid_flags' () in case call 'lists':'member' (K,_24) of <'true'> when 'true' -> apply 'parse_config'/2 (Rest,Config)
<'false'> when 'true' -> call 'erlang':'error' ('badarg',[Options|[Config|[]]])
(<_25> when 'true' -> primop 'match_fail' ({'case_clause',_25})-|['compiler_generated'] ) end
<[],Config> when 'true' -> Config
(<_27,_26> when 'true' -> (primop 'match_fail' ({'function_clause',_27,_26})-|[{'function_name',{'parse_config',2}}] )-|['compiler_generated'] ) end
'init'/1 = fun (_0) -> apply 'start_term'/1 (_0)
'handle_event'/2 = fun (_0,_1) -> case <_0,_1> of <'end_json',State> when 'true' -> apply 'get_value'/1 (State)
<'start_object',State> when 'true' -> apply 'start_object'/1 (State)
<'end_object',State> when 'true' -> apply 'finish'/1 (State)
<'start_array',State> when 'true' -> apply 'start_array'/1 (State)
<'end_array',State> when 'true' -> apply 'finish'/1 (State)
<{'key',Key},State = {_5,Config}> when 'true' -> let <_2> = apply 'format_key'/2 (Key,Config) in apply 'insert'/2 (_2,State)
<{_6,Event},State> when 'true' -> apply 'insert'/2 (Event,State)
(<_4,_3> when 'true' -> (primop 'match_fail' ({'function_clause',_4,_3})-|[{'function_name',{'handle_event',2}}] )-|['compiler_generated'] ) end
'format_key'/2 = fun (_0,_1) -> (case _1 of (<({'config',_rec4,_12}-|['compiler_generated'] )> when 'true' -> case _rec4 of <'binary'> when 'true' -> _0
<'atom'> when 'true' -> call 'erlang':'binary_to_atom' (_0,'utf8')
<'existing_atom'> when 'true' -> call 'erlang':'binary_to_existing_atom' (_0,'utf8')
<'attempt_atom'> when 'true' -> try call 'erlang':'binary_to_existing_atom' (_0,'utf8') of <_4> -> _4 catch <_8,_7,_6> -> case <_8,_7,_6> of <('error'-|['compiler_generated'] ),('badarg'-|['compiler_generated'] ),_14> when 'true' -> _0
(<_16,_17,_18> when 'true' -> primop 'raise' (_18,_17)-|['compiler_generated'] ) end
(<_9> when 'true' -> primop 'match_fail' ({'case_clause',_9})-|['compiler_generated'] ) end-|['compiler_generated'] )
(<_13> when 'true' -> (call ('erlang'-|['compiler_generated'] ):('error'-|['compiler_generated'] ) (({'badrecord','config'}-|['compiler_generated'] ))-|['compiler_generated'] )-|['compiler_generated'] ) end-|['compiler_generated'] )
'start_term'/1 = fun (_0) -> case _0 of <Config> when call 'erlang':'is_list' (_0) -> let <_1> = apply 'parse_config'/1 (Config) in {[],_1}
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'start_term',1}}] )-|['compiler_generated'] ) end
'start_object'/1 = fun (_0) -> case _0 of <{Stack,Config}> when 'true' -> let <_1> = [{'object',[]}|Stack] in {_1,Config}
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'start_object',1}}] )-|['compiler_generated'] ) end
'start_array'/1 = fun (_0) -> case _0 of <{Stack,Config}> when 'true' -> let <_1> = [{'array',[]}|Stack] in {_1,Config}
(<_2> when 'true' -> (primop 'match_fail' ({'function_clause',_2})-|[{'function_name',{'start_array',1}}] )-|['compiler_generated'] ) end
'finish'/1 = fun (_0) -> case _0 of <{[{'object',[]}],Config}> when 'true' -> {[{}],Config}
<{[{'object',[]}|Rest],Config}> when 'true' -> apply 'insert'/2 ([{}],{Rest,Config})
<{[{'object',Pairs}|[]],Config}> when 'true' -> let <_1> = call 'lists':'reverse' (Pairs) in {_1,Config}
<{[{'object',Pairs}|Rest],Config}> when 'true' -> let <_2> = call 'lists':'reverse' (Pairs) in apply 'insert'/2 (_2,{Rest,Config})
<{[{'array',Values}|[]],Config}> when 'true' -> let <_3> = call 'lists':'reverse' (Values) in {_3,Config}
<{[{'array',Values}|Rest],Config}> when 'true' -> let <_4> = call 'lists':'reverse' (Values) in apply 'insert'/2 (_4,{Rest,Config})
<_6> when 'true' -> call 'erlang':'error' ('badarg') end
'insert'/2 = fun (_0,_1) -> case <_0,_1> of <Value,{[],Config}> when 'true' -> {Value,Config}
<Key,{[{'object',Pairs}|Rest],Config}> when 'true' -> let <_2> = [{'object',Key,Pairs}|Rest] in {_2,Config}
<Value,{[{'object',Key,Pairs}|Rest],Config}> when 'true' -> let <_3> = [{Key,Value}|Pairs] in let <_4> = [{'object',_3}|Rest] in {_4,Config}
<Value,{[{'array',Values}|Rest],Config}> when 'true' -> let <_5> = [Value|Values] in let <_6> = [{'array',_5}|Rest] in {_6,Config}
<_9,_10> when 'true' -> call 'erlang':'error' ('badarg') end
'get_key'/1 = fun (_0) -> case _0 of <{[{'object',Key,_2}|_3],_4}> when 'true' -> Key
<_5> when 'true' -> call 'erlang':'error' ('badarg') end
'get_value'/1 = fun (_0) -> case _0 of <{Value,_X_Config}> when 'true' -> Value
<_2> when 'true' -> call 'erlang':'error' ('badarg') end
'module_info'/0 = fun () -> call 'erlang':'get_module_info' ('jsx_to_term')
'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info' ('jsx_to_term',_0) end